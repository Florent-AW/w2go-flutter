{
  "project_info": {
    "name": "lib",
    "path": "D:\\Dev\\LYRA_App\\travel_in_perigord_app\\lib",
    "generated_at": "2025-04-16T13:25:28.2002973",
    "total_files": 264,
    "total_size": 866820
  },
  "structure": {
    "core": {
      "adapters": {
        "cache": {
          "hive_adapters.dart": {
            "type": "file",
            "info": {
              "size": 3408,
              "last_modified": "2025-04-16T13:25:25.9531423",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "hive_location_cache_adapter.dart": {
            "type": "file",
            "info": {
              "size": 6485,
              "last_modified": "2025-04-16T13:25:25.9611649",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "google": {
          "google_ai_studio_service.dart": {
            "type": "file",
            "info": {
              "size": 2768,
              "last_modified": "2025-04-16T13:25:25.9734214",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "route_optimization.adapter.dart": {
            "type": "file",
            "info": {
              "size": 5910,
              "last_modified": "2025-04-16T13:25:25.9799279",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "google_maps": {
          "geocoding_adapter.dart": {
            "type": "file",
            "info": {
              "size": 1772,
              "last_modified": "2025-04-16T13:25:25.9924421",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "maps_adapter.dart": {
            "type": "file",
            "info": {
              "size": 9536,
              "last_modified": "2025-04-16T13:25:25.9999434",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "postgis": {
          "geometry_calculation.adapter.dart": {
            "type": "file",
            "info": {
              "size": 2336,
              "last_modified": "2025-04-16T13:25:26.0119739",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "processing": {
          "activity_hours_adapter.dart": {
            "type": "file",
            "info": {
              "size": 3369,
              "last_modified": "2025-04-16T13:25:26.0250855",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "filter_processing_adapter.dart": {
            "type": "file",
            "info": {
              "size": 1480,
              "last_modified": "2025-04-16T13:25:26.032191",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "supabase": {
          "activity_hours_adapter.dart": {
            "type": "file",
            "info": {
              "size": 2861,
              "last_modified": "2025-04-16T13:25:26.0452277",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_processing_adapter.dart": {
            "type": "file",
            "info": {
              "size": 5906,
              "last_modified": "2025-04-16T13:25:26.0522806",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_scoring_adapter.dart": {
            "type": "file",
            "info": {
              "size": 5177,
              "last_modified": "2025-04-16T13:25:26.0598614",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "config": {
            "remote_config_adapter.dart": {
              "type": "file",
              "info": {
                "size": 4559,
                "last_modified": "2025-04-16T13:25:26.0663808",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "database_adapter.dart": {
            "type": "file",
            "info": {
              "size": 2837,
              "last_modified": "2025-04-16T13:25:26.0789174",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_daily_trip.adapter.dart": {
            "type": "file",
            "info": {
              "size": 3738,
              "last_modified": "2025-04-16T13:25:26.0861912",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_trip_repository.adapter.dart": {
            "type": "file",
            "info": {
              "size": 0,
              "last_modified": "2025-04-16T13:25:26.0932307",
              "mime_type": "application/octet-stream",
              "extension": ".dart"
            }
          },
          "potential_bonus_activity.adapter.dart": {
            "type": "file",
            "info": {
              "size": 2290,
              "last_modified": "2025-04-16T13:25:26.0992299",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "search": {
            "activity_details_adapter.dart": {
              "type": "file",
              "info": {
                "size": 3732,
                "last_modified": "2025-04-16T13:25:26.1063494",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_search_adapter.dart": {
              "type": "file",
              "info": {
                "size": 2510,
                "last_modified": "2025-04-16T13:25:26.1138932",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_cache_adapter.dart": {
              "type": "file",
              "info": {
                "size": 3264,
                "last_modified": "2025-04-16T13:25:26.1209363",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_search_adapter.dart": {
              "type": "file",
              "info": {
                "size": 1278,
                "last_modified": "2025-04-16T13:25:26.1280307",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_search_adapter.dart": {
              "type": "file",
              "info": {
                "size": 1392,
                "last_modified": "2025-04-16T13:25:26.1350733",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "superwow_management.adapter.dart": {
            "type": "file",
            "info": {
              "size": 9684,
              "last_modified": "2025-04-16T13:25:26.1471131",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_activities_adapter.dart": {
            "type": "file",
            "info": {
              "size": 3766,
              "last_modified": "2025-04-16T13:25:26.1531596",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "trip": {
          "trip_adapter.dart": {
            "type": "file",
            "info": {
              "size": 2933,
              "last_modified": "2025-04-16T13:25:26.1657116",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        }
      },
      "common": {
        "constants": {
          "geometry_constants.dart": {
            "type": "file",
            "info": {
              "size": 701,
              "last_modified": "2025-04-16T13:25:26.1827906",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location_constants.dart": {
            "type": "file",
            "info": {
              "size": 1847,
              "last_modified": "2025-04-16T13:25:26.1887908",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "subcategory_icons.dart": {
            "type": "file",
            "info": {
              "size": 1334,
              "last_modified": "2025-04-16T13:25:26.1953039",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_constants.dart": {
            "type": "file",
            "info": {
              "size": 886,
              "last_modified": "2025-04-16T13:25:26.2023369",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "enums": {
          "trip_enums.dart": {
            "type": "file",
            "info": {
              "size": 4680,
              "last_modified": "2025-04-16T13:25:26.2139049",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "exceptions": {
          "calculation_exception.dart": {
            "type": "file",
            "info": {
              "size": 249,
              "last_modified": "2025-04-16T13:25:26.2260226",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "domain_exception.dart": {
            "type": "file",
            "info": {
              "size": 51,
              "last_modified": "2025-04-16T13:25:26.2320717",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_trip_generation_exception.dart": {
            "type": "file",
            "info": {
              "size": 285,
              "last_modified": "2025-04-16T13:25:26.2380712",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "exceptions.dart": {
            "type": "file",
            "info": {
              "size": 423,
              "last_modified": "2025-04-16T13:25:26.245109",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "geometry_calculation_exception.dart": {
            "type": "file",
            "info": {
              "size": 282,
              "last_modified": "2025-04-16T13:25:26.2511463",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "google_api_exception.dart": {
            "type": "file",
            "info": {
              "size": 244,
              "last_modified": "2025-04-16T13:25:26.2576625",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location_exceptions.dart": {
            "type": "file",
            "info": {
              "size": 1271,
              "last_modified": "2025-04-16T13:25:26.2647133",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "route_optimization_exceptions.dart": {
            "type": "file",
            "info": {
              "size": 978,
              "last_modified": "2025-04-16T13:25:26.2712318",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "scoring_exceptions.dart": {
            "type": "file",
            "info": {
              "size": 556,
              "last_modified": "2025-04-16T13:25:26.2782924",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_exception.dart": {
            "type": "file",
            "info": {
              "size": 1153,
              "last_modified": "2025-04-16T13:25:26.2853486",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "utils": {
          "activity_mapper.dart": {
            "type": "file",
            "info": {
              "size": 1032,
              "last_modified": "2025-04-16T13:25:26.2983904",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "date_formatter.dart": {
            "type": "file",
            "info": {
              "size": 1144,
              "last_modified": "2025-04-16T13:25:26.3049075",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "debouncer.dart": {
            "type": "file",
            "info": {
              "size": 519,
              "last_modified": "2025-04-16T13:25:26.3119405",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "geohash.dart": {
            "type": "file",
            "info": {
              "size": 3461,
              "last_modified": "2025-04-16T13:25:26.3179398",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "geo_utils.dart": {
            "type": "file",
            "info": {
              "size": 844,
              "last_modified": "2025-04-16T13:25:26.3245397",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location_formatter.dart": {
            "type": "file",
            "info": {
              "size": 1233,
              "last_modified": "2025-04-16T13:25:26.3310441",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "maps_toolkit_utils.dart": {
            "type": "file",
            "info": {
              "size": 2041,
              "last_modified": "2025-04-16T13:25:26.3370458",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        }
      },
      "domain": {
        "filters": {
          "activity_filter.dart": {
            "type": "file",
            "info": {
              "size": 282,
              "last_modified": "2025-04-16T13:25:26.3551255",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "filter_chain.dart": {
            "type": "file",
            "info": {
              "size": 535,
              "last_modified": "2025-04-16T13:25:26.3611586",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "time_filter.dart": {
            "type": "file",
            "info": {
              "size": 4864,
              "last_modified": "2025-04-16T13:25:26.3686755",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "travel_group_filter.dart": {
            "type": "file",
            "info": {
              "size": 2299,
              "last_modified": "2025-04-16T13:25:26.3742753",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "models": {
          "activity": {
            "base": {
              "activity_base.dart": {
                "type": "file",
                "info": {
                  "size": 1646,
                  "last_modified": "2025-04-16T13:25:26.3863119",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_base.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 16922,
                  "last_modified": "2025-04-16T13:25:26.3933505",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_base.g.dart": {
                "type": "file",
                "info": {
                  "size": 1952,
                  "last_modified": "2025-04-16T13:25:26.4003507",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_interface.dart": {
                "type": "file",
                "info": {
                  "size": 0,
                  "last_modified": "2025-04-16T13:25:26.4074492",
                  "mime_type": "application/octet-stream",
                  "extension": ".dart"
                }
              }
            },
            "search": {
              "searchable_activity.dart": {
                "type": "file",
                "info": {
                  "size": 2748,
                  "last_modified": "2025-04-16T13:25:26.4199672",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "searchable_activity.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 16211,
                  "last_modified": "2025-04-16T13:25:26.4271204",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "searchable_activity.g.dart": {
                "type": "file",
                "info": {
                  "size": 1868,
                  "last_modified": "2025-04-16T13:25:26.4331639",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "search_result.dart": {
                "type": "file",
                "info": {
                  "size": 0,
                  "last_modified": "2025-04-16T13:25:26.4411855",
                  "mime_type": "application/octet-stream",
                  "extension": ".dart"
                }
              }
            },
            "trip": {
              "trip_activity.dart": {
                "type": "file",
                "info": {
                  "size": 0,
                  "last_modified": "2025-04-16T13:25:26.4524634",
                  "mime_type": "application/octet-stream",
                  "extension": ".dart"
                }
              }
            }
          },
          "common_models.dart": {
            "type": "file",
            "info": {
              "size": 651,
              "last_modified": "2025-04-16T13:25:26.4689854",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "config": {
            "app_remote_config.dart": {
              "type": "file",
              "info": {
                "size": 510,
                "last_modified": "2025-04-16T13:25:26.4750017",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "app_remote_config.freezed.dart": {
              "type": "file",
              "info": {
                "size": 7004,
                "last_modified": "2025-04-16T13:25:26.4813668",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "app_remote_config.g.dart": {
              "type": "file",
              "info": {
                "size": 737,
                "last_modified": "2025-04-16T13:25:26.4873663",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_section_config.dart": {
              "type": "file",
              "info": {
                "size": 626,
                "last_modified": "2025-04-16T13:25:26.4938776",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_section_config.freezed.dart": {
              "type": "file",
              "info": {
                "size": 9286,
                "last_modified": "2025-04-16T13:25:26.4998818",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_section_config.g.dart": {
              "type": "file",
              "info": {
                "size": 1013,
                "last_modified": "2025-04-16T13:25:26.5064233",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_section_config.dart": {
              "type": "file",
              "info": {
                "size": 823,
                "last_modified": "2025-04-16T13:25:26.5129588",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_section_config.freezed.dart": {
              "type": "file",
              "info": {
                "size": 10804,
                "last_modified": "2025-04-16T13:25:26.5199506",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_section_config.g.dart": {
              "type": "file",
              "info": {
                "size": 1172,
                "last_modified": "2025-04-16T13:25:26.5260721",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "location": {
            "place_details.dart": {
              "type": "file",
              "info": {
                "size": 693,
                "last_modified": "2025-04-16T13:25:26.5397168",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details.freezed.dart": {
              "type": "file",
              "info": {
                "size": 12172,
                "last_modified": "2025-04-16T13:25:26.5462389",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details.g.dart": {
              "type": "file",
              "info": {
                "size": 1408,
                "last_modified": "2025-04-16T13:25:26.5522903",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_suggestion.dart": {
              "type": "file",
              "info": {
                "size": 557,
                "last_modified": "2025-04-16T13:25:26.5603338",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_suggestion.freezed.dart": {
              "type": "file",
              "info": {
                "size": 8041,
                "last_modified": "2025-04-16T13:25:26.5659497",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_suggestion.g.dart": {
              "type": "file",
              "info": {
                "size": 887,
                "last_modified": "2025-04-16T13:25:26.5732041",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "user_location.dart": {
              "type": "file",
              "info": {
                "size": 548,
                "last_modified": "2025-04-16T13:25:26.5792556",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "user_location.freezed.dart": {
              "type": "file",
              "info": {
                "size": 8457,
                "last_modified": "2025-04-16T13:25:26.5863596",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "user_location.g.dart": {
              "type": "file",
              "info": {
                "size": 1025,
                "last_modified": "2025-04-16T13:25:26.5928727",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "opening_days.dart": {
            "type": "file",
            "info": {
              "size": 989,
              "last_modified": "2025-04-16T13:25:26.6052047",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "scored_activity.dart": {
            "type": "file",
            "info": {
              "size": 1165,
              "last_modified": "2025-04-16T13:25:26.611339",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "shared": {
            "activity_details_model.dart": {
              "type": "file",
              "info": {
                "size": 1441,
                "last_modified": "2025-04-16T13:25:26.6183424",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_details_model.freezed.dart": {
              "type": "file",
              "info": {
                "size": 23571,
                "last_modified": "2025-04-16T13:25:26.6259152",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_details_model.g.dart": {
              "type": "file",
              "info": {
                "size": 2751,
                "last_modified": "2025-04-16T13:25:26.6322028",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_image_model.dart": {
              "type": "file",
              "info": {
                "size": 480,
                "last_modified": "2025-04-16T13:25:26.6382038",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_image_model.freezed.dart": {
              "type": "file",
              "info": {
                "size": 6705,
                "last_modified": "2025-04-16T13:25:26.6452314",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_image_model.g.dart": {
              "type": "file",
              "info": {
                "size": 706,
                "last_modified": "2025-04-16T13:25:26.6514762",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_model.dart": {
              "type": "file",
              "info": {
                "size": 2695,
                "last_modified": "2025-04-16T13:25:26.6585215",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_model.dart": {
              "type": "file",
              "info": {
                "size": 533,
                "last_modified": "2025-04-16T13:25:26.6655501",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_model.freezed.dart": {
              "type": "file",
              "info": {
                "size": 8065,
                "last_modified": "2025-04-16T13:25:26.6720657",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_model.g.dart": {
              "type": "file",
              "info": {
                "size": 848,
                "last_modified": "2025-04-16T13:25:26.6781519",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "trip_designer": {
            "bonus_activities": {
              "potential_bonus_activity.dart": {
                "type": "file",
                "info": {
                  "size": 1642,
                  "last_modified": "2025-04-16T13:25:26.6912315",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "value_objects": {
                "malus_vol_oiseau.dart": {
                  "type": "file",
                  "info": {
                    "size": 527,
                    "last_modified": "2025-04-16T13:25:26.6982164",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "malus_vol_oiseau.freezed.dart": {
                  "type": "file",
                  "info": {
                    "size": 4847,
                    "last_modified": "2025-04-16T13:25:26.7052579",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              }
            },
            "empty_trips": {
              "empty_daily_trip.dart": {
                "type": "file",
                "info": {
                  "size": 1583,
                  "last_modified": "2025-04-16T13:25:26.7232034",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "value_objects": {
                "generation_result.dart": {
                  "type": "file",
                  "info": {
                    "size": 553,
                    "last_modified": "2025-04-16T13:25:26.7302694",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "generation_result.freezed.dart": {
                  "type": "file",
                  "info": {
                    "size": 9186,
                    "last_modified": "2025-04-16T13:25:26.736305",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "superwow_pair.dart": {
                  "type": "file",
                  "info": {
                    "size": 953,
                    "last_modified": "2025-04-16T13:25:26.7433327",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              }
            },
            "processing": {
              "activity_processing_model.dart": {
                "type": "file",
                "info": {
                  "size": 4756,
                  "last_modified": "2025-04-16T13:25:26.7602682",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "scoring": {
              "scoring_activity.dart": {
                "type": "file",
                "info": {
                  "size": 1501,
                  "last_modified": "2025-04-16T13:25:26.771813",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "scoring_config.dart": {
                "type": "file",
                "info": {
                  "size": 417,
                  "last_modified": "2025-04-16T13:25:26.779322",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "scoring_result.dart": {
                "type": "file",
                "info": {
                  "size": 1364,
                  "last_modified": "2025-04-16T13:25:26.7853661",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "trip": {
              "activity_model.dart": {
                "type": "file",
                "info": {
                  "size": 4505,
                  "last_modified": "2025-04-16T13:25:26.7968726",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "daily_trip.dart": {
                "type": "file",
                "info": {
                  "size": 2057,
                  "last_modified": "2025-04-16T13:25:26.8039295",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "trip_model.dart": {
                "type": "file",
                "info": {
                  "size": 6627,
                  "last_modified": "2025-04-16T13:25:26.8099481",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            }
          }
        },
        "ports": {
          "activity_hours_port.dart": {
            "type": "file",
            "info": {
              "size": 330,
              "last_modified": "2025-04-16T13:25:26.8334856",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_processing_port.dart": {
            "type": "file",
            "info": {
              "size": 929,
              "last_modified": "2025-04-16T13:25:26.8384878",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_scoring_port.dart": {
            "type": "file",
            "info": {
              "size": 404,
              "last_modified": "2025-04-16T13:25:26.8459997",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "config": {
            "remote_config_port.dart": {
              "type": "file",
              "info": {
                "size": 478,
                "last_modified": "2025-04-16T13:25:26.8515074",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "daily_trip_generation_port.dart": {
            "type": "file",
            "info": {
              "size": 727,
              "last_modified": "2025-04-16T13:25:26.8637022",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "distance_calculation_port.dart": {
            "type": "file",
            "info": {
              "size": 346,
              "last_modified": "2025-04-16T13:25:26.8702111",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_trips": {
            "available_time_calculation.port.dart": {
              "type": "file",
              "info": {
                "size": 834,
                "last_modified": "2025-04-16T13:25:26.8762728",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "bonus_activities_cache.port.dart": {
              "type": "file",
              "info": {
                "size": 350,
                "last_modified": "2025-04-16T13:25:26.8827789",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "empty_daily_trip.port.dart": {
              "type": "file",
              "info": {
                "size": 1055,
                "last_modified": "2025-04-16T13:25:26.8887828",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "empty_trip_repository.port.dart": {
              "type": "file",
              "info": {
                "size": 68,
                "last_modified": "2025-04-16T13:25:26.8952975",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "geometry_calculation.port.dart": {
              "type": "file",
              "info": {
                "size": 474,
                "last_modified": "2025-04-16T13:25:26.9023451",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "neighbor_geohashes.port.dart": {
              "type": "file",
              "info": {
                "size": 330,
                "last_modified": "2025-04-16T13:25:26.9084206",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "potential_activities.port.dart": {
              "type": "file",
              "info": {
                "size": 456,
                "last_modified": "2025-04-16T13:25:26.9149334",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "route_optimization.port.dart": {
              "type": "file",
              "info": {
                "size": 840,
                "last_modified": "2025-04-16T13:25:26.9289502",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "superwow_management.port.dart": {
              "type": "file",
              "info": {
                "size": 821,
                "last_modified": "2025-04-16T13:25:26.9354588",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "geocoding_port.dart": {
            "type": "file",
            "info": {
              "size": 232,
              "last_modified": "2025-04-16T13:25:26.9469668",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location": {
            "city_cache_port.dart": {
              "type": "file",
              "info": {
                "size": 830,
                "last_modified": "2025-04-16T13:25:26.9534755",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "geolocation_port.dart": {
              "type": "file",
              "info": {
                "size": 518,
                "last_modified": "2025-04-16T13:25:26.9604842",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "location_cache_port.dart": {
              "type": "file",
              "info": {
                "size": 940,
                "last_modified": "2025-04-16T13:25:26.9659934",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_port.dart": {
              "type": "file",
              "info": {
                "size": 325,
                "last_modified": "2025-04-16T13:25:26.9740084",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_port.dart": {
              "type": "file",
              "info": {
                "size": 465,
                "last_modified": "2025-04-16T13:25:26.9805119",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "maps_port.dart": {
            "type": "file",
            "info": {
              "size": 432,
              "last_modified": "2025-04-16T13:25:26.9920234",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "providers": {
            "config": {
              "remote_config_provider.dart": {
                "type": "file",
                "info": {
                  "size": 1583,
                  "last_modified": "2025-04-16T13:25:26.999026",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "daily_trip_generation_provider.dart": {
              "type": "file",
              "info": {
                "size": 844,
                "last_modified": "2025-04-16T13:25:27.0105446",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "empty_trips": {
              "bonus_activities.providers.dart": {
                "type": "file",
                "info": {
                  "size": 2864,
                  "last_modified": "2025-04-16T13:25:27.0165513",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "bonus_activities_cache.provider.dart": {
                "type": "file",
                "info": {
                  "size": 475,
                  "last_modified": "2025-04-16T13:25:27.0235609",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "distance_calculation_provider.dart": {
                "type": "file",
                "info": {
                  "size": 357,
                  "last_modified": "2025-04-16T13:25:27.0300684",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_daily_trip.provider.dart": {
                "type": "file",
                "info": {
                  "size": 480,
                  "last_modified": "2025-04-16T13:25:27.0360733",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation.provider.dart": {
                "type": "file",
                "info": {
                  "size": 1006,
                  "last_modified": "2025-04-16T13:25:27.0420908",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "geometry_calculation.provider.dart": {
                "type": "file",
                "info": {
                  "size": 515,
                  "last_modified": "2025-04-16T13:25:27.0490911",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "google_ai_studio.provider.dart": {
                "type": "file",
                "info": {
                  "size": 552,
                  "last_modified": "2025-04-16T13:25:27.054595",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "google_services_config.provider.dart": {
                "type": "file",
                "info": {
                  "size": 354,
                  "last_modified": "2025-04-16T13:25:27.0616071",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "neighbor_geohashes.provider.dart": {
                "type": "file",
                "info": {
                  "size": 456,
                  "last_modified": "2025-04-16T13:25:27.0671124",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "potential_activities.provider.dart": {
                "type": "file",
                "info": {
                  "size": 466,
                  "last_modified": "2025-04-16T13:25:27.0741319",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization.provider.dart": {
                "type": "file",
                "info": {
                  "size": 734,
                  "last_modified": "2025-04-16T13:25:27.0811966",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "superwow_management.provider.dart": {
                "type": "file",
                "info": {
                  "size": 875,
                  "last_modified": "2025-04-16T13:25:27.0871977",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "infrastructure_providers.dart": {
              "type": "file",
              "info": {
                "size": 280,
                "last_modified": "2025-04-16T13:25:27.0992589",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "location": {
              "location_providers.dart": {
                "type": "file",
                "info": {
                  "size": 3710,
                  "last_modified": "2025-04-16T13:25:27.1052975",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "port_providers.dart": {
              "type": "file",
              "info": {
                "size": 1079,
                "last_modified": "2025-04-16T13:25:27.1173144",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "scoring_providers.dart": {
              "type": "file",
              "info": {
                "size": 579,
                "last_modified": "2025-04-16T13:25:27.1233235",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "search": {
              "activity_distances_provider.dart": {
                "type": "file",
                "info": {
                  "size": 1556,
                  "last_modified": "2025-04-16T13:25:27.1303275",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "distance_providers.dart": {
                "type": "file",
                "info": {
                  "size": 371,
                  "last_modified": "2025-04-16T13:25:27.1358348",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "subcategory_search_provider.dart": {
                "type": "file",
                "info": {
                  "size": 722,
                  "last_modified": "2025-04-16T13:25:27.1433415",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "service_providers.dart": {
              "type": "file",
              "info": {
                "size": 1004,
                "last_modified": "2025-04-16T13:25:27.1548492",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "trip_activities_providers.dart": {
              "type": "file",
              "info": {
                "size": 454,
                "last_modified": "2025-04-16T13:25:27.1608581",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "use_case_providers.dart": {
              "type": "file",
              "info": {
                "size": 735,
                "last_modified": "2025-04-16T13:25:27.1663668",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "search": {
            "activity_details_port.dart": {
              "type": "file",
              "info": {
                "size": 250,
                "last_modified": "2025-04-16T13:25:27.1783814",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_distance_calculation_port.dart": {
              "type": "file",
              "info": {
                "size": 460,
                "last_modified": "2025-04-16T13:25:27.1848912",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_search_port.dart": {
              "type": "file",
              "info": {
                "size": 675,
                "last_modified": "2025-04-16T13:25:27.1913967",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_search_port.dart": {
              "type": "file",
              "info": {
                "size": 227,
                "last_modified": "2025-04-16T13:25:27.1983993",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_search_port.dart": {
              "type": "file",
              "info": {
                "size": 217,
                "last_modified": "2025-04-16T13:25:27.2049068",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "trip_activities_port.dart": {
            "type": "file",
            "info": {
              "size": 359,
              "last_modified": "2025-04-16T13:25:27.2159241",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_port.dart": {
            "type": "file",
            "info": {
              "size": 599,
              "last_modified": "2025-04-16T13:25:27.2229317",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "services": {
          "designer": {
            "empty_trips": {
              "available_time_calculation.service.dart": {
                "type": "file",
                "info": {
                  "size": 8987,
                  "last_modified": "2025-04-16T13:25:27.234443",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "bonus_activities_cache.service.dart": {
                "type": "file",
                "info": {
                  "size": 1893,
                  "last_modified": "2025-04-16T13:25:27.2409504",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "bonus_activity_generation.service.dart": {
                "type": "file",
                "info": {
                  "size": 4244,
                  "last_modified": "2025-04-16T13:25:27.2469497",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "distance_calculation.service.dart": {
                "type": "file",
                "info": {
                  "size": 4333,
                  "last_modified": "2025-04-16T13:25:27.2534555",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation.service.dart": {
                "type": "file",
                "info": {
                  "size": 7477,
                  "last_modified": "2025-04-16T13:25:27.2599605",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "neighbor_geohashes.service.dart": {
                "type": "file",
                "info": {
                  "size": 2725,
                  "last_modified": "2025-04-16T13:25:27.2665166",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "notifier": {
                "potential_bonus_activities.notifier.dart": {
                  "type": "file",
                  "info": {
                    "size": 2030,
                    "last_modified": "2025-04-16T13:25:27.2730234",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              },
              "potential_activities.service.dart": {
                "type": "file",
                "info": {
                  "size": 2776,
                  "last_modified": "2025-04-16T13:25:27.2840375",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "trip_distance_service.dart": {
              "type": "file",
              "info": {
                "size": 1151,
                "last_modified": "2025-04-16T13:25:27.2960534",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "google_services_config.dart": {
            "type": "file",
            "info": {
              "size": 567,
              "last_modified": "2025-04-16T13:25:27.3077319",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location": {
            "enhanced_location_service.dart": {
              "type": "file",
              "info": {
                "size": 6000,
                "last_modified": "2025-04-16T13:25:27.3142422",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "location_service.dart": {
            "type": "file",
            "info": {
              "size": 1445,
              "last_modified": "2025-04-16T13:25:27.3262555",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "scoring_service.dart": {
            "type": "file",
            "info": {
              "size": 1162,
              "last_modified": "2025-04-16T13:25:27.3317613",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "search": {
            "activity_distance_service.dart": {
              "type": "file",
              "info": {
                "size": 1407,
                "last_modified": "2025-04-16T13:25:27.3387664",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "shared": {
            "external_launcher_service.dart": {
              "type": "file",
              "info": {
                "size": 3249,
                "last_modified": "2025-04-16T13:25:27.350273",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "travel_time_service.dart": {
            "type": "file",
            "info": {
              "size": 1859,
              "last_modified": "2025-04-16T13:25:27.361795",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_service.dart": {
            "type": "file",
            "info": {
              "size": 3773,
              "last_modified": "2025-04-16T13:25:27.3683014",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "use_cases": {
          "create_trip_use_case.dart": {
            "type": "file",
            "info": {
              "size": 2086,
              "last_modified": "2025-04-16T13:25:27.379313",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "process_activities_use_case.dart": {
            "type": "file",
            "info": {
              "size": 1686,
              "last_modified": "2025-04-16T13:25:27.3858231",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "search": {
            "get_activities_use_case.dart": {
              "type": "file",
              "info": {
                "size": 2489,
                "last_modified": "2025-04-16T13:25:27.3923381",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      },
      "theme": {
        "animations": {
          "ripple_animation.dart": {
            "type": "file",
            "info": {
              "size": 2904,
              "last_modified": "2025-04-16T13:25:27.4170352",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "app_colors.dart": {
          "type": "file",
          "info": {
            "size": 7061,
            "last_modified": "2025-04-16T13:25:27.4291754",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_dimensions.dart": {
          "type": "file",
          "info": {
            "size": 9281,
            "last_modified": "2025-04-16T13:25:27.4366898",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_filters.dart": {
          "type": "file",
          "info": {
            "size": 485,
            "last_modified": "2025-04-16T13:25:27.4432061",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_fonts.dart": {
          "type": "file",
          "info": {
            "size": 5162,
            "last_modified": "2025-04-16T13:25:27.4492059",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_interactions.dart": {
          "type": "file",
          "info": {
            "size": 7337,
            "last_modified": "2025-04-16T13:25:27.4553447",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_theme.dart": {
          "type": "file",
          "info": {
            "size": 9944,
            "last_modified": "2025-04-16T13:25:27.4623739",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_typography.dart": {
          "type": "file",
          "info": {
            "size": 9142,
            "last_modified": "2025-04-16T13:25:27.4684179",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "atoms": {
          "app_button.dart": {
            "type": "file",
            "info": {
              "size": 13760,
              "last_modified": "2025-04-16T13:25:27.4749708",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "app_card.dart": {
            "type": "file",
            "info": {
              "size": 37,
              "last_modified": "2025-04-16T13:25:27.4820061",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "app_input.dart": {
            "type": "file",
            "info": {
              "size": 17923,
              "last_modified": "2025-04-16T13:25:27.4880056",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "app_text.dart": {
            "type": "file",
            "info": {
              "size": 8633,
              "last_modified": "2025-04-16T13:25:27.4950423",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        }
      }
    },
    "features": {
      "empty_trips": {
        "presentation": {
          "pages": {
            "empty_trips_test_page.dart": {
              "type": "file",
              "info": {
                "size": 20331,
                "last_modified": "2025-04-16T13:25:27.5172739",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "state": {
            "test": {
              "available_time_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 12081,
                  "last_modified": "2025-04-16T13:25:27.5288549",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "available_time_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 2073,
                  "last_modified": "2025-04-16T13:25:27.5353717",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "available_time_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 552,
                  "last_modified": "2025-04-16T13:25:27.5424124",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "available_time_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18575,
                  "last_modified": "2025-04-16T13:25:27.5484124",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 3500,
                  "last_modified": "2025-04-16T13:25:27.5549292",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 702,
                  "last_modified": "2025-04-16T13:25:27.5619644",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 525,
                  "last_modified": "2025-04-16T13:25:27.5684818",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18469,
                  "last_modified": "2025-04-16T13:25:27.5752006",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 2269,
                  "last_modified": "2025-04-16T13:25:27.5812704",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 858,
                  "last_modified": "2025-04-16T13:25:27.5872711",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 660,
                  "last_modified": "2025-04-16T13:25:27.5943078",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18966,
                  "last_modified": "2025-04-16T13:25:27.6003077",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 2208,
                  "last_modified": "2025-04-16T13:25:27.607416",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 604,
                  "last_modified": "2025-04-16T13:25:27.6129334",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 624,
                  "last_modified": "2025-04-16T13:25:27.6199336",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18888,
                  "last_modified": "2025-04-16T13:25:27.6260997",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            }
          }
        }
      },
      "home": {
        "presentation": {
          "pages": {
            "home_page.dart": {
              "type": "file",
              "info": {
                "size": 3653,
                "last_modified": "2025-04-16T13:25:27.6552136",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "widgets": {
            "navigation": {
              "city_picker.dart": {
                "type": "file",
                "info": {
                  "size": 2289,
                  "last_modified": "2025-04-16T13:25:27.6664384",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "city_picker_modal.dart": {
                "type": "file",
                "info": {
                  "size": 10386,
                  "last_modified": "2025-04-16T13:25:27.6729551",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "lyra_footer.dart": {
                "type": "file",
                "info": {
                  "size": 3455,
                  "last_modified": "2025-04-16T13:25:27.6799914",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "lyra_header.dart": {
                "type": "file",
                "info": {
                  "size": 4143,
                  "last_modified": "2025-04-16T13:25:27.6865065",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "lyra_navigation.dart": {
                "type": "file",
                "info": {
                  "size": 1912,
                  "last_modified": "2025-04-16T13:25:27.6930227",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "subcategories_list.dart": {
                "type": "file",
                "info": {
                  "size": 6548,
                  "last_modified": "2025-04-16T13:25:27.6990228",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            }
          }
        }
      },
      "search": {
        "application": {
          "services": {
            "city_selection_service.dart": {
              "type": "file",
              "info": {
                "size": 2750,
                "last_modified": "2025-04-16T13:25:27.7271696",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "state": {
            "activity_details_state.dart": {
              "type": "file",
              "info": {
                "size": 1938,
                "last_modified": "2025-04-16T13:25:27.7397191",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_details_state.freezed.dart": {
              "type": "file",
              "info": {
                "size": 18644,
                "last_modified": "2025-04-16T13:25:27.746252",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_search_provider.dart": {
              "type": "file",
              "info": {
                "size": 951,
                "last_modified": "2025-04-16T13:25:27.7532897",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_activities_state.dart": {
              "type": "file",
              "info": {
                "size": 2319,
                "last_modified": "2025-04-16T13:25:27.7603436",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_notifier.dart": {
              "type": "file",
              "info": {
                "size": 2190,
                "last_modified": "2025-04-16T13:25:27.7663754",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_state.dart": {
              "type": "file",
              "info": {
                "size": 613,
                "last_modified": "2025-04-16T13:25:27.7729582",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_state.freezed.dart": {
              "type": "file",
              "info": {
                "size": 18520,
                "last_modified": "2025-04-16T13:25:27.7789672",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_notifier.dart": {
              "type": "file",
              "info": {
                "size": 1987,
                "last_modified": "2025-04-16T13:25:27.7860215",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_state.dart": {
              "type": "file",
              "info": {
                "size": 634,
                "last_modified": "2025-04-16T13:25:27.7920848",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_state.freezed.dart": {
              "type": "file",
              "info": {
                "size": 23503,
                "last_modified": "2025-04-16T13:25:27.7980843",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "section_activities_provider.dart": {
              "type": "file",
              "info": {
                "size": 2053,
                "last_modified": "2025-04-16T13:25:27.8051323",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "selected_city_state.dart": {
              "type": "file",
              "info": {
                "size": 243,
                "last_modified": "2025-04-16T13:25:27.8122688",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "selected_subcategory_state.dart": {
              "type": "file",
              "info": {
                "size": 607,
                "last_modified": "2025-04-16T13:25:27.818269",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_activities_state.dart": {
              "type": "file",
              "info": {
                "size": 3061,
                "last_modified": "2025-04-16T13:25:27.8249546",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        },
        "domain": {
          "providers": {
            "search_providers.dart": {
              "type": "file",
              "info": {
                "size": 823,
                "last_modified": "2025-04-16T13:25:27.8419848",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        },
        "presentation": {
          "pages": {
            "subcategory_page.dart": {
              "type": "file",
              "info": {
                "size": 2548,
                "last_modified": "2025-04-16T13:25:27.8585798",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "widgets": {
            "location": {
              "current_location_button.dart": {
                "type": "file",
                "info": {
                  "size": 1763,
                  "last_modified": "2025-04-16T13:25:27.8711264",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "location_search_bar.dart": {
                "type": "file",
                "info": {
                  "size": 5320,
                  "last_modified": "2025-04-16T13:25:27.878189",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "location_suggestions_list.dart": {
                "type": "file",
                "info": {
                  "size": 6357,
                  "last_modified": "2025-04-16T13:25:27.8842249",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "subcategory_sections_view.dart": {
              "type": "file",
              "info": {
                "size": 3713,
                "last_modified": "2025-04-16T13:25:27.8962643",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      },
      "shared_ui": {
        "presentation": {
          "pages": {
            "activity_details_page.dart": {
              "type": "file",
              "info": {
                "size": 3806,
                "last_modified": "2025-04-16T13:25:27.918456",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "widgets": {
            "activity_details": {
              "activity_details_content.dart": {
                "type": "file",
                "info": {
                  "size": 1817,
                  "last_modified": "2025-04-16T13:25:27.9320423",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "sections": {
                "description_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 2309,
                    "last_modified": "2025-04-16T13:25:27.938045",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "info_buttons_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 4168,
                    "last_modified": "2025-04-16T13:25:27.9440823",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "info_icons_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 3633,
                    "last_modified": "2025-04-16T13:25:27.9511214",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "location_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 2270,
                    "last_modified": "2025-04-16T13:25:27.9571559",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "schedule_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 4381,
                    "last_modified": "2025-04-16T13:25:27.9631871",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "title_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 788,
                    "last_modified": "2025-04-16T13:25:27.9702095",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              }
            },
            "atoms.dart": {
              "type": "file",
              "info": {
                "size": 494,
                "last_modified": "2025-04-16T13:25:27.9873034",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "buttons": {
              "back_button_widget.dart": {
                "type": "file",
                "info": {
                  "size": 1369,
                  "last_modified": "2025-04-16T13:25:27.993341",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "cards": {
              "activity_card.dart": {
                "type": "file",
                "info": {
                  "size": 3650,
                  "last_modified": "2025-04-16T13:25:28.0043744",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_card_image.dart": {
                "type": "file",
                "info": {
                  "size": 3094,
                  "last_modified": "2025-04-16T13:25:28.0114036",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_card_info.dart": {
                "type": "file",
                "info": {
                  "size": 2467,
                  "last_modified": "2025-04-16T13:25:28.0174039",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_container.dart": {
                "type": "file",
                "info": {
                  "size": 2887,
                  "last_modified": "2025-04-16T13:25:28.0240554",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "carousels": {
              "activity_images_carousel.dart": {
                "type": "file",
                "info": {
                  "size": 2570,
                  "last_modified": "2025-04-16T13:25:28.0365699",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "index.dart": {
              "type": "file",
              "info": {
                "size": 948,
                "last_modified": "2025-04-16T13:25:28.0480863",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "molecules": {
              "filter_chip.dart": {
                "type": "file",
                "info": {
                  "size": 6980,
                  "last_modified": "2025-04-16T13:25:28.0541605",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "molecules.dart": {
              "type": "file",
              "info": {
                "size": 334,
                "last_modified": "2025-04-16T13:25:28.065882",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "organisms.dart": {
              "type": "file",
              "info": {
                "size": 317,
                "last_modified": "2025-04-16T13:25:28.0729055",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "sections": {
              "activity_section.dart": {
                "type": "file",
                "info": {
                  "size": 2300,
                  "last_modified": "2025-04-16T13:25:28.0789147",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "shimmer": {
              "shimmer_loading.dart": {
                "type": "file",
                "info": {
                  "size": 4103,
                  "last_modified": "2025-04-16T13:25:28.0911455",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "shimmer_section.dart": {
                "type": "file",
                "info": {
                  "size": 1016,
                  "last_modified": "2025-04-16T13:25:28.0981463",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "shimmer_skeletons.dart": {
                "type": "file",
                "info": {
                  "size": 4483,
                  "last_modified": "2025-04-16T13:25:28.104661",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "templates.dart": {
              "type": "file",
              "info": {
                "size": 339,
                "last_modified": "2025-04-16T13:25:28.116263",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      },
      "trip": {
        "presentation": {
          "pages": {
            "trip_test_page.dart": {
              "type": "file",
              "info": {
                "size": 12296,
                "last_modified": "2025-04-16T13:25:28.1398969",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "state": {
            "trip_test_notifier.dart": {
              "type": "file",
              "info": {
                "size": 19410,
                "last_modified": "2025-04-16T13:25:28.1519429",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "trip_test_provider.dart": {
              "type": "file",
              "info": {
                "size": 1820,
                "last_modified": "2025-04-16T13:25:28.1584588",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "trip_test_state.dart": {
              "type": "file",
              "info": {
                "size": 577,
                "last_modified": "2025-04-16T13:25:28.1649763",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      }
    },
    "main.dart": {
      "type": "file",
      "info": {
        "size": 2943,
        "last_modified": "2025-04-16T13:25:28.1932974",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    }
  },
  "files": [
    {
      "path": "core\\adapters\\cache\\hive_adapters.dart",
      "content": "// lib/core/adapters/cache/hive_adapters.dart\r\n\r\nimport 'package:hive/hive.dart';\r\nimport '../../../core/domain/models/location/user_location.dart';\r\nimport '../../../core/domain/models/location/place_details.dart';\r\nimport '../../../core/domain/models/location/place_suggestion.dart';\r\n\r\n// Définition des ID d'adaptateurs (doivent être uniques)\r\nconst int userLocationTypeId = 1;\r\nconst int placeDetailsTypeId = 2;\r\nconst int placeSuggestionTypeId = 3;\r\n\r\n// Adaptateur pour convertir UserLocation en format Hive\r\nclass UserLocationAdapter extends TypeAdapter<UserLocation> {\r\n  @override\r\n  final int typeId = userLocationTypeId;\r\n\r\n  @override\r\n  UserLocation read(BinaryReader reader) {\r\n    final map = reader.readMap();\r\n    return UserLocation(\r\n      latitude: map['latitude'] as double,\r\n      longitude: map['longitude'] as double,\r\n      accuracy: map['accuracy'] as double?,\r\n      isFromGps: map['isFromGps'] as bool? ?? false,\r\n      timestamp: map['timestamp'] != null\r\n          ? DateTime.parse(map['timestamp'] as String)\r\n          : null,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void write(BinaryWriter writer, UserLocation obj) {\r\n    writer.writeMap({\r\n      'latitude': obj.latitude,\r\n      'longitude': obj.longitude,\r\n      'accuracy': obj.accuracy,\r\n      'isFromGps': obj.isFromGps,\r\n      'timestamp': obj.timestamp?.toIso8601String(),\r\n    });\r\n  }\r\n}\r\n\r\n// Adaptateur pour PlaceDetails\r\nclass PlaceDetailsAdapter extends TypeAdapter<PlaceDetails> {\r\n  @override\r\n  final int typeId = placeDetailsTypeId;\r\n\r\n  @override\r\n  PlaceDetails read(BinaryReader reader) {\r\n    final map = reader.readMap();\r\n    return PlaceDetails(\r\n      placeId: map['placeId'] as String,\r\n      name: map['name'] as String,\r\n      formattedAddress: map['formattedAddress'] as String,\r\n      location: map['location'] as UserLocation,\r\n      country: map['country'] as String?,\r\n      administrativeArea: map['administrativeArea'] as String?,\r\n      locality: map['locality'] as String?,\r\n      postalCode: map['postalCode'] as String?,\r\n      lastUpdated: map['lastUpdated'] != null\r\n          ? DateTime.parse(map['lastUpdated'] as String)\r\n          : null,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void write(BinaryWriter writer, PlaceDetails obj) {\r\n    writer.writeMap({\r\n      'placeId': obj.placeId,\r\n      'name': obj.name,\r\n      'formattedAddress': obj.formattedAddress,\r\n      'location': obj.location,\r\n      'country': obj.country,\r\n      'administrativeArea': obj.administrativeArea,\r\n      'locality': obj.locality,\r\n      'postalCode': obj.postalCode,\r\n      'lastUpdated': obj.lastUpdated?.toIso8601String(),\r\n    });\r\n  }\r\n}\r\n\r\n// Adaptateur pour PlaceSuggestion\r\nclass PlaceSuggestionAdapter extends TypeAdapter<PlaceSuggestion> {\r\n  @override\r\n  final int typeId = placeSuggestionTypeId;\r\n\r\n  @override\r\n  PlaceSuggestion read(BinaryReader reader) {\r\n    final map = reader.readMap();\r\n    return PlaceSuggestion(\r\n      placeId: map['placeId'] as String,\r\n      primaryText: map['primaryText'] as String,\r\n      secondaryText: map['secondaryText'] as String?,\r\n      isFromCache: map['isFromCache'] as bool? ?? false,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void write(BinaryWriter writer, PlaceSuggestion obj) {\r\n    writer.writeMap({\r\n      'placeId': obj.placeId,\r\n      'primaryText': obj.primaryText,\r\n      'secondaryText': obj.secondaryText,\r\n      'isFromCache': obj.isFromCache,\r\n    });\r\n  }\r\n}",
      "info": {
        "size": 3408,
        "last_modified": "2025-04-16T13:25:25.9531423",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\cache\\hive_location_cache_adapter.dart",
      "content": "// lib/core/adapters/cache/hive_location_cache_adapter.dart\r\n\r\nimport 'package:hive/hive.dart';\r\nimport 'hive_adapters.dart';\r\nimport '../../domain/ports/location/location_cache_port.dart';\r\nimport '../../domain/models/location/place_suggestion.dart';\r\nimport '../../domain/models/location/place_details.dart';\r\nimport '../../common/constants/location_constants.dart';\r\n\r\nclass HiveLocationCacheAdapter implements LocationCachePort {\r\n  static const String _suggestionsBoxName = 'place_suggestions';\r\n  static const String _detailsBoxName = 'place_details';\r\n\r\n  // Initialiser les boîtes avec des valeurs par défaut\r\n  Box<Map>? _suggestionsBox;\r\n  Box<Map>? _detailsBox;\r\n  bool _isInitialized = false;\r\n\r\n  // Modifier cette méthode pour qu'elle soit synchrone\r\n  void initialize() {\r\n    try {\r\n      // Enregistrer les adaptateurs\r\n      if (!Hive.isAdapterRegistered(userLocationTypeId)) {\r\n        Hive.registerAdapter(UserLocationAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeDetailsTypeId)) {\r\n        Hive.registerAdapter(PlaceDetailsAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeSuggestionTypeId)) {\r\n        Hive.registerAdapter(PlaceSuggestionAdapter());\r\n      }\r\n\r\n      // Ouvrir les boxes de manière synchrone si possible, sinon les laisser null\r\n      try {\r\n        if (Hive.isBoxOpen(_suggestionsBoxName)) {\r\n          _suggestionsBox = Hive.box<Map>(_suggestionsBoxName);\r\n        }\r\n        if (Hive.isBoxOpen(_detailsBoxName)) {\r\n          _detailsBox = Hive.box<Map>(_detailsBoxName);\r\n        }\r\n        _isInitialized = true;\r\n        print('✅ Cache Hive initialisé avec succès');\r\n      } catch (e) {\r\n        print('⚠️ Impossible d\\'ouvrir les boîtes Hive de manière synchrone: $e');\r\n        // Ne pas marquer comme initialisé\r\n      }\r\n    } catch (e) {\r\n      print('❌ Erreur lors de l\\'initialisation du cache: $e');\r\n    }\r\n  }\r\n\r\n  // Méthode pour initialiser de manière asynchrone (à appeler au démarrage de l'app)\r\n  Future<void> initializeAsync() async {\r\n    try {\r\n      // Enregistrer les adaptateurs\r\n      if (!Hive.isAdapterRegistered(userLocationTypeId)) {\r\n        Hive.registerAdapter(UserLocationAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeDetailsTypeId)) {\r\n        Hive.registerAdapter(PlaceDetailsAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeSuggestionTypeId)) {\r\n        Hive.registerAdapter(PlaceSuggestionAdapter());\r\n      }\r\n\r\n      // Ouvrir les boxes\r\n      if (!Hive.isBoxOpen(_suggestionsBoxName)) {\r\n        _suggestionsBox = await Hive.openBox<Map>(_suggestionsBoxName);\r\n      } else {\r\n        _suggestionsBox = Hive.box<Map>(_suggestionsBoxName);\r\n      }\r\n\r\n      if (!Hive.isBoxOpen(_detailsBoxName)) {\r\n        _detailsBox = await Hive.openBox<Map>(_detailsBoxName);\r\n      } else {\r\n        _detailsBox = Hive.box<Map>(_detailsBoxName);\r\n      }\r\n\r\n      _isInitialized = true;\r\n      print('✅ Cache Hive initialisé avec succès (async)');\r\n    } catch (e) {\r\n      print('❌ Erreur lors de l\\'initialisation asynchrone du cache: $e');\r\n    }\r\n  }\r\n\r\n  // Vérifier si les boîtes sont initialisées avant de les utiliser\r\n  bool get isInitialized => _isInitialized && _suggestionsBox != null && _detailsBox != null;\r\n\r\n  // Mettre à jour les méthodes pour vérifier l'initialisation\r\n  @override\r\n  Future<void> savePlaceSuggestion(PlaceSuggestion suggestion) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox == null) return;\r\n\r\n    await _suggestionsBox!.put(\r\n      suggestion.placeId,\r\n      suggestion.toJson(),\r\n    );\r\n  }\r\n\r\n  // Modifier les autres méthodes de la même façon\r\n  @override\r\n  Future<void> savePlaceSuggestions(List<PlaceSuggestion> suggestions) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox == null) return;\r\n\r\n    final Map<dynamic, Map<String, dynamic>> entries = {\r\n      for (var suggestion in suggestions)\r\n        suggestion.placeId: suggestion.toJson()\r\n    };\r\n\r\n    await _suggestionsBox!.putAll(entries);\r\n  }\r\n\r\n  @override\r\n  Future<List<PlaceSuggestion>> getPlaceSuggestions(String prefix, {int limit = 5}) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox == null) return [];\r\n\r\n    final suggestions = <PlaceSuggestion>[];\r\n\r\n    // Parcourir tous les éléments pour trouver ceux correspondant au préfixe\r\n    for (var key in _suggestionsBox!.keys) {\r\n      final data = _suggestionsBox!.get(key);\r\n      if (data == null) continue;\r\n\r\n      try {\r\n        final suggestion = PlaceSuggestion.fromJson(Map<String, dynamic>.from(data));\r\n\r\n        // Vérifier si la suggestion correspond au préfixe (insensible à la casse)\r\n        if (suggestion.primaryText.toLowerCase().contains(prefix.toLowerCase())) {\r\n          suggestions.add(suggestion.copyWith(isFromCache: true));\r\n\r\n          // Limiter le nombre de résultats\r\n          if (suggestions.length >= limit) break;\r\n        }\r\n      } catch (e) {\r\n        print('⚠️ Erreur lors de la conversion d\\'une suggestion: $e');\r\n      }\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  @override\r\n  Future<void> savePlaceDetails(PlaceDetails details) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_detailsBox == null) return;\r\n\r\n    await _detailsBox!.put(\r\n      details.placeId,\r\n      details.toJson(),\r\n    );\r\n\r\n    // Limiter la taille du cache si nécessaire\r\n    if (_detailsBox!.length > LocationConstants.maxCacheEntries) {\r\n      final keysToDelete = _detailsBox!.keys.take(_detailsBox!.length - LocationConstants.maxCacheEntries);\r\n      await _detailsBox!.deleteAll(keysToDelete);\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<PlaceDetails?> getPlaceDetails(String placeId) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_detailsBox == null) return null;\r\n\r\n    final data = _detailsBox!.get(placeId);\r\n    if (data == null) return null;\r\n\r\n    try {\r\n      return PlaceDetails.fromJson(Map<String, dynamic>.from(data));\r\n    } catch (e) {\r\n      print('⚠️ Erreur lors de la récupération des détails: $e');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<void> clearCache() async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox != null) await _suggestionsBox!.clear();\r\n    if (_detailsBox != null) await _detailsBox!.clear();\r\n  }\r\n}",
      "info": {
        "size": 6485,
        "last_modified": "2025-04-16T13:25:25.9611649",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google\\google_ai_studio_service.dart",
      "content": "// core/adapters/google/google_ai_studio_service.dart\r\n\r\n\r\nimport 'package:dio/dio.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../domain/services/google_services_config.dart';\r\nimport '../../common/exceptions/google_api_exception.dart';\r\n\r\n\r\nclass GoogleAIStudioService {\r\n  final Dio _dio = Dio();\r\n  final GoogleServicesConfig _config;\r\n\r\n  GoogleAIStudioService(this._config);\r\n\r\n  // lib/core/adapters/google/google_ai_studio_service.dart\r\n\r\n  Future<Map<String, dynamic>> callMapsDirections({\r\n    required LatLng origin,\r\n    required LatLng destination,\r\n    List<LatLng>? waypoints,\r\n  }) async {\r\n    try {\r\n      final url = 'https://maps.googleapis.com/maps/api/directions/json';\r\n      final params = _buildParams(\r\n        origin: origin,\r\n        destination: destination,\r\n        waypoints: waypoints,\r\n      );\r\n\r\n      print('🔑 API Key utilisée: ${_config.aiStudioApiKey}');\r\n      print('🚀 Appel Directions API via AI Studio');\r\n      print('🌐 URL complète: $url');\r\n      print('📝 Paramètres: $params');\r\n\r\n      final response = await _dio.get(url, queryParameters: params);\r\n\r\n      print('📥 Réponse reçue: ${response.statusCode}');\r\n      print('📄 Contenu de la réponse: ${response.data}');\r\n\r\n      return response.data;\r\n    } catch (e) {\r\n      String errorMessage = 'Erreur lors de l\\'appel à l\\'API Google Directions';\r\n\r\n      if (e is DioError) {\r\n        errorMessage += ': ${e.response?.statusCode}, ${e.response?.data}';\r\n        print('🌐 Erreur réseau: ${e.message}');\r\n        if (e.response != null) {\r\n          print('📄 Données de réponse: ${e.response?.data}');\r\n        }\r\n      } else {\r\n        errorMessage += ': $e';\r\n      }\r\n\r\n      print('❌ $errorMessage');\r\n      throw GoogleAPIException(errorMessage);\r\n    }\r\n  }\r\n\r\n  void _validateLatLng(LatLng point, String pointName) {\r\n    if (point.latitude < -90 || point.latitude > 90) {\r\n      throw ArgumentError(\r\n          'Latitude invalide pour $pointName: ${point.latitude}');\r\n    }\r\n    if (point.longitude < -180 || point.longitude > 180) {\r\n      throw ArgumentError(\r\n          'Longitude invalide pour $pointName: ${point.longitude}');\r\n    }\r\n  }\r\n\r\n  Map<String, String> _buildParams({\r\n    required LatLng origin,\r\n    required LatLng destination,\r\n    List<LatLng>? waypoints,\r\n  }) {\r\n    return {\r\n      'origin': '${origin.latitude},${origin.longitude}',  // était inversé\r\n      'destination': '${destination.latitude},${destination.longitude}',  // était inversé\r\n      if (waypoints != null && waypoints.isNotEmpty)\r\n        'waypoints': 'optimize:true|${waypoints.map((w) => '${w.latitude},${w.longitude}').join('|')}',\r\n      'key': _config.aiStudioApiKey,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 2768,
        "last_modified": "2025-04-16T13:25:25.9734214",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google\\route_optimization.adapter.dart",
      "content": " // lib/core/adapters/google/route_optimization.adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../domain/ports/empty_trips/route_optimization.port.dart';\r\nimport '../../domain/services/google_services_config.dart';\r\nimport '../../common/exceptions/route_optimization_exceptions.dart';\r\nimport '../../common/utils/geohash.dart';\r\nimport 'google_ai_studio_service.dart';\r\n\r\n class RouteOptimizationAdapter implements RouteOptimizationPort {\r\n   final SupabaseClient _supabase;\r\n   final GoogleServicesConfig _config;\r\n   final GoogleAIStudioService? _googleService;\r\n\r\n   RouteOptimizationAdapter(this._supabase, this._config, this._googleService);\r\n\r\n   @override\r\n   Future<Map<String, dynamic>> getOptimizedRoute(\r\n       LatLng origin,\r\n       LatLng destination,\r\n       List<LatLng> waypoints,\r\n       ) async {\r\n     try {\r\n       print('🗺️ Récupération du trajet pour ${_formatLatLng(origin)} → ${_formatLatLng(destination)}');\r\n       print('🗺️ Détails de la requête d\\'optimisation:');\r\n       print('📍 Origine: ${_formatLatLng(origin)}');\r\n       print('🎯 Destination: ${_formatLatLng(destination)}');\r\n       if (waypoints.isNotEmpty) {\r\n         print('🚩 Waypoints:');\r\n         waypoints.forEach((wp) => print('  - ${_formatLatLng(wp)}'));\r\n       }\r\n\r\n       _checkGoogleService();\r\n\r\n       final response = await _googleService!.callMapsDirections(\r\n         origin: origin,\r\n         destination: destination,\r\n         waypoints: waypoints,\r\n       );\r\n\r\n       print('📥 Réponse API:');\r\n       print('  - Status: ${response['status']}');\r\n       print('  - Routes trouvées: ${response['routes']?.length ?? 0}');\r\n\r\n       if (response['status'] != 'OK') {\r\n         print('❌ Détails de l\\'erreur:');\r\n         print('  - Status: ${response['status']}');\r\n         print('  - Message d\\'erreur: ${response['error_message'] ?? 'Non spécifié'}');\r\n         throw RouteNotFoundException('Aucun itinéraire trouvé: ${response['status']}');\r\n       }\r\n\r\n       _checkRouteResponse(response);\r\n\r\n       final route = response['routes'][0];\r\n       final legs = route['legs'] as List;\r\n\r\n       // Calculer les totaux\r\n       int totalDistance = 0;\r\n       int totalDuration = 0;\r\n\r\n       for (var leg in legs) {\r\n         totalDistance += leg['distance']['value'] as int;\r\n         totalDuration += leg['duration']['value'] as int;\r\n       }\r\n\r\n       print('📊 Distance totale: ${totalDistance}m, Durée totale: ${totalDuration}s');\r\n\r\n       return {\r\n         'status': 'OK',\r\n         'polyline': route['overview_polyline']['points'],\r\n         'traversed_geohashes': Geohash.getGeohashesFromPolyline(route['overview_polyline']['points']),\r\n         'distance': totalDistance,\r\n         'duration': totalDuration,\r\n         'waypoint_order': route['waypoint_order'] ?? [],\r\n       };\r\n     } catch (e) {\r\n       print('❌ Erreur optimisation route: $e');\r\n       rethrow;\r\n     }\r\n   }\r\n\r\n   @override\r\n   Future<Duration> getTravelTime(\r\n       LatLng origin,\r\n       LatLng destination,\r\n       {DateTime? departureTime}\r\n       ) async {\r\n     try {\r\n       print('🚗 Calcul du temps de trajet entre ${_formatLatLng(origin)} → ${_formatLatLng(destination)}');\r\n\r\n       _checkGoogleService();\r\n\r\n       final response = await _googleService!.callMapsDirections(\r\n         origin: origin,\r\n         destination: destination,\r\n       );\r\n\r\n       _checkRouteResponse(response);\r\n\r\n       final duration = response['routes'][0]['legs'][0]['duration']['value'];\r\n       print('⏱️ Durée calculée: ${(duration / 60).round()} minutes');\r\n\r\n       return Duration(seconds: duration);\r\n     } catch (e) {\r\n       print('❌ Erreur calcul temps de trajet: $e');\r\n       throw TravelTimeCalculationException('Erreur lors du calcul du temps de trajet: $e');\r\n     }\r\n   }\r\n\r\n   @override\r\n   Future<Map<String, dynamic>> evaluateDetour(\r\n       LatLng origin,\r\n       LatLng destination,\r\n       LatLng detourPoint,\r\n       Duration maxDetourTime,\r\n       ) async {\r\n     try {\r\n       print('📍 Évaluation détour via ${_formatLatLng(detourPoint)}');\r\n\r\n       _checkGoogleService();\r\n\r\n       // Route directe\r\n       final directRoute = await getOptimizedRoute(origin, destination, []);\r\n       final directDuration = directRoute['duration'] as int;\r\n\r\n       // Route avec détour\r\n       final detourRoute = await getOptimizedRoute(origin, destination, [detourPoint]);\r\n       final detourDuration = detourRoute['duration'] as int;\r\n\r\n       final additionalTime = detourDuration - directDuration;\r\n       final isFeasible = Duration(seconds: additionalTime) <= maxDetourTime;\r\n\r\n       return {\r\n         'status': 'OK',\r\n         'additionalTime': additionalTime,\r\n         'feasible': isFeasible,\r\n         'detourRoute': detourRoute,\r\n       };\r\n     } catch (e) {\r\n       print('❌ Erreur évaluation détour: $e');\r\n       throw RouteNotFoundException('Erreur lors de l\\'évaluation du détour: $e');\r\n     }\r\n   }\r\n\r\n   // Méthodes utilitaires privées\r\n   void _checkGoogleService() {\r\n     if (_googleService == null) {\r\n       throw GoogleAPIException('Service Google AI Studio non initialisé');\r\n     }\r\n   }\r\n\r\n   void _checkRouteResponse(Map<String, dynamic> response) {\r\n     if (response['status'] != 'OK') {\r\n       throw RouteNotFoundException('Aucun itinéraire trouvé: ${response['status']}');\r\n     }\r\n   }\r\n\r\n   String _formatLatLng(LatLng point) {\r\n     return '${point.latitude.toStringAsFixed(6)},${point.longitude.toStringAsFixed(6)}';\r\n   }\r\n\r\n   int _calculateTotalDistance(List legs) {\r\n     return legs.fold(0, (sum, leg) => sum + (leg['distance']['value'] as int));\r\n   }\r\n\r\n   int _calculateTotalDuration(List legs) {\r\n     return legs.fold(0, (sum, leg) => sum + (leg['duration']['value'] as int));\r\n   }\r\n }",
      "info": {
        "size": 5910,
        "last_modified": "2025-04-16T13:25:25.9799279",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google_maps\\geocoding_adapter.dart",
      "content": "// core/adapters/google_maps/geocoding_adapter.dart\r\n\r\nimport '../../domain/ports/geocoding_port.dart';\r\nimport '../../domain/models/shared/city_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../domain/ports/maps_port.dart';\r\nimport '../../domain/services/location_service.dart';\r\n\r\n\r\n\r\nclass GeocodingAdapter implements GeocodingPort {\r\n  final LocationService _locationService;\r\n  final MapsPort _mapsService;\r\n\r\n  GeocodingAdapter(this._locationService, this._mapsService);\r\n\r\n  @override\r\n  Future<City> getCity(String cityName) async {\r\n    try {\r\n      // Chercher d'abord dans notre base\r\n      final existingCity = await _locationService.findCity(cityName);\r\n      if (existingCity != null) return existingCity;\r\n\r\n      // Si la ville n'existe pas, l'enrichir via Google Maps\r\n      final enriched = await _mapsService.enrichCityData(cityName);\r\n      if (!enriched) {\r\n        throw DataException('Impossible de trouver ou créer la ville: $cityName');\r\n      }\r\n\r\n      // Récupérer la ville nouvellement créée\r\n      final newCity = await _locationService.findCity(cityName);\r\n      if (newCity == null) {\r\n        throw DataException('Ville créée mais non trouvée: $cityName');\r\n      }\r\n\r\n      return newCity;\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche/création de la ville: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<City>> getMultipleCities(List<String> cityNames) async {\r\n    try {\r\n      final cities = <City>[];\r\n      for (final cityName in cityNames) {\r\n        final city = await getCity(cityName);\r\n        cities.add(city);\r\n      }\r\n      return cities;\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche/création des villes: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1772,
        "last_modified": "2025-04-16T13:25:25.9924421",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google_maps\\maps_adapter.dart",
      "content": "// core/adapters/google_maps/maps_adapter.dart\r\n\r\nimport 'dart:convert';\r\nimport 'dart:math' show cos, sqrt, pi;\r\nimport 'package:http/http.dart' as http;\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../domain/ports/maps_port.dart';\r\nimport '../../domain/ports/location/place_search_port.dart';\r\nimport '../../domain/ports/location/place_details_port.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/location_exceptions.dart';\r\nimport '../../common/utils/geohash.dart';\r\nimport '../../domain/services/location_service.dart';\r\nimport '../../domain/models/location/place_suggestion.dart';\r\nimport '../../domain/models/location/place_details.dart';\r\nimport '../../domain/models/location/user_location.dart';\r\n\r\n/// Service pour les interactions avec l'API Google Maps\r\n/// Gère la géolocalisation et l'enrichissement des données de villes\r\nclass GoogleMapsAdapter implements MapsPort, PlaceSearchPort, PlaceDetailsPort {\r\n  final LocationService _locationService;\r\n  final String _apiKey;\r\n  final http.Client _httpClient;\r\n\r\n  static const _DORDOGNE_BOUNDS = {\r\n    'minLat': 44.5,\r\n    'maxLat': 45.7,\r\n    'minLon': 0.0,\r\n    'maxLon': 1.5,\r\n  };\r\n\r\n  // Définition des départements cibles pour la recherche de lieux\r\n  static const Map<String, Map<String, dynamic>> _TARGET_DEPARTMENTS = {\r\n    'Dordogne': {\r\n      'center': {'lat': 45.1909, 'lng': 0.7214},\r\n      'radius': 80000,\r\n    },\r\n    'Lot': {\r\n      'center': {'lat': 44.6239, 'lng': 1.6094},\r\n      'radius': 50000,\r\n    },\r\n    'Corrèze': {\r\n      'center': {'lat': 45.3394, 'lng': 1.8655},\r\n      'radius': 50000,\r\n    },\r\n  };\r\n\r\n  GoogleMapsAdapter(this._locationService, {http.Client? httpClient}) :\r\n        _apiKey = dotenv.env['GOOGLE_MAPS_API_KEY'] ?? '',\r\n        _httpClient = httpClient ?? http.Client() {\r\n    if (_apiKey.isEmpty) {\r\n      throw DataException('Google Maps API key not found in .env file');\r\n    }\r\n  }\r\n\r\n  bool _isInDordogne(double lat, double lon) {\r\n    return lat >= _DORDOGNE_BOUNDS['minLat']! &&\r\n        lat <= _DORDOGNE_BOUNDS['maxLat']! &&\r\n        lon >= _DORDOGNE_BOUNDS['minLon']! &&\r\n        lon <= _DORDOGNE_BOUNDS['maxLon']!;\r\n  }\r\n\r\n  // Implémentation de MapsPort.getPlaceDetails\r\n  @override\r\n  Future<Map<String, dynamic>?> getPlaceDetails(String cityName) async {\r\n    final url = Uri.parse(\r\n        'https://maps.googleapis.com/maps/api/geocode/json?address=${Uri.encodeComponent(cityName.trim())}&key=$_apiKey'\r\n    );\r\n\r\n    try {\r\n      final response = await _httpClient.get(url);\r\n      final data = json.decode(response.body);\r\n\r\n      if (response.statusCode != 200) {\r\n        throw DataException('HTTP error: ${response.statusCode}');\r\n      }\r\n\r\n      if (data['status'] != 'OK' || data['results'].isEmpty) {\r\n        return null;\r\n      }\r\n\r\n      final location = data['results'][0]['geometry']['location'];\r\n\r\n      if (!_isInDordogne(location['lat'], location['lng'])) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        'lat': location['lat'],\r\n        'lon': location['lng'],\r\n        'formatted_address': data['results'][0]['formatted_address'],\r\n      };\r\n    } catch (e) {\r\n      throw DataException('Failed to get place details: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<bool> enrichCityData(String cityName) async {\r\n    try {\r\n      final placeDetails = await getPlaceDetails(cityName);\r\n      if (placeDetails == null) return false;\r\n\r\n      await _locationService.saveCity(\r\n        cityName: cityName,\r\n        lat: placeDetails['lat'] as double,\r\n        lon: placeDetails['lon'] as double,\r\n        geohash5: Geohash.encode(\r\n            placeDetails['lat'] as double,\r\n            placeDetails['lon'] as double\r\n        ),\r\n      );\r\n\r\n      return true;\r\n    } catch (e) {\r\n      throw DataException('Failed to enrich city data: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<String>> enrichMultipleCities(List<String> cityNames) async {\r\n    final successfulCities = <String>[];\r\n    for (final cityName in cityNames) {\r\n      if (await enrichCityData(cityName)) {\r\n        successfulCities.add(cityName);\r\n      }\r\n    }\r\n    return successfulCities;\r\n  }\r\n\r\n  /// Recherche des suggestions de lieux à partir d'un texte de recherche\r\n  @override\r\n  Future<Result<List<PlaceSuggestion>>> searchPlaces(\r\n      String query, {\r\n        UserLocation? locationBias,\r\n        int radius = 50000,\r\n      }) async {\r\n    if (query.isEmpty) {\r\n      return Result.value([]);\r\n    }\r\n\r\n    try {\r\n      // Construction des paramètres de base\r\n      final params = {\r\n        'input': query,\r\n        'types': '(cities)',\r\n        'components': 'country:fr',\r\n        'key': _apiKey,\r\n        'language': 'fr',\r\n      };\r\n\r\n      // Ajout du biais de localisation si fourni\r\n      if (locationBias != null) {\r\n        final circleBias = 'circle:$radius@${locationBias.latitude},${locationBias.longitude}';\r\n        params['locationbias'] = circleBias;\r\n      } else {\r\n        // Utiliser le premier département cible comme biais par défaut\r\n        final defaultDept = _TARGET_DEPARTMENTS.entries.first;\r\n        final center = defaultDept.value['center'];\r\n        final deptRadius = defaultDept.value['radius'];\r\n\r\n        final circleBias = 'circle:$deptRadius@${center['lat']},${center['lng']}';\r\n        params['locationbias'] = circleBias;\r\n      }\r\n\r\n      final uri = Uri.parse('https://maps.googleapis.com/maps/api/place/autocomplete/json')\r\n          .replace(queryParameters: params);\r\n\r\n      final response = await _httpClient.get(uri);\r\n\r\n      if (response.statusCode != 200) {\r\n        return Result.error(PlacesApiException(\r\n            'Erreur HTTP ${response.statusCode}: ${response.reasonPhrase}'\r\n        ));\r\n      }\r\n\r\n      final data = json.decode(response.body);\r\n\r\n      if (data['status'] != 'OK' && data['status'] != 'ZERO_RESULTS') {\r\n        return Result.error(PlacesApiException(\r\n          'Erreur API Places: ${data['status']}',\r\n          errorCode: data['status'],\r\n        ));\r\n      }\r\n\r\n      final List<dynamic> predictions = data['predictions'] ?? [];\r\n\r\n      final suggestions = predictions.map<PlaceSuggestion>((prediction) {\r\n        final mainText = prediction['structured_formatting']['main_text'] ?? '';\r\n        final secondaryText = prediction['structured_formatting']['secondary_text'] ?? '';\r\n\r\n        return PlaceSuggestion(\r\n          placeId: prediction['place_id'],\r\n          primaryText: mainText,\r\n          secondaryText: secondaryText,\r\n        );\r\n      }).toList();\r\n\r\n      return Result.value(suggestions);\r\n    } catch (e) {\r\n      return Result.error(PlacesApiException(\r\n          'Erreur lors de la recherche de lieux: ${e.toString()}'\r\n      ));\r\n    }\r\n  }\r\n\r\n  /// Implémentation de PlaceDetailsPort.getPlaceDetails\r\n  /// Renommée pour éviter le conflit avec MapsPort.getPlaceDetails\r\n  @override\r\n  Future<Result<PlaceDetails>> getPlaceDetailsById(String placeId) async {\r\n    try {\r\n      // Construction des paramètres\r\n      final params = {\r\n        'place_id': placeId,\r\n        'fields': 'name,formatted_address,geometry/location',\r\n        'key': _apiKey,\r\n        'language': 'fr',\r\n      };\r\n\r\n      final uri = Uri.parse('https://maps.googleapis.com/maps/api/place/details/json')\r\n          .replace(queryParameters: params);\r\n\r\n      final response = await _httpClient.get(uri);\r\n\r\n      if (response.statusCode != 200) {\r\n        return Result.error(PlacesApiException(\r\n            'Erreur HTTP ${response.statusCode}: ${response.reasonPhrase}'\r\n        ));\r\n      }\r\n\r\n      final data = json.decode(response.body);\r\n\r\n      if (data['status'] != 'OK') {\r\n        return Result.error(PlacesApiException(\r\n          'Erreur API Place Details: ${data['status']}',\r\n          errorCode: data['status'],\r\n        ));\r\n      }\r\n\r\n      final result = data['result'];\r\n      final geometry = result['geometry'];\r\n      final location = geometry['location'];\r\n\r\n      final placeDetails = PlaceDetails(\r\n        placeId: placeId,\r\n        name: result['name'],\r\n        formattedAddress: result['formatted_address'],\r\n        location: UserLocation(\r\n          latitude: location['lat'],\r\n          longitude: location['lng'],\r\n        ),\r\n        country: null,\r\n        administrativeArea: null,\r\n        locality: null,\r\n        postalCode: null,\r\n        lastUpdated: DateTime.now(),\r\n      );\r\n\r\n      return Result.value(placeDetails);\r\n    } catch (e) {\r\n      print('⚠️ Erreur dans getPlaceDetailsById: $e');\r\n      return Result.error(PlacesApiException(\r\n          'Erreur lors de la récupération des détails du lieu: ${e.toString()}'\r\n      ));\r\n    }\r\n  }\r\n\r\n  /// Vérifie si un lieu se trouve dans l'un des départements ciblés\r\n  bool isInTargetDepartments(double lat, double lng) {\r\n    // Vérifie d'abord avec la méthode existante pour la Dordogne\r\n    if (_isInDordogne(lat, lng)) {\r\n      return true;\r\n    }\r\n\r\n    // Vérifie avec les autres départements ciblés\r\n    for (final dept in _TARGET_DEPARTMENTS.entries) {\r\n      final center = dept.value['center'];\r\n      final radius = dept.value['radius'];\r\n\r\n      // Calcule la distance approximative (en mètres)\r\n      final dLat = (lat - center['lat']) * 111000;\r\n      final dLng = (lng - center['lng']) * 111000 * cos(center['lat'] * pi / 180);\r\n      final distance = sqrt(dLat * dLat + dLng * dLng);\r\n\r\n      if (distance <= radius) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}",
      "info": {
        "size": 9536,
        "last_modified": "2025-04-16T13:25:25.9999434",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\postgis\\geometry_calculation.adapter.dart",
      "content": "// lib/core/adapters/postgis/geometry_calculation.adapter.dart\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/empty_trips/geometry_calculation.port.dart';\r\nimport '../../common/utils/maps_toolkit_utils.dart';\r\nimport '../../common/constants/geometry_constants.dart';\r\nimport '../../common/exceptions/geometry_calculation_exception.dart';\r\n\r\nclass GeometryCalculationAdapter implements GeometryCalculationPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  GeometryCalculationAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<double> calculateDistance(LatLng point1, LatLng point2) async {\r\n    try {\r\n      final response = await _supabase\r\n          .rpc('calculate_distance', params: {\r\n        'lat1': point1.latitude,\r\n        'lng1': point1.longitude,\r\n        'lat2': point2.latitude,\r\n        'lng2': point2.longitude,\r\n      });\r\n\r\n      return response as double;\r\n    } catch (_) {\r\n      // Fallback to Maps Toolkit si PostGIS échoue\r\n      return MapsToolkitUtils.calculateHaversineDistance(point1, point2);\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<int> calculateMalusMinutes(double distanceMeters, String travelStyle) async {\r\n    try {\r\n      return MapsToolkitUtils.calculateMalusMinutes(distanceMeters, travelStyle);\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to calculate malus minutes: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<bool> isLocationOnPath(LatLng point, List<LatLng> pathPoints) async {\r\n    try {\r\n      return MapsToolkitUtils.isLocationOnPath(\r\n          point,\r\n          pathPoints,\r\n          toleranceMeters: GeometryConstants.defaultToleranceMeters\r\n      );\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to check location on path: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<bool> isWithinMaxDetour(LatLng point, LatLng start, LatLng end) async {\r\n    try {\r\n      final directDistance = await calculateDistance(start, end);\r\n      final detourDistance = await calculateDistance(start, point) +\r\n          await calculateDistance(point, end);\r\n\r\n      return detourDistance <= (directDistance + (GeometryConstants.maxDetourDistanceKm * 1000));\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to check max detour: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2336,
        "last_modified": "2025-04-16T13:25:26.0119739",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\processing\\activity_hours_adapter.dart",
      "content": "// lib\\core\\adapters\\processing\\activity_hours_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\n\r\n// Extension pour convertir le numéro du jour en nom\r\nextension DateTimeExtension on int {\r\n  String toDayName() {\r\n    switch (this) {\r\n      case DateTime.monday: return 'monday';\r\n      case DateTime.tuesday: return 'tuesday';\r\n      case DateTime.wednesday: return 'wednesday';\r\n      case DateTime.thursday: return 'thursday';\r\n      case DateTime.friday: return 'friday';\r\n      case DateTime.saturday: return 'saturday';\r\n      case DateTime.sunday: return 'sunday';\r\n      default: throw Exception('Invalid day of week');\r\n    }\r\n  }\r\n}\r\n\r\nclass OpeningDays {\r\n  final Map<String, Map<String, String>> availableDays; // jour -> {opens_at, closes_at}\r\n\r\n  OpeningDays(this.availableDays);\r\n\r\n  bool get hasOpenDays => availableDays.isNotEmpty;\r\n\r\n  Map<String, String>? getHoursForDay(String day) => availableDays[day];\r\n}\r\n\r\nclass ActivityHoursService {\r\n  final SupabaseClient _supabase;\r\n\r\n  const ActivityHoursService(this._supabase);\r\n\r\n  Future<OpeningDays?> getActivityHours(\r\n      String activityId, DateTime dateStart, DateTime dateEnd) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('activity_hours')\r\n          .select()\r\n          .eq('activity_id', activityId)\r\n          .eq('is_open', true)\r\n          .lte('season_start', dateEnd.toIso8601String())\r\n          .gte('season_end', dateStart.toIso8601String());\r\n\r\n      if (response.isEmpty) {\r\n        print('Aucun horaire trouvé pour l\\'activité $activityId');\r\n        return null;\r\n      }\r\n\r\n      final schedule = response[0]['day_of_week'];\r\n      if (schedule == null) {\r\n        print('Structure d\\'horaires invalide pour l\\'activité $activityId');\r\n        return null;\r\n      }\r\n\r\n      // Résultat pour stocker les jours disponibles\r\n      Map<String, Map<String, String>> availableDays = {};\r\n\r\n      // Vérifier chaque jour du séjour\r\n      for (var d = dateStart;\r\n      d.isBefore(dateEnd.add(Duration(days: 1)));\r\n      d = d.add(Duration(days: 1))) {\r\n\r\n        String dayName = d.weekday.toDayName().toLowerCase();\r\n        print('Vérification pour ${d.toString()} (${dayName})');\r\n\r\n        // Vérifier d'abord les horaires 'all'\r\n        if (schedule['all'] != null) {\r\n          availableDays[dayName] = {\r\n            'opens_at': schedule['all']['opens_at'],\r\n            'closes_at': schedule['all']['closes_at'],\r\n          };\r\n          continue;\r\n        }\r\n\r\n        // Sinon vérifier les horaires spécifiques du jour\r\n        if (schedule[dayName] != null) {\r\n          availableDays[dayName] = {\r\n            'opens_at': schedule[dayName]['opens_at'],\r\n            'closes_at': schedule[dayName]['closes_at'],\r\n          };\r\n        }\r\n      }\r\n\r\n      // Si aucun jour d'ouverture trouvé\r\n      if (availableDays.isEmpty) {\r\n        print('Aucun jour d\\'ouverture pendant le séjour pour l\\'activité $activityId');\r\n        return null;\r\n      }\r\n\r\n      print('Jours d\\'ouverture trouvés: ${availableDays.keys.join(', ')}');\r\n      return OpeningDays(availableDays);\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération des horaires: $e');\r\n      return null;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3369,
        "last_modified": "2025-04-16T13:25:26.0250855",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\processing\\filter_processing_adapter.dart",
      "content": "// core/adapters/processing/filter_processing_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/services/travel_time_service.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../domain/filters/filter_chain.dart';\r\nimport '../../domain/filters/travel_group_filter.dart';\r\nimport '../../domain/filters/time_filter.dart';\r\n\r\nclass FilterProcessingAdapter {\r\n  final ActivityHoursPort _hoursAdapter;\r\n  final SupabaseClient _supabase;  // Ajout pour TravelTimeService\r\n\r\n  FilterProcessingAdapter(this._hoursAdapter, this._supabase);  // Mise à jour constructeur\r\n\r\n  Future<List<ActivityForProcessing>> getFilteredActivities(\r\n      String tripId,\r\n      List<ActivityForProcessing> activities,\r\n      Trip trip\r\n      ) async {\r\n    final filterChain = FilterChain()\r\n      ..addFilter(TravelGroupFilter(trip.travelGroup))\r\n      ..addFilter(TimeFilter(\r\n        tripStartDate: trip.startDate,\r\n        tripEndDate: trip.endDate,\r\n        dailyHours: trip.activityHours.daily_hours,  // Au lieu de tripActivityHours\r\n        hoursService: _hoursAdapter,\r\n        departureGeohash5: trip.departureGeohash5 ?? '',  // Ajout\r\n        travelTimeService: TravelTimeService(_supabase),  // Ajout\r\n      ));\r\n\r\n    return await filterChain.apply(activities);\r\n  }\r\n}",
      "info": {
        "size": 1480,
        "last_modified": "2025-04-16T13:25:26.032191",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\activity_hours_adapter.dart",
      "content": "// core/adapters/supabase/activity_hours_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/models/opening_days.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\n\r\nclass ActivityHoursAdapter implements ActivityHoursPort {\r\n  final SupabaseClient _client;  // On garde _client comme nom de variable\r\n\r\n  ActivityHoursAdapter(SupabaseClient supabase) : _client = supabase;  // On initialise _client\r\n\r\n  @override\r\n  Future<OpeningDays?> getActivityHours(\r\n      String activityId,\r\n      DateTime startDate,\r\n      DateTime endDate,\r\n      ) async {\r\n    try {\r\n      final response = await _client\r\n          .from('activity_hours')\r\n          .select()\r\n          .eq('activity_id', activityId)\r\n          .lte('season_start', endDate.toIso8601String())\r\n          .gte('season_end', startDate.toIso8601String())\r\n          .eq('is_open', true);\r\n\r\n      if (response == null || response.isEmpty) {\r\n        return null;\r\n      }\r\n\r\n      final schedule = response[0]; // Prendre le premier horaire valide\r\n      final dayOfWeek = schedule['day_of_week'] as Map<String, dynamic>;\r\n      final Map<String, Map<String, String>> availableDays = {};\r\n\r\n      // Pour chaque jour entre startDate et endDate\r\n      for (var date = startDate; date.isBefore(endDate.add(const Duration(days: 1))); date = date.add(const Duration(days: 1))) {\r\n        String formattedDate = date.toIso8601String().split('T')[0];\r\n\r\n        // Si \"all\" est défini, utiliser ces horaires pour tous les jours\r\n        if (dayOfWeek['all'] != null) {\r\n          availableDays[formattedDate] = {\r\n            'opens_at': dayOfWeek['all']['opens_at'],\r\n            'closes_at': dayOfWeek['all']['closes_at'],\r\n          };\r\n        }\r\n        // Sinon, chercher l'horaire spécifique au jour de la semaine\r\n        else {\r\n          String weekday = _getWeekdayName(date.weekday).toLowerCase();\r\n          if (dayOfWeek[weekday] != null) {\r\n            availableDays[formattedDate] = {\r\n              'opens_at': dayOfWeek[weekday]['opens_at'],\r\n              'closes_at': dayOfWeek[weekday]['closes_at'],\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      return OpeningDays(availableDays: availableDays);\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération des horaires: $e');\r\n      throw DataException('Erreur lors de la récupération des horaires: $e');\r\n    }\r\n  }\r\n\r\n  String _getWeekdayName(int weekday) {\r\n    switch (weekday) {\r\n      case 1: return 'monday';\r\n      case 2: return 'tuesday';\r\n      case 3: return 'wednesday';\r\n      case 4: return 'thursday';\r\n      case 5: return 'friday';\r\n      case 6: return 'saturday';\r\n      case 7: return 'sunday';\r\n      default: throw ArgumentError('Invalid weekday number: $weekday');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2861,
        "last_modified": "2025-04-16T13:25:26.0452277",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\activity_processing_adapter.dart",
      "content": "// core/adapters/supabase/activity_processing_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_processing_port.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../domain/filters/travel_group_filter.dart';\r\nimport '../../domain/filters/time_filter.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/services/travel_time_service.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\nimport '../supabase/activity_hours_adapter.dart';\r\n\r\nclass ActivityProcessingAdapter implements ActivityProcessingPort {\r\n  final SupabaseClient _supabase;\r\n  final ActivityHoursPort _hoursService;\r\n\r\n\r\n  ActivityProcessingAdapter(SupabaseClient supabase) :\r\n        _supabase = supabase,\r\n        _hoursService = ActivityHoursAdapter(supabase);\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> getActivitiesForTrip(String tripId) async {\r\n    try {\r\n      // 1. Récupérer le trip\r\n      final tripResponse = await _supabase\r\n          .from('trips')\r\n          .select('''\r\n            *,\r\n            cities!trips_departure_city_id_fkey (*)\r\n          ''')\r\n          .eq('id', tripId)\r\n          .single();\r\n\r\n      final trip = Trip.fromJson(tripResponse);\r\n      print('🎯 Types d\\'exploration: ${trip.activeExplorationType}');\r\n\r\n      // 2. Calculer la distance maximale\r\n      final maxDistance = _getMaxDistance(trip.activeExplorationType);\r\n      print('📏 Distance maximale calculée: $maxDistance km');\r\n\r\n      // 3. Récupérer les geohash voisins\r\n      final geohash4 = trip.departureGeohash5?.substring(0, 4);\r\n      print('🗺️ Geohash4 de départ: $geohash4');\r\n\r\n      final neighbors = await getGeohashNeighbors(geohash4 ?? '', maxDistance);\r\n      print('🔍 Geohash voisins trouvés: ${neighbors.keys.toList()}');\r\n\r\n      final allGeohashes = [geohash4, ...neighbors.values.expand((e) => e).toList()];\r\n      print('🎯 Recherche des activités dans les geohash: $allGeohashes');\r\n\r\n      final response = await _supabase\r\n          .from('activities')\r\n          .select()\r\n          .inFilter('geohash_4', allGeohashes);\r\n\r\n      print('📍 Nombre d\\'activités trouvées: ${response.length}');\r\n\r\n      return response.map((json) => ActivityForProcessing.fromJson(json)).toList();\r\n    } catch (e) {\r\n      print('❌ Erreur dans getActivitiesForTrip: $e');\r\n      throw DataException('Erreur lors de la récupération des activités: $e');\r\n    }\r\n  }\r\n\r\n  double _getMaxDistance(List<ExplorationType> types) {\r\n    double maxDist = 0;\r\n    print('🔄 Calcul de la distance maximale pour les types: ${types.map((t) => t.value).toList()}');\r\n    for (var type in types) {\r\n      final dist = type.maxDistance;\r\n      print('  - Type ${type.value}: $dist km');\r\n      if (dist > maxDist) maxDist = dist;\r\n    }\r\n    print('  → Distance max retenue: $maxDist km');\r\n    return maxDist;\r\n  }\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> getFilteredActivities({\r\n    required String tripId,\r\n    required Trip trip,\r\n    required List<ActivityForProcessing> activities,\r\n  }) async {\r\n    try {\r\n      print('🎯 Début du filtrage des activités');\r\n      print('Nombre d\\'activités avant filtrage: ${activities.length}');\r\n\r\n      // Créer et appliquer le filtre de temps\r\n      final timeFilter = TimeFilter(\r\n        tripStartDate: trip.startDate,\r\n        tripEndDate: trip.endDate,\r\n        dailyHours: trip.activityHours.daily_hours,\r\n        hoursService: _hoursService,\r\n        departureGeohash5: trip.departureGeohash5 ?? '',  // Ajout\r\n        travelTimeService: TravelTimeService(_supabase),   // Ajout\r\n      );\r\n\r\n      final timeFilteredActivities = await timeFilter.apply(activities);\r\n      print('Nombre d\\'activités après filtre temporel: ${timeFilteredActivities.length}');\r\n\r\n      // Créer et appliquer le filtre de groupe\r\n      final groupFilter = TravelGroupFilter(trip.travelGroup);\r\n      final filteredActivities = await groupFilter.apply(timeFilteredActivities);\r\n      print('Nombre d\\'activités après tous les filtres: ${filteredActivities.length}');\r\n\r\n      return filteredActivities;\r\n    } catch (e) {\r\n      print('❌ Erreur lors du filtrage: $e');\r\n      throw DataException('Erreur lors du filtrage des activités: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  double getExplorationRadius(String explorationType) {\r\n    return ExplorationType.values\r\n        .firstWhere(\r\n            (e) => e.value == explorationType,\r\n        orElse: () => ExplorationType.around_me\r\n    ).maxDistance;\r\n  }\r\n\r\n  @override\r\n  Future<Map<String, List<String>>> getGeohashNeighbors(\r\n      String geohash4, double maxDistance) async {\r\n    try {\r\n      print('🔍 Recherche des voisins pour le geohash: $geohash4');\r\n      print('📏 Distance maximale: $maxDistance km');\r\n\r\n      final response = await _supabase\r\n          .from('geohash_neighbors')\r\n          .select()\r\n          .eq('geohash', geohash4)\r\n          .lte('distance_km', maxDistance)\r\n          .order('distance_km');\r\n\r\n      print('📥 Réponse brute: $response');\r\n\r\n      Map<String, List<String>> neighbors = {};\r\n      neighbors[geohash4] = [];\r\n\r\n      for (var row in response) {\r\n        final neighborHash = row['neighbor_geohash'] as String;\r\n        final neighbor4 = neighborHash.substring(0, 4);\r\n\r\n        print('🔄 Ajout du voisin: $neighbor4');\r\n        neighbors[geohash4]?.add(neighbor4);\r\n      }\r\n\r\n      print('✅ Voisins trouvés: ${neighbors.values.expand((e) => e).toList()}');\r\n      return neighbors;\r\n    } catch (e) {\r\n      print('❌ Erreur dans getGeohashNeighbors: $e');\r\n      throw DataException('Erreur lors de la récupération des geohash voisins: $e');\r\n    }\r\n  }\r\n}\r\n",
      "info": {
        "size": 5906,
        "last_modified": "2025-04-16T13:25:26.0522806",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\activity_scoring_adapter.dart",
      "content": "// core/adapters/supabase/activity_scoring_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_scoring_port.dart';\r\nimport '../../domain/models/trip_designer/scoring/scoring_activity.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/services/scoring_service.dart';\r\n\r\nclass ActivityScoringAdapter implements ActivityScoringPort {\r\n  final SupabaseClient _client;\r\n  final ScoringService _scoringService;\r\n\r\n  ActivityScoringAdapter(this._client) : _scoringService = ScoringService();\r\n\r\n  @override\r\n  Future<List<ScoredActivity>> scoreActivities(String userId, List<ActivityForProcessing> activities) async {\r\n    try {\r\n      print('🎯 Début du scoring des activités pour l\\'utilisateur: $userId');\r\n\r\n      // 1. Récupérer les préférences utilisateur\r\n      final preferences = await getUserPreferences(userId);\r\n\r\n      // 2. Récupérer les scores existants en cache\r\n      final existingScores = await _getCachedScores(userId, activities.map((a) => a.id).toList(), activities);\r\n      final results = <ScoredActivity>[];\r\n\r\n      for (var activity in activities) {\r\n        // Vérifier si un score en cache existe et est toujours valide\r\n        if (existingScores.containsKey(activity.id)) {\r\n          print('✅ Score en cache trouvé pour ${activity.name}');\r\n          results.add(existingScores[activity.id]!);\r\n          continue;\r\n        }\r\n\r\n        print('🔄 Calcul du score pour ${activity.name}');\r\n\r\n        // Calculer les nouveaux scores\r\n        final subcategoryScore = preferences[activity.subcategoryId] ?? 0.0;\r\n        final totalScore = _scoringService.calculateTotalScore(activity, subcategoryScore);\r\n        final isSuperWow = _scoringService.isSuperWow(totalScore, subcategoryScore);\r\n        print('🎯 Activité ${activity.id}: score total=${totalScore}, subcategory=${subcategoryScore}, SuperWow=${isSuperWow}');\r\n\r\n\r\n        // Sauvegarder en cache\r\n        await _saveScore(\r\n          userId,\r\n          activity.id,\r\n          totalScore,\r\n          subcategoryScore,\r\n          isSuperWow,\r\n        );\r\n\r\n        results.add(ScoredActivity(\r\n          activity: activity,\r\n          totalScore: totalScore,\r\n          subcategoryScore: subcategoryScore,\r\n          isSuperWow: isSuperWow,\r\n        ));\r\n      }\r\n\r\n      print('✅ Scoring terminé: ${results.length} activités traitées');\r\n      return results;\r\n    } catch (e) {\r\n      print('❌ Erreur lors du scoring: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<Map<String, double>> getUserPreferences(String userId) async {\r\n    try {\r\n      final response = await _client\r\n          .from('user_subcategory_preferences')\r\n          .select()\r\n          .eq('user_id', userId);\r\n\r\n      final preferences = <String, double>{};\r\n      for (var pref in response) {\r\n        preferences[pref['subcategory_id']] = pref['score']?.toDouble() ?? 0.0;\r\n      }\r\n\r\n      return preferences;\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération des préférences: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  Future<Map<String, ScoredActivity>> _getCachedScores(\r\n      String userId,\r\n      List<String> activityIds,\r\n      List<ActivityForProcessing> activities  // Ajout du paramètre\r\n      ) async {\r\n    try {\r\n      final response = await _client\r\n          .from('user_activities_score')\r\n          .select()\r\n          .eq('user_id', userId)\r\n          .inFilter('activity_id', activityIds);\r\n\r\n      final cachedScores = <String, ScoredActivity>{};\r\n      for (var score in response) {\r\n        // On ne prend que les scores qui ont encore une période de validité\r\n        if (score['superwow_validity_period'] != null &&\r\n            DateTime.parse(score['superwow_validity_period']).isBefore(DateTime.now())) {\r\n          continue;\r\n        }\r\n\r\n        cachedScores[score['activity_id']] = ScoredActivity(\r\n          activity: activities.firstWhere((a) => a.id == score['activity_id']),\r\n          totalScore: score['total_score']?.toDouble() ?? 0.0,\r\n          subcategoryScore: score['subcategory_score']?.toDouble() ?? 0.0,\r\n          isSuperWow: score['is_superwow'] ?? false,\r\n        );\r\n      }\r\n\r\n      return cachedScores;\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération des scores en cache: $e');\r\n      return {};\r\n    }\r\n  }\r\n\r\n  Future<void> _saveScore(\r\n      String userId,\r\n      String activityId,\r\n      double totalScore,\r\n      double subcategoryScore,\r\n      bool isSuperWow,\r\n      ) async {\r\n    try {\r\n      await _client.from('user_activities_score').upsert({\r\n        'user_id': userId,\r\n        'activity_id': activityId,\r\n        'total_score': totalScore,\r\n        'subcategory_score': subcategoryScore,\r\n        'is_superwow': isSuperWow,\r\n        'superwow_validity_period': isSuperWow\r\n            ? DateTime.now().add(Duration(days: 7)).toIso8601String()\r\n            : null,\r\n        'updated_at': DateTime.now().toIso8601String(),\r\n      });\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la sauvegarde du score: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 5177,
        "last_modified": "2025-04-16T13:25:26.0598614",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\config\\remote_config_adapter.dart",
      "content": "// lib/core/adapters/supabase/config/remote_config_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\nimport '../../../domain/models/config/home_section_config.dart';\r\nimport '../../../domain/models/config/app_remote_config.dart';\r\nimport '../../../domain/ports/config/remote_config_port.dart';\r\nimport '../../../domain/models/config/subcategory_section_config.dart';\r\n\r\n\r\nclass SupabaseRemoteConfigAdapter implements RemoteConfigPort {\r\n  final SupabaseClient _client;\r\n\r\n  SupabaseRemoteConfigAdapter(this._client);\r\n\r\n  @override\r\n  Future<List<HomeSectionConfig>> getHomeSections() async {\r\n    try {\r\n      print('🔄 Calling Supabase home_sections');\r\n      final response = await _client\r\n          .from('home_sections')\r\n          .select()\r\n          .order('priority');\r\n      print('📬 Raw Supabase response: $response');\r\n\r\n      if (response == null) return [];\r\n\r\n      final List<HomeSectionConfig> sections = (response as List).map((data) {\r\n        print('🔍 Processing data: $data');\r\n        return HomeSectionConfig(\r\n          id: data['id']?.toString() ?? '',\r\n          title: data['title']?.toString() ?? '',\r\n          queryFilter: data['query_filter']?.toString() ?? '{}',\r\n          iconUrl: data['icon_url']?.toString(),\r\n          priority: data['priority'] as int? ?? 0,\r\n          minAppVersion: data['min_app_version']?.toString() ?? '1.0.0',\r\n        );\r\n      }).toList();\r\n\r\n      print('✅ Created sections: $sections');\r\n      return sections;\r\n    } catch (e, stack) {\r\n      print('❌ Error in getHomeSections: $e');\r\n      print('📜 Stack trace: $stack');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<AppRemoteConfig>> getAppConfig() async {\r\n    final response = await _client\r\n        .from('app_remote_config')\r\n        .select();\r\n\r\n    return response.map((json) => AppRemoteConfig.fromJson(json)).toList();\r\n  }\r\n\r\n  @override\r\n  Future<List<SubcategorySectionConfig>> getSubcategorySections(String? subcategoryId) async {\r\n    try {\r\n      print('🔄 Calling Supabase subcategory_sections');\r\n\r\n      // Construction de la requête de base\r\n      var query = _client\r\n          .from('subcategory_sections')\r\n          .select();\r\n\r\n      if (subcategoryId != null) {\r\n        // Si un subcategoryId est fourni, on cherche d'abord les configurations spécifiques\r\n        query = query.or('subcategory_id.eq.$subcategoryId,is_default.eq.true');\r\n      } else {\r\n        // Sinon, on ne prend que les configurations par défaut\r\n        query = query.eq('is_default', true);\r\n      }\r\n\r\n      final response = await query.order('priority');\r\n      print('📬 Raw Supabase response: $response');\r\n\r\n      if (response == null) return [];\r\n\r\n      final List<SubcategorySectionConfig> sections = (response as List).map((data) {\r\n        print('🔍 Processing data: $data');\r\n        return SubcategorySectionConfig(\r\n          id: data['id']?.toString() ?? '',\r\n          title: data['title']?.toString() ?? '',\r\n          queryFilter: data['query_filter']?.toString() ?? '{}',\r\n          subcategoryId: data['subcategory_id']?.toString(),\r\n          priority: data['priority'] as int? ?? 0,\r\n          minAppVersion: data['min_app_version']?.toString() ?? '1.0.0',\r\n          isDefault: data['is_default'] as bool? ?? false,\r\n        );\r\n      }).toList();\r\n\r\n      // Si on a un subcategoryId, on priorise les configurations spécifiques\r\n      if (subcategoryId != null) {\r\n        // Trier pour avoir les configs spécifiques avant les configs par défaut\r\n        sections.sort((a, b) {\r\n          if (a.subcategoryId == subcategoryId && b.subcategoryId != subcategoryId) return -1;\r\n          if (a.subcategoryId != subcategoryId && b.subcategoryId == subcategoryId) return 1;\r\n          return a.priority.compareTo(b.priority);\r\n        });\r\n\r\n        // Pour chaque priorité, ne garder que la première config (spécifique si elle existe, sinon défaut)\r\n        final uniqueSections = <SubcategorySectionConfig>[];\r\n        final seenPriorities = <int>{};\r\n\r\n        for (var section in sections) {\r\n          if (!seenPriorities.contains(section.priority)) {\r\n            uniqueSections.add(section);\r\n            seenPriorities.add(section.priority);\r\n          }\r\n        }\r\n\r\n        return uniqueSections;\r\n      }\r\n\r\n      print('✅ Created sections: $sections');\r\n      return sections;\r\n    } catch (e, stack) {\r\n      print('❌ Error in getSubcategorySections: $e');\r\n      print('📜 Stack trace: $stack');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n\r\n}",
      "info": {
        "size": 4559,
        "last_modified": "2025-04-16T13:25:26.0663808",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\database_adapter.dart",
      "content": "// lib\\core\\adapters\\supabase\\database_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\n\r\nclass SupabaseService {\r\n  // Initialisation de Supabase\r\n  static Future<void> initialize() async {\r\n    await dotenv.load();\r\n    await Supabase.initialize(\r\n      url: dotenv.env['SUPABASE_URL']!,\r\n      anonKey: dotenv.env['SUPABASE_ANON_KEY']!,\r\n    );\r\n  }\r\n\r\n  // Accès au client Supabase\r\n  static SupabaseClient get client => Supabase.instance.client;\r\n\r\n  // Récupérer toutes les catégories\r\n  static Future<List<Map<String, dynamic>>> getCategories() async {\r\n    final response = await client\r\n        .from('categories')\r\n        .select()\r\n        .order('name');\r\n    return List<Map<String, dynamic>>.from(response);\r\n  }\r\n\r\n  // Récupérer les activités par catégorie\r\n  static Future<List<Map<String, dynamic>>> getActivitiesByCategory(String categoryId) async {\r\n    final response = await client\r\n        .from('activities')\r\n        .select()\r\n        .eq('category_id', categoryId)\r\n        .order('name');\r\n    return List<Map<String, dynamic>>.from(response);\r\n  }\r\n\r\n  // Créer un nouveau voyage\r\n  static Future<Map<String, dynamic>> createTrip(Map<String, dynamic> tripData) async {\r\n    final response = await client\r\n        .from('trips')\r\n        .insert(tripData)\r\n        .select()\r\n        .single();\r\n    return response;\r\n  }\r\n\r\n  // Récupérer les préférences d'un utilisateur\r\n  static Future<List<Map<String, dynamic>>> getUserPreferences(String userId) async {\r\n    final response = await client\r\n        .from('user_preferences')\r\n        .select('*, categories(*)')\r\n        .eq('user_id', userId);\r\n    return List<Map<String, dynamic>>.from(response);\r\n  }\r\n\r\n  // Récupérer les activités filtrées via les préférences utilisateur (RPC)\r\n  static Future<List<Map<String, dynamic>>> getFilteredActivitiesByPreferences(String userId) async {\r\n    try {\r\n      final response = await client.rpc(\r\n        'filter_activities_by_preferences',\r\n        params: {'user_uuid': userId},\r\n      );\r\n\r\n      if (response == null) {\r\n        return [];\r\n      }\r\n\r\n      // Vérifie si la réponse est une liste\r\n      if (response is! List) {\r\n        throw Exception('Format de réponse invalide');\r\n      }\r\n\r\n      // Conversion sécurisée de la réponse\r\n      return response.map((item) {\r\n        if (item is! Map<String, dynamic>) {\r\n          // Conversion explicite si nécessaire\r\n          return Map<String, dynamic>.from(item as Map);\r\n        }\r\n        return item;\r\n      }).toList();\r\n\r\n    } catch (e) {\r\n      print('Erreur lors de la récupération des activités filtrées: $e'); // Pour le débogage\r\n      throw Exception('Erreur lors de la récupération des activités : $e');\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 2837,
        "last_modified": "2025-04-16T13:25:26.0789174",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\empty_daily_trip.adapter.dart",
      "content": "// lib/core/adapters/supabase/empty_daily_trip.adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:uuid/uuid.dart';\r\nimport '../../domain/ports/empty_trips/empty_daily_trip.port.dart';\r\nimport '../../domain/models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\n\r\nclass EmptyDailyTripAdapter implements EmptyDailyTripPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  EmptyDailyTripAdapter(this._supabase);\r\n\r\n  EmptyDailyTrip _convertResponseToEmptyTrip(Map<String, dynamic> response) {\r\n    return EmptyDailyTrip(\r\n      id: response['id'],\r\n      type: response['type'] == 'half_day' ? DailyTripType.half_day : DailyTripType.full_day,\r\n      departureGeohash5: response['departure_geohash5'],\r\n      arrivalGeohash5: response['arrival_geohash5'],\r\n      sw1Id: response['sw1_id'],\r\n      sw2Id: response['sw2_id'],\r\n      traversedGeohashes: List<String>.from(response['traversed_geohashes']),\r\n      routePolyline: response['route_polyline'],\r\n      createdAt: DateTime.parse(response['created_at']),\r\n      totalDuration: response['total_duration'],\r\n      totalDistance: response['total_distance'],\r\n    );\r\n  }\r\n\r\n  @override\r\n  Future<EmptyDailyTrip?> findExistingEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n  }) async {\r\n    try {\r\n      var query = _supabase\r\n          .from('empty_daily_trips')\r\n          .select()\r\n          .eq('type', type.toString().split('.').last)\r\n          .eq('departure_geohash5', departureGeohash5)\r\n          .eq('arrival_geohash5', arrivalGeohash5)\r\n          .eq('sw1_id', sw1Id);\r\n\r\n      query = sw2Id == null\r\n          ? query.filter('sw2_id', 'is', null)\r\n          : query.eq('sw2_id', sw2Id);\r\n\r\n      final response = await query;\r\n\r\n      if (response.isEmpty) return null;\r\n\r\n      return _convertResponseToEmptyTrip(response[0]);\r\n    } catch (e) {\r\n      print('❌ Erreur recherche empty trip: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<EmptyDailyTrip> getEmptyTrip(String emptyTripId) async {\r\n    try {\r\n      print('🔍 Récupération empty trip: $emptyTripId');\r\n      final response = await _supabase\r\n          .from('empty_daily_trips')\r\n          .select()\r\n          .eq('id', emptyTripId)\r\n          .single();\r\n\r\n      return _convertResponseToEmptyTrip(response);\r\n    } catch (e) {\r\n      print('❌ Erreur récupération empty trip: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<EmptyDailyTrip> createEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n    required List<String> traversedGeohashes,\r\n    required String routePolyline,\r\n    required int totalDuration,\r\n    required int totalDistance,\r\n  }) async {\r\n    try {\r\n      final emptyTrip = EmptyDailyTrip(\r\n        id: const Uuid().v4(),\r\n        type: type,\r\n        departureGeohash5: departureGeohash5,\r\n        arrivalGeohash5: arrivalGeohash5,\r\n        sw1Id: sw1Id,\r\n        sw2Id: sw2Id,\r\n        traversedGeohashes: traversedGeohashes,\r\n        routePolyline: routePolyline,\r\n        createdAt: DateTime.now(),\r\n        totalDuration: totalDuration,\r\n        totalDistance: totalDistance,\r\n      );\r\n\r\n      await _supabase.from('empty_daily_trips').insert({\r\n        ...emptyTrip.toJson(),\r\n        'total_distance': emptyTrip.totalDistance,\r\n        'total_duration': emptyTrip.totalDuration,\r\n      });\r\n\r\n      return emptyTrip;\r\n    } catch (e) {\r\n      print('❌ Erreur création empty trip: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3738,
        "last_modified": "2025-04-16T13:25:26.0861912",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\empty_trip_repository.adapter.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.0932307",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\potential_bonus_activity.adapter.dart",
      "content": "// lib/core/adapters/supabase/potential_bonus_activity.adapter.dart\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\nimport '../../common/exceptions/geometry_calculation_exception.dart';\r\n\r\nclass PotentialBonusActivityAdapter {\r\n  final SupabaseClient _supabase;\r\n  static const String _tableName = 'trip_potential_bonus_activities';\r\n\r\n  PotentialBonusActivityAdapter(this._supabase);\r\n\r\n  Future<void> savePotentialBonusActivities(\r\n      List<PotentialBonusActivity> activities\r\n      ) async {\r\n    try {\r\n      final batch = activities.map((activity) => activity.toJson()).toList();\r\n\r\n      await _supabase\r\n          .from(_tableName)\r\n          .upsert(\r\n          batch,\r\n          onConflict: 'trip_potential_bonus_unique'\r\n      );\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to save potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<List<PotentialBonusActivity>> getPotentialBonusActivities({\r\n    required String emptyTripId,\r\n  }) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from(_tableName)\r\n          .select()\r\n          .eq('empty_daily_trip_id', emptyTripId);\r\n\r\n      return (response as List)\r\n          .map((json) => PotentialBonusActivity.fromJson(json))\r\n          .toList();\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to get potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> deletePotentialBonusActivities({\r\n    required String emptyTripId,\r\n  }) async {\r\n    try {\r\n      await _supabase\r\n          .from(_tableName)\r\n          .delete()\r\n          .eq('empty_daily_trip_id', emptyTripId);\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to delete potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> updatePotentialBonusActivity(\r\n      PotentialBonusActivity activity\r\n      ) async {\r\n    try {\r\n      await _supabase\r\n          .from(_tableName)\r\n          .update(activity.toJson())\r\n          .eq('id', activity.id);\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to update potential bonus activity: $e'\r\n      );\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2290,
        "last_modified": "2025-04-16T13:25:26.0992299",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\activity_details_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/activity_details_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../domain/models/shared/activity_details_model.dart';\r\nimport '../../../domain/models/shared/activity_image_model.dart';\r\nimport '../../../domain/ports/search/activity_details_port.dart';\r\n\r\nclass ActivityDetailsAdapter implements ActivityDetailsPort {\r\n  final SupabaseClient _client;\r\n\r\n  ActivityDetailsAdapter(this._client);\r\n\r\n  @override\r\n  Future<ActivityDetails> getActivityDetails(String activityId) async {\r\n    try {\r\n      print('Fetching details for activity: $activityId');\r\n\r\n      final response = await _client\r\n          .from('activities')\r\n          .select('''\r\n      id,\r\n      name,\r\n      description,\r\n      latitude,\r\n      longitude,\r\n      category_id,\r\n      address,\r\n      city,\r\n      google_place_id,\r\n      base_price,\r\n      min_duration_minutes,\r\n      max_duration_minutes,\r\n      booking_required,\r\n      wheelchair_accessible,\r\n      kid_friendly,\r\n      postal_code,\r\n      contact_phone,\r\n      contact_email,\r\n      contact_website,\r\n      current_opening_hours,\r\n      price_level,\r\n      activities_images(\r\n        id,\r\n        mobile_url,\r\n        is_main\r\n      )\r\n    ''')\r\n          .eq('id', activityId)\r\n          .single();\r\n\r\n      print('Raw response activities_images: ${response['activities_images']}');\r\n\r\n      // Mapper les images directement avec mobile_url\r\n// Initialiser une liste vide par défaut\r\n      List<ActivityImage> images = [];\r\n\r\n// Vérifier si on a des images avant de traiter\r\n      final rawImages = response['activities_images'];\r\n      if (rawImages != null) {\r\n        images = (rawImages as List)\r\n            .where((img) => img['mobile_url'] != null)\r\n            .map((img) => ActivityImage(\r\n          id: img['id'] ?? '',\r\n          mobileUrl: img['mobile_url'] ?? '',\r\n          isMain: img['is_main'] ?? false,\r\n        ))\r\n            .toList();\r\n      }\r\n\r\n      print('Images trouvées: ${images.length}');\r\n\r\n      print('Mapped images: $images');\r\n\r\n      final details = ActivityDetails.fromJson({\r\n        'id': response['id'] ?? '',\r\n        'name': response['name'] ?? '',\r\n        'description': response['description'],\r\n        'latitude': (response['latitude'] ?? 0.0).toDouble(),\r\n        'longitude': (response['longitude'] ?? 0.0).toDouble(),\r\n        'categoryId': response['category_id'] ?? '',\r\n        'postalCode': response['postal_code'],\r\n        'address': response['address'],\r\n        'city': response['city'],\r\n        'googlePlaceId': response['google_place_id'],\r\n        'currentOpeningHours': response['current_opening_hours'],\r\n        'contactPhone': response['contact_phone'],\r\n        'contactEmail': response['contact_email'],\r\n        'contactWebsite': response['contact_website'],\r\n        'bookingRequired': response['booking_required'],\r\n        'kidFriendly': response['kid_friendly'],\r\n        'wheelchairAccessible': response['wheelchair_accessible'],\r\n        'minDurationMinutes': response['min_duration_minutes'],\r\n        'maxDurationMinutes': response['max_duration_minutes'],\r\n        'priceLevel': response['price_level'],\r\n        'basePrice': response['base_price'],\r\n        'images': images.map((img) => {\r\n          'id': img.id,\r\n          'mobileUrl': img.mobileUrl,\r\n          'isMain': img.isMain,\r\n        }).toList(),\r\n      });\r\n\r\n      print('Final details with images: ${details.images?.length} images');\r\n      return details;\r\n    } catch (e, stack) {\r\n      print('Error getting activity details: $e');\r\n      print('Stack trace: $stack');\r\n      throw Exception('Erreur lors de la récupération des détails : $e');\r\n    }\r\n  }\r\n}\r\n",
      "info": {
        "size": 3732,
        "last_modified": "2025-04-16T13:25:26.1063494",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\activity_search_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/activity_search_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../domain/ports/search/activity_search_port.dart';\r\nimport '../../../domain/models/activity/search/searchable_activity.dart';\r\n\r\nclass ActivitySearchAdapter implements ActivitySearchPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  ActivitySearchAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<List<SearchableActivity>> getActivitiesWithFilters({\r\n    required double latitude,\r\n    required double longitude,\r\n    required String cityId, // Gardé pour compatibilité mais non envoyé à Supabase\r\n    double? maxDistance,\r\n    String? categoryId,\r\n    String? subcategoryId,\r\n    bool? isWow,\r\n    double? minRating,\r\n    int? minRatingCount,\r\n    int? maxRatingCount,\r\n    bool? kidFriendly,\r\n    String? orderBy,\r\n    String? orderDirection,\r\n    int? limit,\r\n  }) async {\r\n    try {\r\n      // Créer exactement les paramètres attendus par la fonction SQL\r\n      final params = {\r\n        'p_category_id': categoryId,\r\n        'p_is_wow': isWow,\r\n        'p_kid_friendly': kidFriendly,\r\n        'p_latitude': latitude,\r\n        'p_limit': limit ?? 50,\r\n        'p_longitude': longitude,\r\n        'p_max_distance': maxDistance,\r\n        'p_max_rating_count': maxRatingCount,\r\n        'p_min_rating': minRating,\r\n        'p_min_rating_count': minRatingCount,\r\n        'p_order_by': orderBy ?? 'distance',\r\n        'p_order_direction': orderDirection ?? 'ASC',\r\n        'p_subcategory_id': subcategoryId\r\n      };\r\n\r\n      print('🎯 Calling get_activities_list:');\r\n      print('📍 Coords: ($latitude, $longitude), max distance: $maxDistance');\r\n      print('📝 Parameters: $params');\r\n\r\n      final response = await _supabase.rpc(\r\n        'get_activities_list',\r\n        params: params, // Envoyer tous les paramètres\r\n      );\r\n\r\n      print('📊 Number of activities: ${response?.length ?? 0}');\r\n\r\n      if (response == null) return [];\r\n\r\n      final activities = (response as List)\r\n          .map((data) => SearchableActivity.fromSupabase(\r\n        data as Map<String, dynamic>,\r\n        distanceFromSearch: data['distance']?.toDouble(),\r\n      ))\r\n          .toList();\r\n\r\n      print('✅ Processed ${activities.length} activities');\r\n      return activities;\r\n    } catch (e, stack) {\r\n      print('❌ Error fetching activities: $e');\r\n      print('📜 Stack trace: $stack');\r\n      throw Exception('Failed to fetch activities: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2510,
        "last_modified": "2025-04-16T13:25:26.1138932",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\city_cache_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/city_cache_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:uuid/uuid.dart'; // Ajoutez cette dépendance à pubspec.yaml\r\nimport '../../../domain/ports/location/city_cache_port.dart';\r\nimport '../../../domain/models/shared/city_model.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\nimport '../../../common/utils/geohash.dart';\r\nimport '../../../common/exceptions/location_exceptions.dart';\r\n\r\nclass SupabaseCityCacheAdapter implements CityCachePort {\r\n  final SupabaseClient _supabase;\r\n  final _uuid = Uuid();\r\n\r\n  SupabaseCityCacheAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<City?> getCityByPlaceId(String placeId) async {\r\n    try {\r\n      // Rechercher d'abord par place_id (nouvelle colonne)\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('place_id', placeId)  // Utiliser 'place_id' au lieu de 'id'\r\n          .maybeSingle();\r\n\r\n      if (response == null) return null;\r\n\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération de la ville par place_id: $e');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City?> getCityByName(String cityName) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('city_name', cityName)\r\n          .maybeSingle();\r\n\r\n      if (response == null) return null;\r\n\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération de la ville par nom: $e');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City> saveCity({\r\n    required String placeId,\r\n    required String cityName,\r\n    required double lat,\r\n    required double lon,\r\n  }) async {\r\n    try {\r\n      // Générer le geohash\r\n      final geohash5 = Geohash.encode(lat, lon);\r\n\r\n      // Générer un UUID valide pour la colonne 'id'\r\n      final uuid = _uuid.v4();\r\n\r\n      // Préparer les données\r\n      final cityData = {\r\n        'id': uuid,               // UUID généré pour Supabase\r\n        'place_id': placeId,      // Google Place ID dans une colonne dédiée\r\n        'city_name': cityName,\r\n        'lat': lat,\r\n        'lon': lon,\r\n        'geohash_5': geohash5,\r\n      };\r\n\r\n      print('📍 VILLE À SAUVEGARDER: $cityName');\r\n      print('  └─ Latitude: $lat');\r\n      print('  └─ Longitude: $lon');\r\n      print('  └─ Geohash: $geohash5');\r\n\r\n      // Upsert pour gérer à la fois insertion et mise à jour\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .upsert(cityData, onConflict: 'place_id')\r\n          .select()\r\n          .single();\r\n\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la sauvegarde de la ville: $e');\r\n      throw LocationException('Erreur lors de la sauvegarde de la ville: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City> savePlaceDetailsAsCity(PlaceDetails placeDetails) async {\r\n    return saveCity(\r\n      placeId: placeDetails.placeId,\r\n      cityName: placeDetails.name,\r\n      lat: placeDetails.location.latitude,\r\n      lon: placeDetails.location.longitude,\r\n    );\r\n  }\r\n}\r\n\r\n",
      "info": {
        "size": 3264,
        "last_modified": "2025-04-16T13:25:26.1209363",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\city_search_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/city_search_adapter.dart\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../domain/models/shared/city_model.dart';\r\nimport '../../../domain/ports/search/city_search_port.dart';\r\n\r\nclass CitySearchAdapter implements CitySearchPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  CitySearchAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<List<City>> searchCities(String? query) async {\r\n    try {\r\n      print('DEBUG: Searching cities with query: $query');\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .ilike('city_name', '%${query ?? ''}%')\r\n          .limit(10);\r\n\r\n      print('DEBUG: Cities response: $response');\r\n      return (response as List).map((json) => City.fromJson(json)).toList();\r\n    } catch (e) {\r\n      print('DEBUG: Error in searchCities: $e');\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City?> getCityById(String id) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('id', id)\r\n          .single();\r\n\r\n      return response != null ? City.fromJson(response) : null;\r\n    } catch (e) {\r\n      print('Error getting city by id: $e');\r\n      return null;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1278,
        "last_modified": "2025-04-16T13:25:26.1280307",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\subcategory_search_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/subcategory_search_adapter.dart\r\n\r\nimport '../../../domain/ports/search/subcategory_search_port.dart';\r\nimport '../../../domain/models/shared/subcategory_model.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\nclass SubcategorySearchAdapter implements SubcategorySearchPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  SubcategorySearchAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<List<Subcategory>> getSubcategoriesForSearch() async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('activity_subcategories')\r\n          .select('id, name, category_id, icon')\r\n          .lt('priority', 20)\r\n          .order('priority', ascending: true);\r\n\r\n      // Ajouter une vérification et conversion explicite\r\n      final subcategories = (response as List).map((item) {\r\n\r\n        // Assurer que tous les champs requis sont convertis en String\r\n        return {\r\n          'id': item['id'].toString(),\r\n          'name': item['name'].toString(),\r\n          'categoryId': item['category_id'].toString(),\r\n          'description': item['description']?.toString(),\r\n          'icon': item['icon']?.toString() ?? 'activity',\r\n        };\r\n      }).map((json) => Subcategory.fromJson(json)).toList();\r\n\r\n      return subcategories;\r\n    } catch (e, stack) {\r\n      throw Exception('Failed to fetch subcategories');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1392,
        "last_modified": "2025-04-16T13:25:26.1350733",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\superwow_management.adapter.dart",
      "content": "// core/adapters/supabase/superwow_management.adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../domain/ports/empty_trips/superwow_management.port.dart';\r\nimport '../../domain/ports/empty_trips/route_optimization.port.dart';\r\nimport '../../domain/models/trip_designer/empty_trips/value_objects/superwow_pair.dart';\r\nimport '../../domain/models/scored_activity.dart';\r\nimport '../../domain/services/designer/empty_trips/distance_calculation.service.dart';\r\n\r\nclass SuperWowManagementAdapter implements SuperWowManagementPort {\r\n  final SupabaseClient _supabase;\r\n  final RouteOptimizationPort _routeOptimization;\r\n  final DistanceCalculationService _distanceService;\r\n\r\n  SuperWowManagementAdapter(\r\n      this._supabase,\r\n      this._routeOptimization,\r\n      this._distanceService,\r\n      );\r\n\r\n  @override\r\n  Future<List<ScoredActivity>> getTripSuperWows(String tripId) async {\r\n    try {\r\n      print('🔍 Récupération des SuperWow pour le trip $tripId');\r\n\r\n      final response = await _supabase\r\n          .from('trip_activities')\r\n          .select('*, activity:activities(*)')\r\n          .eq('trip_id', tripId)\r\n          .eq('is_superwow', true)\r\n          .eq('status', 'suggested');\r\n\r\n      print('✅ ${response.length} SuperWow trouvés');\r\n\r\n      return response.map<ScoredActivity>((data) =>\r\n          ScoredActivity.fromJson({\r\n            ...data['activity'],\r\n            'total_score': data['total_score'],\r\n            'subcategory_score': data['subcategory_score'],\r\n            'is_superwow': data['is_superwow'],\r\n          })\r\n      ).toList();\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la récupération des SuperWow: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<ScoredActivity> findClosestSuperWow(\r\n      List<ScoredActivity> superWows,\r\n      LatLng fromPoint,\r\n      ) async {\r\n    try {\r\n      print('🎯 Recherche du SuperWow le plus proche');\r\n\r\n      ScoredActivity? closest;\r\n      double minDistance = double.infinity;\r\n\r\n      for (var sw in superWows) {\r\n        final swLocation = LatLng(\r\n            sw.activityData['latitude'],\r\n            sw.activityData['longitude']\r\n        );\r\n\r\n        final distance = _distanceService.calculateDistance(fromPoint, swLocation);\r\n\r\n        if (distance < minDistance) {\r\n          minDistance = distance;\r\n          closest = sw;\r\n        }\r\n      }\r\n\r\n      if (closest == null) {\r\n        throw Exception('Aucun SuperWow trouvé');\r\n      }\r\n\r\n      print('✅ SuperWow le plus proche trouvé: ${closest.activityData['name']}');\r\n      return closest;\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la recherche du SuperWow le plus proche: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<SuperWowPair>> findTop3NearestPairs(\r\n      String tripId,\r\n      String baseSuperWowId,\r\n      List<ScoredActivity> availableSuperWows,\r\n      ) async {\r\n    try {\r\n      print('🔍 Recherche des 3 SuperWow les plus proches de $baseSuperWowId');\r\n\r\n      final baseSW = availableSuperWows.firstWhere((sw) => sw.id == baseSuperWowId);\r\n      final baseLocation = LatLng(\r\n        baseSW.activityData['latitude'],\r\n        baseSW.activityData['longitude'],\r\n      );\r\n\r\n      final pairs = <SuperWowPair>[];\r\n\r\n      for (var sw in availableSuperWows) {\r\n        if (sw.id == baseSuperWowId) continue;\r\n\r\n        // Chercher d'abord en base\r\n        final existingDistances = await _supabase\r\n            .from('activity_distances')\r\n            .select()\r\n            .or('and(activity_id_1.eq.${baseSuperWowId},activity_id_2.eq.${sw.id}),'\r\n            'and(activity_id_1.eq.${sw.id},activity_id_2.eq.${baseSuperWowId})')\r\n            .limit(1);\r\n\r\n        final swLocation = LatLng(\r\n          sw.activityData['latitude'],\r\n          sw.activityData['longitude'],\r\n        );\r\n\r\n        if (existingDistances.isNotEmpty) {\r\n          print('📦 Distance en cache trouvée pour ${sw.activityData['name']}');\r\n          final cached = existingDistances.first;\r\n\r\n          pairs.add(SuperWowPair(\r\n            sw1Id: baseSuperWowId,\r\n            sw2Id: sw.id,\r\n            sw1Location: baseLocation,\r\n            sw2Location: swLocation,\r\n            distanceBetween: cached['distance_meters'],\r\n            travelTime: Duration(seconds: cached['travel_time_seconds']),\r\n          ));\r\n          continue;\r\n        }\r\n\r\n        // Sinon calculer et sauvegarder\r\n        print('🧮 Calcul distance pour ${sw.activityData['name']}');\r\n        final distance = _distanceService.calculateDistance(baseLocation, swLocation);\r\n        final travelTime = _distanceService.estimateTravelTime(distance);\r\n\r\n        // Sauvegarder avec l'ID le plus petit en premier\r\n        final orderedIds = [baseSuperWowId, sw.id]..sort();\r\n        await _supabase.from('activity_distances').insert({\r\n          'activity_id_1': orderedIds[0],\r\n          'activity_id_2': orderedIds[1],\r\n          'distance_meters': distance.round(),\r\n          'travel_time_seconds': travelTime,\r\n        });\r\n\r\n        pairs.add(SuperWowPair(\r\n          sw1Id: baseSuperWowId,\r\n          sw2Id: sw.id,\r\n          sw1Location: baseLocation,\r\n          sw2Location: swLocation,\r\n          distanceBetween: distance.round(),\r\n          travelTime: Duration(seconds: travelTime),\r\n        ));\r\n      }\r\n\r\n      // Tri et sélection des 3 plus proches\r\n      pairs.sort((a, b) => a.distanceBetween.compareTo(b.distanceBetween));\r\n      final top3 = pairs.take(3).toList();\r\n\r\n      print('✅ ${top3.length} paires de SuperWow trouvées');\r\n      return top3;\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la recherche des paires de SuperWow: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n\r\n  @override\r\n  Future<List<SuperWowPair>> generateOptimizedPairs(\r\n      String tripId,\r\n      List<ScoredActivity> superWows,\r\n      LatLng departurePoint,\r\n      ) async {\r\n    try {\r\n      print('🔄 Génération des paires optimisées de SuperWow');\r\n      final validPairs = <SuperWowPair>[];\r\n      final processedPairs = <String>{};  // Pour éviter les doublons\r\n\r\n      // 1. Trier les SW par distance au point de départ\r\n      final sortedSuperWows = [...superWows];\r\n      sortedSuperWows.sort((a, b) {\r\n        final aLocation = LatLng(\r\n            a.activityData['latitude'],\r\n            a.activityData['longitude']\r\n        );\r\n        final bLocation = LatLng(\r\n            b.activityData['latitude'],\r\n            b.activityData['longitude']\r\n        );\r\n\r\n        final distA = _distanceService.calculateDistance(departurePoint, aLocation);\r\n        final distB = _distanceService.calculateDistance(departurePoint, bLocation);\r\n        return distA.compareTo(distB);\r\n      });\r\n\r\n      // 2. Pour chaque SW, trouver ses paires valides\r\n      for (final sw1 in sortedSuperWows) {\r\n        final sw1Preferences = sw1.activityData['moment_preferences'] as Map<String, dynamic>;\r\n        final sw1Location = LatLng(\r\n            sw1.activityData['latitude'],\r\n            sw1.activityData['longitude']\r\n        );\r\n\r\n        // 3. Déterminer les créneaux valides pour SW2\r\n        List<String> validMoments = [];\r\n        if (sw1Preferences['morning'] == true) {\r\n          validMoments = ['afternoon', 'evening'];\r\n        } else if (sw1Preferences['afternoon'] == true) {\r\n          validMoments = ['evening'];\r\n        } else {\r\n          continue; // Skip si pas de créneau valide pour SW1\r\n        }\r\n\r\n        // 4. Filtrer et trier les SW2 potentiels\r\n        final potentialSW2s = superWows.where((sw2) {\r\n          if (sw2.id == sw1.id) return false;\r\n\r\n          final sw2Preferences = sw2.activityData['moment_preferences'] as Map<String, dynamic>;\r\n          return validMoments.any((moment) => sw2Preferences[moment] == true);\r\n        }).toList();\r\n\r\n        // 5. Trier par distance à SW1\r\n        potentialSW2s.sort((a, b) {\r\n          final aLocation = LatLng(\r\n              a.activityData['latitude'],\r\n              a.activityData['longitude']\r\n          );\r\n          final bLocation = LatLng(\r\n              b.activityData['latitude'],\r\n              b.activityData['longitude']\r\n          );\r\n\r\n          final distA = _distanceService.calculateDistance(sw1Location, aLocation);\r\n          final distB = _distanceService.calculateDistance(sw1Location, bLocation);\r\n          return distA.compareTo(distB);\r\n        });\r\n\r\n        // 6. Prendre les 3 plus proches en évitant les doublons\r\n        for (final sw2 in potentialSW2s.take(3)) {\r\n          final sw2Location = LatLng(\r\n              sw2.activityData['latitude'],\r\n              sw2.activityData['longitude']\r\n          );\r\n\r\n          // Vérifier les doublons\r\n          final pairKey = [sw1.id, sw2.id]..sort();\r\n          final pairId = pairKey.join('-');\r\n          if (processedPairs.contains(pairId)) continue;\r\n          processedPairs.add(pairId);\r\n\r\n          // Calculer distance et temps de trajet\r\n          final distance = _distanceService.calculateDistance(sw1Location, sw2Location);\r\n          final travelTime = _distanceService.estimateTravelTime(distance);\r\n\r\n          validPairs.add(SuperWowPair(\r\n            sw1Id: sw1.id,\r\n            sw2Id: sw2.id,\r\n            sw1Location: sw1Location,\r\n            sw2Location: sw2Location,\r\n            distanceBetween: distance.round(),\r\n            travelTime: Duration(seconds: travelTime),\r\n          ));\r\n        }\r\n      }\r\n\r\n      print('✅ ${validPairs.length} paires valides générées');\r\n      return validPairs;\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur génération paires optimisées: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 9684,
        "last_modified": "2025-04-16T13:25:26.1471131",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\trip_activities_adapter.dart",
      "content": "// core/adapters/supabase/trip_activities_adapter.dart\r\n\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/trip_activities_port.dart';\r\nimport '../../domain/models/scored_activity.dart';\r\n\r\nclass TripActivitiesAdapter implements TripActivitiesPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  TripActivitiesAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<void> saveFilteredActivities({\r\n    required String tripId,\r\n    required List<ScoredActivity> activities,\r\n    required bool isSuperwow,\r\n  }) async {\r\n    try {\r\n      print('📝 Début sauvegarde - Trip: $tripId - ${activities.length} activités');\r\n\r\n      final validActivities = activities.where((a) => a.subcategoryScore > 0).toList();\r\n      print('🔍 ${activities.length - validActivities.length} activités ignorées (score 0)');\r\n\r\n      // Avant l'upsert, faire un select pour comparer les données\r\n      final existingRecords = await _supabase\r\n          .from('trip_activities')\r\n          .select()\r\n          .eq('trip_id', tripId)\r\n          .inFilter('activity_id', validActivities.map((a) => a.id).toList());\r\n\r\n      print('🔄 ${existingRecords.length} activités existantes trouvées');\r\n\r\n      // Préparer les nouvelles données ou mises à jour\r\n      final batch = validActivities.map((activity) {\r\n        // Chercher l'enregistrement existant\r\n        final existing = existingRecords\r\n            .firstWhere(\r\n              (e) => e['activity_id'] == activity.id,\r\n          orElse: () => {}, // Retourne un objet vide au lieu de null\r\n        );\r\n\r\n        // Vérifier si une mise à jour est nécessaire\r\n        if (existing.isNotEmpty &&\r\n            existing['total_score'] == activity.totalScore &&\r\n            existing['subcategory_score'] == activity.subcategoryScore &&\r\n            existing['is_superwow'] == isSuperwow) {\r\n          print('⏩ Activité ${activity.id} inchangée');\r\n          return null;  // Skip cette activité\r\n        }\r\n\r\n        // Nouvelle activité ou mise à jour nécessaire\r\n        final data = {\r\n          'trip_id': tripId,\r\n          'activity_id': activity.id,\r\n          'planned_date': DateTime.now().toIso8601String(),\r\n          'status': 'suggested',\r\n          'priority': isSuperwow ? 1 : 2,\r\n          'total_score': activity.totalScore,\r\n          'subcategory_score': activity.subcategoryScore,\r\n          'is_superwow': isSuperwow,\r\n          'geohash': activity.activityData['geohash'],\r\n          'user_modified': false,\r\n          'updated_at': DateTime.now().toIso8601String(),\r\n        };\r\n\r\n        print('📦 Préparation activité ${activity.id} : $data');\r\n        return data;\r\n      }).whereType<Map<String, dynamic>>().toList();  // Filtrer les null\r\n\r\n      if (batch.isEmpty) {\r\n        print('✅ Aucune mise à jour nécessaire');\r\n        return;\r\n      }\r\n\r\n      print('💾 Mise à jour/insertion de ${batch.length} activités');\r\n      await _supabase.from('trip_activities').upsert(batch);\r\n      print('✅ Résultat upsert: Succès');\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur sauvegarde: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n\r\n\r\n  @override\r\n  Future<List<ScoredActivity>> getSuperwowActivities(String tripId) async {\r\n    final response = await _supabase\r\n        .from('trip_activities')\r\n        .select('*, activity:activities(*)')\r\n        .eq('trip_id', tripId)\r\n        .eq('is_superwow', true)\r\n        .eq('status', 'suggested');\r\n\r\n    return response.map<ScoredActivity>((data) =>\r\n        ScoredActivity.fromJson({\r\n          ...data['activity'],\r\n          'total_score': data['total_score'],\r\n          'subcategory_score': data['subcategory_score'],\r\n          'is_superwow': data['is_superwow'],\r\n        })\r\n    ).toList();\r\n  }\r\n}",
      "info": {
        "size": 3766,
        "last_modified": "2025-04-16T13:25:26.1531596",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\trip\\trip_adapter.dart",
      "content": "// core/adapters/supabase/trip_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/trip_port.dart';\r\nimport '../../domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\nimport '../../domain/models/shared/city_model.dart';\r\nimport '../../domain/services/trip_service.dart';\r\nimport '../../domain/use_cases/create_trip_use_case.dart';\r\n\r\nclass TripAdapter implements TripPort {\r\n  final SupabaseClient _supabase;\r\n  final TripService _tripService;\r\n\r\n  TripAdapter(SupabaseClient supabase) :\r\n        _supabase = supabase,\r\n        _tripService = TripService(supabase);\r\n\r\n  @override\r\n  Future<Trip> createTrip(CreateTripParams params, City departureCity) async {\r\n    try {\r\n      return await _tripService.saveTrip(\r\n        userId: params.userId,\r\n        title: params.title,\r\n        startDate: params.startDate,\r\n        endDate: params.endDate,\r\n        travelGroup: params.travelGroup,\r\n        activityHours: params.activityHours,\r\n        departureCity: departureCity,\r\n        travelStyle: params.travelStyle,\r\n        preferredMoment: params.preferredMoment,\r\n        dailyBudget: params.dailyBudget,\r\n      );\r\n    } on TripException {\r\n      rethrow;\r\n    } catch (e) {\r\n      throw TripCreationException('Échec de la création du voyage: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<Trip> getTrip(String tripId) async {\r\n    try {\r\n      print('🔍 Tentative de récupération du voyage: $tripId');\r\n\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .select('''\r\n          *,\r\n          cities!trips_departure_city_id_fkey (*)\r\n        ''')\r\n          .eq('id', tripId)\r\n          .single();\r\n\r\n      print('📦 Réponse Supabase: $response');\r\n\r\n      if (response == null) {\r\n        print('❌ Aucun voyage trouvé');\r\n        throw TripNotFoundException('Voyage non trouvé avec l\\'ID: $tripId');\r\n      }\r\n\r\n      // Renommer la clé pour correspondre à notre modèle\r\n      if (response['cities'] != null) {\r\n        response['departure_city'] = response['cities'];\r\n        response.remove('cities');\r\n      }\r\n\r\n      try {\r\n        final trip = Trip.fromJson(response);\r\n        print('✅ Voyage trouvé et parsé: ${trip.title}');\r\n        return trip;\r\n      } catch (e) {\r\n        print('❌ Erreur lors du parsing du voyage: $e');\r\n        throw TripNotFoundException('Erreur lors du parsing du voyage: $e');\r\n      }\r\n    }\r\n    catch (e) {\r\n      print('❌ Erreur dans getTrip: $e');\r\n      throw TripNotFoundException('Erreur lors de la récupération du voyage: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<Trip>> getTripsForUser(String userId) async {\r\n    try {\r\n      return await _tripService.getTripsForUser(userId);\r\n    } catch (e) {\r\n      throw DataException('User trips fetch failed: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2933,
        "last_modified": "2025-04-16T13:25:26.1657116",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\geometry_constants.dart",
      "content": "// lib/core/common/constants/geometry_constants.dart\r\n\r\nclass GeometryConstants {\r\n  // Distances\r\n  static const double defaultToleranceMeters = 100.0;\r\n  static const double maxDetourDistanceKm = 5.0;\r\n\r\n  // Facteurs de conversion pour le calcul du malus\r\n  static const double relaxedTravelFactor = 2.0;  // Plus de temps alloué\r\n  static const double balancedTravelFactor = 1.75;\r\n  static const double activeTravelFactor = 1.5;  // Moins de temps alloué\r\n\r\n  // Vitesse moyenne estimée (en m/s)\r\n  static const double averageSpeedMetersPerSecond = 13.89; // ~50km/h\r\n\r\n  // Seuils pour les calculs\r\n  static const int minimumMalusMinutes = 5;\r\n  static const int maximumMalusMinutes = 120;\r\n}",
      "info": {
        "size": 701,
        "last_modified": "2025-04-16T13:25:26.1827906",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\location_constants.dart",
      "content": "// lib/core/common/constants/location_constants.dart\r\n\r\nclass LocationConstants {\r\n  // Distance maximale par défaut pour la recherche d'activités (en km)\r\n  static const double defaultSearchRadius = 150.0;\r\n\r\n  // Limites min/max que l'utilisateur peut choisir\r\n  static const double minSearchRadius = 10.0;\r\n  static const double maxSearchRadius = 300.0;\r\n\r\n  // Rayon de recherche pour l'API Places (en mètres)\r\n  static const int defaultPlacesSearchRadiusMeters = 50000;\r\n\r\n  // Délai de debounce pour limiter les appels API (en millisecondes)\r\n  static const int searchDebounceTime = 300;\r\n\r\n  // Précision minimale requise pour la géolocalisation (en mètres)\r\n  static const double minLocationAccuracy = 100.0;\r\n\r\n  // Taille maximale du cache (nombre d'entrées)\r\n  static const int maxCacheEntries = 100;\r\n\r\n  // Coordonnées des départements ciblés (centre, rayon en mètres)\r\n  static const Map<String, Map<String, dynamic>> targetDepartments = {\r\n    'Dordogne': {\r\n      'center': {'lat': 45.1909, 'lng': 0.7214},\r\n      'radius': 80000,\r\n    },\r\n    'Lot': {\r\n      'center': {'lat': 44.6239, 'lng': 1.6094},\r\n      'radius': 50000,\r\n    },\r\n    'Corrèze': {\r\n      'center': {'lat': 45.3394, 'lng': 1.8655},\r\n      'radius': 50000,\r\n    },\r\n  };\r\n}\r\n\r\n/// Représente un biais de localisation pour centrer les recherches\r\nclass LocationBias {\r\n  final String label;\r\n  final double latitude;\r\n  final double longitude;\r\n  final int radius;\r\n\r\n  const LocationBias({\r\n    required this.label,\r\n    required this.latitude,\r\n    required this.longitude,\r\n    required this.radius,\r\n  });\r\n\r\n  @override\r\n  String toString() => '$label ($latitude, $longitude)';\r\n\r\n  /// Convertit en format utilisable par l'API Google Places (circle:radius@lat,lng)\r\n  String toGoogleCircleBias() => 'circle:$radius@$latitude,$longitude';\r\n}\r\n",
      "info": {
        "size": 1847,
        "last_modified": "2025-04-16T13:25:26.1887908",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\subcategory_icons.dart",
      "content": "// lib/core/common/constants/subcategory_icons.dart\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport 'package:flutter/material.dart';\r\n\r\nclass SubcategoryIcons {\r\n  static final Map<String, IconData> icons = {\r\n    'moon-star': LucideIcons.moonStar,\r\n    'bird': LucideIcons.bird,\r\n    'bike': LucideIcons.bike,\r\n    'wine': LucideIcons.wine,\r\n    'utensils-crossed': LucideIcons.utensilsCrossed,\r\n    'sparkles': LucideIcons.sparkles,\r\n    'palette': LucideIcons.palette,\r\n    'spa': LucideIcons.flower2,\r\n    'droplet': LucideIcons.droplet,\r\n    'home': LucideIcons.home,\r\n    'cave': LucideIcons.warehouse,\r\n    'castle': LucideIcons.castle,\r\n    'plate': LucideIcons.utensils,\r\n    'party-popper': LucideIcons.partyPopper,\r\n    'mountain': LucideIcons.mountain,\r\n    'map': LucideIcons.map,\r\n    // 'horse': LucideIcons.horseIcon,\r\n    'anchor': LucideIcons.anchor,\r\n    'roller-coaster': LucideIcons.rollerCoaster,\r\n    'plane': LucideIcons.plane,\r\n    // 'meditation': LucideIcons.yoga,\r\n    'star': LucideIcons.star,\r\n    'key': LucideIcons.key,\r\n    'shopping-bag': LucideIcons.shoppingBag,\r\n    'landmark': LucideIcons.landmark,\r\n    'hammer': LucideIcons.hammer,\r\n    'compass': LucideIcons.compass,\r\n  };\r\n\r\n  static IconData getIcon(String? iconName) {\r\n    return icons[iconName] ?? LucideIcons.activity;\r\n  }\r\n}",
      "info": {
        "size": 1334,
        "last_modified": "2025-04-16T13:25:26.1953039",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\trip_constants.dart",
      "content": "// core/common/constants/trip_constants.dart\r\n\r\n\r\nclass TripConstants {\r\n  static const Map<String, int> maxTravelTimes = {\r\n    'around_me': 60,      // 1h\r\n    'small_getaway': 105, // 1h45\r\n    'exploration_day': 150, // 2h30\r\n    'big_adventure': 300,  // 5h\r\n  };\r\n\r\n  static const Map<String, int> minTravelTimes = {\r\n    'exploration_day': 90,  // 1h30\r\n    'big_adventure': 120,   // 2h\r\n  };\r\n\r\n  // Temps de repas standards\r\n  static const int mealDuration = 90; // 1h30 par repas\r\n\r\n  // Créneaux de repas\r\n  static const Map<String, (int, int)> mealTimeSlots = {\r\n    'lunch': (12, 13),  // 12h-13h\r\n    'dinner': (19, 20), // 19h-20h\r\n  };\r\n\r\n  // Ajouter dans la classe TripConstants\r\n  static const Map<String, int> mealDurationByStyle = {\r\n    'relax': 120,     // 2h par repas\r\n    'balanced': 90,   // 1h30 (standard)\r\n    'active': 60,     // 1h par repas\r\n  };\r\n\r\n}",
      "info": {
        "size": 886,
        "last_modified": "2025-04-16T13:25:26.2023369",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\enums\\trip_enums.dart",
      "content": "// lib\\core\\common\\enums\\trip_enums.dart\r\n\r\nenum GroupMemberType {\r\n  adult,\r\n  senior,\r\n  teenager,\r\n  child,\r\n}\r\n\r\nextension GroupMemberTypeExtension on GroupMemberType {\r\n  static GroupMemberType? fromJson(dynamic value) {\r\n    if (value == null) return null;\r\n    return GroupMemberType.values.firstWhere(\r\n          (e) => e.toString().split('.').last == value.toString().toLowerCase(),\r\n      orElse: () => GroupMemberType.adult,\r\n    );\r\n  }\r\n\r\n  String get value => toString().split('.').last;\r\n}\r\n\r\nenum PreferredMoment {\r\n  morning,\r\n  afternoon,\r\n  all_day,\r\n  evening,\r\n}\r\n\r\nextension PreferredMomentExtension on PreferredMoment {\r\n  static PreferredMoment? fromJson(dynamic value) {\r\n    if (value == null) return null;\r\n    switch (value.toString().toLowerCase()) {\r\n      case 'morning':\r\n        return PreferredMoment.morning;\r\n      case 'afternoon':\r\n        return PreferredMoment.afternoon;\r\n      case 'all_day':\r\n        return PreferredMoment.all_day;\r\n      case 'evening':\r\n        return PreferredMoment.evening;\r\n      default:\r\n        throw Exception('Invalid PreferredMoment value: $value');\r\n    }\r\n  }\r\n\r\n  String get value {\r\n    return this.toString().split('.').last;\r\n  }\r\n}\r\n\r\nenum TravelStyle {\r\n  relax,\r\n  balanced,\r\n  active,\r\n}\r\n\r\nextension TravelStyleExtension on TravelStyle {\r\n  static TravelStyle? fromJson(dynamic value) {\r\n    if (value == null) return null;\r\n    switch (value.toString().toLowerCase()) {\r\n      case 'relax':\r\n        return TravelStyle.relax;\r\n      case 'balanced':\r\n        return TravelStyle.balanced;\r\n      case 'active':\r\n        return TravelStyle.active;\r\n      default:\r\n        throw Exception('Invalid TravelStyle value: $value');\r\n    }\r\n  }\r\n\r\n  String get value {\r\n    return toString().split('.').last;\r\n  }\r\n\r\n  String get displayName {\r\n    return toString().split('.').last;\r\n  }\r\n\r\n  int get maxActivities {\r\n    switch (this) {\r\n      case TravelStyle.relax:\r\n        return 4;\r\n      case TravelStyle.balanced:\r\n        return 5;\r\n      case TravelStyle.active:\r\n        return 6;\r\n    }\r\n  }\r\n\r\n  int getDurationMinutes(int minDuration, int maxDuration) {\r\n    switch (this) {\r\n      case TravelStyle.relax:\r\n        return maxDuration;\r\n      case TravelStyle.active:\r\n        return minDuration;\r\n      case TravelStyle.balanced:\r\n        return (minDuration + maxDuration) ~/ 2;\r\n      default:\r\n        return minDuration; // Par sécurité, même si tous les cas sont couverts\r\n    }\r\n  }\r\n}\r\n\r\nenum ExplorationType {\r\n  around_me,\r\n  small_getaway,\r\n  exploration_day,\r\n  big_adventure\r\n}\r\n\r\nextension ExplorationTypeExtension on ExplorationType {\r\n\r\n  double get maxDistance {\r\n    switch (this) {\r\n      case ExplorationType.around_me:\r\n        return 35.0;\r\n      case ExplorationType.small_getaway:\r\n        return 56.0;\r\n      case ExplorationType.exploration_day:\r\n        return 90.0;\r\n      case ExplorationType.big_adventure:\r\n        return 120.0;\r\n    }\r\n  }\r\n\r\n  static ExplorationType? fromJson(String? json) {\r\n    if (json == null) return null;\r\n    return ExplorationType.values.firstWhere(\r\n          (e) => e.toString().split('.').last == json,\r\n      orElse: () => ExplorationType.around_me,\r\n    );\r\n  }\r\n\r\n  String get value => toString().split('.').last;\r\n\r\n  // Ajout des limites de temps en minutes\r\n  (int, int) get timeLimits {\r\n    switch (this) {\r\n      case ExplorationType.around_me:\r\n        return (0, 60);  // max 1h\r\n      case ExplorationType.small_getaway:\r\n        return (0, 105);  // max 1h45\r\n      case ExplorationType.exploration_day:\r\n        return (90, 150);  // 1h30 - 2h30\r\n      case ExplorationType.big_adventure:\r\n        return (120, 300);  // 2h - 5h\r\n    }\r\n  }\r\n\r\n  static (int, int) getCombinedTimeLimits(List<ExplorationType> types) {\r\n    int minTime = 300;  // Valeur max possible\r\n    int maxTime = 0;    // Valeur min possible\r\n\r\n    for (var type in types) {\r\n      final (typeMin, typeMax) = type.timeLimits;\r\n      if (typeMin < minTime) minTime = typeMin;\r\n      if (typeMax > maxTime) maxTime = typeMax;\r\n    }\r\n\r\n    return (minTime, maxTime);\r\n  }\r\n\r\n  bool isValidDuration(int durationMinutes) {\r\n    final (minMinutes, maxMinutes) = timeLimits;\r\n    return durationMinutes >= minMinutes && durationMinutes <= maxMinutes;\r\n  }\r\n\r\n  int getMaxActivitiesByTime(int timeAvailable) {\r\n    if (timeAvailable < 120) return 5;        // < 2h\r\n    if (timeAvailable < 240) return 7;        // 2-4h\r\n    if (timeAvailable < 360) return 8;        // 4-6h\r\n    if (timeAvailable < 480) return 9;        // 6-8h\r\n    return 10;                                // > 8h\r\n  }\r\n}\r\n\r\nenum DailyTripType {\r\n  half_day,\r\n  full_day\r\n}\r\n",
      "info": {
        "size": 4680,
        "last_modified": "2025-04-16T13:25:26.2139049",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\calculation_exception.dart",
      "content": "// lib/core/common/exceptions/calculation_exception.dart\r\n\r\nclass CalculationException implements Exception {\r\n  final String message;\r\n  CalculationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'CalculationException: $message';\r\n}",
      "info": {
        "size": 249,
        "last_modified": "2025-04-16T13:25:26.2260226",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\domain_exception.dart",
      "content": "// lib\\core\\common\\exceptions\\domain_exception.dart",
      "info": {
        "size": 51,
        "last_modified": "2025-04-16T13:25:26.2320717",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\empty_trip_generation_exception.dart",
      "content": "// lib/core/common/exceptions/empty_trip_generation_exception.dart\r\n\r\nclass EmptyTripGenerationException implements Exception {\r\n  final String message;\r\n\r\n  EmptyTripGenerationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'EmptyTripGenerationException: $message';\r\n}",
      "info": {
        "size": 285,
        "last_modified": "2025-04-16T13:25:26.2380712",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\exceptions.dart",
      "content": "// core/common/exceptions/exceptions.dart\r\n\r\nclass DomainException implements Exception {\r\n  final String message;\r\n  DomainException(this.message);\r\n\r\n  @override\r\n  String toString() => message;\r\n}\r\n\r\nclass DataException implements Exception {\r\n  final String message;\r\n  DataException(this.message);\r\n}\r\n\r\nclass ProcessingException implements Exception {\r\n  final String message;\r\n  ProcessingException(this.message);\r\n}",
      "info": {
        "size": 423,
        "last_modified": "2025-04-16T13:25:26.245109",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\geometry_calculation_exception.dart",
      "content": "// lib/core/common/exceptions/geometry_calculation_exception.dart\r\nclass GeometryCalculationException implements Exception {\r\n  final String message;\r\n\r\n  GeometryCalculationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'GeometryCalculationException: $message';\r\n}",
      "info": {
        "size": 282,
        "last_modified": "2025-04-16T13:25:26.2511463",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\google_api_exception.dart",
      "content": "// lib/core/common/exceptions/google_api_exception.dart\r\n\r\nclass GoogleAPIException implements Exception {\r\n  final String message;\r\n\r\n  GoogleAPIException(this.message);\r\n\r\n  @override\r\n  String toString() => 'GoogleAPIException: $message';\r\n}",
      "info": {
        "size": 244,
        "last_modified": "2025-04-16T13:25:26.2576625",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\location_exceptions.dart",
      "content": "// lib/core/common/exceptions/location_exceptions.dart\r\n\r\n/// Exception de base pour tous les problèmes liés à la localisation\r\nclass LocationException implements Exception {\r\n  final String message;\r\n\r\n  LocationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'LocationException: $message';\r\n}\r\n\r\n/// Exception spécifique pour les problèmes de permission de localisation\r\nclass LocationPermissionException extends LocationException {\r\n  LocationPermissionException(String message) : super(message);\r\n}\r\n\r\n/// Exception spécifique pour les problèmes de services de localisation désactivés\r\nclass LocationServicesDisabledException extends LocationException {\r\n  LocationServicesDisabledException(String message) : super(message);\r\n}\r\n\r\n/// Exception spécifique pour les problèmes d'API Google Places\r\nclass PlacesApiException extends LocationException {\r\n  final String? errorCode;\r\n\r\n  PlacesApiException(String message, {this.errorCode}) : super(message);\r\n\r\n  @override\r\n  String toString() => 'PlacesApiException: $message (code: $errorCode)';\r\n}\r\n\r\n/// Exception spécifique pour les problèmes de cache de localisation\r\nclass LocationCacheException extends LocationException {\r\n  LocationCacheException(String message) : super(message);\r\n}",
      "info": {
        "size": 1271,
        "last_modified": "2025-04-16T13:25:26.2647133",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\route_optimization_exceptions.dart",
      "content": "// core/common/exceptions/route_optimization_exceptions.dart\r\n\r\nabstract class RouteOptimizationException implements Exception {\r\n  final String message;\r\n  RouteOptimizationException(this.message);\r\n}\r\n\r\nclass RouteNotFoundException extends RouteOptimizationException {\r\n  RouteNotFoundException(String message) : super(message);\r\n}\r\n\r\nclass TravelTimeCalculationException extends RouteOptimizationException {\r\n  TravelTimeCalculationException(String message) : super(message);\r\n}\r\n\r\nclass DetourEvaluationException extends RouteOptimizationException {\r\n  DetourEvaluationException(String message) : super(message);\r\n}\r\n\r\nclass GoogleAPIException extends RouteOptimizationException {\r\n  final int? statusCode;\r\n  final String? errorCode;\r\n\r\n  GoogleAPIException(String message, {this.statusCode, this.errorCode}) : super(message);\r\n}\r\n\r\nclass OptimizationTimeoutException extends RouteOptimizationException {\r\n  OptimizationTimeoutException(String message) : super(message);\r\n}",
      "info": {
        "size": 978,
        "last_modified": "2025-04-16T13:25:26.2712318",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\scoring_exceptions.dart",
      "content": "// core/common/exceptions/scoring_exceptions.dart\r\n\r\nabstract class ScoringException implements Exception {\r\n  final String message;\r\n  ScoringException(this.message);\r\n}\r\n\r\nclass PreferencesNotFoundException extends ScoringException {\r\n  PreferencesNotFoundException(String message) : super(message);\r\n}\r\n\r\nclass ScoreCalculationException extends ScoringException {\r\n  ScoreCalculationException(String message) : super(message);\r\n}\r\n\r\nclass CacheOperationException extends ScoringException {\r\n  CacheOperationException(String message) : super(message);\r\n}",
      "info": {
        "size": 556,
        "last_modified": "2025-04-16T13:25:26.2782924",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\trip_exception.dart",
      "content": "// lib/core/common/exceptions/trip_exceptions.dart\r\n\r\n/// Exception de base pour les erreurs liées aux voyages\r\nabstract class TripException implements Exception {\r\n  final String message;\r\n  TripException(this.message);\r\n}\r\n\r\n/// Exception levée quand la ville de départ est invalide\r\nclass InvalidDepartureCityException extends TripException {\r\n  InvalidDepartureCityException(String message) : super(message);\r\n}\r\n\r\n/// Exception levée quand les dates du voyage sont invalides\r\nclass InvalidTripDatesException extends TripException {\r\n  InvalidTripDatesException(String message) : super(message);\r\n}\r\n\r\n/// Exception levée quand la création du voyage échoue\r\nclass TripCreationException extends TripException {\r\n  TripCreationException(String message) : super(message);\r\n}\r\n\r\n/// Exception levée quand la récupération du voyage échoue\r\nclass TripNotFoundException extends TripException {\r\n  TripNotFoundException(String message) : super(message);\r\n}\r\n\r\n/// Exception levée quand le groupe de voyage est invalide\r\nclass InvalidTravelGroupException extends TripException {\r\n  InvalidTravelGroupException(String message) : super(message);\r\n}",
      "info": {
        "size": 1153,
        "last_modified": "2025-04-16T13:25:26.2853486",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\activity_mapper.dart",
      "content": "// lib/core/common/utils/activity_mapper.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../constants/subcategory_icons.dart';\r\nimport '../../../features/shared_ui/presentation/widgets/cards/activity_card.dart';\r\n\r\nclass ActivityMapper {\r\n  static const double defaultUserLat = 44.8333;\r\n  static const double defaultUserLng = 0.7333;\r\n\r\n  static List<ActivityCard> mapToActivityCards(List<dynamic> activities) {\r\n    return activities.map((activity) {\r\n      return ActivityCard(\r\n        imageUrl: activity.mainImageUrl ?? '',\r\n        title: activity.base.name ?? '',\r\n        city: activity.base.city ?? '',\r\n        category: activity.subcategoryName ?? 'Autre',\r\n        categoryIcon: SubcategoryIcons.getIcon(activity.subcategoryIcon),\r\n        distance: activity.distance ?? 0.0,\r\n        activityId: activity.base.id,\r\n        activityLat: activity.base.latitude,\r\n        activityLng: activity.base.longitude,\r\n        userLat: defaultUserLat,\r\n        userLng: defaultUserLng,\r\n      );\r\n    }).toList();\r\n  }\r\n}",
      "info": {
        "size": 1032,
        "last_modified": "2025-04-16T13:25:26.2983904",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\date_formatter.dart",
      "content": "// lib\\core\\common\\utils\\date_formatter.dart\r\n\r\nclass DateFormatter {\r\n  static String formatTripDates(DateTime startDate, DateTime endDate) {\r\n    // Noms des mois en français\r\n    const months = [\r\n      'jan.', 'fév.', 'mars', 'avr.', 'mai', 'juin',\r\n      'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'\r\n    ];\r\n\r\n    // Si même mois et année\r\n    if (startDate.month == endDate.month && startDate.year == endDate.year) {\r\n      return '${startDate.day} - ${endDate.day} ${months[startDate.month - 1]}';\r\n    }\r\n\r\n    // Si même année\r\n    if (startDate.year == endDate.year) {\r\n      return '${startDate.day} ${months[startDate.month - 1]} - ${endDate.day} ${months[endDate.month - 1]}';\r\n    }\r\n\r\n    // Différentes années\r\n    return '${startDate.day} ${months[startDate.month - 1]} ${startDate.year} - ${endDate.day} ${months[endDate.month - 1]} ${endDate.year}';\r\n  }\r\n\r\n  static String formatShortDate(DateTime date) {\r\n    const months = [\r\n      'jan.', 'fév.', 'mars', 'avr.', 'mai', 'juin',\r\n      'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'\r\n    ];\r\n    return '${date.day} ${months[date.month - 1]}';\r\n  }\r\n}",
      "info": {
        "size": 1144,
        "last_modified": "2025-04-16T13:25:26.3049075",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\debouncer.dart",
      "content": "// lib/core/common/utils/debouncer.dart\r\n\r\nimport 'dart:async';\r\nimport 'package:flutter/foundation.dart';\r\n\r\n/// Utilitaire pour limiter les appels fréquents à une fonction\r\nclass Debouncer {\r\n  final int milliseconds;\r\n  Timer? _timer;\r\n\r\n  Debouncer({this.milliseconds = 300});\r\n\r\n  void run(VoidCallback action) {\r\n    _timer?.cancel();\r\n    _timer = Timer(Duration(milliseconds: milliseconds), action);\r\n  }\r\n\r\n  void cancel() {\r\n    _timer?.cancel();\r\n  }\r\n\r\n  bool get isActive => _timer?.isActive ?? false;\r\n}",
      "info": {
        "size": 519,
        "last_modified": "2025-04-16T13:25:26.3119405",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\geohash.dart",
      "content": "// lib\\core\\common\\utils\\geohash.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:maps_toolkit/maps_toolkit.dart' as maps_toolkit;\r\nimport 'package:polyline_codec/polyline_codec.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\n\r\nclass Geohash {\r\n  static const List<String> _base32 = [\r\n    '0','1','2','3','4','5','6','7','8','9',\r\n    'b','c','d','e','f','g','h','j','k','m',\r\n    'n','p','q','r','s','t','u','v','w','x',\r\n    'y','z'\r\n  ];\r\n\r\n  /// Encode une position géographique en geohash\r\n  /// @param lat - Latitude\r\n  /// @param lon - Longitude\r\n  /// @param precision - Précision du geohash (1-12)\r\n  static String encode(double lat, double lon, {int precision = 5}) {\r\n    // Utilisation de la bibliothèque dart_geohash pour assurer la cohérence\r\n    // Note: la bibliothèque attend (longitude, latitude) dans cet ordre\r\n    final geoHasher = GeoHasher();\r\n    return geoHasher.encode(lon, lat, precision: precision);\r\n  }\r\n\r\n  /// Version originale conservée pour référence (décommentez si nécessaire)\r\n  /*\r\n  static String encodeOriginal(double lat, double lon, {int precision = 5}) {\r\n    if (lat < -90.0 || lat > 90.0) {\r\n      throw ArgumentError('Latitude must be between -90 and 90');\r\n    }\r\n    if (lon < -180.0 || lon > 180.0) {\r\n      throw ArgumentError('Longitude must be between -180 and 180');\r\n    }\r\n    if (precision < 1 || precision > 12) {\r\n      throw ArgumentError('Precision must be between 1 and 12');\r\n    }\r\n\r\n    var latMin = -90.0;\r\n    var latMax = 90.0;\r\n    var lonMin = -180.0;\r\n    var lonMax = 180.0;\r\n\r\n    var bits = 0;\r\n    var bitsTotal = 0;\r\n    var hashValue = '';\r\n\r\n    while (hashValue.length < precision) {\r\n      if (bitsTotal % 2 == 0) {\r\n        var mid = (lonMin + lonMax) / 2;\r\n        if (lon >= mid) {\r\n          bits = (bits << 1) + 1;\r\n          lonMin = mid;\r\n        } else {\r\n          bits <<= 1;\r\n          lonMax = mid;\r\n        }\r\n      } else {\r\n        var mid = (latMin + latMax) / 2;\r\n        if (lat >= mid) {\r\n          bits = (bits << 1) + 1;\r\n          latMin = mid;\r\n        } else {\r\n          bits <<= 1;\r\n          latMax = mid;\r\n        }\r\n      }\r\n\r\n      bitsTotal++;\r\n      if (bitsTotal == 5) {\r\n        hashValue += _base32[bits];\r\n        bits = 0;\r\n        bitsTotal = 0;\r\n      }\r\n    }\r\n\r\n    return hashValue;\r\n  }\r\n  */\r\n\r\n  /// Convertit une polyline en liste de geohash5 traversés\r\n  static List<String> getGeohashesFromPolyline(String encodedPolyline) {\r\n    try {\r\n      print('🗺️ Décodage de la polyline');\r\n\r\n      // Décoder la polyline en liste de points avec une précision de 5\r\n      final decodedPoints = PolylineCodec.decode(encodedPolyline, precision: 5);\r\n      final points = decodedPoints.map((point) => LatLng(point[0].toDouble(), point[1].toDouble())).toList();\r\n\r\n      print('📍 ${points.length} points extraits de la polyline');\r\n\r\n      // Convertir chaque point en geohash5 et éliminer les doublons\r\n      final geohashes = <String>{};\r\n      final geoHasher = GeoHasher();\r\n      for (final point in points) {\r\n        final geohash = geoHasher.encode(point.longitude, point.latitude, precision: 5);\r\n        geohashes.add(geohash);\r\n      }\r\n\r\n      print('🔍 ${geohashes.length} geohash5 uniques trouvés');\r\n      return geohashes.toList();\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la conversion polyline → geohash: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3461,
        "last_modified": "2025-04-16T13:25:26.3179398",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\geo_utils.dart",
      "content": "// lib/core/common/utils/geo_utils.dart\r\n\r\nimport 'package:maps_toolkit/maps_toolkit.dart' as maps_toolkit;\r\nimport 'geohash.dart';\r\n\r\nclass GeoUtils {\r\n  /// Calcule le geohash d'une position\r\n  static String calculateGeohash(double latitude, double longitude, {int precision = 4}) {\r\n    return Geohash.encode(latitude, longitude, precision: precision);\r\n  }\r\n\r\n  /// Calcule la distance entre deux points en kilomètres\r\n  static double calculateDistance(\r\n      double startLat,\r\n      double startLng,\r\n      double endLat,\r\n      double endLng,\r\n      ) {\r\n    final start = maps_toolkit.LatLng(startLat, startLng);\r\n    final end = maps_toolkit.LatLng(endLat, endLng);\r\n\r\n    // SphericalUtil.computeDistanceBetween retourne la distance en mètres\r\n    return maps_toolkit.SphericalUtil.computeDistanceBetween(start, end) / 1000;\r\n  }\r\n}",
      "info": {
        "size": 844,
        "last_modified": "2025-04-16T13:25:26.3245397",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\location_formatter.dart",
      "content": "// lib/core/common/utils/location_formatter.dart\r\n\r\nimport '../../domain/models/location/place_details.dart';\r\n\r\n/// Classe utilitaire pour le formatage des adresses et lieux\r\nclass LocationFormatter {\r\n  /// Formate une adresse complète pour l'affichage\r\n  static String formatAddress(PlaceDetails details) {\r\n    final List<String> parts = [];\r\n\r\n    if (details.name.isNotEmpty) {\r\n      parts.add(details.name);\r\n    }\r\n\r\n    if (details.locality != null && details.locality!.isNotEmpty) {\r\n      parts.add(details.locality!);\r\n    }\r\n\r\n    if (details.administrativeArea != null && details.administrativeArea!.isNotEmpty) {\r\n      parts.add(details.administrativeArea!);\r\n    }\r\n\r\n    return parts.join(', ');\r\n  }\r\n\r\n  /// Formate une distance en mètres pour l'affichage\r\n  static String formatDistance(double distanceInMeters) {\r\n    if (distanceInMeters < 1000) {\r\n      return '${distanceInMeters.round()} m';\r\n    } else {\r\n      final double km = distanceInMeters / 1000;\r\n      return '${km.toStringAsFixed(1)} km';\r\n    }\r\n  }\r\n\r\n  /// Extrait le nom principal d'un lieu (généralement la ville ou commune)\r\n  static String extractMainName(PlaceDetails details) {\r\n    return details.locality ?? details.name;\r\n  }\r\n}",
      "info": {
        "size": 1233,
        "last_modified": "2025-04-16T13:25:26.3310441",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\maps_toolkit_utils.dart",
      "content": "// lib/core/common/utils/maps_toolkit_utils.dart\r\n\r\nimport 'package:maps_toolkit/maps_toolkit.dart' as mtk;\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../exceptions/geometry_calculation_exception.dart';\r\nimport '../constants/geometry_constants.dart';\r\n\r\nclass MapsToolkitUtils {\r\n  static double calculateHaversineDistance(LatLng start, LatLng end) {\r\n    try {\r\n      return mtk.SphericalUtil.computeDistanceBetween(\r\n          mtk.LatLng(start.latitude, start.longitude),\r\n          mtk.LatLng(end.latitude, end.longitude)\r\n      ).toDouble();\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Error calculating haversine distance: $e');\r\n    }\r\n  }\r\n\r\n  static bool isLocationOnPath(\r\n      LatLng point,\r\n      List<LatLng> pathPoints,\r\n      {double? toleranceMeters}\r\n      ) {\r\n    try {\r\n      return mtk.PolygonUtil.isLocationOnPath(\r\n          mtk.LatLng(point.latitude, point.longitude),\r\n          pathPoints.map((p) => mtk.LatLng(p.latitude, p.longitude)).toList(),\r\n          true  // On met simplement true car le paramètre est obligatoire mais son utilisation n'est pas claire dans maps_toolkit\r\n      );\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Error checking location on path: $e');\r\n    }\r\n  }\r\n\r\n  static int calculateMalusMinutes(\r\n      double distanceMeters,\r\n      String travelStyle,\r\n      ) {\r\n    try {\r\n      final factor = switch(travelStyle) {\r\n        'relax' => GeometryConstants.relaxedTravelFactor,\r\n        'active' => GeometryConstants.activeTravelFactor,\r\n        _ => GeometryConstants.balancedTravelFactor\r\n      };\r\n\r\n      final estimatedMinutes = (distanceMeters * factor) /\r\n          (GeometryConstants.averageSpeedMetersPerSecond * 60);\r\n\r\n      return estimatedMinutes.clamp(\r\n          GeometryConstants.minimumMalusMinutes.toDouble(),\r\n          GeometryConstants.maximumMalusMinutes.toDouble()\r\n      ).round();\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Error calculating malus minutes: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2041,
        "last_modified": "2025-04-16T13:25:26.3370458",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\activity_filter.dart",
      "content": "// lib\\core\\domain\\filters\\activity_filter.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nabstract class ActivityFilter {\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities);\r\n  String? get exclusionReason;\r\n}",
      "info": {
        "size": 282,
        "last_modified": "2025-04-16T13:25:26.3551255",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\filter_chain.dart",
      "content": "// core/domain/filters/filter_chain.dart\r\n\r\nimport 'activity_filter.dart';\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nclass FilterChain {\r\n  final List<ActivityFilter> _filters = [];\r\n\r\n  void addFilter(ActivityFilter filter) => _filters.add(filter);\r\n\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities) async {\r\n    var filtered = activities;\r\n    for (var filter in _filters) {\r\n      filtered = await filter.apply(filtered);\r\n    }\r\n    return filtered;\r\n  }\r\n}",
      "info": {
        "size": 535,
        "last_modified": "2025-04-16T13:25:26.3611586",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\time_filter.dart",
      "content": "// lib\\core\\domain\\filters\\time_filter.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/services/travel_time_service.dart';\r\nimport 'activity_filter.dart';\r\n\r\nclass TimeFilter implements ActivityFilter {\r\n  final ActivityHoursPort _hoursService;\r\n  final TravelTimeService _travelTimeService;\r\n  final DateTime tripStartDate;\r\n  final DateTime tripEndDate;\r\n  final Map<String, Map<String, String?>> dailyHours;\r\n  final String departureGeohash5;\r\n\r\n  TimeFilter({\r\n    required this.tripStartDate,\r\n    required this.tripEndDate,\r\n    required this.dailyHours,\r\n    required ActivityHoursPort hoursService,\r\n    required TravelTimeService travelTimeService,\r\n    required this.departureGeohash5,\r\n  }) : _hoursService = hoursService,\r\n        _travelTimeService = travelTimeService;\r\n\r\n  @override\r\n  String? get exclusionReason => null;\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities) async {\r\n    print('⏰ Application du TimeFilter');\r\n    print('Période du voyage: ${tripStartDate.toString()} - ${tripEndDate.toString()}');\r\n    print('Horaires journaliers: $dailyHours');\r\n\r\n    final filteredActivities = <ActivityForProcessing>[];\r\n\r\n    for (var activity in activities) {\r\n      activity.exclusionReason = null;\r\n      print('\\n🔍 Analyse de l\\'activité: ${activity.name}');\r\n\r\n      final openingDays = await _hoursService.getActivityHours(\r\n        activity.id,\r\n        tripStartDate,\r\n        tripEndDate,\r\n      );\r\n\r\n      if (openingDays == null || !openingDays.hasOpenDays) {\r\n        activity.exclusionReason = \"Activité fermée pendant cette période\";\r\n        print('❌ ${activity.name}: Fermée pendant la période');\r\n        continue;\r\n      }\r\n\r\n      // Vérifier la compatibilité pour chaque jour du voyage\r\n      bool hasCompatibleDay = false;\r\n      for (var entry in dailyHours.entries) {\r\n        final date = entry.key;\r\n        final hours = entry.value;\r\n\r\n        // Si l'utilisateur n'a pas prévu d'activités ce jour-là\r\n        if (hours['start'] == null || hours['end'] == null) {\r\n          print('📅 $date: Pas d\\'activités prévues');\r\n          continue;\r\n        }\r\n\r\n        // Vérifier si l'activité est ouverte ce jour-là\r\n        final activityHours = openingDays.availableDays[date];\r\n        if (activityHours == null) {\r\n          print('📅 $date: Activité fermée');\r\n          continue;\r\n        }\r\n\r\n        // Calculer d'abord le temps disponible sans le trajet\r\n        final activityOpenMinutes = _timeToMinutes(activityHours['opens_at']!);\r\n        final activityCloseMinutes = _timeToMinutes(activityHours['closes_at']!);\r\n        final tripStartMinutes = _timeToMinutes(hours['start']!);\r\n        final tripEndMinutes = _timeToMinutes(hours['end']!);\r\n\r\n        // Vérifier d'abord s'il y a un chevauchement basique\r\n        if (activityCloseMinutes <= tripStartMinutes || activityOpenMinutes >= tripEndMinutes) {\r\n          print('❌ $date: Pas de chevauchement des horaires');\r\n          continue;\r\n        }\r\n\r\n        // Calculer le temps disponible\r\n        final startTime = activityOpenMinutes > tripStartMinutes ? activityOpenMinutes : tripStartMinutes;\r\n        final endTime = activityCloseMinutes < tripEndMinutes ? activityCloseMinutes : tripEndMinutes;\r\n        final availableTime = endTime - startTime;\r\n\r\n        // Si le temps est serré (moins d'une heure de marge), calculer le temps de trajet\r\n        if (availableTime <= activity.minDurationMinutes + 60) {\r\n          print('⚠️ Temps serré, vérification du temps de trajet');\r\n          final travelTime = await _travelTimeService.calculateTravelTime(\r\n            departureGeohash5,\r\n            activity.geohash5 ?? '',\r\n          );\r\n          final totalTimeNeeded = activity.minDurationMinutes + travelTime;\r\n\r\n          if (availableTime < totalTimeNeeded) {\r\n            print('❌ $date: Temps insuffisant avec trajet (disponible: $availableTime, nécessaire: $totalTimeNeeded)');\r\n            continue;\r\n          }\r\n        }\r\n\r\n        hasCompatibleDay = true;\r\n        print('✅ $date: Horaires compatibles');\r\n        break; // On peut arrêter dès qu'on trouve un jour compatible\r\n      }\r\n\r\n      if (!hasCompatibleDay) {\r\n        activity.exclusionReason = \"Horaires incompatibles avec le planning du voyage\";\r\n        print('❌ ${activity.name}: Aucun jour compatible trouvé');\r\n        continue;\r\n      }\r\n\r\n      print('✅ ${activity.name}: Compatible avec au moins un jour du séjour');\r\n      filteredActivities.add(activity);\r\n    }\r\n\r\n    return filteredActivities;\r\n  }\r\n\r\n  int _timeToMinutes(String time) {\r\n    final parts = time.split(':');\r\n    return int.parse(parts[0]) * 60 + int.parse(parts[1]);\r\n  }\r\n}",
      "info": {
        "size": 4864,
        "last_modified": "2025-04-16T13:25:26.3686755",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\travel_group_filter.dart",
      "content": "// lib\\core\\domain\\filters\\travel_group_filter.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport 'activity_filter.dart';\r\n\r\nclass TravelGroupFilter implements ActivityFilter {\r\n  final TravelGroup travelGroup;\r\n\r\n  TravelGroupFilter(this.travelGroup);\r\n\r\n  @override\r\n  String? get exclusionReason => null; // Plus utilisé ici car géré directement sur l'activité\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities) async {\r\n    print('🔄 Application du TravelGroupFilter');\r\n    print('📋 Contraintes du voyage:');\r\n    print('- Enfants: ${travelGroup.members.children}');\r\n    print('- PMR: ${travelGroup.members.pmr}');\r\n    print('- Seniors: ${travelGroup.members.seniors}');\r\n\r\n    return activities.where((activity) {\r\n      print('\\n🔍 Analyse de l\\'activité: ${activity.name}');\r\n      activity.exclusionReason = null;\r\n\r\n      // Log des données initiales\r\n      print('Données activité:');\r\n      print('- kid_friendly: ${activity.kidFriendly}');\r\n      print('- wheelchairAccessible: ${activity.wheelchairAccessible}');\r\n      print('- intensityLevel: ${activity.intensityLevel}');\r\n\r\n      // Filtre pour enfants\r\n      if (travelGroup.members.children.isNotEmpty) {\r\n        print('👶 Vérification enfants');\r\n        if (activity.kidFriendly == false) {\r\n          print('❌ Non adapté aux enfants');\r\n          activity.exclusionReason = 'Non adapté aux enfants';\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Filtre pour PMR\r\n      if (travelGroup.members.pmr) {\r\n        print('♿ Vérification PMR');\r\n        if (activity.wheelchairAccessible == 'none') {\r\n          print('❌ Non accessible PMR');\r\n          activity.exclusionReason = 'Non accessible PMR';\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Filtre pour seniors\r\n      if (travelGroup.members.seniors) {\r\n        print('👴 Vérification seniors');\r\n        if (activity.intensityLevel > 2) {\r\n          print('❌ Intensité trop élevée pour seniors');\r\n          activity.exclusionReason = 'Intensité trop élevée pour seniors';\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }).toList();\r\n  }\r\n}",
      "info": {
        "size": 2299,
        "last_modified": "2025-04-16T13:25:26.3742753",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_base.dart",
      "content": "// lib/core/domain/models/activity/base/activity_base.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'activity_base.freezed.dart';\r\npart 'activity_base.g.dart';\r\n\r\n@freezed\r\nclass ActivityBase with _$ActivityBase {\r\n  const factory ActivityBase({\r\n    required String id,\r\n    required String name,\r\n    required String? description,\r\n    required double latitude,\r\n    required double longitude,\r\n    required String categoryId,\r\n    String? subcategoryId,\r\n    String? city,\r\n    String? imageUrl,\r\n    @Default(false) bool isWow,\r\n    double? basePrice,\r\n    @Default(0.0) double ratingAvg,\r\n    @Default(0) int ratingCount,\r\n    @Default(false) bool kidFriendly,\r\n    String? wheelchairAccessible,\r\n    @Default(false) bool bookingRequired,\r\n  }) = _ActivityBase;\r\n\r\n  factory ActivityBase.fromJson(Map<String, dynamic> json) => _$ActivityBaseFromJson(json);\r\n\r\n  // Factory depuis activity_model.dart\r\n  factory ActivityBase.fromActivityModel(dynamic activity) {\r\n    return ActivityBase(\r\n      id: activity.id,\r\n      name: activity.name,\r\n      description: activity.description,\r\n      latitude: activity.latitude,\r\n      longitude: activity.longitude,\r\n      categoryId: activity.categoryId,\r\n      subcategoryId: activity.subcategoryId,\r\n      isWow: activity.isWow,\r\n      basePrice: activity.basePrice,\r\n      ratingAvg: double.tryParse(activity.ratingAvg.toString()) ?? 0.0,\r\n      ratingCount: activity.ratingCount,\r\n      kidFriendly: activity.kidFriendly ?? false,\r\n      wheelchairAccessible: activity.wheelchairAccessible,\r\n      bookingRequired: activity.bookingRequired ?? false,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1646,
        "last_modified": "2025-04-16T13:25:26.3863119",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_base.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_base.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nActivityBase _$ActivityBaseFromJson(Map<String, dynamic> json) {\n  return _ActivityBase.fromJson(json);\n}\n\n/// @nodoc\nmixin _$ActivityBase {\n  String get id => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  String? get description => throw _privateConstructorUsedError;\n  double get latitude => throw _privateConstructorUsedError;\n  double get longitude => throw _privateConstructorUsedError;\n  String get categoryId => throw _privateConstructorUsedError;\n  String? get subcategoryId => throw _privateConstructorUsedError;\n  String? get city => throw _privateConstructorUsedError;\n  String? get imageUrl => throw _privateConstructorUsedError;\n  bool get isWow => throw _privateConstructorUsedError;\n  double? get basePrice => throw _privateConstructorUsedError;\n  double get ratingAvg => throw _privateConstructorUsedError;\n  int get ratingCount => throw _privateConstructorUsedError;\n  bool get kidFriendly => throw _privateConstructorUsedError;\n  String? get wheelchairAccessible => throw _privateConstructorUsedError;\n  bool get bookingRequired => throw _privateConstructorUsedError;\n\n  /// Serializes this ActivityBase to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $ActivityBaseCopyWith<ActivityBase> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityBaseCopyWith<$Res> {\n  factory $ActivityBaseCopyWith(\n          ActivityBase value, $Res Function(ActivityBase) then) =\n      _$ActivityBaseCopyWithImpl<$Res, ActivityBase>;\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? subcategoryId,\n      String? city,\n      String? imageUrl,\n      bool isWow,\n      double? basePrice,\n      double ratingAvg,\n      int ratingCount,\n      bool kidFriendly,\n      String? wheelchairAccessible,\n      bool bookingRequired});\n}\n\n/// @nodoc\nclass _$ActivityBaseCopyWithImpl<$Res, $Val extends ActivityBase>\n    implements $ActivityBaseCopyWith<$Res> {\n  _$ActivityBaseCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? subcategoryId = freezed,\n    Object? city = freezed,\n    Object? imageUrl = freezed,\n    Object? isWow = null,\n    Object? basePrice = freezed,\n    Object? ratingAvg = null,\n    Object? ratingCount = null,\n    Object? kidFriendly = null,\n    Object? wheelchairAccessible = freezed,\n    Object? bookingRequired = null,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      imageUrl: freezed == imageUrl\n          ? _value.imageUrl\n          : imageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isWow: null == isWow\n          ? _value.isWow\n          : isWow // ignore: cast_nullable_to_non_nullable\n              as bool,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      ratingAvg: null == ratingAvg\n          ? _value.ratingAvg\n          : ratingAvg // ignore: cast_nullable_to_non_nullable\n              as double,\n      ratingCount: null == ratingCount\n          ? _value.ratingCount\n          : ratingCount // ignore: cast_nullable_to_non_nullable\n              as int,\n      kidFriendly: null == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: null == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$ActivityBaseImplCopyWith<$Res>\n    implements $ActivityBaseCopyWith<$Res> {\n  factory _$$ActivityBaseImplCopyWith(\n          _$ActivityBaseImpl value, $Res Function(_$ActivityBaseImpl) then) =\n      __$$ActivityBaseImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? subcategoryId,\n      String? city,\n      String? imageUrl,\n      bool isWow,\n      double? basePrice,\n      double ratingAvg,\n      int ratingCount,\n      bool kidFriendly,\n      String? wheelchairAccessible,\n      bool bookingRequired});\n}\n\n/// @nodoc\nclass __$$ActivityBaseImplCopyWithImpl<$Res>\n    extends _$ActivityBaseCopyWithImpl<$Res, _$ActivityBaseImpl>\n    implements _$$ActivityBaseImplCopyWith<$Res> {\n  __$$ActivityBaseImplCopyWithImpl(\n      _$ActivityBaseImpl _value, $Res Function(_$ActivityBaseImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? subcategoryId = freezed,\n    Object? city = freezed,\n    Object? imageUrl = freezed,\n    Object? isWow = null,\n    Object? basePrice = freezed,\n    Object? ratingAvg = null,\n    Object? ratingCount = null,\n    Object? kidFriendly = null,\n    Object? wheelchairAccessible = freezed,\n    Object? bookingRequired = null,\n  }) {\n    return _then(_$ActivityBaseImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      imageUrl: freezed == imageUrl\n          ? _value.imageUrl\n          : imageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isWow: null == isWow\n          ? _value.isWow\n          : isWow // ignore: cast_nullable_to_non_nullable\n              as bool,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      ratingAvg: null == ratingAvg\n          ? _value.ratingAvg\n          : ratingAvg // ignore: cast_nullable_to_non_nullable\n              as double,\n      ratingCount: null == ratingCount\n          ? _value.ratingCount\n          : ratingCount // ignore: cast_nullable_to_non_nullable\n              as int,\n      kidFriendly: null == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: null == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$ActivityBaseImpl implements _ActivityBase {\n  const _$ActivityBaseImpl(\n      {required this.id,\n      required this.name,\n      required this.description,\n      required this.latitude,\n      required this.longitude,\n      required this.categoryId,\n      this.subcategoryId,\n      this.city,\n      this.imageUrl,\n      this.isWow = false,\n      this.basePrice,\n      this.ratingAvg = 0.0,\n      this.ratingCount = 0,\n      this.kidFriendly = false,\n      this.wheelchairAccessible,\n      this.bookingRequired = false});\n\n  factory _$ActivityBaseImpl.fromJson(Map<String, dynamic> json) =>\n      _$$ActivityBaseImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String name;\n  @override\n  final String? description;\n  @override\n  final double latitude;\n  @override\n  final double longitude;\n  @override\n  final String categoryId;\n  @override\n  final String? subcategoryId;\n  @override\n  final String? city;\n  @override\n  final String? imageUrl;\n  @override\n  @JsonKey()\n  final bool isWow;\n  @override\n  final double? basePrice;\n  @override\n  @JsonKey()\n  final double ratingAvg;\n  @override\n  @JsonKey()\n  final int ratingCount;\n  @override\n  @JsonKey()\n  final bool kidFriendly;\n  @override\n  final String? wheelchairAccessible;\n  @override\n  @JsonKey()\n  final bool bookingRequired;\n\n  @override\n  String toString() {\n    return 'ActivityBase(id: $id, name: $name, description: $description, latitude: $latitude, longitude: $longitude, categoryId: $categoryId, subcategoryId: $subcategoryId, city: $city, imageUrl: $imageUrl, isWow: $isWow, basePrice: $basePrice, ratingAvg: $ratingAvg, ratingCount: $ratingCount, kidFriendly: $kidFriendly, wheelchairAccessible: $wheelchairAccessible, bookingRequired: $bookingRequired)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ActivityBaseImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.description, description) ||\n                other.description == description) &&\n            (identical(other.latitude, latitude) ||\n                other.latitude == latitude) &&\n            (identical(other.longitude, longitude) ||\n                other.longitude == longitude) &&\n            (identical(other.categoryId, categoryId) ||\n                other.categoryId == categoryId) &&\n            (identical(other.subcategoryId, subcategoryId) ||\n                other.subcategoryId == subcategoryId) &&\n            (identical(other.city, city) || other.city == city) &&\n            (identical(other.imageUrl, imageUrl) ||\n                other.imageUrl == imageUrl) &&\n            (identical(other.isWow, isWow) || other.isWow == isWow) &&\n            (identical(other.basePrice, basePrice) ||\n                other.basePrice == basePrice) &&\n            (identical(other.ratingAvg, ratingAvg) ||\n                other.ratingAvg == ratingAvg) &&\n            (identical(other.ratingCount, ratingCount) ||\n                other.ratingCount == ratingCount) &&\n            (identical(other.kidFriendly, kidFriendly) ||\n                other.kidFriendly == kidFriendly) &&\n            (identical(other.wheelchairAccessible, wheelchairAccessible) ||\n                other.wheelchairAccessible == wheelchairAccessible) &&\n            (identical(other.bookingRequired, bookingRequired) ||\n                other.bookingRequired == bookingRequired));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType,\n      id,\n      name,\n      description,\n      latitude,\n      longitude,\n      categoryId,\n      subcategoryId,\n      city,\n      imageUrl,\n      isWow,\n      basePrice,\n      ratingAvg,\n      ratingCount,\n      kidFriendly,\n      wheelchairAccessible,\n      bookingRequired);\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ActivityBaseImplCopyWith<_$ActivityBaseImpl> get copyWith =>\n      __$$ActivityBaseImplCopyWithImpl<_$ActivityBaseImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$ActivityBaseImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _ActivityBase implements ActivityBase {\n  const factory _ActivityBase(\n      {required final String id,\n      required final String name,\n      required final String? description,\n      required final double latitude,\n      required final double longitude,\n      required final String categoryId,\n      final String? subcategoryId,\n      final String? city,\n      final String? imageUrl,\n      final bool isWow,\n      final double? basePrice,\n      final double ratingAvg,\n      final int ratingCount,\n      final bool kidFriendly,\n      final String? wheelchairAccessible,\n      final bool bookingRequired}) = _$ActivityBaseImpl;\n\n  factory _ActivityBase.fromJson(Map<String, dynamic> json) =\n      _$ActivityBaseImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get name;\n  @override\n  String? get description;\n  @override\n  double get latitude;\n  @override\n  double get longitude;\n  @override\n  String get categoryId;\n  @override\n  String? get subcategoryId;\n  @override\n  String? get city;\n  @override\n  String? get imageUrl;\n  @override\n  bool get isWow;\n  @override\n  double? get basePrice;\n  @override\n  double get ratingAvg;\n  @override\n  int get ratingCount;\n  @override\n  bool get kidFriendly;\n  @override\n  String? get wheelchairAccessible;\n  @override\n  bool get bookingRequired;\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ActivityBaseImplCopyWith<_$ActivityBaseImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 16922,
        "last_modified": "2025-04-16T13:25:26.3933505",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_base.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'activity_base.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$ActivityBaseImpl _$$ActivityBaseImplFromJson(Map<String, dynamic> json) =>\n    _$ActivityBaseImpl(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      description: json['description'] as String?,\n      latitude: (json['latitude'] as num).toDouble(),\n      longitude: (json['longitude'] as num).toDouble(),\n      categoryId: json['categoryId'] as String,\n      subcategoryId: json['subcategoryId'] as String?,\n      city: json['city'] as String?,\n      imageUrl: json['imageUrl'] as String?,\n      isWow: json['isWow'] as bool? ?? false,\n      basePrice: (json['basePrice'] as num?)?.toDouble(),\n      ratingAvg: (json['ratingAvg'] as num?)?.toDouble() ?? 0.0,\n      ratingCount: (json['ratingCount'] as num?)?.toInt() ?? 0,\n      kidFriendly: json['kidFriendly'] as bool? ?? false,\n      wheelchairAccessible: json['wheelchairAccessible'] as String?,\n      bookingRequired: json['bookingRequired'] as bool? ?? false,\n    );\n\nMap<String, dynamic> _$$ActivityBaseImplToJson(_$ActivityBaseImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'name': instance.name,\n      'description': instance.description,\n      'latitude': instance.latitude,\n      'longitude': instance.longitude,\n      'categoryId': instance.categoryId,\n      'subcategoryId': instance.subcategoryId,\n      'city': instance.city,\n      'imageUrl': instance.imageUrl,\n      'isWow': instance.isWow,\n      'basePrice': instance.basePrice,\n      'ratingAvg': instance.ratingAvg,\n      'ratingCount': instance.ratingCount,\n      'kidFriendly': instance.kidFriendly,\n      'wheelchairAccessible': instance.wheelchairAccessible,\n      'bookingRequired': instance.bookingRequired,\n    };\n",
      "info": {
        "size": 1952,
        "last_modified": "2025-04-16T13:25:26.4003507",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_interface.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.4074492",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\searchable_activity.dart",
      "content": "// lib/core/domain/models/activity/search/searchable_activity.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../base/activity_base.dart';\r\n\r\npart 'searchable_activity.freezed.dart';\r\npart 'searchable_activity.g.dart';\r\n\r\n@freezed\r\nclass SearchableActivity with _$SearchableActivity {\r\n  const factory SearchableActivity({\r\n    required ActivityBase base,\r\n    String? categoryName,\r\n    String? subcategoryName,\r\n    String? subcategoryIcon,\r\n    String? geohash4,\r\n    String? geohash5,\r\n    double? approxDistanceKm,\r\n    double? distance,\r\n    String? city,\r\n    String? mainImageUrl,\r\n    List<String>? momentPreferences,\r\n    List<String>? weatherPreferences,\r\n  }) = _SearchableActivity;\r\n\r\n  factory SearchableActivity.fromJson(Map<String, dynamic> json) =>\r\n      _$SearchableActivityFromJson(json);\r\n\r\n  factory SearchableActivity.fromSupabase(\r\n      Map<String, dynamic> json, {\r\n        double? distanceFromSearch,\r\n      }) {\r\n    final categories = json['categories'] as Map<String, dynamic>?;\r\n    final subcategories = json['activity_subcategories'] as Map<String, dynamic>?;\r\n    final imagesData = json['activities_images'] as List?;\r\n    final mainImageUrl = imagesData?.firstWhere(\r\n          (img) => img['is_main'] == true,\r\n      orElse: () => imagesData.firstOrNull,\r\n    )?['mobile_url'];\r\n\r\n    return SearchableActivity(\r\n      base: ActivityBase(\r\n        id: json['id'],\r\n        name: json['name'],\r\n        city: json['city'],\r\n        description: json['description'],\r\n        latitude: json['latitude']?.toDouble() ?? 0.0,\r\n        longitude: json['longitude']?.toDouble() ?? 0.0,\r\n        categoryId: json['category_id'] ?? '',\r\n        subcategoryId: json['subcategory_id'],\r\n        isWow: json['is_wow'] ?? false,\r\n        basePrice: json['base_price']?.toDouble(),\r\n        ratingAvg: json['rating_avg']?.toDouble() ?? 0.0,\r\n        ratingCount: json['rating_count'] ?? 0,\r\n        kidFriendly: json['kid_friendly'] ?? false,\r\n        wheelchairAccessible: json['wheelchair_accessible'],\r\n        bookingRequired: json['booking_required'] ?? false,\r\n      ),\r\n      categoryName: categories?['name'],\r\n      subcategoryName: subcategories?['name'],\r\n      subcategoryIcon: subcategories?['icon'],\r\n      geohash4: json['geohash_4'],\r\n      geohash5: json['geohash_5'],\r\n      approxDistanceKm: (json['approx_distance_km'] as num?)?.toDouble(),\r\n      distance: distanceFromSearch,\r\n      city: json['address']?.toString().split(',').last.trim(),\r\n      mainImageUrl: mainImageUrl,\r\n      momentPreferences: (json['moment_preferences'] as List<dynamic>?)?.cast<String>(),\r\n      weatherPreferences: (json['weather_preferences'] as List<dynamic>?)?.cast<String>(),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2748,
        "last_modified": "2025-04-16T13:25:26.4199672",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\searchable_activity.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'searchable_activity.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nSearchableActivity _$SearchableActivityFromJson(Map<String, dynamic> json) {\n  return _SearchableActivity.fromJson(json);\n}\n\n/// @nodoc\nmixin _$SearchableActivity {\n  ActivityBase get base => throw _privateConstructorUsedError;\n  String? get categoryName => throw _privateConstructorUsedError;\n  String? get subcategoryName => throw _privateConstructorUsedError;\n  String? get subcategoryIcon => throw _privateConstructorUsedError;\n  String? get geohash4 => throw _privateConstructorUsedError;\n  String? get geohash5 => throw _privateConstructorUsedError;\n  double? get approxDistanceKm => throw _privateConstructorUsedError;\n  double? get distance => throw _privateConstructorUsedError;\n  String? get city => throw _privateConstructorUsedError;\n  String? get mainImageUrl => throw _privateConstructorUsedError;\n  List<String>? get momentPreferences => throw _privateConstructorUsedError;\n  List<String>? get weatherPreferences => throw _privateConstructorUsedError;\n\n  /// Serializes this SearchableActivity to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $SearchableActivityCopyWith<SearchableActivity> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $SearchableActivityCopyWith<$Res> {\n  factory $SearchableActivityCopyWith(\n          SearchableActivity value, $Res Function(SearchableActivity) then) =\n      _$SearchableActivityCopyWithImpl<$Res, SearchableActivity>;\n  @useResult\n  $Res call(\n      {ActivityBase base,\n      String? categoryName,\n      String? subcategoryName,\n      String? subcategoryIcon,\n      String? geohash4,\n      String? geohash5,\n      double? approxDistanceKm,\n      double? distance,\n      String? city,\n      String? mainImageUrl,\n      List<String>? momentPreferences,\n      List<String>? weatherPreferences});\n\n  $ActivityBaseCopyWith<$Res> get base;\n}\n\n/// @nodoc\nclass _$SearchableActivityCopyWithImpl<$Res, $Val extends SearchableActivity>\n    implements $SearchableActivityCopyWith<$Res> {\n  _$SearchableActivityCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? base = null,\n    Object? categoryName = freezed,\n    Object? subcategoryName = freezed,\n    Object? subcategoryIcon = freezed,\n    Object? geohash4 = freezed,\n    Object? geohash5 = freezed,\n    Object? approxDistanceKm = freezed,\n    Object? distance = freezed,\n    Object? city = freezed,\n    Object? mainImageUrl = freezed,\n    Object? momentPreferences = freezed,\n    Object? weatherPreferences = freezed,\n  }) {\n    return _then(_value.copyWith(\n      base: null == base\n          ? _value.base\n          : base // ignore: cast_nullable_to_non_nullable\n              as ActivityBase,\n      categoryName: freezed == categoryName\n          ? _value.categoryName\n          : categoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryName: freezed == subcategoryName\n          ? _value.subcategoryName\n          : subcategoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryIcon: freezed == subcategoryIcon\n          ? _value.subcategoryIcon\n          : subcategoryIcon // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash4: freezed == geohash4\n          ? _value.geohash4\n          : geohash4 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash5: freezed == geohash5\n          ? _value.geohash5\n          : geohash5 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      approxDistanceKm: freezed == approxDistanceKm\n          ? _value.approxDistanceKm\n          : approxDistanceKm // ignore: cast_nullable_to_non_nullable\n              as double?,\n      distance: freezed == distance\n          ? _value.distance\n          : distance // ignore: cast_nullable_to_non_nullable\n              as double?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mainImageUrl: freezed == mainImageUrl\n          ? _value.mainImageUrl\n          : mainImageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      momentPreferences: freezed == momentPreferences\n          ? _value.momentPreferences\n          : momentPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n      weatherPreferences: freezed == weatherPreferences\n          ? _value.weatherPreferences\n          : weatherPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n    ) as $Val);\n  }\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $ActivityBaseCopyWith<$Res> get base {\n    return $ActivityBaseCopyWith<$Res>(_value.base, (value) {\n      return _then(_value.copyWith(base: value) as $Val);\n    });\n  }\n}\n\n/// @nodoc\nabstract class _$$SearchableActivityImplCopyWith<$Res>\n    implements $SearchableActivityCopyWith<$Res> {\n  factory _$$SearchableActivityImplCopyWith(_$SearchableActivityImpl value,\n          $Res Function(_$SearchableActivityImpl) then) =\n      __$$SearchableActivityImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {ActivityBase base,\n      String? categoryName,\n      String? subcategoryName,\n      String? subcategoryIcon,\n      String? geohash4,\n      String? geohash5,\n      double? approxDistanceKm,\n      double? distance,\n      String? city,\n      String? mainImageUrl,\n      List<String>? momentPreferences,\n      List<String>? weatherPreferences});\n\n  @override\n  $ActivityBaseCopyWith<$Res> get base;\n}\n\n/// @nodoc\nclass __$$SearchableActivityImplCopyWithImpl<$Res>\n    extends _$SearchableActivityCopyWithImpl<$Res, _$SearchableActivityImpl>\n    implements _$$SearchableActivityImplCopyWith<$Res> {\n  __$$SearchableActivityImplCopyWithImpl(_$SearchableActivityImpl _value,\n      $Res Function(_$SearchableActivityImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? base = null,\n    Object? categoryName = freezed,\n    Object? subcategoryName = freezed,\n    Object? subcategoryIcon = freezed,\n    Object? geohash4 = freezed,\n    Object? geohash5 = freezed,\n    Object? approxDistanceKm = freezed,\n    Object? distance = freezed,\n    Object? city = freezed,\n    Object? mainImageUrl = freezed,\n    Object? momentPreferences = freezed,\n    Object? weatherPreferences = freezed,\n  }) {\n    return _then(_$SearchableActivityImpl(\n      base: null == base\n          ? _value.base\n          : base // ignore: cast_nullable_to_non_nullable\n              as ActivityBase,\n      categoryName: freezed == categoryName\n          ? _value.categoryName\n          : categoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryName: freezed == subcategoryName\n          ? _value.subcategoryName\n          : subcategoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryIcon: freezed == subcategoryIcon\n          ? _value.subcategoryIcon\n          : subcategoryIcon // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash4: freezed == geohash4\n          ? _value.geohash4\n          : geohash4 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash5: freezed == geohash5\n          ? _value.geohash5\n          : geohash5 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      approxDistanceKm: freezed == approxDistanceKm\n          ? _value.approxDistanceKm\n          : approxDistanceKm // ignore: cast_nullable_to_non_nullable\n              as double?,\n      distance: freezed == distance\n          ? _value.distance\n          : distance // ignore: cast_nullable_to_non_nullable\n              as double?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mainImageUrl: freezed == mainImageUrl\n          ? _value.mainImageUrl\n          : mainImageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      momentPreferences: freezed == momentPreferences\n          ? _value._momentPreferences\n          : momentPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n      weatherPreferences: freezed == weatherPreferences\n          ? _value._weatherPreferences\n          : weatherPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$SearchableActivityImpl implements _SearchableActivity {\n  const _$SearchableActivityImpl(\n      {required this.base,\n      this.categoryName,\n      this.subcategoryName,\n      this.subcategoryIcon,\n      this.geohash4,\n      this.geohash5,\n      this.approxDistanceKm,\n      this.distance,\n      this.city,\n      this.mainImageUrl,\n      final List<String>? momentPreferences,\n      final List<String>? weatherPreferences})\n      : _momentPreferences = momentPreferences,\n        _weatherPreferences = weatherPreferences;\n\n  factory _$SearchableActivityImpl.fromJson(Map<String, dynamic> json) =>\n      _$$SearchableActivityImplFromJson(json);\n\n  @override\n  final ActivityBase base;\n  @override\n  final String? categoryName;\n  @override\n  final String? subcategoryName;\n  @override\n  final String? subcategoryIcon;\n  @override\n  final String? geohash4;\n  @override\n  final String? geohash5;\n  @override\n  final double? approxDistanceKm;\n  @override\n  final double? distance;\n  @override\n  final String? city;\n  @override\n  final String? mainImageUrl;\n  final List<String>? _momentPreferences;\n  @override\n  List<String>? get momentPreferences {\n    final value = _momentPreferences;\n    if (value == null) return null;\n    if (_momentPreferences is EqualUnmodifiableListView)\n      return _momentPreferences;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(value);\n  }\n\n  final List<String>? _weatherPreferences;\n  @override\n  List<String>? get weatherPreferences {\n    final value = _weatherPreferences;\n    if (value == null) return null;\n    if (_weatherPreferences is EqualUnmodifiableListView)\n      return _weatherPreferences;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(value);\n  }\n\n  @override\n  String toString() {\n    return 'SearchableActivity(base: $base, categoryName: $categoryName, subcategoryName: $subcategoryName, subcategoryIcon: $subcategoryIcon, geohash4: $geohash4, geohash5: $geohash5, approxDistanceKm: $approxDistanceKm, distance: $distance, city: $city, mainImageUrl: $mainImageUrl, momentPreferences: $momentPreferences, weatherPreferences: $weatherPreferences)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SearchableActivityImpl &&\n            (identical(other.base, base) || other.base == base) &&\n            (identical(other.categoryName, categoryName) ||\n                other.categoryName == categoryName) &&\n            (identical(other.subcategoryName, subcategoryName) ||\n                other.subcategoryName == subcategoryName) &&\n            (identical(other.subcategoryIcon, subcategoryIcon) ||\n                other.subcategoryIcon == subcategoryIcon) &&\n            (identical(other.geohash4, geohash4) ||\n                other.geohash4 == geohash4) &&\n            (identical(other.geohash5, geohash5) ||\n                other.geohash5 == geohash5) &&\n            (identical(other.approxDistanceKm, approxDistanceKm) ||\n                other.approxDistanceKm == approxDistanceKm) &&\n            (identical(other.distance, distance) ||\n                other.distance == distance) &&\n            (identical(other.city, city) || other.city == city) &&\n            (identical(other.mainImageUrl, mainImageUrl) ||\n                other.mainImageUrl == mainImageUrl) &&\n            const DeepCollectionEquality()\n                .equals(other._momentPreferences, _momentPreferences) &&\n            const DeepCollectionEquality()\n                .equals(other._weatherPreferences, _weatherPreferences));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType,\n      base,\n      categoryName,\n      subcategoryName,\n      subcategoryIcon,\n      geohash4,\n      geohash5,\n      approxDistanceKm,\n      distance,\n      city,\n      mainImageUrl,\n      const DeepCollectionEquality().hash(_momentPreferences),\n      const DeepCollectionEquality().hash(_weatherPreferences));\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SearchableActivityImplCopyWith<_$SearchableActivityImpl> get copyWith =>\n      __$$SearchableActivityImplCopyWithImpl<_$SearchableActivityImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$SearchableActivityImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _SearchableActivity implements SearchableActivity {\n  const factory _SearchableActivity(\n      {required final ActivityBase base,\n      final String? categoryName,\n      final String? subcategoryName,\n      final String? subcategoryIcon,\n      final String? geohash4,\n      final String? geohash5,\n      final double? approxDistanceKm,\n      final double? distance,\n      final String? city,\n      final String? mainImageUrl,\n      final List<String>? momentPreferences,\n      final List<String>? weatherPreferences}) = _$SearchableActivityImpl;\n\n  factory _SearchableActivity.fromJson(Map<String, dynamic> json) =\n      _$SearchableActivityImpl.fromJson;\n\n  @override\n  ActivityBase get base;\n  @override\n  String? get categoryName;\n  @override\n  String? get subcategoryName;\n  @override\n  String? get subcategoryIcon;\n  @override\n  String? get geohash4;\n  @override\n  String? get geohash5;\n  @override\n  double? get approxDistanceKm;\n  @override\n  double? get distance;\n  @override\n  String? get city;\n  @override\n  String? get mainImageUrl;\n  @override\n  List<String>? get momentPreferences;\n  @override\n  List<String>? get weatherPreferences;\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SearchableActivityImplCopyWith<_$SearchableActivityImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 16211,
        "last_modified": "2025-04-16T13:25:26.4271204",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\searchable_activity.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'searchable_activity.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$SearchableActivityImpl _$$SearchableActivityImplFromJson(\n        Map<String, dynamic> json) =>\n    _$SearchableActivityImpl(\n      base: ActivityBase.fromJson(json['base'] as Map<String, dynamic>),\n      categoryName: json['categoryName'] as String?,\n      subcategoryName: json['subcategoryName'] as String?,\n      subcategoryIcon: json['subcategoryIcon'] as String?,\n      geohash4: json['geohash4'] as String?,\n      geohash5: json['geohash5'] as String?,\n      approxDistanceKm: (json['approxDistanceKm'] as num?)?.toDouble(),\n      distance: (json['distance'] as num?)?.toDouble(),\n      city: json['city'] as String?,\n      mainImageUrl: json['mainImageUrl'] as String?,\n      momentPreferences: (json['momentPreferences'] as List<dynamic>?)\n          ?.map((e) => e as String)\n          .toList(),\n      weatherPreferences: (json['weatherPreferences'] as List<dynamic>?)\n          ?.map((e) => e as String)\n          .toList(),\n    );\n\nMap<String, dynamic> _$$SearchableActivityImplToJson(\n        _$SearchableActivityImpl instance) =>\n    <String, dynamic>{\n      'base': instance.base,\n      'categoryName': instance.categoryName,\n      'subcategoryName': instance.subcategoryName,\n      'subcategoryIcon': instance.subcategoryIcon,\n      'geohash4': instance.geohash4,\n      'geohash5': instance.geohash5,\n      'approxDistanceKm': instance.approxDistanceKm,\n      'distance': instance.distance,\n      'city': instance.city,\n      'mainImageUrl': instance.mainImageUrl,\n      'momentPreferences': instance.momentPreferences,\n      'weatherPreferences': instance.weatherPreferences,\n    };\n",
      "info": {
        "size": 1868,
        "last_modified": "2025-04-16T13:25:26.4331639",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\search_result.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.4411855",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\trip\\trip_activity.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.4524634",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\common_models.dart",
      "content": "// lib\\core\\domain\\models\\common_models.dart\r\n\r\nimport '../../common/enums/trip_enums.dart';\r\n\r\nclass GeoPoint {\r\n  final double latitude;\r\n  final double longitude;\r\n\r\n  GeoPoint({\r\n    required this.latitude,\r\n    required this.longitude,\r\n  });\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'latitude': latitude,\r\n    'longitude': longitude,\r\n  };\r\n}\r\n\r\nclass GroupMember {\r\n  final GroupMemberType type;\r\n  final bool hasMobilityIssues;\r\n\r\n  GroupMember({\r\n    required this.type,\r\n    this.hasMobilityIssues = false,\r\n  });\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'type': type.toString(),\r\n    'hasMobilityIssues': hasMobilityIssues,\r\n  };\r\n}",
      "info": {
        "size": 651,
        "last_modified": "2025-04-16T13:25:26.4689854",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\app_remote_config.dart",
      "content": "// lib/core/domain/models/config/app_remote_config.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'app_remote_config.freezed.dart';\r\npart 'app_remote_config.g.dart';\r\n\r\n@freezed\r\nclass AppRemoteConfig with _$AppRemoteConfig {\r\n  const factory AppRemoteConfig({\r\n    required String key,\r\n    required dynamic value,\r\n    String? minAppVersion,\r\n  }) = _AppRemoteConfig;\r\n\r\n  factory AppRemoteConfig.fromJson(Map<String, dynamic> json) =>\r\n      _$AppRemoteConfigFromJson(json);\r\n}",
      "info": {
        "size": 510,
        "last_modified": "2025-04-16T13:25:26.4750017",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\app_remote_config.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'app_remote_config.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nAppRemoteConfig _$AppRemoteConfigFromJson(Map<String, dynamic> json) {\n  return _AppRemoteConfig.fromJson(json);\n}\n\n/// @nodoc\nmixin _$AppRemoteConfig {\n  String get key => throw _privateConstructorUsedError;\n  dynamic get value => throw _privateConstructorUsedError;\n  String? get minAppVersion => throw _privateConstructorUsedError;\n\n  /// Serializes this AppRemoteConfig to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $AppRemoteConfigCopyWith<AppRemoteConfig> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $AppRemoteConfigCopyWith<$Res> {\n  factory $AppRemoteConfigCopyWith(\n          AppRemoteConfig value, $Res Function(AppRemoteConfig) then) =\n      _$AppRemoteConfigCopyWithImpl<$Res, AppRemoteConfig>;\n  @useResult\n  $Res call({String key, dynamic value, String? minAppVersion});\n}\n\n/// @nodoc\nclass _$AppRemoteConfigCopyWithImpl<$Res, $Val extends AppRemoteConfig>\n    implements $AppRemoteConfigCopyWith<$Res> {\n  _$AppRemoteConfigCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? key = null,\n    Object? value = freezed,\n    Object? minAppVersion = freezed,\n  }) {\n    return _then(_value.copyWith(\n      key: null == key\n          ? _value.key\n          : key // ignore: cast_nullable_to_non_nullable\n              as String,\n      value: freezed == value\n          ? _value.value\n          : value // ignore: cast_nullable_to_non_nullable\n              as dynamic,\n      minAppVersion: freezed == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$AppRemoteConfigImplCopyWith<$Res>\n    implements $AppRemoteConfigCopyWith<$Res> {\n  factory _$$AppRemoteConfigImplCopyWith(_$AppRemoteConfigImpl value,\n          $Res Function(_$AppRemoteConfigImpl) then) =\n      __$$AppRemoteConfigImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call({String key, dynamic value, String? minAppVersion});\n}\n\n/// @nodoc\nclass __$$AppRemoteConfigImplCopyWithImpl<$Res>\n    extends _$AppRemoteConfigCopyWithImpl<$Res, _$AppRemoteConfigImpl>\n    implements _$$AppRemoteConfigImplCopyWith<$Res> {\n  __$$AppRemoteConfigImplCopyWithImpl(\n      _$AppRemoteConfigImpl _value, $Res Function(_$AppRemoteConfigImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? key = null,\n    Object? value = freezed,\n    Object? minAppVersion = freezed,\n  }) {\n    return _then(_$AppRemoteConfigImpl(\n      key: null == key\n          ? _value.key\n          : key // ignore: cast_nullable_to_non_nullable\n              as String,\n      value: freezed == value\n          ? _value.value\n          : value // ignore: cast_nullable_to_non_nullable\n              as dynamic,\n      minAppVersion: freezed == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$AppRemoteConfigImpl implements _AppRemoteConfig {\n  const _$AppRemoteConfigImpl(\n      {required this.key, required this.value, this.minAppVersion});\n\n  factory _$AppRemoteConfigImpl.fromJson(Map<String, dynamic> json) =>\n      _$$AppRemoteConfigImplFromJson(json);\n\n  @override\n  final String key;\n  @override\n  final dynamic value;\n  @override\n  final String? minAppVersion;\n\n  @override\n  String toString() {\n    return 'AppRemoteConfig(key: $key, value: $value, minAppVersion: $minAppVersion)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$AppRemoteConfigImpl &&\n            (identical(other.key, key) || other.key == key) &&\n            const DeepCollectionEquality().equals(other.value, value) &&\n            (identical(other.minAppVersion, minAppVersion) ||\n                other.minAppVersion == minAppVersion));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, key,\n      const DeepCollectionEquality().hash(value), minAppVersion);\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$AppRemoteConfigImplCopyWith<_$AppRemoteConfigImpl> get copyWith =>\n      __$$AppRemoteConfigImplCopyWithImpl<_$AppRemoteConfigImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$AppRemoteConfigImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _AppRemoteConfig implements AppRemoteConfig {\n  const factory _AppRemoteConfig(\n      {required final String key,\n      required final dynamic value,\n      final String? minAppVersion}) = _$AppRemoteConfigImpl;\n\n  factory _AppRemoteConfig.fromJson(Map<String, dynamic> json) =\n      _$AppRemoteConfigImpl.fromJson;\n\n  @override\n  String get key;\n  @override\n  dynamic get value;\n  @override\n  String? get minAppVersion;\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$AppRemoteConfigImplCopyWith<_$AppRemoteConfigImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 7004,
        "last_modified": "2025-04-16T13:25:26.4813668",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\app_remote_config.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'app_remote_config.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$AppRemoteConfigImpl _$$AppRemoteConfigImplFromJson(\n        Map<String, dynamic> json) =>\n    _$AppRemoteConfigImpl(\n      key: json['key'] as String,\n      value: json['value'],\n      minAppVersion: json['minAppVersion'] as String?,\n    );\n\nMap<String, dynamic> _$$AppRemoteConfigImplToJson(\n        _$AppRemoteConfigImpl instance) =>\n    <String, dynamic>{\n      'key': instance.key,\n      'value': instance.value,\n      'minAppVersion': instance.minAppVersion,\n    };\n",
      "info": {
        "size": 737,
        "last_modified": "2025-04-16T13:25:26.4873663",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\home_section_config.dart",
      "content": "// lib/core/domain/models/config/home_section_config.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'home_section_config.freezed.dart';\r\npart 'home_section_config.g.dart';\r\n\r\n@freezed\r\nclass HomeSectionConfig with _$HomeSectionConfig {\r\n  const factory HomeSectionConfig({\r\n    required String id,\r\n    required String title,\r\n    required String queryFilter,\r\n    String? iconUrl,\r\n    required int priority,\r\n    required String minAppVersion,\r\n  }) = _HomeSectionConfig;\r\n\r\n  factory HomeSectionConfig.fromJson(Map<String, dynamic> json) =>\r\n      _$HomeSectionConfigFromJson(json);\r\n}\r\n\r\n\r\n\r\n",
      "info": {
        "size": 626,
        "last_modified": "2025-04-16T13:25:26.4938776",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\home_section_config.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'home_section_config.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nHomeSectionConfig _$HomeSectionConfigFromJson(Map<String, dynamic> json) {\n  return _HomeSectionConfig.fromJson(json);\n}\n\n/// @nodoc\nmixin _$HomeSectionConfig {\n  String get id => throw _privateConstructorUsedError;\n  String get title => throw _privateConstructorUsedError;\n  String get queryFilter => throw _privateConstructorUsedError;\n  String? get iconUrl => throw _privateConstructorUsedError;\n  int get priority => throw _privateConstructorUsedError;\n  String get minAppVersion => throw _privateConstructorUsedError;\n\n  /// Serializes this HomeSectionConfig to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $HomeSectionConfigCopyWith<HomeSectionConfig> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $HomeSectionConfigCopyWith<$Res> {\n  factory $HomeSectionConfigCopyWith(\n          HomeSectionConfig value, $Res Function(HomeSectionConfig) then) =\n      _$HomeSectionConfigCopyWithImpl<$Res, HomeSectionConfig>;\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? iconUrl,\n      int priority,\n      String minAppVersion});\n}\n\n/// @nodoc\nclass _$HomeSectionConfigCopyWithImpl<$Res, $Val extends HomeSectionConfig>\n    implements $HomeSectionConfigCopyWith<$Res> {\n  _$HomeSectionConfigCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? iconUrl = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      iconUrl: freezed == iconUrl\n          ? _value.iconUrl\n          : iconUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$HomeSectionConfigImplCopyWith<$Res>\n    implements $HomeSectionConfigCopyWith<$Res> {\n  factory _$$HomeSectionConfigImplCopyWith(_$HomeSectionConfigImpl value,\n          $Res Function(_$HomeSectionConfigImpl) then) =\n      __$$HomeSectionConfigImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? iconUrl,\n      int priority,\n      String minAppVersion});\n}\n\n/// @nodoc\nclass __$$HomeSectionConfigImplCopyWithImpl<$Res>\n    extends _$HomeSectionConfigCopyWithImpl<$Res, _$HomeSectionConfigImpl>\n    implements _$$HomeSectionConfigImplCopyWith<$Res> {\n  __$$HomeSectionConfigImplCopyWithImpl(_$HomeSectionConfigImpl _value,\n      $Res Function(_$HomeSectionConfigImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? iconUrl = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n  }) {\n    return _then(_$HomeSectionConfigImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      iconUrl: freezed == iconUrl\n          ? _value.iconUrl\n          : iconUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$HomeSectionConfigImpl implements _HomeSectionConfig {\n  const _$HomeSectionConfigImpl(\n      {required this.id,\n      required this.title,\n      required this.queryFilter,\n      this.iconUrl,\n      required this.priority,\n      required this.minAppVersion});\n\n  factory _$HomeSectionConfigImpl.fromJson(Map<String, dynamic> json) =>\n      _$$HomeSectionConfigImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String title;\n  @override\n  final String queryFilter;\n  @override\n  final String? iconUrl;\n  @override\n  final int priority;\n  @override\n  final String minAppVersion;\n\n  @override\n  String toString() {\n    return 'HomeSectionConfig(id: $id, title: $title, queryFilter: $queryFilter, iconUrl: $iconUrl, priority: $priority, minAppVersion: $minAppVersion)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$HomeSectionConfigImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.title, title) || other.title == title) &&\n            (identical(other.queryFilter, queryFilter) ||\n                other.queryFilter == queryFilter) &&\n            (identical(other.iconUrl, iconUrl) || other.iconUrl == iconUrl) &&\n            (identical(other.priority, priority) ||\n                other.priority == priority) &&\n            (identical(other.minAppVersion, minAppVersion) ||\n                other.minAppVersion == minAppVersion));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, id, title, queryFilter, iconUrl, priority, minAppVersion);\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$HomeSectionConfigImplCopyWith<_$HomeSectionConfigImpl> get copyWith =>\n      __$$HomeSectionConfigImplCopyWithImpl<_$HomeSectionConfigImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$HomeSectionConfigImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _HomeSectionConfig implements HomeSectionConfig {\n  const factory _HomeSectionConfig(\n      {required final String id,\n      required final String title,\n      required final String queryFilter,\n      final String? iconUrl,\n      required final int priority,\n      required final String minAppVersion}) = _$HomeSectionConfigImpl;\n\n  factory _HomeSectionConfig.fromJson(Map<String, dynamic> json) =\n      _$HomeSectionConfigImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get title;\n  @override\n  String get queryFilter;\n  @override\n  String? get iconUrl;\n  @override\n  int get priority;\n  @override\n  String get minAppVersion;\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$HomeSectionConfigImplCopyWith<_$HomeSectionConfigImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 9286,
        "last_modified": "2025-04-16T13:25:26.4998818",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\home_section_config.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'home_section_config.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$HomeSectionConfigImpl _$$HomeSectionConfigImplFromJson(\n        Map<String, dynamic> json) =>\n    _$HomeSectionConfigImpl(\n      id: json['id'] as String,\n      title: json['title'] as String,\n      queryFilter: json['queryFilter'] as String,\n      iconUrl: json['iconUrl'] as String?,\n      priority: (json['priority'] as num).toInt(),\n      minAppVersion: json['minAppVersion'] as String,\n    );\n\nMap<String, dynamic> _$$HomeSectionConfigImplToJson(\n        _$HomeSectionConfigImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'title': instance.title,\n      'queryFilter': instance.queryFilter,\n      'iconUrl': instance.iconUrl,\n      'priority': instance.priority,\n      'minAppVersion': instance.minAppVersion,\n    };\n",
      "info": {
        "size": 1013,
        "last_modified": "2025-04-16T13:25:26.5064233",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\subcategory_section_config.dart",
      "content": "// lib/core/domain/models/config/subcategory_section_config.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'subcategory_section_config.freezed.dart';\r\npart 'subcategory_section_config.g.dart';\r\n\r\n@freezed\r\nclass SubcategorySectionConfig with _$SubcategorySectionConfig {\r\n  const factory SubcategorySectionConfig({\r\n    required String id,\r\n    required String title,\r\n    required String queryFilter,\r\n    String? subcategoryId,  // Nullable car peut être null pour config par défaut\r\n    required int priority,\r\n    required String minAppVersion,\r\n    @Default(false) bool isDefault,  // Nouveau champ avec valeur par défaut\r\n  }) = _SubcategorySectionConfig;\r\n\r\n  factory SubcategorySectionConfig.fromJson(Map<String, dynamic> json) =>\r\n      _$SubcategorySectionConfigFromJson(json);\r\n}",
      "info": {
        "size": 823,
        "last_modified": "2025-04-16T13:25:26.5129588",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\subcategory_section_config.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'subcategory_section_config.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nSubcategorySectionConfig _$SubcategorySectionConfigFromJson(\n    Map<String, dynamic> json) {\n  return _SubcategorySectionConfig.fromJson(json);\n}\n\n/// @nodoc\nmixin _$SubcategorySectionConfig {\n  String get id => throw _privateConstructorUsedError;\n  String get title => throw _privateConstructorUsedError;\n  String get queryFilter => throw _privateConstructorUsedError;\n  String? get subcategoryId =>\n      throw _privateConstructorUsedError; // Nullable car peut être null pour config par défaut\n  int get priority => throw _privateConstructorUsedError;\n  String get minAppVersion => throw _privateConstructorUsedError;\n  bool get isDefault => throw _privateConstructorUsedError;\n\n  /// Serializes this SubcategorySectionConfig to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $SubcategorySectionConfigCopyWith<SubcategorySectionConfig> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $SubcategorySectionConfigCopyWith<$Res> {\n  factory $SubcategorySectionConfigCopyWith(SubcategorySectionConfig value,\n          $Res Function(SubcategorySectionConfig) then) =\n      _$SubcategorySectionConfigCopyWithImpl<$Res, SubcategorySectionConfig>;\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? subcategoryId,\n      int priority,\n      String minAppVersion,\n      bool isDefault});\n}\n\n/// @nodoc\nclass _$SubcategorySectionConfigCopyWithImpl<$Res,\n        $Val extends SubcategorySectionConfig>\n    implements $SubcategorySectionConfigCopyWith<$Res> {\n  _$SubcategorySectionConfigCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? subcategoryId = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n    Object? isDefault = null,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n      isDefault: null == isDefault\n          ? _value.isDefault\n          : isDefault // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$SubcategorySectionConfigImplCopyWith<$Res>\n    implements $SubcategorySectionConfigCopyWith<$Res> {\n  factory _$$SubcategorySectionConfigImplCopyWith(\n          _$SubcategorySectionConfigImpl value,\n          $Res Function(_$SubcategorySectionConfigImpl) then) =\n      __$$SubcategorySectionConfigImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? subcategoryId,\n      int priority,\n      String minAppVersion,\n      bool isDefault});\n}\n\n/// @nodoc\nclass __$$SubcategorySectionConfigImplCopyWithImpl<$Res>\n    extends _$SubcategorySectionConfigCopyWithImpl<$Res,\n        _$SubcategorySectionConfigImpl>\n    implements _$$SubcategorySectionConfigImplCopyWith<$Res> {\n  __$$SubcategorySectionConfigImplCopyWithImpl(\n      _$SubcategorySectionConfigImpl _value,\n      $Res Function(_$SubcategorySectionConfigImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? subcategoryId = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n    Object? isDefault = null,\n  }) {\n    return _then(_$SubcategorySectionConfigImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n      isDefault: null == isDefault\n          ? _value.isDefault\n          : isDefault // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$SubcategorySectionConfigImpl implements _SubcategorySectionConfig {\n  const _$SubcategorySectionConfigImpl(\n      {required this.id,\n      required this.title,\n      required this.queryFilter,\n      this.subcategoryId,\n      required this.priority,\n      required this.minAppVersion,\n      this.isDefault = false});\n\n  factory _$SubcategorySectionConfigImpl.fromJson(Map<String, dynamic> json) =>\n      _$$SubcategorySectionConfigImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String title;\n  @override\n  final String queryFilter;\n  @override\n  final String? subcategoryId;\n// Nullable car peut être null pour config par défaut\n  @override\n  final int priority;\n  @override\n  final String minAppVersion;\n  @override\n  @JsonKey()\n  final bool isDefault;\n\n  @override\n  String toString() {\n    return 'SubcategorySectionConfig(id: $id, title: $title, queryFilter: $queryFilter, subcategoryId: $subcategoryId, priority: $priority, minAppVersion: $minAppVersion, isDefault: $isDefault)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SubcategorySectionConfigImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.title, title) || other.title == title) &&\n            (identical(other.queryFilter, queryFilter) ||\n                other.queryFilter == queryFilter) &&\n            (identical(other.subcategoryId, subcategoryId) ||\n                other.subcategoryId == subcategoryId) &&\n            (identical(other.priority, priority) ||\n                other.priority == priority) &&\n            (identical(other.minAppVersion, minAppVersion) ||\n                other.minAppVersion == minAppVersion) &&\n            (identical(other.isDefault, isDefault) ||\n                other.isDefault == isDefault));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, id, title, queryFilter,\n      subcategoryId, priority, minAppVersion, isDefault);\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SubcategorySectionConfigImplCopyWith<_$SubcategorySectionConfigImpl>\n      get copyWith => __$$SubcategorySectionConfigImplCopyWithImpl<\n          _$SubcategorySectionConfigImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$SubcategorySectionConfigImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _SubcategorySectionConfig implements SubcategorySectionConfig {\n  const factory _SubcategorySectionConfig(\n      {required final String id,\n      required final String title,\n      required final String queryFilter,\n      final String? subcategoryId,\n      required final int priority,\n      required final String minAppVersion,\n      final bool isDefault}) = _$SubcategorySectionConfigImpl;\n\n  factory _SubcategorySectionConfig.fromJson(Map<String, dynamic> json) =\n      _$SubcategorySectionConfigImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get title;\n  @override\n  String get queryFilter;\n  @override\n  String?\n      get subcategoryId; // Nullable car peut être null pour config par défaut\n  @override\n  int get priority;\n  @override\n  String get minAppVersion;\n  @override\n  bool get isDefault;\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SubcategorySectionConfigImplCopyWith<_$SubcategorySectionConfigImpl>\n      get copyWith => throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 10804,
        "last_modified": "2025-04-16T13:25:26.5199506",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\subcategory_section_config.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'subcategory_section_config.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$SubcategorySectionConfigImpl _$$SubcategorySectionConfigImplFromJson(\n        Map<String, dynamic> json) =>\n    _$SubcategorySectionConfigImpl(\n      id: json['id'] as String,\n      title: json['title'] as String,\n      queryFilter: json['queryFilter'] as String,\n      subcategoryId: json['subcategoryId'] as String?,\n      priority: (json['priority'] as num).toInt(),\n      minAppVersion: json['minAppVersion'] as String,\n      isDefault: json['isDefault'] as bool? ?? false,\n    );\n\nMap<String, dynamic> _$$SubcategorySectionConfigImplToJson(\n        _$SubcategorySectionConfigImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'title': instance.title,\n      'queryFilter': instance.queryFilter,\n      'subcategoryId': instance.subcategoryId,\n      'priority': instance.priority,\n      'minAppVersion': instance.minAppVersion,\n      'isDefault': instance.isDefault,\n    };\n",
      "info": {
        "size": 1172,
        "last_modified": "2025-04-16T13:25:26.5260721",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_details.dart",
      "content": "// lib/core/domain/models/location/place_details.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport 'user_location.dart';\r\n\r\npart 'place_details.freezed.dart';\r\npart 'place_details.g.dart';\r\n\r\n@freezed\r\nclass PlaceDetails with _$PlaceDetails {\r\n  const factory PlaceDetails({\r\n    required String placeId,\r\n    required String formattedAddress,\r\n    required String name,\r\n    required UserLocation location,\r\n    String? country,\r\n    String? administrativeArea,\r\n    String? locality,\r\n    String? postalCode,\r\n    DateTime? lastUpdated,\r\n  }) = _PlaceDetails;\r\n\r\n  factory PlaceDetails.fromJson(Map<String, dynamic> json) =>\r\n      _$PlaceDetailsFromJson(json);\r\n}",
      "info": {
        "size": 693,
        "last_modified": "2025-04-16T13:25:26.5397168",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_details.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_details.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nPlaceDetails _$PlaceDetailsFromJson(Map<String, dynamic> json) {\n  return _PlaceDetails.fromJson(json);\n}\n\n/// @nodoc\nmixin _$PlaceDetails {\n  String get placeId => throw _privateConstructorUsedError;\n  String get formattedAddress => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  UserLocation get location => throw _privateConstructorUsedError;\n  String? get country => throw _privateConstructorUsedError;\n  String? get administrativeArea => throw _privateConstructorUsedError;\n  String? get locality => throw _privateConstructorUsedError;\n  String? get postalCode => throw _privateConstructorUsedError;\n  DateTime? get lastUpdated => throw _privateConstructorUsedError;\n\n  /// Serializes this PlaceDetails to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $PlaceDetailsCopyWith<PlaceDetails> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceDetailsCopyWith<$Res> {\n  factory $PlaceDetailsCopyWith(\n          PlaceDetails value, $Res Function(PlaceDetails) then) =\n      _$PlaceDetailsCopyWithImpl<$Res, PlaceDetails>;\n  @useResult\n  $Res call(\n      {String placeId,\n      String formattedAddress,\n      String name,\n      UserLocation location,\n      String? country,\n      String? administrativeArea,\n      String? locality,\n      String? postalCode,\n      DateTime? lastUpdated});\n\n  $UserLocationCopyWith<$Res> get location;\n}\n\n/// @nodoc\nclass _$PlaceDetailsCopyWithImpl<$Res, $Val extends PlaceDetails>\n    implements $PlaceDetailsCopyWith<$Res> {\n  _$PlaceDetailsCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? formattedAddress = null,\n    Object? name = null,\n    Object? location = null,\n    Object? country = freezed,\n    Object? administrativeArea = freezed,\n    Object? locality = freezed,\n    Object? postalCode = freezed,\n    Object? lastUpdated = freezed,\n  }) {\n    return _then(_value.copyWith(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      formattedAddress: null == formattedAddress\n          ? _value.formattedAddress\n          : formattedAddress // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      location: null == location\n          ? _value.location\n          : location // ignore: cast_nullable_to_non_nullable\n              as UserLocation,\n      country: freezed == country\n          ? _value.country\n          : country // ignore: cast_nullable_to_non_nullable\n              as String?,\n      administrativeArea: freezed == administrativeArea\n          ? _value.administrativeArea\n          : administrativeArea // ignore: cast_nullable_to_non_nullable\n              as String?,\n      locality: freezed == locality\n          ? _value.locality\n          : locality // ignore: cast_nullable_to_non_nullable\n              as String?,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      lastUpdated: freezed == lastUpdated\n          ? _value.lastUpdated\n          : lastUpdated // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ) as $Val);\n  }\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $UserLocationCopyWith<$Res> get location {\n    return $UserLocationCopyWith<$Res>(_value.location, (value) {\n      return _then(_value.copyWith(location: value) as $Val);\n    });\n  }\n}\n\n/// @nodoc\nabstract class _$$PlaceDetailsImplCopyWith<$Res>\n    implements $PlaceDetailsCopyWith<$Res> {\n  factory _$$PlaceDetailsImplCopyWith(\n          _$PlaceDetailsImpl value, $Res Function(_$PlaceDetailsImpl) then) =\n      __$$PlaceDetailsImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String placeId,\n      String formattedAddress,\n      String name,\n      UserLocation location,\n      String? country,\n      String? administrativeArea,\n      String? locality,\n      String? postalCode,\n      DateTime? lastUpdated});\n\n  @override\n  $UserLocationCopyWith<$Res> get location;\n}\n\n/// @nodoc\nclass __$$PlaceDetailsImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsCopyWithImpl<$Res, _$PlaceDetailsImpl>\n    implements _$$PlaceDetailsImplCopyWith<$Res> {\n  __$$PlaceDetailsImplCopyWithImpl(\n      _$PlaceDetailsImpl _value, $Res Function(_$PlaceDetailsImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? formattedAddress = null,\n    Object? name = null,\n    Object? location = null,\n    Object? country = freezed,\n    Object? administrativeArea = freezed,\n    Object? locality = freezed,\n    Object? postalCode = freezed,\n    Object? lastUpdated = freezed,\n  }) {\n    return _then(_$PlaceDetailsImpl(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      formattedAddress: null == formattedAddress\n          ? _value.formattedAddress\n          : formattedAddress // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      location: null == location\n          ? _value.location\n          : location // ignore: cast_nullable_to_non_nullable\n              as UserLocation,\n      country: freezed == country\n          ? _value.country\n          : country // ignore: cast_nullable_to_non_nullable\n              as String?,\n      administrativeArea: freezed == administrativeArea\n          ? _value.administrativeArea\n          : administrativeArea // ignore: cast_nullable_to_non_nullable\n              as String?,\n      locality: freezed == locality\n          ? _value.locality\n          : locality // ignore: cast_nullable_to_non_nullable\n              as String?,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      lastUpdated: freezed == lastUpdated\n          ? _value.lastUpdated\n          : lastUpdated // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$PlaceDetailsImpl implements _PlaceDetails {\n  const _$PlaceDetailsImpl(\n      {required this.placeId,\n      required this.formattedAddress,\n      required this.name,\n      required this.location,\n      this.country,\n      this.administrativeArea,\n      this.locality,\n      this.postalCode,\n      this.lastUpdated});\n\n  factory _$PlaceDetailsImpl.fromJson(Map<String, dynamic> json) =>\n      _$$PlaceDetailsImplFromJson(json);\n\n  @override\n  final String placeId;\n  @override\n  final String formattedAddress;\n  @override\n  final String name;\n  @override\n  final UserLocation location;\n  @override\n  final String? country;\n  @override\n  final String? administrativeArea;\n  @override\n  final String? locality;\n  @override\n  final String? postalCode;\n  @override\n  final DateTime? lastUpdated;\n\n  @override\n  String toString() {\n    return 'PlaceDetails(placeId: $placeId, formattedAddress: $formattedAddress, name: $name, location: $location, country: $country, administrativeArea: $administrativeArea, locality: $locality, postalCode: $postalCode, lastUpdated: $lastUpdated)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$PlaceDetailsImpl &&\n            (identical(other.placeId, placeId) || other.placeId == placeId) &&\n            (identical(other.formattedAddress, formattedAddress) ||\n                other.formattedAddress == formattedAddress) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.location, location) ||\n                other.location == location) &&\n            (identical(other.country, country) || other.country == country) &&\n            (identical(other.administrativeArea, administrativeArea) ||\n                other.administrativeArea == administrativeArea) &&\n            (identical(other.locality, locality) ||\n                other.locality == locality) &&\n            (identical(other.postalCode, postalCode) ||\n                other.postalCode == postalCode) &&\n            (identical(other.lastUpdated, lastUpdated) ||\n                other.lastUpdated == lastUpdated));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, placeId, formattedAddress, name,\n      location, country, administrativeArea, locality, postalCode, lastUpdated);\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$PlaceDetailsImplCopyWith<_$PlaceDetailsImpl> get copyWith =>\n      __$$PlaceDetailsImplCopyWithImpl<_$PlaceDetailsImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$PlaceDetailsImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _PlaceDetails implements PlaceDetails {\n  const factory _PlaceDetails(\n      {required final String placeId,\n      required final String formattedAddress,\n      required final String name,\n      required final UserLocation location,\n      final String? country,\n      final String? administrativeArea,\n      final String? locality,\n      final String? postalCode,\n      final DateTime? lastUpdated}) = _$PlaceDetailsImpl;\n\n  factory _PlaceDetails.fromJson(Map<String, dynamic> json) =\n      _$PlaceDetailsImpl.fromJson;\n\n  @override\n  String get placeId;\n  @override\n  String get formattedAddress;\n  @override\n  String get name;\n  @override\n  UserLocation get location;\n  @override\n  String? get country;\n  @override\n  String? get administrativeArea;\n  @override\n  String? get locality;\n  @override\n  String? get postalCode;\n  @override\n  DateTime? get lastUpdated;\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$PlaceDetailsImplCopyWith<_$PlaceDetailsImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 12172,
        "last_modified": "2025-04-16T13:25:26.5462389",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_details.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'place_details.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$PlaceDetailsImpl _$$PlaceDetailsImplFromJson(Map<String, dynamic> json) =>\n    _$PlaceDetailsImpl(\n      placeId: json['placeId'] as String,\n      formattedAddress: json['formattedAddress'] as String,\n      name: json['name'] as String,\n      location: UserLocation.fromJson(json['location'] as Map<String, dynamic>),\n      country: json['country'] as String?,\n      administrativeArea: json['administrativeArea'] as String?,\n      locality: json['locality'] as String?,\n      postalCode: json['postalCode'] as String?,\n      lastUpdated: json['lastUpdated'] == null\n          ? null\n          : DateTime.parse(json['lastUpdated'] as String),\n    );\n\nMap<String, dynamic> _$$PlaceDetailsImplToJson(_$PlaceDetailsImpl instance) =>\n    <String, dynamic>{\n      'placeId': instance.placeId,\n      'formattedAddress': instance.formattedAddress,\n      'name': instance.name,\n      'location': instance.location,\n      'country': instance.country,\n      'administrativeArea': instance.administrativeArea,\n      'locality': instance.locality,\n      'postalCode': instance.postalCode,\n      'lastUpdated': instance.lastUpdated?.toIso8601String(),\n    };\n",
      "info": {
        "size": 1408,
        "last_modified": "2025-04-16T13:25:26.5522903",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_suggestion.dart",
      "content": "// lib/core/domain/models/location/place_suggestion.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'place_suggestion.freezed.dart';\r\npart 'place_suggestion.g.dart';\r\n\r\n@freezed\r\nclass PlaceSuggestion with _$PlaceSuggestion {\r\n  const factory PlaceSuggestion({\r\n    required String placeId,\r\n    required String primaryText,\r\n    String? secondaryText,\r\n    @Default(false) bool isFromCache,\r\n  }) = _PlaceSuggestion;\r\n\r\n  factory PlaceSuggestion.fromJson(Map<String, dynamic> json) =>\r\n      _$PlaceSuggestionFromJson(json);\r\n}",
      "info": {
        "size": 557,
        "last_modified": "2025-04-16T13:25:26.5603338",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_suggestion.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_suggestion.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nPlaceSuggestion _$PlaceSuggestionFromJson(Map<String, dynamic> json) {\n  return _PlaceSuggestion.fromJson(json);\n}\n\n/// @nodoc\nmixin _$PlaceSuggestion {\n  String get placeId => throw _privateConstructorUsedError;\n  String get primaryText => throw _privateConstructorUsedError;\n  String? get secondaryText => throw _privateConstructorUsedError;\n  bool get isFromCache => throw _privateConstructorUsedError;\n\n  /// Serializes this PlaceSuggestion to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $PlaceSuggestionCopyWith<PlaceSuggestion> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceSuggestionCopyWith<$Res> {\n  factory $PlaceSuggestionCopyWith(\n          PlaceSuggestion value, $Res Function(PlaceSuggestion) then) =\n      _$PlaceSuggestionCopyWithImpl<$Res, PlaceSuggestion>;\n  @useResult\n  $Res call(\n      {String placeId,\n      String primaryText,\n      String? secondaryText,\n      bool isFromCache});\n}\n\n/// @nodoc\nclass _$PlaceSuggestionCopyWithImpl<$Res, $Val extends PlaceSuggestion>\n    implements $PlaceSuggestionCopyWith<$Res> {\n  _$PlaceSuggestionCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? primaryText = null,\n    Object? secondaryText = freezed,\n    Object? isFromCache = null,\n  }) {\n    return _then(_value.copyWith(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      primaryText: null == primaryText\n          ? _value.primaryText\n          : primaryText // ignore: cast_nullable_to_non_nullable\n              as String,\n      secondaryText: freezed == secondaryText\n          ? _value.secondaryText\n          : secondaryText // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isFromCache: null == isFromCache\n          ? _value.isFromCache\n          : isFromCache // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$PlaceSuggestionImplCopyWith<$Res>\n    implements $PlaceSuggestionCopyWith<$Res> {\n  factory _$$PlaceSuggestionImplCopyWith(_$PlaceSuggestionImpl value,\n          $Res Function(_$PlaceSuggestionImpl) then) =\n      __$$PlaceSuggestionImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String placeId,\n      String primaryText,\n      String? secondaryText,\n      bool isFromCache});\n}\n\n/// @nodoc\nclass __$$PlaceSuggestionImplCopyWithImpl<$Res>\n    extends _$PlaceSuggestionCopyWithImpl<$Res, _$PlaceSuggestionImpl>\n    implements _$$PlaceSuggestionImplCopyWith<$Res> {\n  __$$PlaceSuggestionImplCopyWithImpl(\n      _$PlaceSuggestionImpl _value, $Res Function(_$PlaceSuggestionImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? primaryText = null,\n    Object? secondaryText = freezed,\n    Object? isFromCache = null,\n  }) {\n    return _then(_$PlaceSuggestionImpl(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      primaryText: null == primaryText\n          ? _value.primaryText\n          : primaryText // ignore: cast_nullable_to_non_nullable\n              as String,\n      secondaryText: freezed == secondaryText\n          ? _value.secondaryText\n          : secondaryText // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isFromCache: null == isFromCache\n          ? _value.isFromCache\n          : isFromCache // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$PlaceSuggestionImpl implements _PlaceSuggestion {\n  const _$PlaceSuggestionImpl(\n      {required this.placeId,\n      required this.primaryText,\n      this.secondaryText,\n      this.isFromCache = false});\n\n  factory _$PlaceSuggestionImpl.fromJson(Map<String, dynamic> json) =>\n      _$$PlaceSuggestionImplFromJson(json);\n\n  @override\n  final String placeId;\n  @override\n  final String primaryText;\n  @override\n  final String? secondaryText;\n  @override\n  @JsonKey()\n  final bool isFromCache;\n\n  @override\n  String toString() {\n    return 'PlaceSuggestion(placeId: $placeId, primaryText: $primaryText, secondaryText: $secondaryText, isFromCache: $isFromCache)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$PlaceSuggestionImpl &&\n            (identical(other.placeId, placeId) || other.placeId == placeId) &&\n            (identical(other.primaryText, primaryText) ||\n                other.primaryText == primaryText) &&\n            (identical(other.secondaryText, secondaryText) ||\n                other.secondaryText == secondaryText) &&\n            (identical(other.isFromCache, isFromCache) ||\n                other.isFromCache == isFromCache));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, placeId, primaryText, secondaryText, isFromCache);\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$PlaceSuggestionImplCopyWith<_$PlaceSuggestionImpl> get copyWith =>\n      __$$PlaceSuggestionImplCopyWithImpl<_$PlaceSuggestionImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$PlaceSuggestionImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _PlaceSuggestion implements PlaceSuggestion {\n  const factory _PlaceSuggestion(\n      {required final String placeId,\n      required final String primaryText,\n      final String? secondaryText,\n      final bool isFromCache}) = _$PlaceSuggestionImpl;\n\n  factory _PlaceSuggestion.fromJson(Map<String, dynamic> json) =\n      _$PlaceSuggestionImpl.fromJson;\n\n  @override\n  String get placeId;\n  @override\n  String get primaryText;\n  @override\n  String? get secondaryText;\n  @override\n  bool get isFromCache;\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$PlaceSuggestionImplCopyWith<_$PlaceSuggestionImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 8041,
        "last_modified": "2025-04-16T13:25:26.5659497",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_suggestion.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'place_suggestion.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$PlaceSuggestionImpl _$$PlaceSuggestionImplFromJson(\n        Map<String, dynamic> json) =>\n    _$PlaceSuggestionImpl(\n      placeId: json['placeId'] as String,\n      primaryText: json['primaryText'] as String,\n      secondaryText: json['secondaryText'] as String?,\n      isFromCache: json['isFromCache'] as bool? ?? false,\n    );\n\nMap<String, dynamic> _$$PlaceSuggestionImplToJson(\n        _$PlaceSuggestionImpl instance) =>\n    <String, dynamic>{\n      'placeId': instance.placeId,\n      'primaryText': instance.primaryText,\n      'secondaryText': instance.secondaryText,\n      'isFromCache': instance.isFromCache,\n    };\n",
      "info": {
        "size": 887,
        "last_modified": "2025-04-16T13:25:26.5732041",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\user_location.dart",
      "content": "// lib/core/domain/models/location/user_location.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'user_location.freezed.dart';\r\npart 'user_location.g.dart';\r\n\r\n@freezed\r\nclass UserLocation with _$UserLocation {\r\n  const factory UserLocation({\r\n    required double latitude,\r\n    required double longitude,\r\n    double? accuracy,\r\n    @Default(false) bool isFromGps,\r\n    DateTime? timestamp,\r\n  }) = _UserLocation;\r\n\r\n  factory UserLocation.fromJson(Map<String, dynamic> json) =>\r\n      _$UserLocationFromJson(json);\r\n}",
      "info": {
        "size": 548,
        "last_modified": "2025-04-16T13:25:26.5792556",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\user_location.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'user_location.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nUserLocation _$UserLocationFromJson(Map<String, dynamic> json) {\n  return _UserLocation.fromJson(json);\n}\n\n/// @nodoc\nmixin _$UserLocation {\n  double get latitude => throw _privateConstructorUsedError;\n  double get longitude => throw _privateConstructorUsedError;\n  double? get accuracy => throw _privateConstructorUsedError;\n  bool get isFromGps => throw _privateConstructorUsedError;\n  DateTime? get timestamp => throw _privateConstructorUsedError;\n\n  /// Serializes this UserLocation to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $UserLocationCopyWith<UserLocation> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $UserLocationCopyWith<$Res> {\n  factory $UserLocationCopyWith(\n          UserLocation value, $Res Function(UserLocation) then) =\n      _$UserLocationCopyWithImpl<$Res, UserLocation>;\n  @useResult\n  $Res call(\n      {double latitude,\n      double longitude,\n      double? accuracy,\n      bool isFromGps,\n      DateTime? timestamp});\n}\n\n/// @nodoc\nclass _$UserLocationCopyWithImpl<$Res, $Val extends UserLocation>\n    implements $UserLocationCopyWith<$Res> {\n  _$UserLocationCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? accuracy = freezed,\n    Object? isFromGps = null,\n    Object? timestamp = freezed,\n  }) {\n    return _then(_value.copyWith(\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      accuracy: freezed == accuracy\n          ? _value.accuracy\n          : accuracy // ignore: cast_nullable_to_non_nullable\n              as double?,\n      isFromGps: null == isFromGps\n          ? _value.isFromGps\n          : isFromGps // ignore: cast_nullable_to_non_nullable\n              as bool,\n      timestamp: freezed == timestamp\n          ? _value.timestamp\n          : timestamp // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$UserLocationImplCopyWith<$Res>\n    implements $UserLocationCopyWith<$Res> {\n  factory _$$UserLocationImplCopyWith(\n          _$UserLocationImpl value, $Res Function(_$UserLocationImpl) then) =\n      __$$UserLocationImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {double latitude,\n      double longitude,\n      double? accuracy,\n      bool isFromGps,\n      DateTime? timestamp});\n}\n\n/// @nodoc\nclass __$$UserLocationImplCopyWithImpl<$Res>\n    extends _$UserLocationCopyWithImpl<$Res, _$UserLocationImpl>\n    implements _$$UserLocationImplCopyWith<$Res> {\n  __$$UserLocationImplCopyWithImpl(\n      _$UserLocationImpl _value, $Res Function(_$UserLocationImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? accuracy = freezed,\n    Object? isFromGps = null,\n    Object? timestamp = freezed,\n  }) {\n    return _then(_$UserLocationImpl(\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      accuracy: freezed == accuracy\n          ? _value.accuracy\n          : accuracy // ignore: cast_nullable_to_non_nullable\n              as double?,\n      isFromGps: null == isFromGps\n          ? _value.isFromGps\n          : isFromGps // ignore: cast_nullable_to_non_nullable\n              as bool,\n      timestamp: freezed == timestamp\n          ? _value.timestamp\n          : timestamp // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$UserLocationImpl implements _UserLocation {\n  const _$UserLocationImpl(\n      {required this.latitude,\n      required this.longitude,\n      this.accuracy,\n      this.isFromGps = false,\n      this.timestamp});\n\n  factory _$UserLocationImpl.fromJson(Map<String, dynamic> json) =>\n      _$$UserLocationImplFromJson(json);\n\n  @override\n  final double latitude;\n  @override\n  final double longitude;\n  @override\n  final double? accuracy;\n  @override\n  @JsonKey()\n  final bool isFromGps;\n  @override\n  final DateTime? timestamp;\n\n  @override\n  String toString() {\n    return 'UserLocation(latitude: $latitude, longitude: $longitude, accuracy: $accuracy, isFromGps: $isFromGps, timestamp: $timestamp)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$UserLocationImpl &&\n            (identical(other.latitude, latitude) ||\n                other.latitude == latitude) &&\n            (identical(other.longitude, longitude) ||\n                other.longitude == longitude) &&\n            (identical(other.accuracy, accuracy) ||\n                other.accuracy == accuracy) &&\n            (identical(other.isFromGps, isFromGps) ||\n                other.isFromGps == isFromGps) &&\n            (identical(other.timestamp, timestamp) ||\n                other.timestamp == timestamp));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, latitude, longitude, accuracy, isFromGps, timestamp);\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$UserLocationImplCopyWith<_$UserLocationImpl> get copyWith =>\n      __$$UserLocationImplCopyWithImpl<_$UserLocationImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$UserLocationImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _UserLocation implements UserLocation {\n  const factory _UserLocation(\n      {required final double latitude,\n      required final double longitude,\n      final double? accuracy,\n      final bool isFromGps,\n      final DateTime? timestamp}) = _$UserLocationImpl;\n\n  factory _UserLocation.fromJson(Map<String, dynamic> json) =\n      _$UserLocationImpl.fromJson;\n\n  @override\n  double get latitude;\n  @override\n  double get longitude;\n  @override\n  double? get accuracy;\n  @override\n  bool get isFromGps;\n  @override\n  DateTime? get timestamp;\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$UserLocationImplCopyWith<_$UserLocationImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 8457,
        "last_modified": "2025-04-16T13:25:26.5863596",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\user_location.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'user_location.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$UserLocationImpl _$$UserLocationImplFromJson(Map<String, dynamic> json) =>\n    _$UserLocationImpl(\n      latitude: (json['latitude'] as num).toDouble(),\n      longitude: (json['longitude'] as num).toDouble(),\n      accuracy: (json['accuracy'] as num?)?.toDouble(),\n      isFromGps: json['isFromGps'] as bool? ?? false,\n      timestamp: json['timestamp'] == null\n          ? null\n          : DateTime.parse(json['timestamp'] as String),\n    );\n\nMap<String, dynamic> _$$UserLocationImplToJson(_$UserLocationImpl instance) =>\n    <String, dynamic>{\n      'latitude': instance.latitude,\n      'longitude': instance.longitude,\n      'accuracy': instance.accuracy,\n      'isFromGps': instance.isFromGps,\n      'timestamp': instance.timestamp?.toIso8601String(),\n    };\n",
      "info": {
        "size": 1025,
        "last_modified": "2025-04-16T13:25:26.5928727",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\opening_days.dart",
      "content": "// core/domain/models/opening_days.dart\r\n\r\nclass OpeningDays {\r\n  final Map<String, Map<String, String>> availableDays;\r\n  final Map<String, String>? allDaysHours;  // Nouveau champ pour \"all\"\r\n\r\n  OpeningDays({\r\n    required this.availableDays,\r\n    this.allDaysHours,\r\n  });\r\n\r\n  factory OpeningDays.fromActivityHours(Map<String, dynamic> json) {\r\n    // Si nous avons des horaires pour tous les jours\r\n    if (json['day_of_week']['all'] != null) {\r\n      return OpeningDays(\r\n        availableDays: {},\r\n        allDaysHours: Map<String, String>.from(json['day_of_week']['all']),\r\n      );\r\n    }\r\n\r\n    // Sinon, on traite les jours spécifiques\r\n    return OpeningDays(\r\n      availableDays: {}, // à remplir avec les jours spécifiques si nécessaire\r\n      allDaysHours: null,\r\n    );\r\n  }\r\n\r\n  bool get hasOpenDays => allDaysHours != null || availableDays.isNotEmpty;\r\n\r\n  Map<String, String>? getHoursForDay(String date) {\r\n    return allDaysHours ?? availableDays[date];\r\n  }\r\n}",
      "info": {
        "size": 989,
        "last_modified": "2025-04-16T13:25:26.6052047",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\scored_activity.dart",
      "content": "// lib/core/domain/models/scored_activity.dart\r\n\r\nclass ScoredActivity {\r\n  final String id;\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperwow;\r\n  final Map<String, dynamic> activityData;  // Données brutes de l'activité\r\n\r\n  const ScoredActivity({\r\n    required this.id,\r\n    required this.totalScore,\r\n    required this.subcategoryScore,\r\n    required this.isSuperwow,\r\n    required this.activityData,\r\n  });\r\n\r\n  /// Crée une instance depuis les données JSON de Supabase\r\n  factory ScoredActivity.fromJson(Map<String, dynamic> json) {\r\n    return ScoredActivity(\r\n      id: json['id'],\r\n      totalScore: json['total_score']?.toDouble() ?? 0.0,\r\n      subcategoryScore: json['subcategory_score']?.toDouble() ?? 0.0,\r\n      isSuperwow: json['is_superwow'] ?? false,\r\n      activityData: json,\r\n    );\r\n  }\r\n\r\n  /// Convertit l'instance en Map pour Supabase\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_superwow': isSuperwow,\r\n      ...activityData,  // Inclut toutes les données de l'activité\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 1165,
        "last_modified": "2025-04-16T13:25:26.611339",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_details_model.dart",
      "content": "// core/domain/models/shared/activity_details_model.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../activity/base/activity_base.dart';\r\nimport 'activity_image_model.dart';\r\n\r\npart 'activity_details_model.freezed.dart';\r\npart 'activity_details_model.g.dart';\r\n\r\n@freezed\r\nclass ActivityDetails with _$ActivityDetails {\r\n  const factory ActivityDetails({\r\n    required String id,\r\n    required String name,\r\n    String? description,\r\n    required double latitude,\r\n    required double longitude,\r\n    required String categoryId,\r\n    String? postalCode,\r\n    String? address,\r\n    String? city,\r\n    String? googlePlaceId,\r\n    Map<String, dynamic>? currentOpeningHours,\r\n    String? contactPhone,\r\n    String? contactEmail,\r\n    String? contactWebsite,\r\n    bool? bookingRequired,\r\n    bool? kidFriendly,\r\n    String? wheelchairAccessible,\r\n    int? minDurationMinutes,\r\n    int? maxDurationMinutes,\r\n    int? priceLevel,\r\n    double? basePrice,\r\n    List<ActivityImage>? images,\r\n  }) = _ActivityDetails;\r\n\r\n  factory ActivityDetails.fromJson(Map<String, dynamic> json) =>\r\n      _$ActivityDetailsFromJson(json);\r\n\r\n  factory ActivityDetails.fromActivityBase(ActivityBase base) {\r\n    return ActivityDetails(\r\n      id: base.id,\r\n      name: base.name,\r\n      description: base.description,\r\n      latitude: base.latitude,\r\n      longitude: base.longitude,\r\n      categoryId: base.categoryId,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1441,
        "last_modified": "2025-04-16T13:25:26.6183424",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_details_model.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_details_model.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nActivityDetails _$ActivityDetailsFromJson(Map<String, dynamic> json) {\n  return _ActivityDetails.fromJson(json);\n}\n\n/// @nodoc\nmixin _$ActivityDetails {\n  String get id => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  String? get description => throw _privateConstructorUsedError;\n  double get latitude => throw _privateConstructorUsedError;\n  double get longitude => throw _privateConstructorUsedError;\n  String get categoryId => throw _privateConstructorUsedError;\n  String? get postalCode => throw _privateConstructorUsedError;\n  String? get address => throw _privateConstructorUsedError;\n  String? get city => throw _privateConstructorUsedError;\n  String? get googlePlaceId => throw _privateConstructorUsedError;\n  Map<String, dynamic>? get currentOpeningHours =>\n      throw _privateConstructorUsedError;\n  String? get contactPhone => throw _privateConstructorUsedError;\n  String? get contactEmail => throw _privateConstructorUsedError;\n  String? get contactWebsite => throw _privateConstructorUsedError;\n  bool? get bookingRequired => throw _privateConstructorUsedError;\n  bool? get kidFriendly => throw _privateConstructorUsedError;\n  String? get wheelchairAccessible => throw _privateConstructorUsedError;\n  int? get minDurationMinutes => throw _privateConstructorUsedError;\n  int? get maxDurationMinutes => throw _privateConstructorUsedError;\n  int? get priceLevel => throw _privateConstructorUsedError;\n  double? get basePrice => throw _privateConstructorUsedError;\n  List<ActivityImage>? get images => throw _privateConstructorUsedError;\n\n  /// Serializes this ActivityDetails to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $ActivityDetailsCopyWith<ActivityDetails> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityDetailsCopyWith<$Res> {\n  factory $ActivityDetailsCopyWith(\n          ActivityDetails value, $Res Function(ActivityDetails) then) =\n      _$ActivityDetailsCopyWithImpl<$Res, ActivityDetails>;\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? postalCode,\n      String? address,\n      String? city,\n      String? googlePlaceId,\n      Map<String, dynamic>? currentOpeningHours,\n      String? contactPhone,\n      String? contactEmail,\n      String? contactWebsite,\n      bool? bookingRequired,\n      bool? kidFriendly,\n      String? wheelchairAccessible,\n      int? minDurationMinutes,\n      int? maxDurationMinutes,\n      int? priceLevel,\n      double? basePrice,\n      List<ActivityImage>? images});\n}\n\n/// @nodoc\nclass _$ActivityDetailsCopyWithImpl<$Res, $Val extends ActivityDetails>\n    implements $ActivityDetailsCopyWith<$Res> {\n  _$ActivityDetailsCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? postalCode = freezed,\n    Object? address = freezed,\n    Object? city = freezed,\n    Object? googlePlaceId = freezed,\n    Object? currentOpeningHours = freezed,\n    Object? contactPhone = freezed,\n    Object? contactEmail = freezed,\n    Object? contactWebsite = freezed,\n    Object? bookingRequired = freezed,\n    Object? kidFriendly = freezed,\n    Object? wheelchairAccessible = freezed,\n    Object? minDurationMinutes = freezed,\n    Object? maxDurationMinutes = freezed,\n    Object? priceLevel = freezed,\n    Object? basePrice = freezed,\n    Object? images = freezed,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      address: freezed == address\n          ? _value.address\n          : address // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      googlePlaceId: freezed == googlePlaceId\n          ? _value.googlePlaceId\n          : googlePlaceId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      currentOpeningHours: freezed == currentOpeningHours\n          ? _value.currentOpeningHours\n          : currentOpeningHours // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>?,\n      contactPhone: freezed == contactPhone\n          ? _value.contactPhone\n          : contactPhone // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactEmail: freezed == contactEmail\n          ? _value.contactEmail\n          : contactEmail // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactWebsite: freezed == contactWebsite\n          ? _value.contactWebsite\n          : contactWebsite // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: freezed == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      kidFriendly: freezed == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      minDurationMinutes: freezed == minDurationMinutes\n          ? _value.minDurationMinutes\n          : minDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      maxDurationMinutes: freezed == maxDurationMinutes\n          ? _value.maxDurationMinutes\n          : maxDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      priceLevel: freezed == priceLevel\n          ? _value.priceLevel\n          : priceLevel // ignore: cast_nullable_to_non_nullable\n              as int?,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      images: freezed == images\n          ? _value.images\n          : images // ignore: cast_nullable_to_non_nullable\n              as List<ActivityImage>?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$ActivityDetailsImplCopyWith<$Res>\n    implements $ActivityDetailsCopyWith<$Res> {\n  factory _$$ActivityDetailsImplCopyWith(_$ActivityDetailsImpl value,\n          $Res Function(_$ActivityDetailsImpl) then) =\n      __$$ActivityDetailsImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? postalCode,\n      String? address,\n      String? city,\n      String? googlePlaceId,\n      Map<String, dynamic>? currentOpeningHours,\n      String? contactPhone,\n      String? contactEmail,\n      String? contactWebsite,\n      bool? bookingRequired,\n      bool? kidFriendly,\n      String? wheelchairAccessible,\n      int? minDurationMinutes,\n      int? maxDurationMinutes,\n      int? priceLevel,\n      double? basePrice,\n      List<ActivityImage>? images});\n}\n\n/// @nodoc\nclass __$$ActivityDetailsImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsCopyWithImpl<$Res, _$ActivityDetailsImpl>\n    implements _$$ActivityDetailsImplCopyWith<$Res> {\n  __$$ActivityDetailsImplCopyWithImpl(\n      _$ActivityDetailsImpl _value, $Res Function(_$ActivityDetailsImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? postalCode = freezed,\n    Object? address = freezed,\n    Object? city = freezed,\n    Object? googlePlaceId = freezed,\n    Object? currentOpeningHours = freezed,\n    Object? contactPhone = freezed,\n    Object? contactEmail = freezed,\n    Object? contactWebsite = freezed,\n    Object? bookingRequired = freezed,\n    Object? kidFriendly = freezed,\n    Object? wheelchairAccessible = freezed,\n    Object? minDurationMinutes = freezed,\n    Object? maxDurationMinutes = freezed,\n    Object? priceLevel = freezed,\n    Object? basePrice = freezed,\n    Object? images = freezed,\n  }) {\n    return _then(_$ActivityDetailsImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      address: freezed == address\n          ? _value.address\n          : address // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      googlePlaceId: freezed == googlePlaceId\n          ? _value.googlePlaceId\n          : googlePlaceId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      currentOpeningHours: freezed == currentOpeningHours\n          ? _value._currentOpeningHours\n          : currentOpeningHours // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>?,\n      contactPhone: freezed == contactPhone\n          ? _value.contactPhone\n          : contactPhone // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactEmail: freezed == contactEmail\n          ? _value.contactEmail\n          : contactEmail // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactWebsite: freezed == contactWebsite\n          ? _value.contactWebsite\n          : contactWebsite // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: freezed == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      kidFriendly: freezed == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      minDurationMinutes: freezed == minDurationMinutes\n          ? _value.minDurationMinutes\n          : minDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      maxDurationMinutes: freezed == maxDurationMinutes\n          ? _value.maxDurationMinutes\n          : maxDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      priceLevel: freezed == priceLevel\n          ? _value.priceLevel\n          : priceLevel // ignore: cast_nullable_to_non_nullable\n              as int?,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      images: freezed == images\n          ? _value._images\n          : images // ignore: cast_nullable_to_non_nullable\n              as List<ActivityImage>?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$ActivityDetailsImpl implements _ActivityDetails {\n  const _$ActivityDetailsImpl(\n      {required this.id,\n      required this.name,\n      this.description,\n      required this.latitude,\n      required this.longitude,\n      required this.categoryId,\n      this.postalCode,\n      this.address,\n      this.city,\n      this.googlePlaceId,\n      final Map<String, dynamic>? currentOpeningHours,\n      this.contactPhone,\n      this.contactEmail,\n      this.contactWebsite,\n      this.bookingRequired,\n      this.kidFriendly,\n      this.wheelchairAccessible,\n      this.minDurationMinutes,\n      this.maxDurationMinutes,\n      this.priceLevel,\n      this.basePrice,\n      final List<ActivityImage>? images})\n      : _currentOpeningHours = currentOpeningHours,\n        _images = images;\n\n  factory _$ActivityDetailsImpl.fromJson(Map<String, dynamic> json) =>\n      _$$ActivityDetailsImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String name;\n  @override\n  final String? description;\n  @override\n  final double latitude;\n  @override\n  final double longitude;\n  @override\n  final String categoryId;\n  @override\n  final String? postalCode;\n  @override\n  final String? address;\n  @override\n  final String? city;\n  @override\n  final String? googlePlaceId;\n  final Map<String, dynamic>? _currentOpeningHours;\n  @override\n  Map<String, dynamic>? get currentOpeningHours {\n    final value = _currentOpeningHours;\n    if (value == null) return null;\n    if (_currentOpeningHours is EqualUnmodifiableMapView)\n      return _currentOpeningHours;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(value);\n  }\n\n  @override\n  final String? contactPhone;\n  @override\n  final String? contactEmail;\n  @override\n  final String? contactWebsite;\n  @override\n  final bool? bookingRequired;\n  @override\n  final bool? kidFriendly;\n  @override\n  final String? wheelchairAccessible;\n  @override\n  final int? minDurationMinutes;\n  @override\n  final int? maxDurationMinutes;\n  @override\n  final int? priceLevel;\n  @override\n  final double? basePrice;\n  final List<ActivityImage>? _images;\n  @override\n  List<ActivityImage>? get images {\n    final value = _images;\n    if (value == null) return null;\n    if (_images is EqualUnmodifiableListView) return _images;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(value);\n  }\n\n  @override\n  String toString() {\n    return 'ActivityDetails(id: $id, name: $name, description: $description, latitude: $latitude, longitude: $longitude, categoryId: $categoryId, postalCode: $postalCode, address: $address, city: $city, googlePlaceId: $googlePlaceId, currentOpeningHours: $currentOpeningHours, contactPhone: $contactPhone, contactEmail: $contactEmail, contactWebsite: $contactWebsite, bookingRequired: $bookingRequired, kidFriendly: $kidFriendly, wheelchairAccessible: $wheelchairAccessible, minDurationMinutes: $minDurationMinutes, maxDurationMinutes: $maxDurationMinutes, priceLevel: $priceLevel, basePrice: $basePrice, images: $images)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ActivityDetailsImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.description, description) ||\n                other.description == description) &&\n            (identical(other.latitude, latitude) ||\n                other.latitude == latitude) &&\n            (identical(other.longitude, longitude) ||\n                other.longitude == longitude) &&\n            (identical(other.categoryId, categoryId) ||\n                other.categoryId == categoryId) &&\n            (identical(other.postalCode, postalCode) ||\n                other.postalCode == postalCode) &&\n            (identical(other.address, address) || other.address == address) &&\n            (identical(other.city, city) || other.city == city) &&\n            (identical(other.googlePlaceId, googlePlaceId) ||\n                other.googlePlaceId == googlePlaceId) &&\n            const DeepCollectionEquality()\n                .equals(other._currentOpeningHours, _currentOpeningHours) &&\n            (identical(other.contactPhone, contactPhone) ||\n                other.contactPhone == contactPhone) &&\n            (identical(other.contactEmail, contactEmail) ||\n                other.contactEmail == contactEmail) &&\n            (identical(other.contactWebsite, contactWebsite) ||\n                other.contactWebsite == contactWebsite) &&\n            (identical(other.bookingRequired, bookingRequired) ||\n                other.bookingRequired == bookingRequired) &&\n            (identical(other.kidFriendly, kidFriendly) ||\n                other.kidFriendly == kidFriendly) &&\n            (identical(other.wheelchairAccessible, wheelchairAccessible) ||\n                other.wheelchairAccessible == wheelchairAccessible) &&\n            (identical(other.minDurationMinutes, minDurationMinutes) ||\n                other.minDurationMinutes == minDurationMinutes) &&\n            (identical(other.maxDurationMinutes, maxDurationMinutes) ||\n                other.maxDurationMinutes == maxDurationMinutes) &&\n            (identical(other.priceLevel, priceLevel) ||\n                other.priceLevel == priceLevel) &&\n            (identical(other.basePrice, basePrice) ||\n                other.basePrice == basePrice) &&\n            const DeepCollectionEquality().equals(other._images, _images));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hashAll([\n        runtimeType,\n        id,\n        name,\n        description,\n        latitude,\n        longitude,\n        categoryId,\n        postalCode,\n        address,\n        city,\n        googlePlaceId,\n        const DeepCollectionEquality().hash(_currentOpeningHours),\n        contactPhone,\n        contactEmail,\n        contactWebsite,\n        bookingRequired,\n        kidFriendly,\n        wheelchairAccessible,\n        minDurationMinutes,\n        maxDurationMinutes,\n        priceLevel,\n        basePrice,\n        const DeepCollectionEquality().hash(_images)\n      ]);\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ActivityDetailsImplCopyWith<_$ActivityDetailsImpl> get copyWith =>\n      __$$ActivityDetailsImplCopyWithImpl<_$ActivityDetailsImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$ActivityDetailsImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _ActivityDetails implements ActivityDetails {\n  const factory _ActivityDetails(\n      {required final String id,\n      required final String name,\n      final String? description,\n      required final double latitude,\n      required final double longitude,\n      required final String categoryId,\n      final String? postalCode,\n      final String? address,\n      final String? city,\n      final String? googlePlaceId,\n      final Map<String, dynamic>? currentOpeningHours,\n      final String? contactPhone,\n      final String? contactEmail,\n      final String? contactWebsite,\n      final bool? bookingRequired,\n      final bool? kidFriendly,\n      final String? wheelchairAccessible,\n      final int? minDurationMinutes,\n      final int? maxDurationMinutes,\n      final int? priceLevel,\n      final double? basePrice,\n      final List<ActivityImage>? images}) = _$ActivityDetailsImpl;\n\n  factory _ActivityDetails.fromJson(Map<String, dynamic> json) =\n      _$ActivityDetailsImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get name;\n  @override\n  String? get description;\n  @override\n  double get latitude;\n  @override\n  double get longitude;\n  @override\n  String get categoryId;\n  @override\n  String? get postalCode;\n  @override\n  String? get address;\n  @override\n  String? get city;\n  @override\n  String? get googlePlaceId;\n  @override\n  Map<String, dynamic>? get currentOpeningHours;\n  @override\n  String? get contactPhone;\n  @override\n  String? get contactEmail;\n  @override\n  String? get contactWebsite;\n  @override\n  bool? get bookingRequired;\n  @override\n  bool? get kidFriendly;\n  @override\n  String? get wheelchairAccessible;\n  @override\n  int? get minDurationMinutes;\n  @override\n  int? get maxDurationMinutes;\n  @override\n  int? get priceLevel;\n  @override\n  double? get basePrice;\n  @override\n  List<ActivityImage>? get images;\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ActivityDetailsImplCopyWith<_$ActivityDetailsImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 23571,
        "last_modified": "2025-04-16T13:25:26.6259152",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_details_model.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'activity_details_model.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$ActivityDetailsImpl _$$ActivityDetailsImplFromJson(\n        Map<String, dynamic> json) =>\n    _$ActivityDetailsImpl(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      description: json['description'] as String?,\n      latitude: (json['latitude'] as num).toDouble(),\n      longitude: (json['longitude'] as num).toDouble(),\n      categoryId: json['categoryId'] as String,\n      postalCode: json['postalCode'] as String?,\n      address: json['address'] as String?,\n      city: json['city'] as String?,\n      googlePlaceId: json['googlePlaceId'] as String?,\n      currentOpeningHours: json['currentOpeningHours'] as Map<String, dynamic>?,\n      contactPhone: json['contactPhone'] as String?,\n      contactEmail: json['contactEmail'] as String?,\n      contactWebsite: json['contactWebsite'] as String?,\n      bookingRequired: json['bookingRequired'] as bool?,\n      kidFriendly: json['kidFriendly'] as bool?,\n      wheelchairAccessible: json['wheelchairAccessible'] as String?,\n      minDurationMinutes: (json['minDurationMinutes'] as num?)?.toInt(),\n      maxDurationMinutes: (json['maxDurationMinutes'] as num?)?.toInt(),\n      priceLevel: (json['priceLevel'] as num?)?.toInt(),\n      basePrice: (json['basePrice'] as num?)?.toDouble(),\n      images: (json['images'] as List<dynamic>?)\n          ?.map((e) => ActivityImage.fromJson(e as Map<String, dynamic>))\n          .toList(),\n    );\n\nMap<String, dynamic> _$$ActivityDetailsImplToJson(\n        _$ActivityDetailsImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'name': instance.name,\n      'description': instance.description,\n      'latitude': instance.latitude,\n      'longitude': instance.longitude,\n      'categoryId': instance.categoryId,\n      'postalCode': instance.postalCode,\n      'address': instance.address,\n      'city': instance.city,\n      'googlePlaceId': instance.googlePlaceId,\n      'currentOpeningHours': instance.currentOpeningHours,\n      'contactPhone': instance.contactPhone,\n      'contactEmail': instance.contactEmail,\n      'contactWebsite': instance.contactWebsite,\n      'bookingRequired': instance.bookingRequired,\n      'kidFriendly': instance.kidFriendly,\n      'wheelchairAccessible': instance.wheelchairAccessible,\n      'minDurationMinutes': instance.minDurationMinutes,\n      'maxDurationMinutes': instance.maxDurationMinutes,\n      'priceLevel': instance.priceLevel,\n      'basePrice': instance.basePrice,\n      'images': instance.images,\n    };\n",
      "info": {
        "size": 2751,
        "last_modified": "2025-04-16T13:25:26.6322028",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_image_model.dart",
      "content": "// core/domain/models/shared/activity_image_model.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'activity_image_model.freezed.dart';\r\npart 'activity_image_model.g.dart';\r\n\r\n@freezed\r\nclass ActivityImage with _$ActivityImage {\r\n  const factory ActivityImage({\r\n    String? id,\r\n    String? mobileUrl,\r\n    bool? isMain,\r\n  }) = _ActivityImage;\r\n\r\n  factory ActivityImage.fromJson(Map<String, dynamic> json) =>\r\n      _$ActivityImageFromJson(json);\r\n}",
      "info": {
        "size": 480,
        "last_modified": "2025-04-16T13:25:26.6382038",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_image_model.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_image_model.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nActivityImage _$ActivityImageFromJson(Map<String, dynamic> json) {\n  return _ActivityImage.fromJson(json);\n}\n\n/// @nodoc\nmixin _$ActivityImage {\n  String? get id => throw _privateConstructorUsedError;\n  String? get mobileUrl => throw _privateConstructorUsedError;\n  bool? get isMain => throw _privateConstructorUsedError;\n\n  /// Serializes this ActivityImage to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $ActivityImageCopyWith<ActivityImage> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityImageCopyWith<$Res> {\n  factory $ActivityImageCopyWith(\n          ActivityImage value, $Res Function(ActivityImage) then) =\n      _$ActivityImageCopyWithImpl<$Res, ActivityImage>;\n  @useResult\n  $Res call({String? id, String? mobileUrl, bool? isMain});\n}\n\n/// @nodoc\nclass _$ActivityImageCopyWithImpl<$Res, $Val extends ActivityImage>\n    implements $ActivityImageCopyWith<$Res> {\n  _$ActivityImageCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = freezed,\n    Object? mobileUrl = freezed,\n    Object? isMain = freezed,\n  }) {\n    return _then(_value.copyWith(\n      id: freezed == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mobileUrl: freezed == mobileUrl\n          ? _value.mobileUrl\n          : mobileUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isMain: freezed == isMain\n          ? _value.isMain\n          : isMain // ignore: cast_nullable_to_non_nullable\n              as bool?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$ActivityImageImplCopyWith<$Res>\n    implements $ActivityImageCopyWith<$Res> {\n  factory _$$ActivityImageImplCopyWith(\n          _$ActivityImageImpl value, $Res Function(_$ActivityImageImpl) then) =\n      __$$ActivityImageImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call({String? id, String? mobileUrl, bool? isMain});\n}\n\n/// @nodoc\nclass __$$ActivityImageImplCopyWithImpl<$Res>\n    extends _$ActivityImageCopyWithImpl<$Res, _$ActivityImageImpl>\n    implements _$$ActivityImageImplCopyWith<$Res> {\n  __$$ActivityImageImplCopyWithImpl(\n      _$ActivityImageImpl _value, $Res Function(_$ActivityImageImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = freezed,\n    Object? mobileUrl = freezed,\n    Object? isMain = freezed,\n  }) {\n    return _then(_$ActivityImageImpl(\n      id: freezed == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mobileUrl: freezed == mobileUrl\n          ? _value.mobileUrl\n          : mobileUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isMain: freezed == isMain\n          ? _value.isMain\n          : isMain // ignore: cast_nullable_to_non_nullable\n              as bool?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$ActivityImageImpl implements _ActivityImage {\n  const _$ActivityImageImpl({this.id, this.mobileUrl, this.isMain});\n\n  factory _$ActivityImageImpl.fromJson(Map<String, dynamic> json) =>\n      _$$ActivityImageImplFromJson(json);\n\n  @override\n  final String? id;\n  @override\n  final String? mobileUrl;\n  @override\n  final bool? isMain;\n\n  @override\n  String toString() {\n    return 'ActivityImage(id: $id, mobileUrl: $mobileUrl, isMain: $isMain)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ActivityImageImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.mobileUrl, mobileUrl) ||\n                other.mobileUrl == mobileUrl) &&\n            (identical(other.isMain, isMain) || other.isMain == isMain));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, id, mobileUrl, isMain);\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ActivityImageImplCopyWith<_$ActivityImageImpl> get copyWith =>\n      __$$ActivityImageImplCopyWithImpl<_$ActivityImageImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$ActivityImageImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _ActivityImage implements ActivityImage {\n  const factory _ActivityImage(\n      {final String? id,\n      final String? mobileUrl,\n      final bool? isMain}) = _$ActivityImageImpl;\n\n  factory _ActivityImage.fromJson(Map<String, dynamic> json) =\n      _$ActivityImageImpl.fromJson;\n\n  @override\n  String? get id;\n  @override\n  String? get mobileUrl;\n  @override\n  bool? get isMain;\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ActivityImageImplCopyWith<_$ActivityImageImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 6705,
        "last_modified": "2025-04-16T13:25:26.6452314",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_image_model.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'activity_image_model.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$ActivityImageImpl _$$ActivityImageImplFromJson(Map<String, dynamic> json) =>\n    _$ActivityImageImpl(\n      id: json['id'] as String?,\n      mobileUrl: json['mobileUrl'] as String?,\n      isMain: json['isMain'] as bool?,\n    );\n\nMap<String, dynamic> _$$ActivityImageImplToJson(_$ActivityImageImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'mobileUrl': instance.mobileUrl,\n      'isMain': instance.isMain,\n    };\n",
      "info": {
        "size": 706,
        "last_modified": "2025-04-16T13:25:26.6514762",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\city_model.dart",
      "content": "// lib/core/domain/models/shared/city_model.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\n\r\n\r\nclass City extends Equatable{\r\n  final String id;\r\n  final String cityName;\r\n  final double lat;\r\n  final double lon;\r\n  final String geohash5;\r\n  final String? placeId;\r\n  final String? zoneCode;\r\n  final DateTime createdAt;\r\n  final DateTime updatedAt;\r\n\r\n  const City({  // Ajout du const pour optimisation\r\n    required this.id,\r\n    required this.cityName,\r\n    required this.lat,\r\n    required this.lon,\r\n    required this.geohash5,\r\n    this.zoneCode,\r\n    this.placeId,\r\n    required this.createdAt,\r\n    required this.updatedAt,\r\n  });\r\n\r\n  // Factory constructor pour créer une instance à partir d'un JSON\r\n  factory City.fromJson(Map<String, dynamic> json) {\r\n    return City(\r\n      id: json['id']?.toString() ?? '',  // Assurons-nous d'avoir une String\r\n      cityName: json['city_name']?.toString() ?? '',\r\n      lat: (json['lat'] as num?)?.toDouble() ?? 0.0,\r\n      lon: (json['lon'] as num?)?.toDouble() ?? 0.0,\r\n      geohash5: json['geohash_5']?.toString() ?? '',\r\n      zoneCode: json['zone_code']?.toString(),\r\n      placeId: json['place_id']?.toString(),\r\n      createdAt: json['created_at'] != null\r\n          ? DateTime.parse(json['created_at'].toString())\r\n          : DateTime.now(),\r\n      updatedAt: json['updated_at'] != null\r\n          ? DateTime.parse(json['updated_at'].toString())\r\n          : DateTime.now(),\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'city_name': cityName,\r\n      'lat': lat,\r\n      'lon': lon,\r\n      'geohash_5': geohash5,\r\n      'zone_code': zoneCode,\r\n      'place_id': placeId,\r\n      'created_at': createdAt.toIso8601String(),\r\n      'updated_at': updatedAt.toIso8601String(),\r\n    };\r\n  }\r\n\r\n  // Ajout d'une méthode pour la copie avec modifications\r\n  City copyWith({\r\n    String? id,\r\n    String? cityName,\r\n    double? lat,\r\n    double? lon,\r\n    String? geohash5,\r\n    String? zoneCode,\r\n    String? placeId,\r\n    DateTime? createdAt,\r\n    DateTime? updatedAt,\r\n  }) {\r\n    return City(\r\n      id: id ?? this.id,\r\n      cityName: cityName ?? this.cityName,\r\n      lat: lat ?? this.lat,\r\n      lon: lon ?? this.lon,\r\n      geohash5: geohash5 ?? this.geohash5,\r\n      zoneCode: zoneCode ?? this.zoneCode,\r\n      placeId: placeId ?? this.placeId,\r\n      createdAt: createdAt ?? this.createdAt,\r\n      updatedAt: updatedAt ?? this.updatedAt,\r\n    );\r\n  }\r\n\r\n  @override\r\n  String toString() => 'City(id: $id, cityName: $cityName, geohash5: $geohash5, zoneCode: $zoneCode)';\r\n\r\n  @override\r\n  List<Object?> get props => [id, cityName, lat, lon, geohash5, zoneCode, createdAt, updatedAt];\r\n}",
      "info": {
        "size": 2695,
        "last_modified": "2025-04-16T13:25:26.6585215",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\subcategory_model.dart",
      "content": "// lib/core/domain/models/shared/subcategory_model.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'subcategory_model.freezed.dart';\r\npart 'subcategory_model.g.dart';\r\n\r\n@freezed\r\nclass Subcategory with _$Subcategory {\r\n  const factory Subcategory({\r\n    required String id,\r\n    required String name,\r\n    required String categoryId,\r\n    String? description,\r\n    String? icon,\r\n  }) = _Subcategory;\r\n\r\n  factory Subcategory.fromJson(Map<String, dynamic> json) =>\r\n      _$SubcategoryFromJson(json);\r\n}",
      "info": {
        "size": 533,
        "last_modified": "2025-04-16T13:25:26.6655501",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\subcategory_model.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'subcategory_model.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nSubcategory _$SubcategoryFromJson(Map<String, dynamic> json) {\n  return _Subcategory.fromJson(json);\n}\n\n/// @nodoc\nmixin _$Subcategory {\n  String get id => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  String get categoryId => throw _privateConstructorUsedError;\n  String? get description => throw _privateConstructorUsedError;\n  String? get icon => throw _privateConstructorUsedError;\n\n  /// Serializes this Subcategory to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $SubcategoryCopyWith<Subcategory> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $SubcategoryCopyWith<$Res> {\n  factory $SubcategoryCopyWith(\n          Subcategory value, $Res Function(Subcategory) then) =\n      _$SubcategoryCopyWithImpl<$Res, Subcategory>;\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String categoryId,\n      String? description,\n      String? icon});\n}\n\n/// @nodoc\nclass _$SubcategoryCopyWithImpl<$Res, $Val extends Subcategory>\n    implements $SubcategoryCopyWith<$Res> {\n  _$SubcategoryCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? categoryId = null,\n    Object? description = freezed,\n    Object? icon = freezed,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      icon: freezed == icon\n          ? _value.icon\n          : icon // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$SubcategoryImplCopyWith<$Res>\n    implements $SubcategoryCopyWith<$Res> {\n  factory _$$SubcategoryImplCopyWith(\n          _$SubcategoryImpl value, $Res Function(_$SubcategoryImpl) then) =\n      __$$SubcategoryImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String categoryId,\n      String? description,\n      String? icon});\n}\n\n/// @nodoc\nclass __$$SubcategoryImplCopyWithImpl<$Res>\n    extends _$SubcategoryCopyWithImpl<$Res, _$SubcategoryImpl>\n    implements _$$SubcategoryImplCopyWith<$Res> {\n  __$$SubcategoryImplCopyWithImpl(\n      _$SubcategoryImpl _value, $Res Function(_$SubcategoryImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? categoryId = null,\n    Object? description = freezed,\n    Object? icon = freezed,\n  }) {\n    return _then(_$SubcategoryImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      icon: freezed == icon\n          ? _value.icon\n          : icon // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$SubcategoryImpl implements _Subcategory {\n  const _$SubcategoryImpl(\n      {required this.id,\n      required this.name,\n      required this.categoryId,\n      this.description,\n      this.icon});\n\n  factory _$SubcategoryImpl.fromJson(Map<String, dynamic> json) =>\n      _$$SubcategoryImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String name;\n  @override\n  final String categoryId;\n  @override\n  final String? description;\n  @override\n  final String? icon;\n\n  @override\n  String toString() {\n    return 'Subcategory(id: $id, name: $name, categoryId: $categoryId, description: $description, icon: $icon)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SubcategoryImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.categoryId, categoryId) ||\n                other.categoryId == categoryId) &&\n            (identical(other.description, description) ||\n                other.description == description) &&\n            (identical(other.icon, icon) || other.icon == icon));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, id, name, categoryId, description, icon);\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SubcategoryImplCopyWith<_$SubcategoryImpl> get copyWith =>\n      __$$SubcategoryImplCopyWithImpl<_$SubcategoryImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$SubcategoryImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _Subcategory implements Subcategory {\n  const factory _Subcategory(\n      {required final String id,\n      required final String name,\n      required final String categoryId,\n      final String? description,\n      final String? icon}) = _$SubcategoryImpl;\n\n  factory _Subcategory.fromJson(Map<String, dynamic> json) =\n      _$SubcategoryImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get name;\n  @override\n  String get categoryId;\n  @override\n  String? get description;\n  @override\n  String? get icon;\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SubcategoryImplCopyWith<_$SubcategoryImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 8065,
        "last_modified": "2025-04-16T13:25:26.6720657",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\subcategory_model.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'subcategory_model.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$SubcategoryImpl _$$SubcategoryImplFromJson(Map<String, dynamic> json) =>\n    _$SubcategoryImpl(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      categoryId: json['categoryId'] as String,\n      description: json['description'] as String?,\n      icon: json['icon'] as String?,\n    );\n\nMap<String, dynamic> _$$SubcategoryImplToJson(_$SubcategoryImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'name': instance.name,\n      'categoryId': instance.categoryId,\n      'description': instance.description,\n      'icon': instance.icon,\n    };\n",
      "info": {
        "size": 848,
        "last_modified": "2025-04-16T13:25:26.6781519",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\bonus_activities\\potential_bonus_activity.dart",
      "content": "// lib/core/domain/models/bonus_activities/potential_bonus_activity.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport 'value_objects/malus_vol_oiseau.dart';\r\n\r\nclass PotentialBonusActivity extends Equatable {\r\n  final String id;\r\n  final String emptyDailyTripId;\r\n  final String activityId;\r\n  final MalusVolOiseau malusVolOiseau;\r\n  final DateTime tripDate;\r\n  final DateTime createdAt;\r\n  final DateTime updatedAt;\r\n\r\n  const PotentialBonusActivity({\r\n    required this.id,\r\n    required this.emptyDailyTripId,\r\n    required this.activityId,\r\n    required this.malusVolOiseau,\r\n    required this.tripDate,\r\n    required this.createdAt,\r\n    required this.updatedAt,\r\n  });\r\n\r\n  @override\r\n  List<Object> get props => [\r\n    id,\r\n    emptyDailyTripId,\r\n    activityId,\r\n    malusVolOiseau,\r\n    createdAt,\r\n    updatedAt\r\n  ];\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'id': id,\r\n    'empty_daily_trip_id': emptyDailyTripId,\r\n    'activity_id': activityId,\r\n    'malus_vol_oiseau': malusVolOiseau.minutes,\r\n    'trip_date': tripDate.toIso8601String(),\r\n    'created_at': createdAt.toIso8601String(),\r\n    'updated_at': updatedAt.toIso8601String(),\r\n  };\r\n\r\n  factory PotentialBonusActivity.fromJson(Map<String, dynamic> json) {\r\n    return PotentialBonusActivity(\r\n      id: json['id'],\r\n      emptyDailyTripId: json['empty_daily_trip_id'],\r\n      activityId: json['activity_id'],\r\n      malusVolOiseau: MalusVolOiseau.fromInt(json['malus_vol_oiseau']),\r\n      tripDate: DateTime.parse(json['trip_date']),\r\n      createdAt: DateTime.parse(json['created_at']),\r\n      updatedAt: DateTime.parse(json['updated_at']),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1642,
        "last_modified": "2025-04-16T13:25:26.6912315",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\bonus_activities\\value_objects\\malus_vol_oiseau.dart",
      "content": "// lib/core/domain/models/bonus_activities/value_objects/malus_vol_oiseau.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\npart 'malus_vol_oiseau.freezed.dart';\r\n\r\n\r\n@freezed\r\nclass MalusVolOiseau with _$MalusVolOiseau {\r\n  const factory MalusVolOiseau({\r\n    required int minutes,\r\n  }) = _MalusVolOiseau;\r\n\r\n  factory MalusVolOiseau.fromInt(int minutes) {\r\n    if (minutes < 0) {\r\n      throw ArgumentError('Malus minutes cannot be negative');\r\n    }\r\n    return MalusVolOiseau(minutes: minutes);\r\n  }\r\n}",
      "info": {
        "size": 527,
        "last_modified": "2025-04-16T13:25:26.6982164",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\bonus_activities\\value_objects\\malus_vol_oiseau.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'malus_vol_oiseau.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$MalusVolOiseau {\n  int get minutes => throw _privateConstructorUsedError;\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $MalusVolOiseauCopyWith<MalusVolOiseau> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $MalusVolOiseauCopyWith<$Res> {\n  factory $MalusVolOiseauCopyWith(\n          MalusVolOiseau value, $Res Function(MalusVolOiseau) then) =\n      _$MalusVolOiseauCopyWithImpl<$Res, MalusVolOiseau>;\n  @useResult\n  $Res call({int minutes});\n}\n\n/// @nodoc\nclass _$MalusVolOiseauCopyWithImpl<$Res, $Val extends MalusVolOiseau>\n    implements $MalusVolOiseauCopyWith<$Res> {\n  _$MalusVolOiseauCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? minutes = null,\n  }) {\n    return _then(_value.copyWith(\n      minutes: null == minutes\n          ? _value.minutes\n          : minutes // ignore: cast_nullable_to_non_nullable\n              as int,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$MalusVolOiseauImplCopyWith<$Res>\n    implements $MalusVolOiseauCopyWith<$Res> {\n  factory _$$MalusVolOiseauImplCopyWith(_$MalusVolOiseauImpl value,\n          $Res Function(_$MalusVolOiseauImpl) then) =\n      __$$MalusVolOiseauImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call({int minutes});\n}\n\n/// @nodoc\nclass __$$MalusVolOiseauImplCopyWithImpl<$Res>\n    extends _$MalusVolOiseauCopyWithImpl<$Res, _$MalusVolOiseauImpl>\n    implements _$$MalusVolOiseauImplCopyWith<$Res> {\n  __$$MalusVolOiseauImplCopyWithImpl(\n      _$MalusVolOiseauImpl _value, $Res Function(_$MalusVolOiseauImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? minutes = null,\n  }) {\n    return _then(_$MalusVolOiseauImpl(\n      minutes: null == minutes\n          ? _value.minutes\n          : minutes // ignore: cast_nullable_to_non_nullable\n              as int,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$MalusVolOiseauImpl implements _MalusVolOiseau {\n  const _$MalusVolOiseauImpl({required this.minutes});\n\n  @override\n  final int minutes;\n\n  @override\n  String toString() {\n    return 'MalusVolOiseau(minutes: $minutes)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$MalusVolOiseauImpl &&\n            (identical(other.minutes, minutes) || other.minutes == minutes));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, minutes);\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$MalusVolOiseauImplCopyWith<_$MalusVolOiseauImpl> get copyWith =>\n      __$$MalusVolOiseauImplCopyWithImpl<_$MalusVolOiseauImpl>(\n          this, _$identity);\n}\n\nabstract class _MalusVolOiseau implements MalusVolOiseau {\n  const factory _MalusVolOiseau({required final int minutes}) =\n      _$MalusVolOiseauImpl;\n\n  @override\n  int get minutes;\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$MalusVolOiseauImplCopyWith<_$MalusVolOiseauImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 4847,
        "last_modified": "2025-04-16T13:25:26.7052579",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\empty_daily_trip.dart",
      "content": "// lib/core/domain/empty_trips/empty_daily_trip.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\n\r\nclass EmptyDailyTrip extends Equatable {\r\n  final String id;\r\n  final DailyTripType type;\r\n  final String departureGeohash5;\r\n  final String arrivalGeohash5;\r\n  final String sw1Id;\r\n  final String? sw2Id;\r\n  final List<String> traversedGeohashes;\r\n  final String routePolyline;\r\n  final int totalDuration;\r\n  final int totalDistance;\r\n  final DateTime createdAt;\r\n\r\n  const EmptyDailyTrip({\r\n    required this.id,\r\n    required this.type,\r\n    required this.departureGeohash5,\r\n    required this.arrivalGeohash5,\r\n    required this.sw1Id,\r\n    this.sw2Id,\r\n    required this.traversedGeohashes,\r\n    required this.routePolyline,\r\n    required this.totalDuration,\r\n    required this.totalDistance,\r\n    required this.createdAt,\r\n  });\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id,\r\n    type,\r\n    departureGeohash5,\r\n    arrivalGeohash5,\r\n    sw1Id,\r\n    sw2Id,\r\n    traversedGeohashes,\r\n    routePolyline,\r\n    totalDuration,\r\n    totalDistance,\r\n    createdAt,\r\n  ];\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'id': id,\r\n    'type': type.toString().split('.').last,\r\n    'departure_geohash5': departureGeohash5,\r\n    'arrival_geohash5': arrivalGeohash5,\r\n    'sw1_id': sw1Id,\r\n    'sw2_id': sw2Id,\r\n    'traversed_geohashes': traversedGeohashes,\r\n    'route_polyline': routePolyline,\r\n    'total_duration': totalDuration,\r\n    'total_distance': totalDistance,\r\n    'created_at': createdAt.toIso8601String(),\r\n  };\r\n}",
      "info": {
        "size": 1583,
        "last_modified": "2025-04-16T13:25:26.7232034",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\value_objects\\generation_result.dart",
      "content": "// lib/core/domain/models/empty_trips/value_objects/generation_result.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../empty_daily_trip.dart';\r\n\r\npart 'generation_result.freezed.dart';\r\n\r\n@freezed\r\nclass EmptyTripGenerationResult with _$EmptyTripGenerationResult {\r\n  const factory EmptyTripGenerationResult({\r\n    required List<EmptyDailyTrip> halfDayTrips,\r\n    required List<EmptyDailyTrip> fullDayTrips,\r\n    required String departureGeohash5,\r\n    required List<String> errors,\r\n  }) = _EmptyTripGenerationResult;\r\n}",
      "info": {
        "size": 553,
        "last_modified": "2025-04-16T13:25:26.7302694",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\value_objects\\generation_result.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'generation_result.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$EmptyTripGenerationResult {\n  List<EmptyDailyTrip> get halfDayTrips => throw _privateConstructorUsedError;\n  List<EmptyDailyTrip> get fullDayTrips => throw _privateConstructorUsedError;\n  String get departureGeohash5 => throw _privateConstructorUsedError;\n  List<String> get errors => throw _privateConstructorUsedError;\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $EmptyTripGenerationResultCopyWith<EmptyTripGenerationResult> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $EmptyTripGenerationResultCopyWith<$Res> {\n  factory $EmptyTripGenerationResultCopyWith(EmptyTripGenerationResult value,\n          $Res Function(EmptyTripGenerationResult) then) =\n      _$EmptyTripGenerationResultCopyWithImpl<$Res, EmptyTripGenerationResult>;\n  @useResult\n  $Res call(\n      {List<EmptyDailyTrip> halfDayTrips,\n      List<EmptyDailyTrip> fullDayTrips,\n      String departureGeohash5,\n      List<String> errors});\n}\n\n/// @nodoc\nclass _$EmptyTripGenerationResultCopyWithImpl<$Res,\n        $Val extends EmptyTripGenerationResult>\n    implements $EmptyTripGenerationResultCopyWith<$Res> {\n  _$EmptyTripGenerationResultCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? halfDayTrips = null,\n    Object? fullDayTrips = null,\n    Object? departureGeohash5 = null,\n    Object? errors = null,\n  }) {\n    return _then(_value.copyWith(\n      halfDayTrips: null == halfDayTrips\n          ? _value.halfDayTrips\n          : halfDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      fullDayTrips: null == fullDayTrips\n          ? _value.fullDayTrips\n          : fullDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      departureGeohash5: null == departureGeohash5\n          ? _value.departureGeohash5\n          : departureGeohash5 // ignore: cast_nullable_to_non_nullable\n              as String,\n      errors: null == errors\n          ? _value.errors\n          : errors // ignore: cast_nullable_to_non_nullable\n              as List<String>,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$EmptyTripGenerationResultImplCopyWith<$Res>\n    implements $EmptyTripGenerationResultCopyWith<$Res> {\n  factory _$$EmptyTripGenerationResultImplCopyWith(\n          _$EmptyTripGenerationResultImpl value,\n          $Res Function(_$EmptyTripGenerationResultImpl) then) =\n      __$$EmptyTripGenerationResultImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {List<EmptyDailyTrip> halfDayTrips,\n      List<EmptyDailyTrip> fullDayTrips,\n      String departureGeohash5,\n      List<String> errors});\n}\n\n/// @nodoc\nclass __$$EmptyTripGenerationResultImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationResultCopyWithImpl<$Res,\n        _$EmptyTripGenerationResultImpl>\n    implements _$$EmptyTripGenerationResultImplCopyWith<$Res> {\n  __$$EmptyTripGenerationResultImplCopyWithImpl(\n      _$EmptyTripGenerationResultImpl _value,\n      $Res Function(_$EmptyTripGenerationResultImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? halfDayTrips = null,\n    Object? fullDayTrips = null,\n    Object? departureGeohash5 = null,\n    Object? errors = null,\n  }) {\n    return _then(_$EmptyTripGenerationResultImpl(\n      halfDayTrips: null == halfDayTrips\n          ? _value._halfDayTrips\n          : halfDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      fullDayTrips: null == fullDayTrips\n          ? _value._fullDayTrips\n          : fullDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      departureGeohash5: null == departureGeohash5\n          ? _value.departureGeohash5\n          : departureGeohash5 // ignore: cast_nullable_to_non_nullable\n              as String,\n      errors: null == errors\n          ? _value._errors\n          : errors // ignore: cast_nullable_to_non_nullable\n              as List<String>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$EmptyTripGenerationResultImpl implements _EmptyTripGenerationResult {\n  const _$EmptyTripGenerationResultImpl(\n      {required final List<EmptyDailyTrip> halfDayTrips,\n      required final List<EmptyDailyTrip> fullDayTrips,\n      required this.departureGeohash5,\n      required final List<String> errors})\n      : _halfDayTrips = halfDayTrips,\n        _fullDayTrips = fullDayTrips,\n        _errors = errors;\n\n  final List<EmptyDailyTrip> _halfDayTrips;\n  @override\n  List<EmptyDailyTrip> get halfDayTrips {\n    if (_halfDayTrips is EqualUnmodifiableListView) return _halfDayTrips;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_halfDayTrips);\n  }\n\n  final List<EmptyDailyTrip> _fullDayTrips;\n  @override\n  List<EmptyDailyTrip> get fullDayTrips {\n    if (_fullDayTrips is EqualUnmodifiableListView) return _fullDayTrips;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_fullDayTrips);\n  }\n\n  @override\n  final String departureGeohash5;\n  final List<String> _errors;\n  @override\n  List<String> get errors {\n    if (_errors is EqualUnmodifiableListView) return _errors;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_errors);\n  }\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationResult(halfDayTrips: $halfDayTrips, fullDayTrips: $fullDayTrips, departureGeohash5: $departureGeohash5, errors: $errors)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$EmptyTripGenerationResultImpl &&\n            const DeepCollectionEquality()\n                .equals(other._halfDayTrips, _halfDayTrips) &&\n            const DeepCollectionEquality()\n                .equals(other._fullDayTrips, _fullDayTrips) &&\n            (identical(other.departureGeohash5, departureGeohash5) ||\n                other.departureGeohash5 == departureGeohash5) &&\n            const DeepCollectionEquality().equals(other._errors, _errors));\n  }\n\n  @override\n  int get hashCode => Object.hash(\n      runtimeType,\n      const DeepCollectionEquality().hash(_halfDayTrips),\n      const DeepCollectionEquality().hash(_fullDayTrips),\n      departureGeohash5,\n      const DeepCollectionEquality().hash(_errors));\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$EmptyTripGenerationResultImplCopyWith<_$EmptyTripGenerationResultImpl>\n      get copyWith => __$$EmptyTripGenerationResultImplCopyWithImpl<\n          _$EmptyTripGenerationResultImpl>(this, _$identity);\n}\n\nabstract class _EmptyTripGenerationResult implements EmptyTripGenerationResult {\n  const factory _EmptyTripGenerationResult(\n      {required final List<EmptyDailyTrip> halfDayTrips,\n      required final List<EmptyDailyTrip> fullDayTrips,\n      required final String departureGeohash5,\n      required final List<String> errors}) = _$EmptyTripGenerationResultImpl;\n\n  @override\n  List<EmptyDailyTrip> get halfDayTrips;\n  @override\n  List<EmptyDailyTrip> get fullDayTrips;\n  @override\n  String get departureGeohash5;\n  @override\n  List<String> get errors;\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$EmptyTripGenerationResultImplCopyWith<_$EmptyTripGenerationResultImpl>\n      get copyWith => throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 9186,
        "last_modified": "2025-04-16T13:25:26.736305",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\value_objects\\superwow_pair.dart",
      "content": "// lib/core/domain/empty_trips/value_objects/superwow_pair.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nclass SuperWowPair extends Equatable {\r\n  final String sw1Id;  // Premier SuperWow (le plus proche du départ)\r\n  final String sw2Id;  // Second SuperWow\r\n  final LatLng sw1Location;\r\n  final LatLng sw2Location;\r\n  final int distanceBetween;  // Distance en mètres entre SW1 et SW2\r\n  final Duration travelTime;  // Temps de trajet entre SW1 et SW2\r\n\r\n  const SuperWowPair({\r\n    required this.sw1Id,\r\n    required this.sw2Id,\r\n    required this.sw1Location,\r\n    required this.sw2Location,\r\n    required this.distanceBetween,\r\n    required this.travelTime,\r\n  });\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    sw1Id,\r\n    sw2Id,\r\n    sw1Location,\r\n    sw2Location,\r\n    distanceBetween,\r\n    travelTime,\r\n  ];\r\n\r\n  double get distanceInKm => distanceBetween / 1000;\r\n}",
      "info": {
        "size": 953,
        "last_modified": "2025-04-16T13:25:26.7433327",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\processing\\activity_processing_model.dart",
      "content": "// core/domain/models/processing/activity_processing_model.dart\r\n\r\nimport '../trip/activity_model.dart';\r\n\r\nclass ActivityForProcessing extends Activity {\r\n  String? exclusionReason;\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperWow;\r\n  final String? superwowValidityPeriod;\r\n  final Map<String, dynamic>? superwowScoreSnapshot;\r\n  final Map<String, dynamic>? superwowCriteriaMet;\r\n\r\n  ActivityForProcessing({\r\n    required super.id,\r\n    required super.name,\r\n    required super.latitude,\r\n    required super.longitude,\r\n    required super.geohash,\r\n    super.geohash5,\r\n    required super.isWow,\r\n    required super.minDurationMinutes,\r\n    required super.maxDurationMinutes,\r\n    required super.momentPreferences,\r\n    required super.intensityLevel,\r\n    required super.categoryId,\r\n    super.subcategoryId,\r\n    super.kidFriendly,\r\n    super.wheelchairAccessible,\r\n    super.metadata,\r\n    required super.ratingAvg,\r\n    required super.ratingCount,\r\n    super.basePrice,\r\n    super.bookingRequired,\r\n    super.weatherPreferences,\r\n    super.activitySubtype,\r\n    super.seasonPrices,\r\n    this.exclusionReason,\r\n    this.totalScore = 0.0,\r\n    this.subcategoryScore = 0.0,\r\n    this.isSuperWow = false,\r\n    this.superwowValidityPeriod,\r\n    this.superwowScoreSnapshot,\r\n    this.superwowCriteriaMet,\r\n  });\r\n\r\n  factory ActivityForProcessing.fromJson(Map<String, dynamic> json) {\r\n    return ActivityForProcessing(\r\n      id: json['id'],\r\n      name: json['name'],\r\n      latitude: json['latitude']?.toDouble() ?? 0.0,\r\n      longitude: json['longitude']?.toDouble() ?? 0.0,\r\n      geohash: json['geohash_4'] ?? '',\r\n      geohash5: json['geohash_5'],\r\n      isWow: json['is_wow'] ?? false,\r\n      minDurationMinutes: json['min_duration_minutes'] ?? 60,\r\n      maxDurationMinutes: json['max_duration_minutes'] ?? 60,\r\n      momentPreferences: (json['moment_preferences'] is List)\r\n          ? List<String>.from(json['moment_preferences'])\r\n          : (json['moment_preferences'] is Map)\r\n          ? (json['moment_preferences'] as Map).keys.cast<String>().toList()\r\n          : [],\r\n      intensityLevel: json['intensity_level'] ?? 1,\r\n      categoryId: json['category_id'] ?? '',\r\n      subcategoryId: json['subcategory_id'],\r\n      kidFriendly: json['kid_friendly'],\r\n      wheelchairAccessible: json['wheelchair_accessible'],\r\n      metadata: json['metadata'],\r\n      ratingAvg: json['rating_avg']?.toString() ?? '0',\r\n      ratingCount: json['rating_count'] ?? 0,\r\n      basePrice: json['base_price']?.toDouble(),\r\n      bookingRequired: json['booking_required'],\r\n      weatherPreferences: json['weather_preferences'],\r\n      activitySubtype: json['activity_subtype'],\r\n      seasonPrices: json['season_prices'],\r\n      exclusionReason: json['exclusion_reason'],\r\n      totalScore: (json['total_score'] ?? 0.0).toDouble(),\r\n      subcategoryScore: (json['subcategory_score'] ?? 0.0).toDouble(),\r\n      isSuperWow: json['is_super_wow'] ?? false,\r\n      superwowValidityPeriod: json['superwow_validity_period'],\r\n      superwowScoreSnapshot: json['superwow_score_snapshot'],\r\n      superwowCriteriaMet: json['superwow_criteria_met'],\r\n    );\r\n  }\r\n\r\n  factory ActivityForProcessing.fromActivity(Activity activity) {\r\n    return ActivityForProcessing(\r\n      id: activity.id,\r\n      name: activity.name,\r\n      latitude: activity.latitude,\r\n      longitude: activity.longitude,\r\n      geohash: activity.geohash,\r\n      geohash5: activity.geohash5,\r\n      isWow: activity.isWow,\r\n      minDurationMinutes: activity.minDurationMinutes,\r\n      maxDurationMinutes: activity.maxDurationMinutes,\r\n      momentPreferences: activity.momentPreferences,\r\n      intensityLevel: activity.intensityLevel,\r\n      categoryId: activity.categoryId,\r\n      subcategoryId: activity.subcategoryId,\r\n      kidFriendly: activity.kidFriendly,\r\n      wheelchairAccessible: activity.wheelchairAccessible,\r\n      metadata: activity.metadata,\r\n      ratingAvg: activity.ratingAvg,\r\n      ratingCount: activity.ratingCount,\r\n      basePrice: activity.basePrice,\r\n      bookingRequired: activity.bookingRequired,\r\n      weatherPreferences: activity.weatherPreferences,\r\n      activitySubtype: activity.activitySubtype,\r\n      seasonPrices: activity.seasonPrices,\r\n    );\r\n  }\r\n\r\n  @override\r\n  Map<String, dynamic> toJson() {\r\n    final baseJson = super.toJson();\r\n    return {\r\n      ...baseJson,\r\n      'exclusion_reason': exclusionReason,\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_super_wow': isSuperWow,\r\n      'superwow_validity_period': superwowValidityPeriod,\r\n      'superwow_score_snapshot': superwowScoreSnapshot,\r\n      'superwow_criteria_met': superwowCriteriaMet,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 4756,
        "last_modified": "2025-04-16T13:25:26.7602682",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\scoring\\scoring_activity.dart",
      "content": "// core/domain/models/scoring/scored_activity.dart\r\n\r\nimport '../processing/activity_processing_model.dart';\r\n\r\nclass ScoredActivity {\r\n  final ActivityForProcessing activity;\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperWow;\r\n  final DateTime? superwowValidityPeriod;\r\n  final Map<String, dynamic>? superwowScoreSnapshot;\r\n\r\n  const ScoredActivity({\r\n    required this.activity,\r\n    required this.totalScore,\r\n    required this.subcategoryScore,\r\n    this.isSuperWow = false,\r\n    this.superwowValidityPeriod,\r\n    this.superwowScoreSnapshot,\r\n  });\r\n\r\n  factory ScoredActivity.fromJson(Map<String, dynamic> json, ActivityForProcessing activity) {\r\n    return ScoredActivity(\r\n      activity: activity,\r\n      totalScore: json['total_score']?.toDouble() ?? 0.0,\r\n      subcategoryScore: json['subcategory_score']?.toDouble() ?? 0.0,\r\n      isSuperWow: json['is_superwow'] ?? false,\r\n      superwowValidityPeriod: json['superwow_validity_period'] != null\r\n          ? DateTime.parse(json['superwow_validity_period'])\r\n          : null,\r\n      superwowScoreSnapshot: json['superwow_score_snapshot'],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'activity_id': activity.id,\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_superwow': isSuperWow,\r\n      'superwow_validity_period': superwowValidityPeriod?.toIso8601String(),\r\n      'superwow_score_snapshot': superwowScoreSnapshot,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 1501,
        "last_modified": "2025-04-16T13:25:26.771813",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\scoring\\scoring_config.dart",
      "content": "// core/domain/models/scoring/scoring_config.dart\r\n\r\nimport 'dart:math' as math;\r\n\r\nclass ScoringConfig {\r\n  // Pondérations\r\n  static const double subcategoryWeight = 0.5;\r\n  static const double ratingWeight = 0.4;\r\n  static const double durationWeight = 0.1;\r\n\r\n  // Scores sous-catégories\r\n  static const Map<String, double> subcategoryScores = {\r\n    'adore': 1.0,\r\n    'aime': 0.6,\r\n    'parfois': 0.3\r\n  };\r\n}",
      "info": {
        "size": 417,
        "last_modified": "2025-04-16T13:25:26.779322",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\scoring\\scoring_result.dart",
      "content": "// core/domain/models/scoring/scoring_result.dart\r\n\r\n\r\nclass ScoringResult {\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperWow;\r\n  final DateTime? superwowValidityPeriod;\r\n  final Map<String, dynamic>? superwowScoreSnapshot;\r\n\r\n  const ScoringResult({\r\n    required this.totalScore,\r\n    required this.subcategoryScore,\r\n    required this.isSuperWow,\r\n    this.superwowValidityPeriod,\r\n    this.superwowScoreSnapshot,\r\n  });\r\n\r\n  // Optionnel : Factory pour créer depuis JSON\r\n  factory ScoringResult.fromJson(Map<String, dynamic> json) {\r\n    return ScoringResult(\r\n      totalScore: json['total_score']?.toDouble() ?? 0.0,\r\n      subcategoryScore: json['subcategory_score']?.toDouble() ?? 0.0,\r\n      isSuperWow: json['is_superwow'] ?? false,\r\n      superwowValidityPeriod: json['superwow_validity_period'] != null\r\n          ? DateTime.parse(json['superwow_validity_period'])\r\n          : null,\r\n      superwowScoreSnapshot: json['superwow_score_snapshot'],\r\n    );\r\n  }\r\n\r\n  // Optionnel : Conversion en JSON\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_superwow': isSuperWow,\r\n      'superwow_validity_period': superwowValidityPeriod?.toIso8601String(),\r\n      'superwow_score_snapshot': superwowScoreSnapshot,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 1364,
        "last_modified": "2025-04-16T13:25:26.7853661",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\trip\\activity_model.dart",
      "content": "// core\\domain\\models\\trip_designer\\trip\\activity_model.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\n\r\nclass Activity extends Equatable {\r\n  final String id;\r\n  final String name;\r\n  final double latitude;\r\n  final double longitude;\r\n  final String geohash;\r\n  final String? geohash5;\r\n  final bool isWow;\r\n  final int minDurationMinutes;\r\n  final int maxDurationMinutes;\r\n  final List<String> momentPreferences;\r\n  final int intensityLevel;\r\n  final String categoryId;\r\n  final String? subcategoryId;\r\n  final bool? kidFriendly;\r\n  final String? wheelchairAccessible;\r\n  final Map<String, dynamic>? metadata;\r\n  final String ratingAvg;\r\n  final int ratingCount;\r\n  final double? basePrice;\r\n  final bool? bookingRequired;\r\n  final Map<String, dynamic>? weatherPreferences;\r\n  final String? activitySubtype;\r\n  final Map<String, dynamic>? seasonPrices;\r\n\r\n  const Activity({\r\n    required this.id,\r\n    required this.name,\r\n    required this.latitude,\r\n    required this.longitude,\r\n    required this.geohash,\r\n    this.geohash5,\r\n    required this.isWow,\r\n    required this.minDurationMinutes,\r\n    required this.maxDurationMinutes,\r\n    required this.momentPreferences,\r\n    required this.intensityLevel,\r\n    required this.categoryId,\r\n    this.subcategoryId,\r\n    this.kidFriendly,\r\n    this.wheelchairAccessible,\r\n    this.metadata,\r\n    required this.ratingAvg,\r\n    required this.ratingCount,\r\n    this.basePrice,\r\n    this.bookingRequired,\r\n    this.weatherPreferences,\r\n    this.activitySubtype,\r\n    this.seasonPrices,\r\n  });\r\n\r\n  factory Activity.fromJson(Map<String, dynamic> json) {\r\n    List<String> momentPrefs;\r\n    if (json['moment_preferences'] is List) {\r\n      momentPrefs = List<String>.from(json['moment_preferences']);\r\n    } else if (json['moment_preferences'] is Map) {\r\n      momentPrefs = (json['moment_preferences'] as Map).keys.cast<String>().toList();\r\n    } else {\r\n      momentPrefs = [];\r\n    }\r\n\r\n    return Activity(\r\n      id: json['id'],\r\n      name: json['name'],\r\n      latitude: json['latitude']?.toDouble() ?? 0.0,\r\n      longitude: json['longitude']?.toDouble() ?? 0.0,\r\n      geohash: json['geohash_4'] ?? '',\r\n      geohash5: json['geohash_5'],\r\n      isWow: json['is_wow'] ?? false,\r\n      minDurationMinutes: json['min_duration_minutes'] ?? 60,\r\n      maxDurationMinutes: json['max_duration_minutes'] ?? 60,\r\n      momentPreferences: momentPrefs,\r\n      intensityLevel: json['intensity_level'] ?? 1,\r\n      categoryId: json['category_id'] ?? '',\r\n      subcategoryId: json['subcategory_id'],\r\n      kidFriendly: json['kid_friendly'],\r\n      wheelchairAccessible: json['wheelchair_accessible'],\r\n      metadata: json['metadata'],\r\n      ratingAvg: json['rating_avg']?.toString() ?? '0',\r\n      ratingCount: json['rating_count'] ?? 0,\r\n      basePrice: json['base_price']?.toDouble(),\r\n      bookingRequired: json['booking_required'],\r\n      weatherPreferences: json['weather_preferences'],\r\n      activitySubtype: json['activity_subtype'],\r\n      seasonPrices: json['season_prices'],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'id': id,\r\n    'name': name,\r\n    'latitude': latitude,\r\n    'longitude': longitude,\r\n    'geohash_4': geohash,\r\n    'geohash_5': geohash5,\r\n    'is_wow': isWow,\r\n    'min_duration_minutes': minDurationMinutes,\r\n    'max_duration_minutes': maxDurationMinutes,\r\n    'moment_preferences': momentPreferences,\r\n    'intensity_level': intensityLevel,\r\n    'category_id': categoryId,\r\n    'subcategory_id': subcategoryId,\r\n    'kid_friendly': kidFriendly,\r\n    'wheelchair_accessible': wheelchairAccessible,\r\n    'metadata': metadata,\r\n    'rating_avg': ratingAvg,\r\n    'rating_count': ratingCount,\r\n    'base_price': basePrice,\r\n    'booking_required': bookingRequired,\r\n    'weather_preferences': weatherPreferences,\r\n    'activity_subtype': activitySubtype,\r\n    'season_prices': seasonPrices,\r\n  };\r\n\r\n  // Getters utilitaires\r\n  int get durationMinutes => maxDurationMinutes;\r\n  double get rating => double.tryParse(ratingAvg) ?? 0.0;\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id,\r\n    name,\r\n    latitude,\r\n    longitude,\r\n    geohash,\r\n    geohash5,\r\n    isWow,\r\n    minDurationMinutes,\r\n    maxDurationMinutes,\r\n    momentPreferences,\r\n    intensityLevel,\r\n    categoryId,\r\n    subcategoryId,\r\n    kidFriendly,\r\n    wheelchairAccessible,\r\n    metadata,\r\n    ratingAvg,\r\n    ratingCount,\r\n    basePrice,\r\n    bookingRequired,\r\n    weatherPreferences,\r\n    activitySubtype,\r\n    seasonPrices,\r\n  ];\r\n}",
      "info": {
        "size": 4505,
        "last_modified": "2025-04-16T13:25:26.7968726",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\trip\\daily_trip.dart",
      "content": "// lib/core/domain/models/trip/daily_trip.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\n\r\n\r\nclass DailyTrip extends Equatable {\r\n  final String id;\r\n  final DailyTripType type;\r\n  final DateTime date;\r\n  final LatLng startPoint;\r\n  final LatLng endPoint;\r\n  final List<String> superWowIds;  // Les IDs des SW inclus\r\n  final Duration totalDuration;     // Durée totale estimée\r\n  final int totalDistance;          // Distance en mètres\r\n\r\n  const DailyTrip({\r\n    required this.id,\r\n    required this.type,\r\n    required this.date,\r\n    required this.startPoint,\r\n    required this.endPoint,\r\n    required this.superWowIds,\r\n    required this.totalDuration,\r\n    required this.totalDistance,\r\n  });\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id, type, date, startPoint, endPoint, superWowIds, totalDuration, totalDistance\r\n  ];\r\n\r\n  // Conversion depuis/vers JSON pour Supabase\r\n  factory DailyTrip.fromJson(Map<String, dynamic> json) {\r\n    return DailyTrip(\r\n      id: json['id'],\r\n      type: DailyTripType.values.firstWhere(\r\n              (e) => e.toString() == 'DailyTripType.${json['type']}'\r\n      ),\r\n      date: DateTime.parse(json['date']),\r\n      startPoint: LatLng(json['start_lat'], json['start_lng']),\r\n      endPoint: LatLng(json['end_lat'], json['end_lng']),\r\n      superWowIds: List<String>.from(json['superwow_ids']),\r\n      totalDuration: Duration(seconds: json['total_duration']),\r\n      totalDistance: json['total_distance'],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'type': type.toString().split('.').last,\r\n      'planned_date': date.toIso8601String(),\r\n      'start_lat': startPoint.latitude,\r\n      'start_lng': startPoint.longitude,\r\n      'end_lat': endPoint.latitude,\r\n      'end_lng': endPoint.longitude,\r\n      'superwow_ids': superWowIds,\r\n      'total_duration': totalDuration.inSeconds,\r\n      'total_distance': totalDistance,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 2057,
        "last_modified": "2025-04-16T13:25:26.8039295",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\trip\\trip_model.dart",
      "content": "// lib/core/domain/models/trip_model.dart\r\n\r\nimport '../../shared/city_model.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\nimport 'package:equatable/equatable.dart';\r\n\r\nclass Trip extends Equatable{\r\n  final String id;\r\n  final String userId;\r\n  final String title;\r\n  final DateTime startDate;\r\n  final DateTime endDate;\r\n  final double? dailyBudget;\r\n  final String status;\r\n  final Map<String, dynamic> metadata;\r\n  final TravelGroup travelGroup;\r\n  final int tripDuration;\r\n  final ActivityHours activityHours;\r\n  final String? departureCityId;\r\n  final String? departureGeohash5;\r\n  final TravelStyle? travelStyle;\r\n  final PreferredMoment? preferredMoment;\r\n  final int? maxActivitiesPerDay;\r\n  final DateTime createdAt;\r\n  final DateTime updatedAt;\r\n  final City? departureCity;\r\n  final List<ExplorationType> activeExplorationType;\r\n\r\n  Trip({\r\n    required this.id,\r\n    required this.userId,\r\n    required this.title,\r\n    required this.startDate,\r\n    required this.endDate,\r\n    this.dailyBudget,\r\n    required this.status,\r\n    required this.metadata,\r\n    required this.travelGroup,\r\n    required this.tripDuration,\r\n    required this.activityHours,\r\n    this.departureCityId,\r\n    this.departureGeohash5,\r\n    this.travelStyle,\r\n    this.preferredMoment,\r\n    this.maxActivitiesPerDay,\r\n    required this.createdAt,\r\n    required this.updatedAt,\r\n    this.departureCity,\r\n    required this.activeExplorationType,\r\n  });\r\n\r\n  factory Trip.fromJson(Map<String, dynamic> json) {\r\n    print('Raw JSON in fromJson: ${json}');\r\n\r\n    return Trip(\r\n      id: json['id'],\r\n      userId: json['user_id'],\r\n      title: json['title'],\r\n      startDate: DateTime.parse(json['start_date']),\r\n      endDate: DateTime.parse(json['end_date']),\r\n      dailyBudget: json['daily_budget']?.toDouble(),\r\n      status: json['status'],\r\n      metadata: json['metadata'] ?? {},\r\n      maxActivitiesPerDay: json['max_activities_per_day'],\r\n      travelGroup: TravelGroup.fromJson(json['travel_group'] ?? {}),\r\n      tripDuration: json['trip_duration'],\r\n      activityHours: ActivityHours.fromJson(json['activity_hours'] ?? {}),\r\n      departureCityId: json['departure_city_id'],\r\n      departureGeohash5: json['departure_geohash5'],\r\n      travelStyle: TravelStyleExtension.fromJson(json['travel_style']),\r\n      preferredMoment: PreferredMomentExtension.fromJson(json['preferred_moment']),\r\n      createdAt: DateTime.parse(json['created_at']),\r\n      updatedAt: DateTime.parse(json['updated_at']),\r\n      departureCity: json['departure_city'] != null\r\n          ? City.fromJson(json['departure_city'])\r\n          : null,\r\n      activeExplorationType: (json['active_exploration_types'] as List)\r\n          .map((type) => ExplorationTypeExtension.fromJson(type) ?? ExplorationType.around_me)\r\n          .toList(),\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'user_id': userId,\r\n      'title': title,\r\n      'start_date': startDate.toIso8601String(),\r\n      'end_date': endDate.toIso8601String(),\r\n      'daily_budget': dailyBudget,\r\n      'status': status,\r\n      'metadata': metadata,\r\n      'max_activities_per_day': maxActivitiesPerDay,\r\n      'travel_group': travelGroup.toJson(),\r\n      'trip_duration': tripDuration,\r\n      'activity_hours': activityHours.toJson(),\r\n      'departure_city_id': departureCityId,\r\n      'departure_geohash5': departureGeohash5,\r\n      'travel_style': travelStyle?.value,\r\n      'preferred_moment': preferredMoment?.value,\r\n      'created_at': createdAt.toIso8601String(),\r\n      'updated_at': updatedAt.toIso8601String(),\r\n      'active_exploration_types': activeExplorationType.map((e) => e.value).toList(),\r\n    };\r\n  }\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id,\r\n    userId,\r\n    title,\r\n    startDate,\r\n    endDate,\r\n    dailyBudget,\r\n    status,\r\n    metadata,\r\n    travelGroup,\r\n    tripDuration,\r\n    activityHours,\r\n    departureCityId,\r\n    departureGeohash5,\r\n    travelStyle,\r\n    preferredMoment,\r\n    maxActivitiesPerDay,\r\n    createdAt,\r\n    updatedAt,\r\n    departureCity,\r\n    activeExplorationType,\r\n  ];\r\n}\r\n\r\nclass ActivityHours {\r\n  final String start;\r\n  final String end;\r\n  final Map<String, Map<String, String?>> daily_hours;\r\n\r\n  const ActivityHours({\r\n    required this.start,\r\n    required this.end,\r\n    required this.daily_hours,\r\n  });\r\n\r\n  factory ActivityHours.fromJson(Map<String, dynamic> json) {\r\n    print('ActivityHours JSON: $json');\r\n    return ActivityHours(\r\n      start: json['start'] ?? '',\r\n      end: json['end'] ?? '',\r\n      daily_hours: json['daily_hours'] != null\r\n          ? Map<String, Map<String, String?>>.from(\r\n        json['daily_hours'].map((key, value) => MapEntry(\r\n          key,\r\n          Map<String, String?>.from(value as Map),\r\n        )),\r\n      )\r\n          : {},\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'start': start,\r\n      'end': end,\r\n      'daily_hours': daily_hours,\r\n    };\r\n  }\r\n}\r\n\r\nclass TravelGroup {\r\n  final String type;\r\n  final TravelGroupMembers members;\r\n  final String physicalCondition;\r\n\r\n  const TravelGroup({\r\n    required this.type,\r\n    required this.members,\r\n    required this.physicalCondition,\r\n  });\r\n\r\n  factory TravelGroup.fromJson(Map<String, dynamic> json) {\r\n    return TravelGroup(\r\n      type: json['type'] ?? '',\r\n      members: TravelGroupMembers.fromJson(json['members'] ?? {}),\r\n      physicalCondition: json['physical_condition'] ?? '',\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'type': type,\r\n      'members': members.toJson(),\r\n      'physical_condition': physicalCondition,\r\n    };\r\n  }\r\n}\r\n\r\nclass TravelGroupMembers {\r\n  final bool pmr;\r\n  final int adults;\r\n  final bool seniors;\r\n  final List<int> children;\r\n  final List<int> teenagers;\r\n\r\n  const TravelGroupMembers({\r\n    required this.pmr,\r\n    required this.adults,\r\n    required this.seniors,\r\n    required this.children,\r\n    required this.teenagers,\r\n  });\r\n\r\n  factory TravelGroupMembers.fromJson(Map<String, dynamic> json) {\r\n    return TravelGroupMembers(\r\n      pmr: json['pmr'] ?? false,\r\n      adults: json['adults'] ?? 0,\r\n      seniors: json['seniors'] ?? false,\r\n      children: json['children'] != null\r\n          ? List<int>.from(json['children'])\r\n          : [],\r\n      teenagers: json['teenagers'] != null\r\n          ? List<int>.from(json['teenagers'])\r\n          : [],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'pmr': pmr,\r\n      'adults': adults,\r\n      'seniors': seniors,\r\n      'children': children,\r\n      'teenagers': teenagers,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 6627,
        "last_modified": "2025-04-16T13:25:26.8099481",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\activity_hours_port.dart",
      "content": "// core/domain/ports/activity_hours_port.dart\r\n\r\nimport '../models/opening_days.dart';\r\n\r\nabstract class ActivityHoursPort {\r\n  /// Récupère les horaires d'une activité pour une période donnée\r\n  Future<OpeningDays?> getActivityHours(\r\n      String activityId,\r\n      DateTime startDate,\r\n      DateTime endDate,\r\n      );\r\n}",
      "info": {
        "size": 330,
        "last_modified": "2025-04-16T13:25:26.8334856",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\activity_processing_port.dart",
      "content": "// core/domain/ports/activity_processing_port.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\n\r\nabstract class ActivityProcessingPort {\r\n  /// Récupère les activités brutes dans la zone du voyage\r\n  Future<List<ActivityForProcessing>> getActivitiesForTrip(String tripId);\r\n\r\n  /// Récupère les activités avec les distances par rapport au geohash de départ\r\n  Future<Map<String, List<String>>> getGeohashNeighbors(String geohash4, double maxDistance);\r\n\r\n  /// Applique les filtres et retourne les activités éligibles\r\n  Future<List<ActivityForProcessing>> getFilteredActivities({\r\n    required String tripId,\r\n    required Trip trip,\r\n    required List<ActivityForProcessing> activities,\r\n  });\r\n\r\n  /// Récupère le rayon de recherche basé sur le type d'exploration\r\n  double getExplorationRadius(String explorationType);\r\n}",
      "info": {
        "size": 929,
        "last_modified": "2025-04-16T13:25:26.8384878",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\activity_scoring_port.dart",
      "content": "// core/domain/ports/activity_scoring_port.dart\r\n\r\nimport '../models/trip_designer/scoring/scoring_activity.dart';\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nabstract class ActivityScoringPort {\r\n  Future<List<ScoredActivity>> scoreActivities(String userId, List<ActivityForProcessing> activities);\r\n  Future<Map<String, double>> getUserPreferences(String userId);\r\n}",
      "info": {
        "size": 404,
        "last_modified": "2025-04-16T13:25:26.8459997",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\config\\remote_config_port.dart",
      "content": "// lib/core/domain/ports/config/remote_config_port.dart\r\n\r\nimport '../../models/config/home_section_config.dart';\r\nimport '../../models/config/app_remote_config.dart';\r\nimport '../../models/config/subcategory_section_config.dart';\r\n\r\nabstract class RemoteConfigPort {\r\n  Future<List<HomeSectionConfig>> getHomeSections();\r\n  Future<List<AppRemoteConfig>> getAppConfig();\r\n  Future<List<SubcategorySectionConfig>> getSubcategorySections(String? subcategoryId);  // Nouveau\r\n}\r\n\r\n",
      "info": {
        "size": 478,
        "last_modified": "2025-04-16T13:25:26.8515074",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\daily_trip_generation_port.dart",
      "content": "// core/domain/ports/daily_trip_generation_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../models/trip_designer/trip/daily_trip.dart';\r\nimport '../models/scored_activity.dart';\r\n\r\nabstract class DailyTripGenerationPort {\r\n  Future<List<DailyTrip>> generateHalfDayTrips({\r\n    required String tripId,\r\n    required List<ScoredActivity> superWows,\r\n    required LatLng departurePoint,\r\n    required LatLng arrivalPoint,\r\n  });\r\n\r\n  Future<List<DailyTrip>> generateFullDayTrips({\r\n    required String tripId,\r\n    required List<ScoredActivity> superWows,\r\n    required LatLng departurePoint,\r\n    required LatLng arrivalPoint,\r\n    required Map<String, dynamic> momentPreferences,\r\n  });\r\n}",
      "info": {
        "size": 727,
        "last_modified": "2025-04-16T13:25:26.8637022",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\distance_calculation_port.dart",
      "content": "// lib/core/domain/ports/distance_calculation_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nabstract class DistanceCalculationPort {\r\n  double calculateDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  });\r\n}",
      "info": {
        "size": 346,
        "last_modified": "2025-04-16T13:25:26.8702111",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\available_time_calculation.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/available_time_calculation.port.dart\r\n\r\nimport '../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\n\r\nabstract class AvailableTimeCalculationPort {\r\n  Future<int> calculateAvailableTime({\r\n    required String emptyTripId,\r\n    required Map<String, dynamic> activityHours,\r\n    required String travelStyle,\r\n    required List<String> superWowIds,\r\n  });\r\n\r\n  Future<int> calculateSuperWowDuration({\r\n    required List<String> superWowIds,\r\n    required String travelStyle,\r\n  });\r\n\r\n  int calculateMealBreaksDuration(Map<String, dynamic> activityHours, String travelStyle);\r\n\r\n  Future<Map<DateTime, int>> calculateAvailableTimeForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Map<String, Map<String, String?>> dailyHours,\r\n    required String travelStyle,\r\n  });\r\n}",
      "info": {
        "size": 834,
        "last_modified": "2025-04-16T13:25:26.8762728",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\bonus_activities_cache.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/bonus_activities_cache.port.dart\r\n\r\nabstract class BonusActivitiesCachePort {\r\n  Future<void> cacheEmptyTripBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Map<String, dynamic>> bonusActivities,\r\n  });\r\n\r\n  Future<List<Map<String, dynamic>>> getCachedBonusActivities(String emptyTripId);\r\n}",
      "info": {
        "size": 350,
        "last_modified": "2025-04-16T13:25:26.8827789",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\empty_daily_trip.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/empty_daily_trip_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../common/enums/trip_enums.dart';\r\n\r\n\r\n\r\nabstract class EmptyDailyTripPort {\r\n  /// Vérifie si un empty trip existe déjà avec ces paramètres\r\n  Future<EmptyDailyTrip?> findExistingEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n  });\r\n\r\n  /// Crée un nouvel empty trip\r\n  Future<EmptyDailyTrip> createEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n    required List<String> traversedGeohashes,\r\n    required String routePolyline,\r\n    required int totalDuration,     // Ajout\r\n    required int totalDistance,\r\n  });\r\n\r\n  Future<EmptyDailyTrip> getEmptyTrip(String emptyTripId);\r\n\r\n}",
      "info": {
        "size": 1055,
        "last_modified": "2025-04-16T13:25:26.8887828",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\empty_trip_repository.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/empty_trip_repository.port.dart",
      "info": {
        "size": 68,
        "last_modified": "2025-04-16T13:25:26.8952975",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\geometry_calculation.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/geometry_calculation.port.dart\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nabstract class GeometryCalculationPort {\r\n  Future<double> calculateDistance(LatLng point1, LatLng point2);\r\n  Future<int> calculateMalusMinutes(double distanceMeters, String travelStyle);\r\n  Future<bool> isLocationOnPath(LatLng point, List<LatLng> pathPoints);\r\n  Future<bool> isWithinMaxDetour(LatLng point, LatLng start, LatLng end);\r\n}",
      "info": {
        "size": 474,
        "last_modified": "2025-04-16T13:25:26.9023451",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\neighbor_geohashes.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/neighbor_geohashes.port.dart\r\n\r\nabstract class NeighborGeohashesPort {\r\n  Future<void> generateAndSaveNeighbors({\r\n    required String emptyTripId,\r\n    required List<String> traversedGeohashes,\r\n  });\r\n\r\n  Future<Map<String, Map<String, dynamic>>> getNeighborGeohashes(String emptyTripId);\r\n}",
      "info": {
        "size": 330,
        "last_modified": "2025-04-16T13:25:26.9084206",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\potential_activities.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/potential_activities.port.dart\r\n\r\nimport '../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../models/trip_designer/trip/activity_model.dart';\r\n\r\nabstract class PotentialActivitiesPort {\r\n  Future<Map<String, List<Activity>>> getFilteredActivitiesForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required String tripId,\r\n    required Map<DateTime, int> availableTimeByDate,\r\n  });\r\n}",
      "info": {
        "size": 456,
        "last_modified": "2025-04-16T13:25:26.9149334",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\route_optimization.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/route_optimization.port.dart\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../models/trip_designer/trip/trip_model.dart';\r\n\r\nabstract class RouteOptimizationPort {\r\n  /// Calcule le trajet optimal entre plusieurs points\r\n  Future<Map<String, dynamic>> getOptimizedRoute(\r\n      LatLng origin,\r\n      LatLng destination,\r\n      List<LatLng> waypoints,\r\n      );\r\n\r\n  /// Obtient le temps de trajet estimé entre deux points\r\n  Future<Duration> getTravelTime(\r\n      LatLng origin,\r\n      LatLng destination,\r\n      {DateTime? departureTime}\r\n      );\r\n\r\n  /// Vérifie si un détour par un point est viable\r\n  Future<Map<String, dynamic>> evaluateDetour(\r\n      LatLng origin,\r\n      LatLng destination,\r\n      LatLng detourPoint,\r\n      Duration maxDetourTime,\r\n      );\r\n}",
      "info": {
        "size": 840,
        "last_modified": "2025-04-16T13:25:26.9289502",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\superwow_management.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/superwow_management.port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../models/scored_activity.dart';\r\nimport '../../models/trip_designer/empty_trips/value_objects/superwow_pair.dart';\r\n\r\n// lib/core/domain/ports/empty_trips/superwow_management.port.dart\r\n\r\nabstract class SuperWowManagementPort {\r\n  // Les méthodes existantes restent\r\n  Future<List<ScoredActivity>> getTripSuperWows(String tripId);\r\n  Future<ScoredActivity> findClosestSuperWow(\r\n      List<ScoredActivity> superWows,\r\n      LatLng fromPoint,\r\n      );\r\n\r\n  // Nouvelle méthode plus simple qui fait tout le processus\r\n  Future<List<SuperWowPair>> generateOptimizedPairs(\r\n      String tripId,\r\n      List<ScoredActivity> superWows,\r\n      LatLng departurePoint,\r\n      );\r\n}",
      "info": {
        "size": 821,
        "last_modified": "2025-04-16T13:25:26.9354588",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\geocoding_port.dart",
      "content": "// core/domain/ports/geocoding_port.dart\r\n\r\nimport '../models/shared/city_model.dart';\r\n\r\n\r\nabstract class GeocodingPort {\r\n  Future<City> getCity(String cityName);\r\n  Future<List<City>> getMultipleCities(List<String> cityNames);\r\n}",
      "info": {
        "size": 232,
        "last_modified": "2025-04-16T13:25:26.9469668",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\city_cache_port.dart",
      "content": "// lib/core/domain/ports/location/city_cache_port.dart\r\n\r\nimport '../../models/shared/city_model.dart';\r\nimport '../../models/location/place_details.dart';\r\n\r\n/// Port pour interagir avec le cache de villes dans Supabase\r\nabstract class CityCachePort {\r\n  /// Vérifie si une ville existe dans le cache par son place_id Google\r\n  Future<City?> getCityByPlaceId(String placeId);\r\n\r\n  /// Vérifie si une ville existe dans le cache par son nom\r\n  Future<City?> getCityByName(String cityName);\r\n\r\n  /// Sauvegarde les informations d'une ville dans le cache\r\n  Future<City> saveCity({\r\n    required String placeId,\r\n    required String cityName,\r\n    required double lat,\r\n    required double lon,\r\n  });\r\n\r\n  /// Convertit un PlaceDetails en City et le sauvegarde\r\n  Future<City> savePlaceDetailsAsCity(PlaceDetails placeDetails);\r\n}",
      "info": {
        "size": 830,
        "last_modified": "2025-04-16T13:25:26.9534755",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\geolocation_port.dart",
      "content": "// lib/core/domain/ports/location/geolocation_port.dart\r\n\r\nimport 'package:async/async.dart';\r\nimport '../../../domain/models/location/user_location.dart';\r\n\r\nabstract class GeolocationPort {\r\n  /// Récupère la position actuelle de l'utilisateur\r\n  Future<Result<UserLocation>> getCurrentLocation();\r\n\r\n  /// Vérifie si les services de localisation sont activés\r\n  Future<bool> isLocationServiceEnabled();\r\n\r\n  /// Demande la permission d'accéder à la localisation\r\n  Future<bool> requestLocationPermission();\r\n}",
      "info": {
        "size": 518,
        "last_modified": "2025-04-16T13:25:26.9604842",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\location_cache_port.dart",
      "content": "//lib/core/domain/ports/location/location_cache_port.dart\r\n\r\nimport '../../../domain/models/location/place_suggestion.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\n\r\nabstract class LocationCachePort {\r\n  /// Sauvegarde une suggestion de lieu dans le cache\r\n  Future<void> savePlaceSuggestion(PlaceSuggestion suggestion);\r\n\r\n  /// Sauvegarde plusieurs suggestions de lieu dans le cache\r\n  Future<void> savePlaceSuggestions(List<PlaceSuggestion> suggestions);\r\n\r\n  /// Récupère les suggestions de lieu du cache correspondant à un préfixe\r\n  Future<List<PlaceSuggestion>> getPlaceSuggestions(String prefix, {int limit = 5});\r\n\r\n  /// Sauvegarde les détails d'un lieu dans le cache\r\n  Future<void> savePlaceDetails(PlaceDetails details);\r\n\r\n  /// Récupère les détails d'un lieu du cache\r\n  Future<PlaceDetails?> getPlaceDetails(String placeId);\r\n\r\n  /// Efface le cache des lieux\r\n  Future<void> clearCache();\r\n}",
      "info": {
        "size": 940,
        "last_modified": "2025-04-16T13:25:26.9659934",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\place_details_port.dart",
      "content": "// lib/core/domain/ports/location/place_details_port.dart\r\nimport 'package:async/async.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\n\r\nabstract class PlaceDetailsPort {\r\n  /// Récupère les détails d'un lieu à partir de son ID\r\n  Future<Result<PlaceDetails>> getPlaceDetailsById(String placeId);\r\n}",
      "info": {
        "size": 325,
        "last_modified": "2025-04-16T13:25:26.9740084",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\place_search_port.dart",
      "content": "// lib/core/domain/ports/location/place_search_port.dart\r\n\r\n\r\nimport 'package:async/async.dart';\r\nimport '../../../domain/models/location/place_suggestion.dart';\r\nimport '../../../domain/models/location/user_location.dart';\r\n\r\nabstract class PlaceSearchPort {\r\n  /// Recherche des lieux à partir d'un texte\r\n  Future<Result<List<PlaceSuggestion>>> searchPlaces(\r\n      String query, {\r\n        UserLocation? locationBias,\r\n        int radius = 50000,\r\n      });\r\n}",
      "info": {
        "size": 465,
        "last_modified": "2025-04-16T13:25:26.9805119",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\maps_port.dart",
      "content": "// core/domain/ports/maps_port.dart\r\n\r\nabstract class MapsPort {\r\n  /// Récupère les détails de géolocalisation d'une ville\r\n  Future<Map<String, dynamic>?> getPlaceDetails(String cityName);\r\n\r\n  /// Enrichit les données d'une ville avec ses coordonnées\r\n  Future<bool> enrichCityData(String cityName);\r\n\r\n  /// Enrichit les données de plusieurs villes\r\n  Future<List<String>> enrichMultipleCities(List<String> cityNames);\r\n}",
      "info": {
        "size": 432,
        "last_modified": "2025-04-16T13:25:26.9920234",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\config\\remote_config_provider.dart",
      "content": "// lib/core/domain/ports/providers/config/remote_config_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../adapters/supabase/config/remote_config_adapter.dart';\r\nimport '../../../../domain/models/config/home_section_config.dart';\r\nimport '../../../../adapters/supabase/database_adapter.dart';\r\nimport '../../../../domain/models/config/subcategory_section_config.dart';\r\n\r\n\r\nfinal remoteConfigProvider = Provider((ref) =>\r\n    SupabaseRemoteConfigAdapter(SupabaseService.client)\r\n);\r\n\r\nfinal homeSectionsConfigProvider = FutureProvider<List<HomeSectionConfig>>((ref) async {\r\n  print('📥 Starting to fetch home sections');\r\n  try {\r\n    final configAdapter = ref.watch(remoteConfigProvider);\r\n    print('📦 Got config adapter');\r\n    final sections = await configAdapter.getHomeSections();\r\n    print('📋 Fetched sections: $sections');\r\n    return sections;\r\n  } catch (e) {\r\n    print('❌ Error fetching sections: $e');\r\n    rethrow;\r\n  }\r\n});\r\n\r\nfinal subcategorySectionsConfigProvider =\r\nFutureProvider.family<List<SubcategorySectionConfig>, String?>((ref, subcategoryId) async {\r\n  print('📥 Starting to fetch subcategory sections for id: $subcategoryId');\r\n  try {\r\n    final configAdapter = ref.watch(remoteConfigProvider);\r\n    print('📦 Got config adapter');\r\n    final sections = await configAdapter.getSubcategorySections(subcategoryId);\r\n    print('📋 Fetched subcategory sections: $sections');\r\n    return sections;\r\n  } catch (e) {\r\n    print('❌ Error fetching subcategory sections: $e');\r\n    rethrow;\r\n  }\r\n});",
      "info": {
        "size": 1583,
        "last_modified": "2025-04-16T13:25:26.999026",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\daily_trip_generation_provider.dart",
      "content": "// // lib/core/domain/ports/providers/route_optimization_providers.dart\r\n//\r\n// import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n// import '../../ports/daily_trip_generation_port.dart';\r\n// import '../../../adapters/supabase/daily_trip_generation_adapter.dart';\r\n// import 'infrastructure_providers.dart';\r\n// import 'empty_trips/route_optimization_providers.dart';\r\n// import 'empty_trips/empty_daily_trip_provider.dart';\r\n//\r\n// final dailyTripGenerationPortProvider = Provider<DailyTripGenerationPort>((ref) {\r\n//   final supabase = ref.watch(supabaseProvider);\r\n//   final routeOptimization = ref.watch(routeOptimizationPortProvider);\r\n//   final emptyTripPort = ref.watch(emptyDailyTripPortProvider);\r\n//\r\n//   return DailyTripGenerationAdapter(\r\n//     supabase,\r\n//     routeOptimization,\r\n//     emptyTripPort,\r\n//   );\r\n// });",
      "info": {
        "size": 844,
        "last_modified": "2025-04-16T13:25:27.0105446",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\bonus_activities.providers.dart",
      "content": "// lib/features/empty_trips/presentation/state/providers/bonus_activities.providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../../adapters/supabase/potential_bonus_activity.adapter.dart';\r\nimport '../../../../adapters/postgis/geometry_calculation.adapter.dart';\r\nimport '../../../services/designer/empty_trips/distance_calculation.service.dart';\r\nimport '../../../services/designer/empty_trips/bonus_activity_generation.service.dart';\r\nimport '../../../services/designer/empty_trips/available_time_calculation.service.dart';\r\nimport '../../../services/designer/empty_trips/notifier/potential_bonus_activities.notifier.dart';\r\nimport '../../../models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\n\r\n\r\n// Adapters providers\r\nfinal potentialBonusActivityAdapterProvider = Provider<PotentialBonusActivityAdapter>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return PotentialBonusActivityAdapter(supabase);\r\n});\r\n\r\nfinal geometryCalculationAdapterProvider = Provider<GeometryCalculationAdapter>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return GeometryCalculationAdapter(supabase);\r\n});\r\n\r\n// Services providers\r\nfinal distanceCalculationServiceProvider = Provider<DistanceCalculationService>((ref) {\r\n  final geometryPort = ref.watch(geometryCalculationAdapterProvider);\r\n  return DistanceCalculationService(geometryPort);\r\n});\r\n\r\nfinal bonusActivityGenerationServiceProvider = Provider<BonusActivityGenerationService>((ref) {\r\n  final geometryPort = ref.watch(geometryCalculationAdapterProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n  final availableTimeService = ref.watch(availableTimeServiceProvider); // Ajouter ce provider\r\n\r\n  return BonusActivityGenerationService(\r\n      geometryPort,\r\n      distanceService,\r\n      availableTimeService // Ajouter le 3ème argument\r\n  );\r\n});\r\n\r\nfinal availableTimeServiceProvider = Provider<AvailableTimeCalculationService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return AvailableTimeCalculationService(supabase);\r\n});\r\n\r\n// State providers si nécessaire pour la gestion d'état\r\nfinal potentialBonusActivitiesProvider = StateNotifierProvider<PotentialBonusActivitiesNotifier, AsyncValue<List<PotentialBonusActivity>>>((ref) {\r\n  final adapter = ref.watch(potentialBonusActivityAdapterProvider);\r\n  final geometryPort = ref.watch(geometryCalculationAdapterProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n  final availableTimeService = ref.watch(availableTimeServiceProvider);\r\n\r\n  final bonusService = BonusActivityGenerationService(\r\n      geometryPort,\r\n      distanceService,\r\n      availableTimeService\r\n  );\r\n\r\n  return PotentialBonusActivitiesNotifier(adapter, bonusService);\r\n});",
      "info": {
        "size": 2864,
        "last_modified": "2025-04-16T13:25:27.0165513",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\bonus_activities_cache.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/bonus_activities_cache.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../services/designer/empty_trips/bonus_activities_cache.service.dart';\r\n\r\n\r\nfinal bonusActivitiesCacheProvider = Provider<BonusActivitiesCacheService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return BonusActivitiesCacheService(supabase);\r\n});",
      "info": {
        "size": 475,
        "last_modified": "2025-04-16T13:25:27.0235609",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\distance_calculation_provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/distance_calculation.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../services/designer/empty_trips/distance_calculation.service.dart';\r\n\r\nfinal distanceCalculationServiceProvider = Provider<DistanceCalculationService>((ref) {\r\n  return DistanceCalculationService();\r\n});",
      "info": {
        "size": 357,
        "last_modified": "2025-04-16T13:25:27.0300684",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\empty_daily_trip.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/empty_daily_trip.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../empty_trips/empty_daily_trip.port.dart';\r\nimport '../../../../adapters/supabase/empty_daily_trip.adapter.dart';\r\nimport '../infrastructure_providers.dart';\r\n\r\nfinal emptyDailyTripPortProvider = Provider<EmptyDailyTripPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return EmptyDailyTripAdapter(supabase);\r\n});",
      "info": {
        "size": 480,
        "last_modified": "2025-04-16T13:25:27.0360733",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\empty_trip_generation.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/empty_trip_generation.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../services/designer/empty_trips/empty_trip_generation.service.dart';\r\nimport 'superwow_management.provider.dart';\r\nimport 'route_optimization.provider.dart';\r\nimport '../infrastructure_providers.dart';\r\nimport 'empty_daily_trip.provider.dart';\r\nimport 'neighbor_geohashes.provider.dart';\r\n\r\nfinal emptyTripGenerationServiceProvider = Provider<EmptyTripGenerationService>((ref) {\r\n  final superwowPort = ref.watch(superwowManagementPortProvider);\r\n  final routePort = ref.watch(routeOptimizationPortProvider);\r\n  final emptyTripPort = ref.watch(emptyDailyTripPortProvider);\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final neighborGeohashesService = ref.watch(neighborGeohashesProvider);\r\n\r\n  return EmptyTripGenerationService(\r\n    superwowPort,\r\n    routePort,\r\n    emptyTripPort,\r\n    neighborGeohashesService,\r\n    supabase,\r\n  );\r\n});",
      "info": {
        "size": 1006,
        "last_modified": "2025-04-16T13:25:27.0420908",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\geometry_calculation.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/geometry_calculation.provider.dart\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../../adapters/postgis/geometry_calculation.adapter.dart';\r\nimport '../../empty_trips/geometry_calculation.port.dart';\r\n\r\nfinal geometryCalculationPortProvider = Provider<GeometryCalculationPort>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return GeometryCalculationAdapter(supabase);\r\n});",
      "info": {
        "size": 515,
        "last_modified": "2025-04-16T13:25:27.0490911",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\google_ai_studio.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/google_ai_studio.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../adapters/google/google_ai_studio_service.dart';\r\nimport 'google_services_config.provider.dart';\r\n\r\nfinal googleAIStudioServiceProvider = Provider<GoogleAIStudioService?>((ref) {\r\n  final config = ref.watch(googleServicesConfigProvider);\r\n\r\n  try {\r\n    return GoogleAIStudioService(config);\r\n  } catch (e) {\r\n    print('❌ Erreur initialisation Google AI Studio: $e');\r\n    return null;\r\n  }\r\n});",
      "info": {
        "size": 552,
        "last_modified": "2025-04-16T13:25:27.054595",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\google_services_config.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/google_services_config.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../services/google_services_config.dart';\r\n\r\nfinal googleServicesConfigProvider = Provider<GoogleServicesConfig>((ref) {\r\n  throw UnimplementedError('Doit être surchargé au niveau de l\\'app');\r\n});",
      "info": {
        "size": 354,
        "last_modified": "2025-04-16T13:25:27.0616071",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\neighbor_geohashes.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/neighbor_geohashes.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../services/designer/empty_trips/neighbor_geohashes.service.dart';\r\n\r\nfinal neighborGeohashesProvider = Provider<NeighborGeohashesService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return NeighborGeohashesService(supabase);\r\n});",
      "info": {
        "size": 456,
        "last_modified": "2025-04-16T13:25:27.0671124",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\potential_activities.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/potential_activities.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../services/designer/empty_trips/potential_activities.service.dart';\r\n\r\nfinal potentialActivitiesProvider = Provider<PotentialActivitiesService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return PotentialActivitiesService(supabase);\r\n});",
      "info": {
        "size": 466,
        "last_modified": "2025-04-16T13:25:27.0741319",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\route_optimization.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/route_optimization.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../empty_trips/route_optimization.port.dart';\r\nimport '../../../../adapters/google/route_optimization.adapter.dart';\r\nimport '../infrastructure_providers.dart';\r\nimport './google_services_config.provider.dart';\r\nimport './google_ai_studio.provider.dart';\r\n\r\nfinal routeOptimizationPortProvider = Provider<RouteOptimizationPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final config = ref.watch(googleServicesConfigProvider);\r\n  final googleService = ref.watch(googleAIStudioServiceProvider);\r\n\r\n  return RouteOptimizationAdapter(supabase, config, googleService);\r\n});",
      "info": {
        "size": 734,
        "last_modified": "2025-04-16T13:25:27.0811966",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\superwow_management.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/superwow_management.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'route_optimization.provider.dart';\r\nimport 'distance_calculation_provider.dart';\r\nimport '../infrastructure_providers.dart';\r\nimport '../../empty_trips/superwow_management.port.dart';\r\nimport '../../../../adapters/supabase/superwow_management.adapter.dart';\r\nimport '../../../services/designer/empty_trips/distance_calculation.service.dart';\r\n\r\nfinal superwowManagementPortProvider = Provider<SuperWowManagementPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final routeOptimization = ref.watch(routeOptimizationPortProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n\r\n  return SuperWowManagementAdapter(\r\n    supabase,\r\n    routeOptimization,\r\n    distanceService,\r\n  );\r\n});",
      "info": {
        "size": 875,
        "last_modified": "2025-04-16T13:25:27.0871977",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\infrastructure_providers.dart",
      "content": "// core/domain/ports/providers/infrastructure_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\nfinal supabaseProvider = Provider<SupabaseClient>((ref) {\r\n  return Supabase.instance.client;\r\n});",
      "info": {
        "size": 280,
        "last_modified": "2025-04-16T13:25:27.0992589",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\location\\location_providers.dart",
      "content": "// lib/core/domain/ports/providers/location/location_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:http/http.dart' as http;\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport '../../../../domain/services/location_service.dart';\r\nimport '../../../../adapters/google_maps/maps_adapter.dart';\r\nimport '../../../../adapters/cache/hive_location_cache_adapter.dart';\r\nimport '../../../services/location/enhanced_location_service.dart';\r\nimport '../../../ports/location/location_cache_port.dart';\r\nimport '../../../ports/location/city_cache_port.dart';\r\nimport '../../../../adapters/supabase/search/city_cache_adapter.dart';\r\n\r\n// Provider pour Supabase client\r\nfinal supabaseClientProvider = Provider<SupabaseClient>((ref) {\r\n  return Supabase.instance.client;\r\n});\r\n\r\n// Provider pour le client HTTP\r\nfinal httpClientProvider = Provider<http.Client>((ref) {\r\n  return http.Client();\r\n});\r\n\r\n// Provider pour le LocationService\r\nfinal locationServiceProvider = Provider<LocationService>((ref) {\r\n  final supabase = ref.watch(supabaseClientProvider);\r\n  return LocationService(supabase);\r\n});\r\n\r\n// Provider pour l'adapter de cache de villes\r\nfinal cityCacheProvider = Provider<CityCachePort>((ref) {\r\n  final supabase = ref.watch(supabaseClientProvider);\r\n  return SupabaseCityCacheAdapter(supabase);\r\n});\r\n\r\n// Provider d'état interne pour stocker l'instance initialisée\r\nfinal initializedCacheProvider = StateProvider<HiveLocationCacheAdapter?>((ref) => null);\r\n\r\n// Provider d'initialisation qui retourne l'adaptateur une fois initialisé\r\nfinal cacheInitializationProvider = FutureProvider<HiveLocationCacheAdapter>((ref) async {\r\n  // Initialisation de Hive lui-même si pas déjà fait\r\n  // Note: Normalement ceci devrait être fait au démarrage de l'app (main.dart)\r\n  try {\r\n    await Hive.initFlutter();\r\n  } catch (e) {\r\n    // Ignorer l'erreur si Hive est déjà initialisé\r\n    print('Note: Hive.initFlutter a lancé une erreur, probablement déjà initialisé: $e');\r\n  }\r\n\r\n  final cacheAdapter = HiveLocationCacheAdapter();\r\n  await cacheAdapter.initializeAsync();\r\n\r\n  // Stocker l'instance initialisée pour qu'elle soit utilisée par le provider suivant\r\n  ref.read(initializedCacheProvider.notifier).state = cacheAdapter;\r\n\r\n  return cacheAdapter;\r\n});\r\n\r\n// Provider pour le cache de localisation\r\nfinal locationCacheProvider = Provider<LocationCachePort>((ref) {\r\n  // Vérifier d'abord si nous avons déjà une instance initialisée\r\n  final initializedCache = ref.watch(initializedCacheProvider);\r\n  if (initializedCache != null && initializedCache.isInitialized) {\r\n    return initializedCache;\r\n  }\r\n\r\n  // Sinon, créer une nouvelle instance et l'initialiser de manière synchrone\r\n  final adapter = HiveLocationCacheAdapter();\r\n  adapter.initialize(); // Initialisation synchrone\r\n  return adapter;\r\n});\r\n\r\n// Provider pour l'adaptateur Google Maps existant\r\nfinal googleMapsAdapterProvider = Provider<GoogleMapsAdapter>((ref) {\r\n  final locationService = ref.watch(locationServiceProvider);\r\n  final httpClient = ref.watch(httpClientProvider);\r\n\r\n  return GoogleMapsAdapter(locationService, httpClient: httpClient);\r\n});\r\n\r\n\r\n// Provider pour le service de localisation avancé\r\nfinal enhancedLocationServiceProvider = Provider<EnhancedLocationService>((ref) {\r\n  final mapsAdapter = ref.watch(googleMapsAdapterProvider);\r\n  final locationCache = ref.watch(locationCacheProvider);\r\n  final cityCache = ref.watch(cityCacheProvider);\r\n\r\n  return EnhancedLocationService(\r\n    mapsAdapter: mapsAdapter,\r\n    locationCache: locationCache,\r\n    cityCache: cityCache,\r\n  );\r\n});",
      "info": {
        "size": 3710,
        "last_modified": "2025-04-16T13:25:27.1052975",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\port_providers.dart",
      "content": "// core/domain/ports/providers/port_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../adapters/trip/trip_adapter.dart';\r\nimport '../../../adapters/supabase/activity_processing_adapter.dart';\r\nimport '../trip_port.dart';\r\nimport '../activity_processing_port.dart';\r\nimport '../../../adapters/supabase/activity_hours_adapter.dart';\r\nimport '../activity_hours_port.dart';\r\n\r\nfinal supabaseProvider = Provider((ref) => Supabase.instance.client);\r\n\r\nfinal tripPortProvider = Provider<TripPort>((ref) {\r\n  final supabase = Supabase.instance.client;  // Utilisation directe de Supabase.instance\r\n  return TripAdapter(supabase);\r\n});\r\n\r\nfinal activityProcessingPortProvider = Provider<ActivityProcessingPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return ActivityProcessingAdapter(supabase);\r\n});\r\n\r\nfinal activityHoursPortProvider = Provider<ActivityHoursPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return ActivityHoursAdapter(supabase);\r\n});",
      "info": {
        "size": 1079,
        "last_modified": "2025-04-16T13:25:27.1173144",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\scoring_providers.dart",
      "content": "// core/domain/providers/scoring_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'infrastructure_providers.dart';\r\nimport '../activity_scoring_port.dart';\r\nimport '../../../adapters/supabase/activity_scoring_adapter.dart';\r\nimport '../../services/scoring_service.dart';\r\n\r\nfinal scoringServiceProvider = Provider<ScoringService>((ref) {\r\n  return ScoringService();\r\n});\r\n\r\nfinal activityScoringPortProvider = Provider<ActivityScoringPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return ActivityScoringAdapter(supabase);\r\n});",
      "info": {
        "size": 579,
        "last_modified": "2025-04-16T13:25:27.1233235",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\search\\activity_distances_provider.dart",
      "content": "// lib/core/domain/ports/providers/search/activity_distances_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../models/activity/search/searchable_activity.dart';\r\nimport '../../../ports/search/activity_distance_calculation_port.dart';\r\nimport 'distance_providers.dart';\r\n\r\nfinal activityDistancesProvider = StateNotifierProvider<ActivityDistancesNotifier, Map<String, double>>((ref) {\r\n  final distanceCalculator = ref.watch(activityDistanceProvider);\r\n  return ActivityDistancesNotifier(distanceCalculator);\r\n});\r\n\r\nclass ActivityDistancesNotifier extends StateNotifier<Map<String, double>> {\r\n  final ActivityDistanceCalculationPort _distanceCalculator;\r\n\r\n  ActivityDistancesNotifier(this._distanceCalculator) : super({});\r\n\r\n  void cacheDistances(List<SearchableActivity> activities, LatLng userLocation) {\r\n    final newDistances = <String, double>{};\r\n\r\n    for (final activity in activities) {\r\n      final distance = _distanceCalculator.calculateDistance(\r\n        activityId: activity.base.id,\r\n        userLocation: userLocation,\r\n        activityLocation: LatLng(activity.base.latitude, activity.base.longitude),\r\n        approximateDistance: activity.approxDistanceKm,\r\n      );\r\n      newDistances[activity.base.id] = distance;\r\n    }\r\n\r\n    state = {...state, ...newDistances};\r\n  }\r\n\r\n  double? getDistance(String activityId) => state[activityId];\r\n\r\n  void clearCache() {\r\n    _distanceCalculator.clearCache();\r\n    state = {};\r\n  }\r\n}",
      "info": {
        "size": 1556,
        "last_modified": "2025-04-16T13:25:27.1303275",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\search\\distance_providers.dart",
      "content": "// lib/core/domain/providers/search/distance_providers.dart\r\n\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../../ports/search/activity_distance_calculation_port.dart';\r\nimport '../../../services/search/activity_distance_service.dart';\r\n\r\nfinal activityDistanceProvider = Provider<ActivityDistanceCalculationPort>((ref) {\r\n  return ActivityDistanceService();\r\n});",
      "info": {
        "size": 371,
        "last_modified": "2025-04-16T13:25:27.1358348",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\search\\subcategory_search_provider.dart",
      "content": "// lib/core/domain/providers/search/subcategory_search_provider.dart\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../search/subcategory_search_port.dart';\r\nimport '../../../models/shared/subcategory_model.dart';\r\nimport '../../../../adapters/supabase/search/subcategory_search_adapter.dart';\r\nimport '../../../../adapters/supabase/database_adapter.dart';\r\n\r\nfinal subcategorySearchProvider = Provider<SubcategorySearchPort>((ref) {\r\n  return SubcategorySearchAdapter(SupabaseService.client);\r\n});\r\n\r\nfinal subcategoriesProvider = FutureProvider<List<Subcategory>>((ref) async {\r\n  final subcategorySearchPort = ref.read(subcategorySearchProvider);\r\n  return subcategorySearchPort.getSubcategoriesForSearch();\r\n});",
      "info": {
        "size": 722,
        "last_modified": "2025-04-16T13:25:27.1433415",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\service_providers.dart",
      "content": "// core/domain/ports/providers/service_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../adapters/google_maps/maps_adapter.dart';\r\nimport '../../../adapters/google_maps/geocoding_adapter.dart';\r\nimport '../maps_port.dart';\r\nimport '../geocoding_port.dart';\r\nimport 'infrastructure_providers.dart';\r\nimport '../../services/location_service.dart';\r\n\r\n\r\n// Service de base pour les opérations de localisation\r\nfinal locationServiceProvider = Provider<LocationService>((ref) {\r\n  return LocationService(ref.watch(supabaseProvider));\r\n});\r\n\r\n// Service Google Maps qui dépend du LocationService\r\nfinal mapsServiceProvider = Provider<MapsPort>((ref) {\r\n  return GoogleMapsAdapter(ref.watch(locationServiceProvider));\r\n});\r\n\r\n// Service Geocoding qui dépend des deux précédents\r\nfinal geocodingServiceProvider = Provider<GeocodingPort>((ref) {\r\n  return GeocodingAdapter(\r\n      ref.watch(locationServiceProvider),\r\n      ref.watch(mapsServiceProvider)\r\n  );\r\n});",
      "info": {
        "size": 1004,
        "last_modified": "2025-04-16T13:25:27.1548492",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\trip_activities_providers.dart",
      "content": "// lib/core/domain/ports/providers/trip_activities_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../ports/trip_activities_port.dart';\r\nimport '../../../adapters/supabase/trip_activities_adapter.dart';\r\nimport 'infrastructure_providers.dart';\r\n\r\nfinal tripActivitiesPortProvider = Provider<TripActivitiesPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return TripActivitiesAdapter(supabase);\r\n});",
      "info": {
        "size": 454,
        "last_modified": "2025-04-16T13:25:27.1608581",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\use_case_providers.dart",
      "content": "// core/domain/ports/providers/use_case_providers.dart\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../use_cases/create_trip_use_case.dart';\r\nimport '../../use_cases/process_activities_use_case.dart';\r\nimport 'port_providers.dart';\r\nimport 'service_providers.dart';\r\n\r\nfinal createTripUseCaseProvider = Provider((ref) {\r\n  return CreateTripUseCase(\r\n      ref.watch(tripPortProvider),\r\n      ref.watch(geocodingServiceProvider)\r\n  );\r\n});\r\n\r\nfinal processActivitiesUseCaseProvider = Provider<ProcessActivitiesUseCase>((ref) {\r\n  final processingPort = ref.watch(activityProcessingPortProvider);\r\n  final tripPort = ref.watch(tripPortProvider);\r\n  return ProcessActivitiesUseCase(processingPort, tripPort);\r\n});",
      "info": {
        "size": 735,
        "last_modified": "2025-04-16T13:25:27.1663668",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\activity_details_port.dart",
      "content": "// features/search/domain/ports/activity_details_port.dart\r\n\r\nimport '../../../../core/domain/models/shared/activity_details_model.dart';\r\n\r\nabstract class ActivityDetailsPort {\r\n  Future<ActivityDetails> getActivityDetails(String activityId);\r\n}\r\n\r\n",
      "info": {
        "size": 250,
        "last_modified": "2025-04-16T13:25:27.1783814",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\activity_distance_calculation_port.dart",
      "content": "// lib/core/domain/ports/search/activity_distance_calculation_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nabstract class ActivityDistanceCalculationPort {\r\n  double calculateDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  });\r\n\r\n  // Facultatif : méthode pour nettoyer le cache si nécessaire\r\n  void clearCache();\r\n}",
      "info": {
        "size": 460,
        "last_modified": "2025-04-16T13:25:27.1848912",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\activity_search_port.dart",
      "content": "// lib/core/domain/ports/activity_search_port.dart\r\n\r\nimport '../../models/activity/search/searchable_activity.dart';\r\n\r\nabstract class ActivitySearchPort {\r\n  /// Récupère les activités avec des filtres spécifiques\r\n  Future<List<SearchableActivity>> getActivitiesWithFilters({\r\n    required double latitude,\r\n    required double longitude,\r\n    required String cityId,\r\n    double? maxDistance,\r\n    String? categoryId,\r\n    String? subcategoryId,\r\n    bool? isWow,\r\n    double? minRating,\r\n    int? minRatingCount,\r\n    int? maxRatingCount,\r\n    bool? kidFriendly,\r\n    String orderBy = 'rating_avg',\r\n    String orderDirection = 'DESC',\r\n    int limit = 10,\r\n  });\r\n}",
      "info": {
        "size": 675,
        "last_modified": "2025-04-16T13:25:27.1913967",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\city_search_port.dart",
      "content": "// lib/core/domain/ports/city_search_port.dart\r\n\r\nimport '../../models/shared/city_model.dart';\r\n\r\n\r\nabstract class CitySearchPort {\r\n  Future<List<City>> searchCities(String? query);\r\n  Future<City?> getCityById(String id);\r\n}",
      "info": {
        "size": 227,
        "last_modified": "2025-04-16T13:25:27.1983993",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\subcategory_search_port.dart",
      "content": "// lib/core/domain/ports/search/subcategory_search_port.dart\r\nimport '../../models/shared/subcategory_model.dart';\r\n\r\nabstract class SubcategorySearchPort {\r\n  Future<List<Subcategory>> getSubcategoriesForSearch();\r\n}",
      "info": {
        "size": 217,
        "last_modified": "2025-04-16T13:25:27.2049068",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\trip_activities_port.dart",
      "content": "// core/domain/ports/trip_activities_port.dart\r\n\r\nimport '../models/scored_activity.dart';\r\n\r\nabstract class TripActivitiesPort {\r\n  Future<void> saveFilteredActivities({\r\n    required String tripId,\r\n    required List<ScoredActivity> activities,\r\n    required bool isSuperwow,\r\n  });\r\n\r\n  Future<List<ScoredActivity>> getSuperwowActivities(String tripId);\r\n}",
      "info": {
        "size": 359,
        "last_modified": "2025-04-16T13:25:27.2159241",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\trip_port.dart",
      "content": "// core/domain/ports/trip_port.dart\r\n\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../models/shared/city_model.dart';\r\nimport '../use_cases/create_trip_use_case.dart'; // Pour CreateTripParams\r\n\r\n/// Port définissant les opérations de gestion des voyages\r\nabstract class TripPort {\r\n  /// Crée un nouveau voyage\r\n  Future<Trip> createTrip(CreateTripParams params, City departureCity);\r\n\r\n  /// Récupère un voyage par son ID\r\n  Future<Trip> getTrip(String tripId);\r\n\r\n  /// Récupère tous les voyages d'un utilisateur\r\n  Future<List<Trip>> getTripsForUser(String userId);\r\n}",
      "info": {
        "size": 599,
        "last_modified": "2025-04-16T13:25:27.2229317",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\available_time_calculation.service.dart",
      "content": "// lib/core/domain/services/empty_trips/available_time_calculation.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/available_time_calculation.port.dart';\r\nimport '../../../../common/constants/trip_constants.dart';\r\nimport '../../../../common/exceptions/calculation_exception.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\n\r\n/// Service dédié au calcul du temps disponible pour un emptyTrip, \r\n/// intégrant la durée des SW, le temps de trajet principal, et les pauses repas.\r\nclass AvailableTimeCalculationService implements AvailableTimeCalculationPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  AvailableTimeCalculationService(this._supabase);\r\n\r\n  /// Calcule le temps disponible global pour un [emptyTripId] donné, \r\n  /// sur un créneau [activityHours], selon [travelStyle] et [superWowIds].\r\n  Future<int> calculateAvailableTime({\r\n    required String emptyTripId,\r\n    required Map<String, dynamic> activityHours,\r\n    required String travelStyle,\r\n    required List<String> superWowIds,\r\n  }) async {\r\n    try {\r\n      // 1) Récupérer la durée totale du emptyTrip (trajet principal)\r\n      print('📊 Activity Hours: $activityHours'); // Debug input\r\n      final totalDuration = await _getTotalDuration(emptyTripId);\r\n      print('⏱ Total Duration: $totalDuration');\r\n\r\n      // 2) Calculer la durée des SW (selon travelStyle)\r\n      final swDuration = await calculateSuperWowDuration(\r\n        superWowIds: superWowIds,\r\n        travelStyle: travelStyle,\r\n      );\r\n      print('⭐ SW Duration: $swDuration');\r\n\r\n      // 3) Calculer les pauses repas (mealBreaks)\r\n      final mealBreaks = calculateMealBreaksDuration(activityHours, travelStyle);\r\n      print('🍽 Meal Breaks: $mealBreaks');\r\n\r\n      // 4) Calculer les heures totales (start -> end)\r\n      final totalActivityHours = _calculateTotalActivityHours(activityHours);\r\n      print('🕒 Total Hours: $totalActivityHours');\r\n\r\n      // 5) Formule finale\r\n      final timeLeft = totalActivityHours - totalDuration - swDuration - mealBreaks;\r\n      print('✨ Time Left: $timeLeft');\r\n\r\n      print('🕒 Calcul timeLeft => '\r\n          'totalActivityHours=$totalActivityHours, '\r\n          'totalDuration=$totalDuration, '\r\n          'swDuration=$swDuration, '\r\n          'mealBreaks=$mealBreaks, '\r\n          'timeLeft=$timeLeft');\r\n\r\n      return timeLeft;\r\n    } catch (e) {\r\n      throw CalculationException('Error calculating available time: $e');\r\n    }\r\n  }\r\n\r\n  /// Calcule le temps de repas en minutes (midi + soir éventuellement).\r\n  /// Se base sur l’intervalle [activityHours] (start, end) \r\n  /// et des slots de repas dans [TripConstants].\r\n  @override\r\n  int calculateMealBreaksDuration(Map<String, dynamic> activityHours, String travelStyle) {\r\n    final baseDuration = TripConstants.mealDurationByStyle[travelStyle] ?? TripConstants.mealDurationByStyle['balanced']!;\r\n\r\n    int breaks = 0;\r\n    if (_slotIncludesLunch(activityHours)) breaks += baseDuration;\r\n    if (_slotIncludesDinner(activityHours)) breaks += baseDuration;\r\n    return breaks;\r\n  }\r\n\r\n  /// Récupère le [total_duration] depuis la table `empty_daily_trips`.\r\n  /// Peut être `0` si non trouvé ou s'il s'agit d'un half_day minimal.\r\n  Future<int> _getTotalDuration(String emptyTripId) async {\r\n    final response = await _supabase\r\n        .from('empty_daily_trips')\r\n        .select('total_duration')\r\n        .eq('id', emptyTripId)\r\n        .single() as Map<String, dynamic>?;\r\n\r\n    if (response == null) {\r\n      print('⚠️ Aucune donnée pour emptyDailyTrip $emptyTripId. Retourne 0.');\r\n      return 0;\r\n    }\r\n\r\n    final duration = (response['total_duration'] ?? 0) / 60;  // Conversion secondes -> minutes\r\n    return (duration is int ? duration : duration.round());\r\n  }\r\n\r\n  /// Convertit [activityHours] (start, end) en minutes totales. \r\n  /// Ex: \"10:00\" -> 600, \"18:00\" -> 1080 => total 480 minutes.\r\n  int _calculateTotalActivityHours(Map<String, dynamic> activityHours) {\r\n    final startStr = activityHours['start'] as String;\r\n    final endStr = activityHours['end'] as String;\r\n\r\n    final startMins = _convertTimeStringToMinutes(startStr);\r\n    final endMins = _convertTimeStringToMinutes(endStr);\r\n\r\n    final total = endMins - startMins;\r\n    if (total < 0) {\r\n      // Si jamais l'utilisateur a inversé start/end, on peut retourner 0 ou throw\r\n      print('⚠️ Intervalle horaire négatif ($startStr -> $endStr). Retourne 0.');\r\n      return 0;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  /// Vérifie si le créneau couvre au moins [12h-13h].\r\n  bool _slotIncludesLunch(Map<String, dynamic> activityHours) {\r\n    final start = activityHours['start'] as String;\r\n    final end = activityHours['end'] as String;\r\n\r\n    final activityStart = _convertTimeStringToMinutes(start);\r\n    final activityEnd = _convertTimeStringToMinutes(end);\r\n    final lunchStart = TripConstants.mealTimeSlots['lunch']!.$1 * 60; // 12 * 60\r\n    final lunchEnd = TripConstants.mealTimeSlots['lunch']!.$2 * 60;   // 13 * 60\r\n\r\n    // On veut s'assurer que l'intervalle [activityStart, activityEnd] \r\n    // recouvre [lunchStart, lunchEnd].\r\n    return activityStart <= lunchStart && activityEnd >= lunchEnd;\r\n  }\r\n\r\n  /// Vérifie si le créneau couvre au moins [19h-20h].\r\n  bool _slotIncludesDinner(Map<String, dynamic> activityHours) {\r\n    final start = activityHours['start'] as String;\r\n    final end = activityHours['end'] as String;\r\n\r\n    final activityStart = _convertTimeStringToMinutes(start);\r\n    final activityEnd = _convertTimeStringToMinutes(end);\r\n    final dinnerStart = TripConstants.mealTimeSlots['dinner']!.$1 * 60;  // 19*60\r\n    final dinnerEnd = TripConstants.mealTimeSlots['dinner']!.$2 * 60;    // 20*60\r\n\r\n    return activityStart <= dinnerStart && activityEnd >= dinnerEnd;\r\n  }\r\n\r\n  int _convertTimeStringToMinutes(String timeString) {\r\n    final parts = timeString.split(':');\r\n    final hour = int.parse(parts[0]);\r\n    final minute = int.parse(parts[1]);\r\n    return hour * 60 + minute;\r\n  }\r\n\r\n  /// Calcule la durée totale des SW en minutes (selon min/max)\r\n  /// et le [travelStyle] (relax=prend max, active=min, balanced=moyenne).\r\n  Future<int> calculateSuperWowDuration({\r\n    required List<String> superWowIds,\r\n    required String travelStyle,\r\n  }) async {\r\n    try {\r\n      // Si la liste est vide, retourner 0\r\n      if (superWowIds.isEmpty) return 0;\r\n\r\n      // Utiliser in() plutôt que des eq() multiples\r\n      final response = await _supabase\r\n          .from('activities')\r\n          .select('min_duration_minutes, max_duration_minutes')\r\n          .inFilter('id', superWowIds);\r\n\r\n      if (response == null || (response as List).isEmpty) {\r\n        throw CalculationException('No activities found for given SuperWow IDs');\r\n      }\r\n\r\n      // Calculer la durée totale\r\n      int totalDuration = 0;\r\n      for (final activity in response) {\r\n        final minDuration = (activity['min_duration_minutes'] as num).toInt();\r\n        final maxDuration = (activity['max_duration_minutes'] as num).toInt();\r\n\r\n        // Utiliser le style pour déterminer la durée\r\n        totalDuration += TravelStyle.values\r\n            .firstWhere((e) => e.name == travelStyle)\r\n            .getDurationMinutes(minDuration, maxDuration);\r\n      }\r\n\r\n      return totalDuration;\r\n    } catch (e) {\r\n      throw CalculationException('Error calculating SW duration: $e');\r\n    }\r\n  }\r\n\r\n  Future<Map<DateTime, int>> calculateAvailableTimeForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Map<String, Map<String, String?>> dailyHours,\r\n    required String travelStyle,\r\n  }) async {\r\n    Map<DateTime, int> timeByDate = {};\r\n\r\n    for (var entry in dailyHours.entries) {\r\n      final date = DateTime.parse(entry.key);\r\n      final hours = entry.value;\r\n\r\n      if (hours['start'] == null || hours['end'] == null) continue;\r\n\r\n      // Vérifier compatibilité type/durée\r\n      final isDailyTypeCompatible = _checkDailyTypeCompatibility(hours, emptyTrip.type);\r\n      if (!isDailyTypeCompatible) continue;\r\n\r\n      final timeLeft = await calculateAvailableTime(\r\n        emptyTripId: emptyTrip.id,\r\n        activityHours: {\r\n          'start': hours['start']!,\r\n          'end': hours['end']!,\r\n        },\r\n        travelStyle: travelStyle,\r\n        superWowIds: emptyTrip.sw2Id != null ? [emptyTrip.sw1Id, emptyTrip.sw2Id!] : [emptyTrip.sw1Id],\r\n      );\r\n\r\n      timeByDate[date] = timeLeft;\r\n    }\r\n\r\n    return timeByDate;\r\n  }\r\n\r\n  bool _checkDailyTypeCompatibility(Map<String, String?> hours, DailyTripType tripType) {\r\n    final startTime = _convertTimeStringToMinutes(hours['start']!);\r\n    final endTime = _convertTimeStringToMinutes(hours['end']!);\r\n    final duration = endTime - startTime;\r\n\r\n    return tripType == DailyTripType.full_day ? duration >= 360 : duration < 360; // 6h seuil\r\n  }\r\n\r\n\r\n}\r\n",
      "info": {
        "size": 8987,
        "last_modified": "2025-04-16T13:25:27.234443",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\bonus_activities_cache.service.dart",
      "content": "// lib/core/domain/services/empty_trips/bonus_activities_cache.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/bonus_activities_cache.port.dart';\r\nimport '../../../../common/exceptions/calculation_exception.dart';\r\n\r\nclass BonusActivitiesCacheService implements BonusActivitiesCachePort {\r\n  final SupabaseClient _supabase;\r\n  static const String _tableName = 'empty_trip_bonus_activities';\r\n\r\n  BonusActivitiesCacheService(this._supabase);\r\n\r\n  @override\r\n  Future<void> cacheEmptyTripBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Map<String, dynamic>> bonusActivities,\r\n  }) async {\r\n    try {\r\n      for (var activity in bonusActivities) {\r\n        // Vérifier si la combinaison existe déjà\r\n        final existing = await _supabase\r\n            .from(_tableName)\r\n            .select()\r\n            .eq('empty_daily_trip_id', emptyTripId)\r\n            .eq('activity_id', activity['id'])\r\n            .maybeSingle();\r\n\r\n        if (existing == null) {\r\n          // Si elle n'existe pas, l'insérer\r\n          await _supabase\r\n              .from(_tableName)\r\n              .insert({\r\n            'empty_daily_trip_id': emptyTripId,\r\n            'activity_id': activity['id'],\r\n            'malus_vol_oiseau': activity['malus'],\r\n          });\r\n        }\r\n      }\r\n    } catch (e) {\r\n      throw CalculationException('Failed to cache bonus activities: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<Map<String, dynamic>>> getCachedBonusActivities(String emptyTripId) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from(_tableName)\r\n          .select()\r\n          .eq('empty_daily_trip_id', emptyTripId);\r\n\r\n      return List<Map<String, dynamic>>.from(response);\r\n    } catch (e) {\r\n      throw CalculationException('Failed to get cached bonus activities: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1893,
        "last_modified": "2025-04-16T13:25:27.2409504",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\bonus_activity_generation.service.dart",
      "content": "// lib/core/domain/services/empty_trips/bonus_activity_generation.service.dart\r\n\r\nimport 'package:uuid/uuid.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../models/trip_designer/trip/activity_model.dart';\r\nimport '../../../models/trip_designer/trip/trip_model.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\nimport '../../../../common/exceptions/geometry_calculation_exception.dart';\r\nimport '../../../ports/empty_trips/geometry_calculation.port.dart';\r\nimport 'distance_calculation.service.dart';\r\nimport 'available_time_calculation.service.dart';\r\n\r\nclass BonusActivityGenerationService {\r\n  final GeometryCalculationPort _geometryPort;\r\n  final DistanceCalculationService _distanceService;\r\n  final AvailableTimeCalculationService _availableTimeService;\r\n\r\n  BonusActivityGenerationService(\r\n      this._geometryPort,\r\n      this._distanceService,\r\n      this._availableTimeService,\r\n      );\r\n\r\n  Future<List<PotentialBonusActivity>> generatePotentialBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Activity> availableActivities,\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Trip trip,\r\n  }) async {\r\n    try {\r\n      final potentialBonusActivities = <PotentialBonusActivity>[];\r\n\r\n      for (final activity in availableActivities) {\r\n        if (_isActivitySuperWow(activity.id, emptyTrip)) continue;\r\n\r\n        try {\r\n          final malus = await _distanceService.calculateActivityMalus(\r\n            activityLocation: LatLng(\r\n                activity.latitude.toDouble(),\r\n                activity.longitude.toDouble()\r\n            ),\r\n            tripStart: _getLocationFromGeohash(emptyTrip.departureGeohash5),\r\n            tripEnd: _getLocationFromGeohash(emptyTrip.arrivalGeohash5),\r\n            travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n          );\r\n\r\n          potentialBonusActivities.add(\r\n              PotentialBonusActivity(\r\n                id: const Uuid().v4(),\r\n                emptyDailyTripId: emptyTripId,\r\n                activityId: activity.id,\r\n                malusVolOiseau: malus,\r\n                tripDate: trip.startDate,\r\n                createdAt: DateTime.now(),\r\n                updatedAt: DateTime.now(),\r\n              )\r\n          );\r\n        } catch (e) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      return potentialBonusActivities;\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to generate potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  LatLng _getLocationFromGeohash(String geohash) {\r\n    try {\r\n      final GeoHasher geoHasher = GeoHasher();\r\n      final List<double> coordinates = geoHasher.decode(geohash);\r\n      // GeoHasher retourne [longitude, latitude] donc on inverse pour LatLng\r\n      return LatLng(coordinates[1], coordinates[0]);\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to decode geohash: $e');\r\n    }\r\n  }\r\n\r\n  bool _isActivitySuperWow(String activityId, EmptyDailyTrip emptyTrip) {\r\n    return activityId == emptyTrip.sw1Id || activityId == emptyTrip.sw2Id;\r\n  }\r\n\r\n  Future<Map<DateTime, int>> calculateAvailableTimeForAllDates({\r\n    required String emptyTripId,\r\n    required Map<String, Map<String, String?>> dailyHours,\r\n    required String travelStyle,\r\n    required List<String> superWowIds,\r\n  }) async {\r\n    final Map<DateTime, int> availableTimeByDate = {};\r\n\r\n    for (var entry in dailyHours.entries) {\r\n      final date = DateTime.parse(entry.key);\r\n      final hours = entry.value;\r\n\r\n      if (hours['start'] != null && hours['end'] != null) {\r\n        final activityHoursMap = {\r\n          'start': hours['start']!,\r\n          'end': hours['end']!,\r\n        };\r\n\r\n        final availableTime = await _availableTimeService.calculateAvailableTime(\r\n          emptyTripId: emptyTripId,\r\n          activityHours: activityHoursMap,\r\n          travelStyle: travelStyle,\r\n          superWowIds: superWowIds,\r\n        );\r\n\r\n        availableTimeByDate[date] = availableTime;\r\n      }\r\n    }\r\n\r\n    return availableTimeByDate;\r\n  }\r\n\r\n}",
      "info": {
        "size": 4244,
        "last_modified": "2025-04-16T13:25:27.2469497",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\distance_calculation.service.dart",
      "content": "// lib/core/domain/services/designer/empty_trips/distance_calculation.service.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'dart:math' show sin, cos, sqrt, atan2, pi;\r\nimport '../../../models/trip_designer/bonus_activities/value_objects/malus_vol_oiseau.dart';\r\nimport '../../../ports/empty_trips/geometry_calculation.port.dart';\r\nimport '../../../../common/constants/geometry_constants.dart';\r\nimport '../../../../common/exceptions/geometry_calculation_exception.dart';\r\n\r\nclass DistanceCalculationService {\r\n  final GeometryCalculationPort? _geometryPort; // Optional pour compatibilité\r\n\r\n  DistanceCalculationService([this._geometryPort]);\r\n\r\n  /// Méthodes existantes\r\n  double calculateDistance(\r\n      LatLng point1,\r\n      LatLng point2, {\r\n        double roadFactor = 1.4\r\n      }) {\r\n    const earthRadius = 6371000;\r\n\r\n    final lat1 = point1.latitude * pi / 180;\r\n    final lat2 = point2.latitude * pi / 180;\r\n    final dLat = (point2.latitude - point1.latitude) * pi / 180;\r\n    final dLon = (point2.longitude - point1.longitude) * pi / 180;\r\n\r\n    final a = sin(dLat/2) * sin(dLat/2) +\r\n        cos(lat1) * cos(lat2) * sin(dLon/2) * sin(dLon/2);\r\n    final c = 2 * atan2(sqrt(a), sqrt(1-a));\r\n\r\n    return (earthRadius * c) * roadFactor;\r\n  }\r\n\r\n  int estimateTravelTime(double distanceMeters, {double averageSpeedKmh = 50}) {\r\n    final speedMeterPerSecond = averageSpeedKmh / 3.6;\r\n    return (distanceMeters / speedMeterPerSecond).round();\r\n  }\r\n\r\n  /// Nouvelles méthodes pour bonus activities\r\n  Future<MalusVolOiseau> calculateActivityMalus({\r\n    required LatLng activityLocation,\r\n    required LatLng tripStart,\r\n    required LatLng tripEnd,\r\n    required String travelStyle,\r\n  }) async {\r\n    try {\r\n      if (_geometryPort != null) {\r\n        // Utilisation du port si disponible\r\n        final isWithinDetour = await _geometryPort!.isWithinMaxDetour(\r\n            activityLocation,\r\n            tripStart,\r\n            tripEnd\r\n        );\r\n\r\n        if (!isWithinDetour) {\r\n          throw GeometryCalculationException('Activity is outside acceptable detour range');\r\n        }\r\n\r\n        final detourDistance = await _calculateDetourDistanceWithPort(\r\n            activityLocation,\r\n            tripStart,\r\n            tripEnd\r\n        );\r\n\r\n        final malusMinutes = await _geometryPort!.calculateMalusMinutes(\r\n            detourDistance,\r\n            travelStyle\r\n        );\r\n\r\n        return MalusVolOiseau.fromInt(malusMinutes);\r\n      } else {\r\n        // Fallback vers le calcul local si pas de port\r\n        return _calculateMalusLocally(\r\n            activityLocation,\r\n            tripStart,\r\n            tripEnd,\r\n            travelStyle\r\n        );\r\n      }\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to calculate activity malus: $e');\r\n    }\r\n  }\r\n\r\n  Future<double> _calculateDetourDistanceWithPort(\r\n      LatLng activityPoint,\r\n      LatLng start,\r\n      LatLng end\r\n      ) async {\r\n    final directDistance = await _geometryPort!.calculateDistance(start, end);\r\n    final detourDistance = await _geometryPort!.calculateDistance(start, activityPoint) +\r\n        await _geometryPort!.calculateDistance(activityPoint, end);\r\n\r\n    return detourDistance - directDistance;\r\n  }\r\n\r\n  MalusVolOiseau _calculateMalusLocally(\r\n      LatLng activityLocation,\r\n      LatLng tripStart,\r\n      LatLng tripEnd,\r\n      String travelStyle,\r\n      ) {\r\n    final directDistance = calculateDistance(tripStart, tripEnd);\r\n    final detourDistance = calculateDistance(tripStart, activityLocation) +\r\n        calculateDistance(activityLocation, tripEnd);\r\n\r\n    if (detourDistance > directDistance + (GeometryConstants.maxDetourDistanceKm * 1000)) {\r\n      throw GeometryCalculationException('Activity is outside acceptable detour range');\r\n    }\r\n\r\n    final factor = switch(travelStyle) {\r\n      'relax' => GeometryConstants.relaxedTravelFactor,\r\n      'active' => GeometryConstants.activeTravelFactor,\r\n      _ => GeometryConstants.balancedTravelFactor\r\n    };\r\n\r\n    final estimatedMinutes = estimateTravelTime(detourDistance - directDistance) * factor / 60;\r\n\r\n    return MalusVolOiseau.fromInt(estimatedMinutes.round().clamp(\r\n        GeometryConstants.minimumMalusMinutes,\r\n        GeometryConstants.maximumMalusMinutes\r\n    ));\r\n  }\r\n}",
      "info": {
        "size": 4333,
        "last_modified": "2025-04-16T13:25:27.2534555",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\empty_trip_generation.service.dart",
      "content": "// lib/core/domain/services/empty_trips/empty_trip_generation.service.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../models/trip_designer/empty_trips/value_objects/generation_result.dart';\r\nimport '../../../models/trip_designer/empty_trips/value_objects/superwow_pair.dart';\r\nimport '../../../models/scored_activity.dart';\r\nimport '../../../ports/empty_trips/empty_daily_trip.port.dart';\r\nimport '../../../ports/empty_trips/route_optimization.port.dart';\r\nimport '../../../ports/empty_trips/superwow_management.port.dart';\r\nimport '../../../ports/empty_trips/neighbor_geohashes.port.dart';\r\nimport '../../../../common/exceptions/empty_trip_generation_exception.dart';\r\n\r\n\r\nclass EmptyTripGenerationService {\r\n  final SuperWowManagementPort _superwowPort;\r\n  final RouteOptimizationPort _routePort;\r\n  final EmptyDailyTripPort _emptyTripPort;\r\n  final NeighborGeohashesPort _neighborGeohashesService;\r\n  final SupabaseClient _supabase;\r\n\r\n  EmptyTripGenerationService(\r\n      this._superwowPort,\r\n      this._routePort,\r\n      this._emptyTripPort,\r\n      this._neighborGeohashesService,\r\n      this._supabase);\r\n\r\n  Future<EmptyTripGenerationResult> generateEmptyTrips(String tripId) async {\r\n    try {\r\n      print('🔄 Début de la génération des empty trips');\r\n      final errors = <String>[];\r\n\r\n      final tripInfo = await _getTripInfo(tripId);\r\n      final superWows = await _superwowPort.getTripSuperWows(tripId);\r\n      final optimizedPairs = await _superwowPort.generateOptimizedPairs(\r\n        tripId,\r\n        superWows,\r\n        _getLatLngFromGeohash(tripInfo['departure_geohash5']),\r\n      );\r\n\r\n      final halfDayResults = await _generateHalfDayTrips(tripInfo, superWows);\r\n      final fullDayResults = await _generateFullDayTrips(\r\n          tripInfo, optimizedPairs);\r\n\r\n      return EmptyTripGenerationResult(\r\n        halfDayTrips: halfDayResults.$1,\r\n        fullDayTrips: fullDayResults.$1,\r\n        departureGeohash5: tripInfo['departure_geohash5'],\r\n        errors: [...halfDayResults.$2, ...fullDayResults.$2],\r\n      );\r\n    } catch (e) {\r\n      print('❌ Erreur génération empty trips: $e');\r\n      throw EmptyTripGenerationException(\r\n          'Erreur lors de la génération des empty trips: $e');\r\n    }\r\n  }\r\n\r\n  Future<(List<EmptyDailyTrip>, List<String>)> _generateHalfDayTrips(\r\n      Map<String, dynamic> tripInfo,\r\n      List<ScoredActivity> superWows,) async {\r\n    final emptyTrips = <EmptyDailyTrip>[];\r\n    final errors = <String>[];\r\n\r\n    for (final sw in superWows) {\r\n      final swLocation = LatLng(\r\n        sw.activityData['latitude'],\r\n        sw.activityData['longitude'],\r\n      );\r\n\r\n      final result = await _generateEmptyTripsCommon(\r\n        type: DailyTripType.half_day,\r\n        departureGeohash5: tripInfo['departure_geohash5'],\r\n        sw1Id: sw.id,\r\n        waypoints: [swLocation],\r\n      );\r\n\r\n      emptyTrips.addAll(result.$1);\r\n      errors.addAll(result.$2);\r\n    }\r\n\r\n    return (emptyTrips, errors);\r\n  }\r\n\r\n  Future<(List<EmptyDailyTrip>, List<String>)> _generateFullDayTrips(\r\n      Map<String, dynamic> tripInfo,\r\n      List<SuperWowPair> optimizedPairs,) async {\r\n    final emptyTrips = <EmptyDailyTrip>[];\r\n    final errors = <String>[];\r\n\r\n    for (final pair in optimizedPairs) {\r\n      final result = await _generateEmptyTripsCommon(\r\n        type: DailyTripType.full_day,\r\n        departureGeohash5: tripInfo['departure_geohash5'],\r\n        sw1Id: pair.sw1Id,\r\n        sw2Id: pair.sw2Id,\r\n        waypoints: [pair.sw1Location, pair.sw2Location],\r\n      );\r\n\r\n      emptyTrips.addAll(result.$1);\r\n      errors.addAll(result.$2);\r\n    }\r\n\r\n    return (emptyTrips, errors);\r\n  }\r\n\r\n  Future<(List<EmptyDailyTrip>, List<String>)> _generateEmptyTripsCommon({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n    required List<LatLng> waypoints,\r\n  }) async {\r\n    final errors = <String>[];\r\n    try {\r\n      final existingTrip = await _emptyTripPort.findExistingEmptyTrip(\r\n        type: type,\r\n        departureGeohash5: departureGeohash5,\r\n        arrivalGeohash5: departureGeohash5,\r\n        sw1Id: sw1Id,\r\n        sw2Id: sw2Id,\r\n      );\r\n\r\n      if (existingTrip != null) {\r\n        return (<EmptyDailyTrip>[existingTrip], errors);\r\n      }\r\n\r\n      final departurePoint = _getLatLngFromGeohash(departureGeohash5);\r\n      final arrivalPoint = LatLng(\r\n          departurePoint.latitude + 0.001,\r\n          departurePoint.longitude + 0.001\r\n      );\r\n\r\n      final route = await _routePort.getOptimizedRoute(\r\n        departurePoint,\r\n        arrivalPoint,\r\n        waypoints,\r\n      );\r\n\r\n      final newTrip = await _emptyTripPort.createEmptyTrip(\r\n        type: type,\r\n        departureGeohash5: departureGeohash5,\r\n        arrivalGeohash5: departureGeohash5,\r\n        sw1Id: sw1Id,\r\n        sw2Id: sw2Id,\r\n        traversedGeohashes: route['traversed_geohashes'],\r\n        routePolyline: route['polyline'],\r\n        totalDistance: route['distance'],\r\n        totalDuration: route['duration'],\r\n      );\r\n\r\n      print('🚀 About to generate neighbors');\r\n      print('  Empty Trip ID: ${newTrip.id}');\r\n      print('  Traversed geohashes: ${route['traversed_geohashes']}');\r\n\r\n      await _neighborGeohashesService.generateAndSaveNeighbors(\r\n        emptyTripId: newTrip.id,\r\n        traversedGeohashes: route['traversed_geohashes'],\r\n      );\r\n\r\n      return (<EmptyDailyTrip>[newTrip], errors);\r\n    } catch (e) {\r\n      final error = 'Erreur génération ${type.name} pour SW$sw1Id${sw2Id != null\r\n          ? \"-$sw2Id\"\r\n          : \"\"}: $e';\r\n      print('❌ $error');\r\n      errors.add(error);\r\n      return (<EmptyDailyTrip>[], errors);\r\n    }\r\n  }\r\n\r\n  int _calculateTotalDistance(List? legs) {\r\n    if (legs == null || legs.isEmpty) return 0;\r\n    return legs.fold<int>(\r\n        0, (sum, leg) => sum + (leg['distance']?['value'] as int? ?? 0));\r\n  }\r\n\r\n  int _calculateTotalDuration(List? legs) {\r\n    if (legs == null || legs.isEmpty) return 0;\r\n    return legs.fold<int>(\r\n        0, (sum, leg) => sum + (leg['duration']?['value'] as int? ?? 0));\r\n  }\r\n\r\n  Future<Map<String, dynamic>> _getTripInfo(String tripId) async {\r\n    final response = await _supabase\r\n        .from('trips')\r\n        .select('departure_geohash5, active_exploration_types')\r\n        .eq('id', tripId)\r\n        .single();\r\n\r\n    if (response['departure_geohash5'] == null) {\r\n      throw EmptyTripGenerationException('Geohash de départ manquant');\r\n    }\r\n    return response;\r\n  }\r\n\r\n  LatLng _getLatLngFromGeohash(String geohash5) {\r\n    try {\r\n      final geohasher = GeoHasher();\r\n      final coordinates = geohasher.decode(geohash5);\r\n      // Inverser coordinates[0] et coordinates[1] car GeoHasher retourne [lng, lat]\r\n      final lat = double.parse(coordinates[1].toStringAsFixed(6));\r\n      final lng = double.parse(coordinates[0].toStringAsFixed(6));\r\n\r\n      print('🗺️ Conversion geohash $geohash5 → $lat,$lng');\r\n      return LatLng(lat, lng);\r\n    } catch (e) {\r\n      print('❌ Erreur décodage geohash: $e');\r\n      throw EmptyTripGenerationException(\r\n          'Impossible de décoder le geohash $geohash5');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 7477,
        "last_modified": "2025-04-16T13:25:27.2599605",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\neighbor_geohashes.service.dart",
      "content": "// lib/core/domain/services/empty_trips/neighbor_geohashes.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/neighbor_geohashes.port.dart';\r\n\r\n// lib/core/domain/services/empty_trips/neighbor_geohashes.service.dart\r\n\r\nclass NeighborGeohashesService implements NeighborGeohashesPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  NeighborGeohashesService(this._supabase);\r\n\r\n  @override\r\n  Future<void> generateAndSaveNeighbors({\r\n    required String emptyTripId,\r\n    required List<String> traversedGeohashes,\r\n  }) async {\r\n    try {\r\n      print('🔄 Processing neighbors for empty trip: $emptyTripId');\r\n      Map<String, Map<String, dynamic>> neighborsWithClosest = {};\r\n\r\n      for (var routeGeohash in traversedGeohashes) {\r\n        final neighbors = await _supabase\r\n            .from('geohash5_distances')\r\n            .select()\r\n            .eq('geohash5_origin', routeGeohash)\r\n            .lte('center_distance_km', 30.0);\r\n\r\n        for (var neighbor in neighbors) {\r\n          final neighborGeohash = neighbor['geohash5_neighbor'];\r\n          final distance = (neighbor['center_distance_km'] * 1000).round();\r\n\r\n          if (!neighborsWithClosest.containsKey(neighborGeohash) ||\r\n              distance < neighborsWithClosest[neighborGeohash]!['distance_to_route']) {\r\n            neighborsWithClosest[neighborGeohash] = {\r\n              'closest_route_geohash5': routeGeohash,\r\n              'distance_to_route': distance\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      if (neighborsWithClosest.isNotEmpty) {\r\n        final dataToUpsert = neighborsWithClosest.entries.map((e) => ({\r\n          'empty_trip_id': emptyTripId,\r\n          'geohash5': e.key,\r\n          'closest_route_geohash5': e.value['closest_route_geohash5'],\r\n          'distance_to_route': e.value['distance_to_route'],\r\n        })).toList();\r\n\r\n        await _supabase\r\n            .from('empty_trip_neighbor_geohashes')\r\n            .upsert(dataToUpsert);\r\n\r\n        print('✅ Saved ${dataToUpsert.length} unique neighbors');\r\n      }\r\n    } catch (e) {\r\n      print('❌ Error: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<Map<String, Map<String, dynamic>>> getNeighborGeohashes(String emptyTripId) async {\r\n    final response = await _supabase\r\n        .from('empty_trip_neighbor_geohashes')\r\n        .select()\r\n        .eq('empty_trip_id', emptyTripId);\r\n\r\n    return Map.fromEntries(\r\n        (response as List).map((n) => MapEntry(\r\n            n['geohash5'] as String,\r\n            {\r\n              'closest_route_geohash5': n['closest_route_geohash5'],\r\n              'distance_to_route': n['distance_to_route']\r\n            }\r\n        ))\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2725,
        "last_modified": "2025-04-16T13:25:27.2665166",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\notifier\\potential_bonus_activities.notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/potential_bonus_activities.notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\nimport '../../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../../models/trip_designer/trip/activity_model.dart';\r\nimport '../../../../models/trip_designer/trip/trip_model.dart';\r\nimport '../bonus_activity_generation.service.dart';\r\nimport '../../../../../../core/adapters/supabase/potential_bonus_activity.adapter.dart';\r\n\r\n\r\nclass PotentialBonusActivitiesNotifier extends StateNotifier<AsyncValue<List<PotentialBonusActivity>>> {\r\n  final PotentialBonusActivityAdapter _adapter;\r\n  final BonusActivityGenerationService _generationService;\r\n\r\n  PotentialBonusActivitiesNotifier(this._adapter, this._generationService)\r\n      : super(const AsyncValue.loading());\r\n\r\n  Future<void> generateAndSavePotentialBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Activity> availableActivities,\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Trip trip,\r\n  }) async {\r\n    try {\r\n      state = const AsyncValue.loading();\r\n\r\n      final potentialActivities = await _generationService.generatePotentialBonusActivities(\r\n        emptyTripId: emptyTripId,\r\n        availableActivities: availableActivities,\r\n        emptyTrip: emptyTrip,\r\n        trip: trip,\r\n      );\r\n\r\n      await _adapter.savePotentialBonusActivities(potentialActivities);\r\n\r\n      state = AsyncValue.data(potentialActivities);\r\n    } catch (e, st) {\r\n      state = AsyncValue.error(e, st);\r\n    }\r\n  }\r\n\r\n  Future<void> loadPotentialBonusActivities(String emptyTripId) async {\r\n    try {\r\n      state = const AsyncValue.loading();\r\n\r\n      final activities = await _adapter.getPotentialBonusActivities(\r\n        emptyTripId: emptyTripId,\r\n      );\r\n\r\n      state = AsyncValue.data(activities);\r\n    } catch (e, st) {\r\n      state = AsyncValue.error(e, st);\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2030,
        "last_modified": "2025-04-16T13:25:27.2730234",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\potential_activities.service.dart",
      "content": "// lib/core/domain/services/empty_trips/potential_activities.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/potential_activities.port.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../models/trip_designer/trip/activity_model.dart';\r\nimport '../../../../common/exceptions/calculation_exception.dart';\r\n\r\nclass PotentialActivitiesService implements PotentialActivitiesPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  PotentialActivitiesService(this._supabase);\r\n\r\n  @override\r\n  Future<Map<String, List<Activity>>> getFilteredActivitiesForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required String tripId,\r\n    required Map<DateTime, int> availableTimeByDate,\r\n  }) async {\r\n    try {\r\n      // 1. Filtrer les dates avec du temps disponible\r\n      final validDates = availableTimeByDate.entries\r\n          .where((entry) => entry.value > 0)\r\n          .map((e) => e.key)\r\n          .toList();\r\n\r\n      if (validDates.isEmpty) return {};\r\n\r\n      // 2. Récupérer les activités depuis trip_activities\r\n      final response = await _supabase\r\n          .from('trip_activities')\r\n          .select('activity_id, planned_date')\r\n          .eq('trip_id', tripId);\r\n\r\n      // 3. Convertir en Map date -> List<Activity>\r\n      Map<String, List<Activity>> activitiesByDate = {};\r\n\r\n      for (final date in validDates) {\r\n        final activities = await _getActivitiesForDate(\r\n          emptyTrip: emptyTrip,\r\n          tripId: tripId,\r\n          date: date,\r\n          existingActivityIds: (response as List)\r\n              .where((r) => r['planned_date'] == date.toIso8601String())\r\n              .map((r) => r['activity_id'] as String)\r\n              .toList(),\r\n        );\r\n\r\n        if (activities.isNotEmpty) {\r\n          activitiesByDate[date.toIso8601String()] = activities;\r\n        }\r\n      }\r\n\r\n      return activitiesByDate;\r\n    } catch (e) {\r\n      throw CalculationException('Error getting filtered activities: $e');\r\n    }\r\n  }\r\n\r\n  Future<List<Activity>> _getActivitiesForDate({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required String tripId,\r\n    required DateTime date,\r\n    required List<String> existingActivityIds,\r\n  }) async {\r\n    // Exclure les SW\r\n    final excludeIds = [...existingActivityIds, emptyTrip.sw1Id];\r\n    if (emptyTrip.sw2Id != null) excludeIds.add(emptyTrip.sw2Id!);\r\n\r\n    // Récupérer les activités dans le geohash5\r\n    final response = await _supabase\r\n        .from('activities')\r\n        .select()\r\n        .eq('geohash_5', emptyTrip.departureGeohash5)\r\n        .not('id', 'in', excludeIds);\r\n\r\n    return (response as List)\r\n        .map((json) => Activity.fromJson(json))\r\n        .toList();\r\n  }\r\n}",
      "info": {
        "size": 2776,
        "last_modified": "2025-04-16T13:25:27.2840375",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\trip_distance_service.dart",
      "content": "// lib/core/domain/services/distance_service.dart\r\n\r\nimport '../../../common/utils/maps_toolkit_utils.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nclass DistanceService {\r\n  // Cache des distances calculées\r\n  final Map<String, double> _distanceCache = {};\r\n\r\n  // Clé de cache combinant l'ID de l'activité et la position utilisateur\r\n  String _getCacheKey(String activityId, LatLng userLocation) {\r\n    return '$activityId-${userLocation.latitude}-${userLocation.longitude}';\r\n  }\r\n\r\n  double getDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  }) {\r\n    final cacheKey = _getCacheKey(activityId, userLocation);\r\n\r\n    // Vérifier le cache d'abord\r\n    if (_distanceCache.containsKey(cacheKey)) {\r\n      return _distanceCache[cacheKey]!;\r\n    }\r\n\r\n    // Sinon calculer la distance précise\r\n    final distance = MapsToolkitUtils.calculateHaversineDistance(\r\n      userLocation,\r\n      activityLocation,\r\n    );\r\n\r\n    // Mettre en cache\r\n    _distanceCache[cacheKey] = distance;\r\n\r\n    return distance;\r\n  }\r\n}",
      "info": {
        "size": 1151,
        "last_modified": "2025-04-16T13:25:27.2960534",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\google_services_config.dart",
      "content": "// core/domain/services/google_services_config.dart\r\n\r\n\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\n\r\nclass GoogleServicesConfig {\r\n  final String mapsApiKey;\r\n  final String aiStudioApiKey;\r\n\r\n  GoogleServicesConfig._({\r\n    required this.mapsApiKey,\r\n    required this.aiStudioApiKey,\r\n  });\r\n\r\n  static Future<GoogleServicesConfig> init() async {\r\n    await dotenv.load();\r\n    return GoogleServicesConfig._(\r\n      mapsApiKey: dotenv.env['GOOGLE_MAPS_API_KEY'] ?? '',\r\n      aiStudioApiKey: dotenv.env['GOOGLE_AI_STUDIO_API_KEY'] ?? '',\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 567,
        "last_modified": "2025-04-16T13:25:27.3077319",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\location\\enhanced_location_service.dart",
      "content": "// lib/core/domain/services/location/enhanced_location_service.dart\r\n\r\nimport 'package:async/async.dart';\r\nimport 'package:geolocator/geolocator.dart';\r\nimport '../../../domain/models/location/user_location.dart';\r\nimport '../../../domain/models/location/place_suggestion.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\nimport '../../../domain/models/shared/city_model.dart';\r\nimport '../../../domain/ports/location/location_cache_port.dart';\r\nimport '../../../domain/ports/location/city_cache_port.dart';\r\nimport '../../../adapters/google_maps/maps_adapter.dart';\r\nimport '../../../common/utils/debouncer.dart';\r\nimport '../../../common/constants/location_constants.dart';\r\n\r\nclass EnhancedLocationService {\r\n  final GoogleMapsAdapter _mapsAdapter;\r\n  final LocationCachePort _locationCache;\r\n  final Debouncer _searchDebouncer;\r\n  final CityCachePort _cityCache;\r\n\r\n  EnhancedLocationService({\r\n    required GoogleMapsAdapter mapsAdapter,\r\n    required LocationCachePort locationCache,\r\n    required CityCachePort cityCache,\r\n  }) : _mapsAdapter = mapsAdapter,\r\n        _locationCache = locationCache,\r\n        _cityCache = cityCache,\r\n        _searchDebouncer = Debouncer(\r\n          milliseconds: LocationConstants.searchDebounceTime,\r\n        );\r\n\r\n  /// Recherche de lieux avec debounce\r\n  void searchPlacesWithDebounce(\r\n      String query,\r\n      Function(Result<List<PlaceSuggestion>>) callback,\r\n      ) {\r\n    _searchDebouncer.run(() async {\r\n      // Recherche d'abord dans le cache\r\n      if (query.length >= 2) {\r\n        final cachedSuggestions = await _locationCache.getPlaceSuggestions(query);\r\n\r\n        if (cachedSuggestions.isNotEmpty) {\r\n          callback(Result.value(cachedSuggestions));\r\n        }\r\n      }\r\n\r\n      // Si la requête est trop courte, on arrête là\r\n      if (query.length < 3) {\r\n        return;\r\n      }\r\n\r\n      // Recherche via l'API\r\n      final result = await _mapsAdapter.searchPlaces(query);\r\n\r\n      if (result.isValue && result.asValue!.value.isNotEmpty) {\r\n        // Sauvegarder les résultats dans le cache\r\n        await _locationCache.savePlaceSuggestions(result.asValue!.value);\r\n      }\r\n\r\n      callback(result);\r\n    });\r\n  }\r\n\r\n  /// Récupère les détails d'un lieu avec optimisation via la table cities\r\n  Future<Result<PlaceDetails>> getPlaceDetails(String placeId) async {\r\n    // ÉTAPE 1: Vérifier d'abord dans le cache Hive local\r\n    final cachedDetails = await _locationCache.getPlaceDetails(placeId);\r\n    if (cachedDetails != null) {\r\n      print('✅ Détails trouvés dans le cache local: ${cachedDetails.name}');\r\n      return Result.value(cachedDetails);\r\n    }\r\n\r\n    // ÉTAPE 2: Vérifier ensuite dans la table cities de Supabase\r\n    final cachedCity = await _cityCache.getCityByPlaceId(placeId);\r\n    if (cachedCity != null) {\r\n      print('✅ Ville trouvée dans la base de données: ${cachedCity.cityName}');\r\n\r\n      // Convertir City en PlaceDetails\r\n      final placeDetails = PlaceDetails(\r\n        placeId: cachedCity.placeId ?? cachedCity.id,\r\n        name: cachedCity.cityName,\r\n        formattedAddress: cachedCity.cityName,\r\n        location: UserLocation(\r\n          latitude: cachedCity.lat,\r\n          longitude: cachedCity.lon,\r\n          isFromGps: false,\r\n          timestamp: DateTime.now(),\r\n        ),\r\n        lastUpdated: DateTime.now(),\r\n      );\r\n\r\n      // Sauvegarder dans le cache local aussi\r\n      await _locationCache.savePlaceDetails(placeDetails);\r\n\r\n      return Result.value(placeDetails);\r\n    }\r\n\r\n    // ÉTAPE 3: Si pas trouvé, faire l'appel API\r\n    print('🔍 Appel à l\\'API Google pour obtenir les détails: $placeId');\r\n    final result = await _mapsAdapter.getPlaceDetailsById(placeId);\r\n\r\n    if (result.isValue) {\r\n      final placeDetails = result.asValue!.value;\r\n\r\n      // Sauvegarder dans le cache local\r\n      await _locationCache.savePlaceDetails(placeDetails);\r\n\r\n      // Sauvegarder dans la table cities\r\n      try {\r\n        await _cityCache.savePlaceDetailsAsCity(placeDetails);\r\n        print('✅ Ville sauvegardée dans la base de données: ${placeDetails.name}');\r\n      } catch (e) {\r\n        print('⚠️ Impossible de sauvegarder la ville: $e');\r\n        // On continue même si la sauvegarde échoue\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n\r\n  /// Récupère la position actuelle\r\n  Future<Result<UserLocation>> getCurrentLocation() async {\r\n    try {\r\n      // Vérifier si le service de localisation est activé\r\n      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();\r\n      if (!serviceEnabled) {\r\n        return Result.error(Exception('Les services de localisation sont désactivés.'));\r\n      }\r\n\r\n      // Vérifier les permissions\r\n      LocationPermission permission = await Geolocator.checkPermission();\r\n      if (permission == LocationPermission.denied) {\r\n        permission = await Geolocator.requestPermission();\r\n        if (permission == LocationPermission.denied) {\r\n          return Result.error(Exception('La permission de localisation a été refusée.'));\r\n        }\r\n      }\r\n\r\n      if (permission == LocationPermission.deniedForever) {\r\n        return Result.error(Exception('Les permissions de localisation sont définitivement refusées, veuillez les activer dans les paramètres.'));\r\n      }\r\n\r\n      // Obtenir la position actuelle\r\n      final position = await Geolocator.getCurrentPosition(\r\n        desiredAccuracy: LocationAccuracy.high,\r\n        timeLimit: const Duration(seconds: 5),\r\n      );\r\n\r\n      return Result.value(UserLocation(\r\n        latitude: position.latitude,\r\n        longitude: position.longitude,\r\n        accuracy: position.accuracy,\r\n        isFromGps: true,\r\n        timestamp: DateTime.now(),\r\n      ));\r\n    } catch (e) {\r\n      return Result.error(Exception('Erreur lors de la récupération de la position: ${e.toString()}'));\r\n    }\r\n  }\r\n  /// Annule la recherche en cours\r\n  void cancelSearch() {\r\n    _searchDebouncer.cancel();\r\n  }\r\n}",
      "info": {
        "size": 6000,
        "last_modified": "2025-04-16T13:25:27.3142422",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\location_service.dart",
      "content": "// core/domain/services/location_service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../models/shared/city_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\n\r\n/// Service centralisé pour les opérations sur les villes et localisations\r\nclass LocationService {\r\n  final SupabaseClient _supabase;\r\n\r\n  LocationService(this._supabase);\r\n\r\n  /// Vérifie si une ville existe dans la base\r\n  Future<City?> findCity(String cityName) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('city_name', cityName)\r\n          .maybeSingle();\r\n      return response != null ? City.fromJson(response) : null;\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche de la ville: $e');\r\n    }\r\n  }\r\n\r\n  /// Sauvegarde une ville dans la base\r\n  Future<City> saveCity({\r\n    required String cityName,\r\n    required double lat,\r\n    required double lon,\r\n    required String geohash5,\r\n  }) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .upsert({\r\n        'city_name': cityName,\r\n        'lat': lat,\r\n        'lon': lon,\r\n        'geohash_5': geohash5,\r\n      }, onConflict: 'city_name')\r\n          .select()\r\n          .single();\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la sauvegarde de la ville: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1445,
        "last_modified": "2025-04-16T13:25:27.3262555",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\scoring_service.dart",
      "content": "// core/domain/services/scoring_service.dart\r\n\r\nimport 'dart:math' as math;\r\nimport '../models/trip_designer/scoring/scoring_config.dart';\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nclass ScoringService {\r\n  static const double SUPERWOW_TOTAL_THRESHOLD = 0.78;\r\n  static const double SUPERWOW_SUBCATEGORY_THRESHOLD = 0.6;\r\n\r\n  double calculateTotalScore(ActivityForProcessing activity, double subcategoryScore) {\r\n    final ratingScore = normalizeRating(activity.ratingCount);\r\n    final durationScore = calculateDurationBonus(activity.minDurationMinutes);\r\n\r\n    return (subcategoryScore * ScoringConfig.subcategoryWeight) +\r\n        (ratingScore * ScoringConfig.ratingWeight) +\r\n        (durationScore * ScoringConfig.durationWeight);\r\n  }\r\n\r\n  double normalizeRating(int rating) {\r\n    return rating / 100;\r\n  }\r\n\r\n  double calculateDurationBonus(int durationMinutes) {\r\n    return math.log(durationMinutes + 1) / math.log(10);\r\n  }\r\n\r\n  bool isSuperWow(double totalScore, double subcategoryScore) {\r\n    return totalScore >= SUPERWOW_TOTAL_THRESHOLD &&\r\n        subcategoryScore >= SUPERWOW_SUBCATEGORY_THRESHOLD;\r\n  }\r\n}",
      "info": {
        "size": 1162,
        "last_modified": "2025-04-16T13:25:27.3317613",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\search\\activity_distance_service.dart",
      "content": "// lib/core/domain/services/search/activity_distance_service.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../ports/search/activity_distance_calculation_port.dart';\r\nimport '../../../common/utils/maps_toolkit_utils.dart';\r\n\r\nclass ActivityDistanceService implements ActivityDistanceCalculationPort {\r\n  final Map<String, double> _distanceCache = {};\r\n\r\n  String _getCacheKey(String activityId, LatLng userLocation) {\r\n    return '$activityId-${userLocation.latitude}-${userLocation.longitude}';\r\n  }\r\n\r\n  // Ajout d'une constante pour le facteur de correction\r\n  static const double ROAD_DISTANCE_FACTOR = 0.75;\r\n\r\n  @override\r\n  double calculateDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  }) {\r\n    final cacheKey = _getCacheKey(activityId, userLocation);\r\n\r\n    if (_distanceCache.containsKey(cacheKey)) {\r\n      return _distanceCache[cacheKey]!;\r\n    }\r\n\r\n    final rawDistance = MapsToolkitUtils.calculateHaversineDistance(\r\n      userLocation,\r\n      activityLocation,\r\n    );\r\n\r\n    // Application du facteur de correction\r\n    final correctedDistance = rawDistance * ROAD_DISTANCE_FACTOR;\r\n\r\n    _distanceCache[cacheKey] = correctedDistance;\r\n    return correctedDistance;\r\n  }\r\n\r\n  @override\r\n  void clearCache() {\r\n    _distanceCache.clear();\r\n  }\r\n}",
      "info": {
        "size": 1407,
        "last_modified": "2025-04-16T13:25:27.3387664",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\shared\\external_launcher_service.dart",
      "content": "// lib/core/domain/services/shared/external_launcher_service.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:url_launcher/url_launcher.dart' as url_launcher;\r\nimport 'package:flutter_custom_tabs/flutter_custom_tabs.dart' as custom_tabs;\r\nimport 'package:map_launcher/map_launcher.dart';\r\nimport '../../../../core/theme/app_colors.dart';\r\n\r\nclass ExternalLauncherService {\r\n  static Future<void> openMap(\r\n      double? latitude,\r\n      double? longitude,\r\n      String title,\r\n      BuildContext context,\r\n      {String? placeId}\r\n      ) async {\r\n    try {\r\n      // Si on a un Place ID, on ouvre la fiche Google Maps\r\n      if (placeId != null && placeId.isNotEmpty) {\r\n        final encodedTitle = Uri.encodeComponent(title);\r\n        final googlePlaceUrl = 'https://www.google.com/maps/search/?api=1'\r\n            '&query=$encodedTitle'\r\n            '&query_place_id=$placeId';\r\n\r\n        await openCustomTab(context, googlePlaceUrl);\r\n        return;\r\n      }\r\n\r\n      // Sinon on lance l'itinéraire avec l'app de navigation par défaut\r\n      final availableMaps = await MapLauncher.installedMaps;\r\n\r\n      if (availableMaps.isNotEmpty) {\r\n        if (latitude != null && longitude != null) {\r\n          await availableMaps.first.showDirections(\r\n            destination: Coords(latitude, longitude),\r\n            destinationTitle: title,\r\n          );\r\n        } else {\r\n          // Pour l'adresse textuelle, utiliser showMarker à la place\r\n          await availableMaps.first.showMarker(\r\n            coords: Coords(latitude ?? 0, longitude ?? 0),\r\n            title: title,\r\n          );\r\n        }\r\n      } else {\r\n        throw 'Aucune application de navigation disponible';\r\n      }\r\n    } catch (e) {\r\n      throw 'Erreur lors de l\\'ouverture de la navigation : $e';\r\n    }\r\n  }\r\n\r\n\r\n\r\n  static Future<void> openPhone(String phoneNumber) async {\r\n    try {\r\n      final Uri uri = Uri(\r\n        scheme: 'tel',\r\n        path: phoneNumber.replaceAll(RegExp(r'[^\\d+]'), ''),\r\n      );\r\n\r\n      if (await url_launcher.canLaunchUrl(uri)) {\r\n        await url_launcher.launchUrl(uri);\r\n      } else {\r\n        throw 'Aucune application de téléphone disponible';\r\n      }\r\n    } catch (e) {\r\n      throw 'Erreur lors de l\\'appel : $e';\r\n    }\r\n  }\r\n\r\n  static Future<void> openCustomTab(BuildContext context, String url) async {\r\n    try {\r\n      final Uri uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');\r\n\r\n      await custom_tabs.launchUrl(\r\n        uri,\r\n        customTabsOptions: custom_tabs.CustomTabsOptions(\r\n          colorSchemes: custom_tabs.CustomTabsColorSchemes.defaults(\r\n            toolbarColor: AppColors.neutral900,\r\n          ),\r\n          shareState: custom_tabs.CustomTabsShareState.on,\r\n          urlBarHidingEnabled: true,\r\n          showTitle: true,\r\n        ),\r\n        safariVCOptions: custom_tabs.SafariViewControllerOptions(\r\n          preferredBarTintColor: AppColors.neutral900,\r\n          preferredControlTintColor: Colors.white,\r\n          barCollapsingEnabled: true,\r\n          dismissButtonStyle: custom_tabs.SafariViewControllerDismissButtonStyle.close,\r\n        ),\r\n      );\r\n    } catch (e) {\r\n      throw 'Erreur lors de l\\'ouverture du site web : $e';\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3249,
        "last_modified": "2025-04-16T13:25:27.350273",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\travel_time_service.dart",
      "content": "// core/domain/services/travel_time_service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\n\r\nclass TravelTimeService {\r\n  final SupabaseClient _client;\r\n\r\n  TravelTimeService(this._client);\r\n\r\n  Future<int> calculateTravelTime(String originGeohash5, String destinationGeohash5) async {\r\n    // Si même geohash5\r\n    if (originGeohash5 == destinationGeohash5) {\r\n      return 15; // 15 minutes\r\n    }\r\n\r\n    // Essayer d'abord geohash5_distances\r\n    final geohash5Response = await _client\r\n        .from('geohash5_distances')\r\n        .select()\r\n        .eq('geohash5_origin', originGeohash5)\r\n        .eq('geohash5_neighbor', destinationGeohash5)\r\n        .maybeSingle();\r\n\r\n    if (geohash5Response != null) {\r\n      double distance = geohash5Response['center_distance_km'];\r\n      return 15 + (distance.round()); // 15min + 1min/km\r\n    }\r\n\r\n    // Sinon, utiliser geohash_neighbors avec geohash4\r\n    String geohash4Origin = originGeohash5.substring(0, 4);\r\n    String geohash4Destination = destinationGeohash5.substring(0, 4);\r\n\r\n    final geohash4Response = await _client\r\n        .from('geohash_neighbors')\r\n        .select()\r\n        .eq('geohash', geohash4Origin)\r\n        .eq('neighbor_geohash', geohash4Destination)\r\n        .maybeSingle();\r\n\r\n    if (geohash4Response != null) {\r\n      double distance = geohash4Response['distance_km'];\r\n      // Appliquer les règles de temps selon la distance\r\n      return _getTimeForDistance(distance);\r\n    }\r\n\r\n    // Par défaut, retourner un temps maximum\r\n    return 150; // 2h30\r\n  }\r\n\r\n  int _getTimeForDistance(double distance) {\r\n    if (distance <= 30) return 45;      // 45min\r\n    if (distance <= 50) return 60;      // 1h\r\n    if (distance <= 80) return 90;      // 1h30\r\n    if (distance <= 110) return 120;    // 2h\r\n    return 150;                         // 2h30\r\n  }\r\n}",
      "info": {
        "size": 1859,
        "last_modified": "2025-04-16T13:25:27.361795",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\trip_service.dart",
      "content": "// lib/core/domain/services/trip_service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../models/shared/city_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\n\r\nclass TripService {\r\n  final SupabaseClient _supabase;\r\n\r\n  TripService(this._supabase);\r\n\r\n  Future<Trip?> findTrip(String tripId) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .select('*, departure_city(*)')\r\n          .eq('id', tripId)\r\n          .maybeSingle();\r\n\r\n      if (response == null) return null;\r\n      return Trip.fromJson(response);\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche du voyage: $e');\r\n    }\r\n  }\r\n\r\n  Future<Trip> saveTrip({\r\n    required String userId,\r\n    required String title,\r\n    required DateTime startDate,\r\n    required DateTime endDate,\r\n    required TravelGroup travelGroup,\r\n    required ActivityHours activityHours,\r\n    required City departureCity,\r\n    required TravelStyle travelStyle,\r\n    required PreferredMoment preferredMoment,\r\n    double? dailyBudget,\r\n  }) async {\r\n    try {\r\n      print('TripService - Début de saveTrip');\r\n      // Afficher les données qu'on va sauvegarder\r\n      print('Données à sauvegarder:');\r\n      final tripData = {\r\n        'user_id': userId,\r\n        'title': title,\r\n        'start_date': startDate.toIso8601String(),\r\n        'end_date': endDate.toIso8601String(),\r\n        'departure_city_id': departureCity.id,\r\n        'departure_geohash5': departureCity.geohash5,\r\n        'travel_group': travelGroup.toJson(),\r\n        'activity_hours': activityHours.toJson(),\r\n        'daily_budget': dailyBudget,\r\n        'travel_style': travelStyle.name,\r\n        'preferred_moment': preferredMoment.name,\r\n        'metadata': _generateMetadata(startDate),\r\n        'status': 'planned',\r\n        'trip_duration': endDate.difference(startDate).inDays + 1,\r\n      };\r\n      print('TripData: $tripData');\r\n\r\n      // Modification ici : on ne récupère pas departure_city\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .insert(tripData)\r\n          .select()\r\n          .single();\r\n\r\n      // On récupère la ville séparément si nécessaire\r\n      final cityResponse = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('id', departureCity.id)\r\n          .single();\r\n\r\n      // On combine les données\r\n      var tripResponse = response;\r\n      tripResponse['departure_city'] = cityResponse;\r\n\r\n      return Trip.fromJson(tripResponse);\r\n    } catch (e, stackTrace) {\r\n      print('Erreur dans saveTrip: $e');\r\n      print('Stack trace: $stackTrace');\r\n      throw TripCreationException('Erreur lors de la sauvegarde du voyage: $e');\r\n    }\r\n  }\r\n\r\n  Map<String, dynamic> _generateMetadata(DateTime startDate) {\r\n    return {\r\n      'season': _getSeason(startDate),\r\n      'transport_mode': 'car',  // Par défaut pour l'instant\r\n    };\r\n  }\r\n\r\n  String _getSeason(DateTime date) {\r\n    int month = date.month;\r\n    if (month >= 3 && month <= 5) return 'spring';\r\n    if (month >= 6 && month <= 8) return 'summer';\r\n    if (month >= 9 && month <= 11) return 'autumn';\r\n    return 'winter';\r\n  }\r\n\r\n  Future<List<Trip>> getTripsForUser(String userId) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .select('*, departure_city(*)')\r\n          .eq('user_id', userId);\r\n      return response.map((json) => Trip.fromJson(json)).toList();\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la récupération des voyages: $e');\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 3773,
        "last_modified": "2025-04-16T13:25:27.3683014",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\use_cases\\create_trip_use_case.dart",
      "content": "// core/domain/use_cases/create_trip_use_case.dart\r\n\r\nimport '../ports/trip_port.dart';\r\nimport '../ports/geocoding_port.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\n\r\n/// Use case pour créer un nouveau voyage\r\n/// Coordonne la création d'un voyage en validant la ville de départ\r\nclass CreateTripUseCase {\r\n  final TripPort _tripPort;\r\n  final GeocodingPort _geocodingPort;\r\n\r\n  CreateTripUseCase(this._tripPort, this._geocodingPort);\r\n\r\n  Future<Trip> execute(CreateTripParams params) async {\r\n    try {\r\n      print('CreateTripUseCase - Début de l\\'exécution');\r\n      print('Recherche de la ville: ${params.departureCityName}');\r\n\r\n      final city = await _geocodingPort.getCity(params.departureCityName);\r\n      print('Ville trouvée: ${city.cityName}');\r\n\r\n      print('Création du voyage...');\r\n      final trip = await _tripPort.createTrip(params, city);\r\n      print('Voyage créé avec succès');\r\n\r\n      return trip;\r\n    } catch (e, stackTrace) {\r\n      print('Erreur dans CreateTripUseCase: $e');\r\n      print('Stack trace: $stackTrace');\r\n      throw TripCreationException('Erreur lors de la création du voyage: $e');\r\n    }\r\n  }\r\n}\r\n\r\n/// Paramètres requis pour la création d'un voyage\r\nclass CreateTripParams {\r\n  final String userId;\r\n  final String title;\r\n  final DateTime startDate;\r\n  final DateTime endDate;\r\n  final String departureCityName;\r\n  final TravelGroup travelGroup;\r\n  final ActivityHours activityHours;\r\n  final double dailyBudget;\r\n  final TravelStyle travelStyle;\r\n  final PreferredMoment preferredMoment;\r\n  final String transportMode;\r\n\r\n  CreateTripParams({\r\n    required this.userId,\r\n    required this.title,\r\n    required this.startDate,\r\n    required this.endDate,\r\n    required this.departureCityName,\r\n    required this.travelGroup,\r\n    required this.activityHours,\r\n    required this.dailyBudget,\r\n    required this.travelStyle,\r\n    required this.preferredMoment,\r\n    required this.transportMode,\r\n  });\r\n}",
      "info": {
        "size": 2086,
        "last_modified": "2025-04-16T13:25:27.379313",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\use_cases\\process_activities_use_case.dart",
      "content": "// core/domain/use_cases/process_activities_use_case.dart\r\n\r\nimport '../ports/activity_processing_port.dart';\r\nimport '../ports/trip_port.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\n\r\n\r\nclass ProcessActivitiesUseCase {\r\n  final ActivityProcessingPort _processingPort;\r\n  final TripPort _tripPort;\r\n\r\n  ProcessActivitiesUseCase(this._processingPort, this._tripPort);\r\n\r\n  Future<List<ActivityForProcessing>> execute(String tripId) async {\r\n    try {\r\n      print('🔄 Début du processing des activités pour le voyage: $tripId');\r\n\r\n      // 1. Récupérer les détails du voyage\r\n      try {\r\n        final trip = await _tripPort.getTrip(tripId);\r\n        print('✅ Voyage récupéré: ${trip.title}');\r\n\r\n        // 2. Récupérer les activités brutes\r\n        final activities = await _processingPort.getActivitiesForTrip(tripId);\r\n        print('✅ ${activities.length} activités récupérées');\r\n\r\n        // 3. Obtenir les activités filtrées\r\n        return await _processingPort.getFilteredActivities(\r\n          tripId: tripId,\r\n          trip: trip,\r\n          activities: activities,\r\n        );\r\n      } on TripNotFoundException catch (e) {\r\n        print('❌ Voyage non trouvé: $tripId');\r\n        throw TripNotFoundException('Le voyage spécifié n\\'existe pas: $tripId');\r\n      }\r\n    } catch (e) {\r\n      print('❌ Erreur pendant le processing: $e');\r\n      throw DomainException('Erreur pendant le traitement des activités: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1686,
        "last_modified": "2025-04-16T13:25:27.3858231",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\use_cases\\search\\get_activities_use_case.dart",
      "content": "// lib/core/domain/use_cases/search/get_activities_use_case.dart\r\n\r\nimport '../../models/activity/search/searchable_activity.dart';\r\nimport '../../ports/search/activity_search_port.dart';\r\n\r\nfinal class GetActivitiesUseCase {\r\n  final ActivitySearchPort _searchPort;\r\n\r\n  GetActivitiesUseCase(this._searchPort);\r\n\r\n  Future<List<SearchableActivity>> executeQuery({\r\n    required double latitude,\r\n    required double longitude,\r\n    required String cityId,\r\n    required dynamic queryFilter,\r\n    String? categoryId,\r\n    String? subcategoryId,\r\n  }) async {\r\n    try {\r\n      print('📥 Input queryFilter: $queryFilter');\r\n\r\n      // Si c'est une String, on la convertit d'abord en Map\r\n      final Map<String, dynamic> filters;\r\n      if (queryFilter is String) {\r\n        // On retire les accolades et on split par virgule\r\n        final pairs = queryFilter\r\n            .replaceAll('{', '')\r\n            .replaceAll('}', '')\r\n            .split(',');\r\n\r\n        // On crée un Map à partir des paires clé:valeur\r\n        filters = {};\r\n        for (var pair in pairs) {\r\n          final parts = pair.split(':');\r\n          if (parts.length == 2) {\r\n            final key = parts[0].trim();\r\n            final value = parts[1].trim();\r\n            // Conversion des valeurs selon leur type\r\n            if (value == 'true') filters[key] = true;\r\n            else if (value == 'false') filters[key] = false;\r\n            else if (value == 'DESC' || value == 'ASC') filters[key] = value;\r\n            else if (value.contains('.')) filters[key] = double.tryParse(value);\r\n            else filters[key] = int.tryParse(value) ?? value;\r\n          }\r\n        }\r\n      } else {\r\n        filters = Map<String, dynamic>.from(queryFilter);\r\n      }\r\n\r\n      print('🔄 Parsed filters: $filters');\r\n\r\n      return _searchPort.getActivitiesWithFilters(\r\n        latitude: latitude,\r\n        longitude: longitude,\r\n        cityId: cityId,\r\n        maxDistance: filters['maxDistance']?.toDouble(),\r\n        isWow: filters['isWow'],\r\n        minRating: filters['minRating']?.toDouble(),\r\n        minRatingCount: filters['minRatingCount'],\r\n        kidFriendly: filters['kidFriendly'],\r\n        categoryId: null,  // La catégorie parent si nécessaire\r\n        subcategoryId: subcategoryId,\r\n      );\r\n\r\n    } catch (e, stackTrace) {\r\n      print('❌ Error in executeQuery: $e');\r\n      print('📜 Stack trace: $stackTrace');\r\n      throw Exception('Failed to execute query: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2489,
        "last_modified": "2025-04-16T13:25:27.3923381",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\animations\\ripple_animation.dart",
      "content": "// lib/core/theme/animations/ripple_animation.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\nclass RippleAnimation extends StatefulWidget {\r\n  final Widget child;\r\n  final VoidCallback? onTap;\r\n  final Color? rippleColor;\r\n  final Duration duration;\r\n\r\n  const RippleAnimation({\r\n    super.key,\r\n    required this.child,\r\n    this.onTap,\r\n    this.rippleColor,\r\n    this.duration = const Duration(milliseconds: 600),\r\n  });\r\n\r\n  @override\r\n  State<RippleAnimation> createState() => _RippleAnimationState();\r\n}\r\n\r\nclass _RippleAnimationState extends State<RippleAnimation> with SingleTickerProviderStateMixin {\r\n  late AnimationController _controller;\r\n  late Animation<double> _animation;\r\n  Offset? _tapPosition;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _controller = AnimationController(\r\n      duration: widget.duration,\r\n      vsync: this,\r\n    );\r\n    _animation = Tween<double>(begin: 0.0, end: 1.0).animate(\r\n      CurvedAnimation(\r\n        parent: _controller,\r\n        curve: Curves.easeOut,\r\n      ),\r\n    );\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _controller.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  void _handleTapDown(TapDownDetails details) {\r\n    setState(() {\r\n      _tapPosition = details.localPosition;\r\n    });\r\n  }\r\n\r\n  void _handleTap() {\r\n    if (_tapPosition != null) {\r\n      _controller.forward(from: 0.0);\r\n      widget.onTap?.call();\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTapDown: _handleTapDown,\r\n      onTap: _handleTap,\r\n      child: Stack(\r\n        children: [\r\n          widget.child,\r\n          if (_tapPosition != null)\r\n            AnimatedBuilder(\r\n              animation: _animation,\r\n              builder: (context, child) {\r\n                return CustomPaint(\r\n                  size: Size.infinite,\r\n                  painter: CircleRipplePainter(\r\n                    position: _tapPosition!,\r\n                    progress: _animation.value,\r\n                    color: widget.rippleColor ?? Colors.white.withAlpha(50),\r\n                  ),\r\n                );\r\n              },\r\n            ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass CircleRipplePainter extends CustomPainter {\r\n  final Offset position;\r\n  final double progress;\r\n  final Color color;\r\n\r\n  CircleRipplePainter({\r\n    required this.position,\r\n    required this.progress,\r\n    required this.color,\r\n  });\r\n\r\n  @override\r\n  void paint(Canvas canvas, Size size) {\r\n    final maxRadius = size.longestSide * 1.5;  // L'onde dépasse le widget\r\n    final Paint paint = Paint()\r\n      ..color = color.withOpacity(1 - progress)\r\n      ..style = PaintingStyle.fill;\r\n\r\n    canvas.drawCircle(\r\n      position,\r\n      maxRadius * progress,\r\n      paint,\r\n    );\r\n  }\r\n\r\n  @override\r\n  bool shouldRepaint(CircleRipplePainter oldDelegate) {\r\n    return oldDelegate.progress != progress;\r\n  }\r\n}",
      "info": {
        "size": 2904,
        "last_modified": "2025-04-16T13:25:27.4170352",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_colors.dart",
      "content": "// lib/core/theme/app_colors.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\n/// Système de couleurs de l'application Lyra\r\n///\r\n/// Cette classe contient toutes les couleurs utilisées dans l'application,\r\n/// organisées de manière sémantique et accessibles via des getters contextuels.\r\n/// Elle gère automatiquement les thèmes clairs et sombres.\r\nclass AppColors {\r\n  // Couleurs primaires\r\n  static const Color primary = Color(0xFF00798C); // Sports & Loisirs comme couleur principale\r\n  static const Color primaryDark = Color(0xFF005F70);\r\n  static const Color primaryLight = Color(0xFF4DACBD);\r\n\r\n  // Couleurs secondaires\r\n  static const Color secondary = Color(0xFF44AF69); // Nature\r\n  static const Color secondaryDark = Color(0xFF358F54);\r\n  static const Color secondaryLight = Color(0xFF7AC894);\r\n\r\n  // Couleurs d'accent\r\n  static const Color accent = Color(0xFFAD771F); // Culture\r\n  static const Color accentDark = Color(0xFF8A5E18);\r\n  static const Color accentLight = Color(0xFFD19F4F);\r\n\r\n  // Couleurs neutres\r\n  static const Color neutral900 = Color(0xFF212121); // Le plus foncé\r\n  static const Color neutral800 = Color(0xFF424242);\r\n  static const Color neutral700 = Color(0xFF616161);\r\n  static const Color neutral600 = Color(0xFF757575);\r\n  static const Color neutral500 = Color(0xFF9E9E9E);\r\n  static const Color neutral400 = Color(0xFFBDBDBD);\r\n  static const Color neutral300 = Color(0xFFE0E0E0);\r\n  static const Color neutral200 = Color(0xFFEEEEEE);\r\n  static const Color neutral100 = Color(0xFFF5F5F5);\r\n  static const Color neutral50 = Color(0xFFFAFAFA);  // Le plus clair\r\n\r\n  // Couleurs sémantiques\r\n  static const Color success = Color(0xFF4CAF50);\r\n  static const Color successDark = Color(0xFF3B8C3D);\r\n  static const Color successLight = Color(0xFF81C784);\r\n\r\n  static const Color error = Color(0xFFFF5252);\r\n  static const Color errorDark = Color(0xFFD32F2F);\r\n  static const Color errorLight = Color(0xFFFF8A80);\r\n\r\n  static const Color warning = Color(0xFFFFC107);\r\n  static const Color warningDark = Color(0xFFFFA000);\r\n  static const Color warningLight = Color(0xFFFFD54F);\r\n\r\n  static const Color info = Color(0xFF2196F3);\r\n  static const Color infoDark = Color(0xFF1976D2);\r\n  static const Color infoLight = Color(0xFF64B5F6);\r\n\r\n  // Couleurs de fond\r\n  static const Color background = Color(0xFFFEFEFE);\r\n  static const Color backgroundDark = Color(0xFF121212);\r\n\r\n  static const Color surfaceLight = Color(0xFFFFFFFF);\r\n  static const Color surfaceDark = Color(0xFF1E1E1E);\r\n\r\n  // Couleurs spécifiques aux catégories\r\n  static const Color categoryGastronomie = Color(0xFF4E040F);\r\n  static const Color categoryCulture = Color(0xFFAD771F);\r\n  static const Color categoryEvenements = Color(0xFFFF390E);\r\n  static const Color categoryBienEtre = Color(0xFFE09367);\r\n  static const Color categoryDetenteSoiree = Color(0xFF041E39);\r\n  static const Color categorySportsLoisirs = Color(0xFF00798C);\r\n  static const Color categoryNature = Color(0xFF44AF69);\r\n\r\n  // Versions dark des couleurs de catégorie\r\n  static const Color categoryGastronomieDark = Color(0xFF7A0617);\r\n  static const Color categoryCultureDark = Color(0xFFD19F4F);\r\n  static const Color categoryEvenementsDark = Color(0xFFFF6E4E);\r\n  static const Color categoryBienEtreDark = Color(0xFFECB395);\r\n  static const Color categoryDetenteSoireeDark = Color(0xFF1A3C5E);\r\n  static const Color categorySportsLoisirsDark = Color(0xFF4DACBD);\r\n  static const Color categoryNatureDark = Color(0xFF7AC894);\r\n\r\n  /// Obtient les couleurs des catégories en fonction du mode clair/sombre\r\n  static Color getCategoryColor(String category, {bool isDark = false}) {\r\n    switch (category.toLowerCase()) {\r\n      case 'gastronomie':\r\n        return isDark ? categoryGastronomieDark : categoryGastronomie;\r\n      case 'culture':\r\n        return isDark ? categoryCultureDark : categoryCulture;\r\n      case 'evenements':\r\n      case 'événements':\r\n        return isDark ? categoryEvenementsDark : categoryEvenements;\r\n      case 'bien-etre':\r\n      case 'bien être':\r\n        return isDark ? categoryBienEtreDark : categoryBienEtre;\r\n      case 'detente-soiree':\r\n      case 'détente et soirée':\r\n        return isDark ? categoryDetenteSoireeDark : categoryDetenteSoiree;\r\n      case 'sports-loisirs':\r\n      case 'sports & loisirs':\r\n        return isDark ? categorySportsLoisirsDark : categorySportsLoisirs;\r\n      case 'nature':\r\n        return isDark ? categoryNatureDark : categoryNature;\r\n      default:\r\n        return isDark ? primaryDark : primary;\r\n    }\r\n  }\r\n\r\n  /// Génère un ColorScheme complet pour le thème clair\r\n  static ColorScheme get lightColorScheme => ColorScheme(\r\n    primary: primary,\r\n    primaryContainer: primaryLight,\r\n    secondary: secondary,\r\n    secondaryContainer: secondaryLight,\r\n    surface: surfaceLight,\r\n    background: background,\r\n    error: error,\r\n    onPrimary: Colors.white,\r\n    onSecondary: Colors.white,\r\n    onSurface: neutral800,\r\n    onBackground: neutral900,\r\n    onError: Colors.white,\r\n    brightness: Brightness.light,\r\n  );\r\n\r\n  /// Génère un ColorScheme complet pour le thème sombre\r\n  static ColorScheme get darkColorScheme => ColorScheme(\r\n    primary: primaryDark,\r\n    primaryContainer: primary,\r\n    secondary: secondaryDark,\r\n    secondaryContainer: secondary,\r\n    surface: surfaceDark,\r\n    background: backgroundDark,\r\n    error: errorDark,\r\n    onPrimary: Colors.white,\r\n    onSecondary: Colors.white,\r\n    onSurface: neutral200,\r\n    onBackground: neutral100,\r\n    onError: Colors.white,\r\n    brightness: Brightness.dark,\r\n  );\r\n\r\n  /// Retourne les couleurs adaptées au contexte actuel (clair/sombre)\r\n  static Color getContextualColor(BuildContext context, Color lightColor, Color darkColor) {\r\n    final brightness = Theme.of(context).brightness;\r\n    return brightness == Brightness.light ? lightColor : darkColor;\r\n  }\r\n\r\n  /// Adapte automatiquement une couleur pour le mode sombre en l'éclaircissant\r\n  static Color adaptToDarkMode(Color color, {double lightenFactor = 0.2}) {\r\n    final hslColor = HSLColor.fromColor(color);\r\n    return hslColor.withLightness((hslColor.lightness + lightenFactor).clamp(0.0, 1.0)).toColor();\r\n  }\r\n\r\n  // COULEURS POUR SHIMMER EFFECT\r\n  // Couleurs pour l'effet de chargement en mode clair\r\n  static const Color shimmerBaseLight = Color(0xFFE0E0E0);\r\n  static const Color shimmerHighlightLight = Color(0xFFF5F5F5);\r\n\r\n  // Couleurs pour l'effet de chargement en mode sombre\r\n  static const Color shimmerBaseDark = Color(0xFF303030);\r\n  static const Color shimmerHighlightDark = Color(0xFF383838);\r\n\r\n  // Pour la compatibilité avec l'ancien code\r\n  static const Color shimmerBase = shimmerBaseLight;\r\n  static const Color shimmerHighlight = shimmerHighlightLight;\r\n\r\n  // Getters qui renvoient la couleur appropriée selon le mode\r\n  static Color getShimmerBase(bool isDark) => isDark ? shimmerBaseDark : shimmerBaseLight;\r\n  static Color getShimmerHighlight(bool isDark) => isDark ? shimmerHighlightDark : shimmerHighlightLight;\r\n\r\n}",
      "info": {
        "size": 7061,
        "last_modified": "2025-04-16T13:25:27.4291754",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_dimensions.dart",
      "content": "// lib/core/theme/app_dimensions.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\n/// Système de dimensions et d'espacements de l'application Lyra\r\n///\r\n/// Cette classe contient toutes les valeurs standards pour les espacements,\r\n/// rayons, tailles et élévations à utiliser de manière cohérente dans toute l'application.\r\nclass AppDimensions {\r\n  // Système d'espacement basé sur une grille de 4px\r\n  // Système de nommage: space{N} où N est la valeur en pixels divisée par 4\r\n  static const double space0 = 0;      // 0px - Pas d'espacement\r\n  static const double space1 = 4;      // 4px - Très petit\r\n  static const double space2 = 8;      // 8px - Petit\r\n  static const double space3 = 12;     // 12px - Compact\r\n  static const double space4 = 16;     // 16px - Standard\r\n  static const double space5 = 20;     // 20px - Moyen\r\n  static const double space6 = 24;     // 24px - Confortable\r\n  static const double space8 = 32;     // 32px - Large\r\n  static const double space10 = 40;    // 40px - Très large\r\n  static const double space12 = 48;    // 48px - Extra large\r\n  static const double space16 = 64;    // 64px - Énorme\r\n  static const double space20 = 80;    // 80px - Super énorme\r\n  static const double space24 = 96;    // 96px - Ultra large\r\n  static const double space32 = 128;   // 128px - Maximum\r\n\r\n  // Espacements nommés sémantiquement (plus facile à utiliser)\r\n  static const double spacingXxxs = space1;   // 4px\r\n  static const double spacingXxs = space2;    // 8px\r\n  static const double spacingXs = space3;     // 12px\r\n  static const double spacingS = space4;      // 16px\r\n  static const double spacingM = space6;      // 24px\r\n  static const double spacingL = space8;      // 32px\r\n  static const double spacingXl = space12;    // 48px\r\n  static const double spacingXxl = space16;   // 64px\r\n  static const double spacingXxxl = space24;  // 96px\r\n\r\n  // Paddings standards pour les containers\r\n  static const EdgeInsets paddingXxs = EdgeInsets.all(spacingXxs);\r\n  static const EdgeInsets paddingXs = EdgeInsets.all(spacingXs);\r\n  static const EdgeInsets paddingS = EdgeInsets.all(spacingS);\r\n  static const EdgeInsets paddingM = EdgeInsets.all(spacingM);\r\n  static const EdgeInsets paddingL = EdgeInsets.all(spacingL);\r\n\r\n  // Paddings horizontaux standards\r\n  static const EdgeInsets paddingHorizontalXxs = EdgeInsets.symmetric(horizontal: spacingXxs);\r\n  static const EdgeInsets paddingHorizontalXs = EdgeInsets.symmetric(horizontal: spacingXs);\r\n  static const EdgeInsets paddingHorizontalS = EdgeInsets.symmetric(horizontal: spacingS);\r\n  static const EdgeInsets paddingHorizontalM = EdgeInsets.symmetric(horizontal: spacingM);\r\n  static const EdgeInsets paddingHorizontalL = EdgeInsets.symmetric(horizontal: spacingL);\r\n\r\n  // Paddings verticaux standards\r\n  static const EdgeInsets paddingVerticalXxs = EdgeInsets.symmetric(vertical: spacingXxs);\r\n  static const EdgeInsets paddingVerticalXs = EdgeInsets.symmetric(vertical: spacingXs);\r\n  static const EdgeInsets paddingVerticalS = EdgeInsets.symmetric(vertical: spacingS);\r\n  static const EdgeInsets paddingVerticalM = EdgeInsets.symmetric(vertical: spacingM);\r\n  static const EdgeInsets paddingVerticalL = EdgeInsets.symmetric(vertical: spacingL);\r\n\r\n  // Paddings de page standards (horizontal seulement)\r\n  static const EdgeInsets pagePaddingSmall = EdgeInsets.symmetric(horizontal: spacingS);\r\n  static const EdgeInsets pagePaddingMedium = EdgeInsets.symmetric(horizontal: spacingM);\r\n  static const EdgeInsets pagePaddingLarge = EdgeInsets.symmetric(horizontal: spacingL);\r\n\r\n  // Rayons d'arrondi\r\n  static const double radiusNone = 0;                // Pas d'arrondis\r\n  static const double radiusXs = 4;                  // Très faible arrondi\r\n  static const double radiusS = 8;                   // Faible arrondi\r\n  static const double radiusM = 12;                  // Arrondi moyen\r\n  static const double radiusL = 16;                  // Grand arrondi\r\n  static const double radiusXl = 24;                 // Très grand arrondi\r\n  static const double radiusCircular = 1000;         // Complètement circulaire\r\n\r\n  // Border radius\r\n  static BorderRadius borderRadiusNone = BorderRadius.circular(radiusNone);\r\n  static BorderRadius borderRadiusXs = BorderRadius.circular(radiusXs);\r\n  static BorderRadius borderRadiusS = BorderRadius.circular(radiusS);\r\n  static BorderRadius borderRadiusM = BorderRadius.circular(radiusM);\r\n  static BorderRadius borderRadiusL = BorderRadius.circular(radiusL);\r\n  static BorderRadius borderRadiusXl = BorderRadius.circular(radiusXl);\r\n  static BorderRadius borderRadiusCircular = BorderRadius.circular(radiusCircular);\r\n\r\n  // Hauteurs standardisées pour les composants\r\n  static const double buttonHeightS = 32;     // Petit bouton\r\n  static const double buttonHeightM = 40;     // Bouton standard\r\n  static const double buttonHeightL = 48;     // Grand bouton\r\n  static const double buttonHeightXl = 56;    // Très grand bouton\r\n\r\n  static const double inputHeightS = 36;      // Petit champ de saisie\r\n  static const double inputHeightM = 44;      // Champ standard\r\n  static const double inputHeightL = 52;      // Grand champ\r\n\r\n  static const double appBarHeight = 56;      // Hauteur standard de la barre d'application\r\n  static const double tabBarHeight = 48;      // Hauteur de la barre d'onglets\r\n  static const double bottomNavBarHeight = 56; // Hauteur de la barre de navigation inférieure\r\n\r\n  // Tailles d'icônes\r\n  static const double iconSizeXs = 12;        // Très petite icône\r\n  static const double iconSizeS = 16;         // Petite icône\r\n  static const double iconSizeM = 24;         // Icône standard\r\n  static const double iconSizeL = 32;         // Grande icône\r\n  static const double iconSizeXl = 48;        // Très grande icône\r\n\r\n  // Niveaux d'élévation (pour les ombres)\r\n  static const double elevationNone = 0;      // Pas d'élévation\r\n  static const double elevationXs = 1;        // Très faible élévation\r\n  static const double elevationS = 2;         // Faible élévation (cartes)\r\n  static const double elevationM = 4;         // Élévation moyenne (barres d'app)\r\n  static const double elevationL = 8;         // Forte élévation (FAB, dialogs)\r\n  static const double elevationXl = 16;       // Très forte élévation (modals)\r\n\r\n  // Taille de l'avatar\r\n  static const double avatarSizeS = 32;       // Petit avatar\r\n  static const double avatarSizeM = 40;       // Avatar moyen\r\n  static const double avatarSizeL = 56;       // Grand avatar\r\n  static const double avatarSizeXl = 80;      // Très grand avatar\r\n\r\n  // Épaisseurs de bordure\r\n  static const double borderWidthThin = 1;    // Bordure fine\r\n  static const double borderWidthRegular = 2; // Bordure standard\r\n  static const double borderWidthThick = 3;   // Bordure épaisse\r\n\r\n  // Breakpoints pour le design responsive\r\n  static const double breakpointXs = 0;       // Extra petit (téléphones en portrait)\r\n  static const double breakpointS = 480;      // Petit (téléphones en paysage)\r\n  static const double breakpointM = 768;      // Moyen (tablettes)\r\n  static const double breakpointL = 1024;     // Large (tablettes paysage / petits ordinateurs)\r\n  static const double breakpointXl = 1440;    // Extra large (ordinateurs)\r\n\r\n  // Méthodes utilitaires pour le responsive\r\n\r\n  /// Détermine si l'écran actuel est considéré comme petit (téléphone en portrait)\r\n  static bool isSmallScreen(BuildContext context) {\r\n    return MediaQuery.of(context).size.width < breakpointS;\r\n  }\r\n\r\n  /// Détermine si l'écran actuel est considéré comme moyen (tablette)\r\n  static bool isMediumScreen(BuildContext context) {\r\n    final width = MediaQuery.of(context).size.width;\r\n    return width >= breakpointS && width < breakpointL;\r\n  }\r\n\r\n  /// Détermine si l'écran actuel est considéré comme large (tablette paysage / petit ordinateur)\r\n  static bool isLargeScreen(BuildContext context) {\r\n    final width = MediaQuery.of(context).size.width;\r\n    return width >= breakpointL && width < breakpointXl;\r\n  }\r\n\r\n  /// Détermine si l'écran actuel est considéré comme extra large (ordinateur)\r\n  static bool isExtraLargeScreen(BuildContext context) {\r\n    return MediaQuery.of(context).size.width >= breakpointXl;\r\n  }\r\n\r\n  /// Retourne une valeur qui s'adapte à la taille de l'écran\r\n  static double responsiveSize(\r\n      BuildContext context, {\r\n        required double small,\r\n        double? medium,\r\n        double? large,\r\n        double? extraLarge,\r\n      }) {\r\n    final screenWidth = MediaQuery.of(context).size.width;\r\n\r\n    if (screenWidth >= breakpointXl && extraLarge != null) {\r\n      return extraLarge;\r\n    } else if (screenWidth >= breakpointL && large != null) {\r\n      return large;\r\n    } else if (screenWidth >= breakpointS && medium != null) {\r\n      return medium;\r\n    } else {\r\n      return small;\r\n    }\r\n  }\r\n\r\n  /// Obtient le padding horizontal de page adapté à la taille de l'écran\r\n  static EdgeInsets getResponsivePagePadding(BuildContext context) {\r\n    if (isSmallScreen(context)) {\r\n      return pagePaddingSmall;\r\n    } else if (isMediumScreen(context)) {\r\n      return pagePaddingMedium;\r\n    } else {\r\n      return pagePaddingLarge;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 9281,
        "last_modified": "2025-04-16T13:25:27.4366898",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_filters.dart",
      "content": "// lib/core/theme/app_filters.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\nabstract class AppFilters {\r\n  // Désaturation de 10%\r\n  static const ColorFilter desaturate = ColorFilter.matrix([\r\n    0.8, 0, 0, 0, 0,    // Rouge à 90%\r\n    0, 0.8, 0, 0, 0,    // Vert à 90%\r\n    0, 0, 0.8, 0, 0,    // Bleu à 90%\r\n    0, 0, 0, 1, 0,      // Alpha inchangé\r\n  ]);\r\n\r\n  // Filtre beige\r\n  static final Color beigeOverlay = const Color(0xFFDE7C5A).withAlpha(20); // ~0.1 opacity\r\n}",
      "info": {
        "size": 485,
        "last_modified": "2025-04-16T13:25:27.4432061",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_fonts.dart",
      "content": "// lib/core/theme/app_fonts.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:google_fonts/google_fonts.dart';\r\n\r\n/// Configuration centralisée des polices de l'application\r\n///\r\n/// Cette classe permet de changer facilement la police principale\r\n/// utilisée dans toute l'application.\r\nclass AppFonts {\r\n  // Empêcher l'instanciation\r\n  AppFonts._();\r\n\r\n  /// Définit la police principale de l'application\r\n  /// Changer uniquement cette valeur pour modifier la police partout\r\n  static String _primaryFontFamily = 'Work Sans';\r\n\r\n  /// Définit si on utilise Google Fonts ou une police locale\r\n  static bool _useGoogleFonts = true;\r\n\r\n  /// Change la police principale de l'application\r\n  /// Exemple: AppFonts.changePrimaryFont('Roboto');\r\n  static void changePrimaryFont(String fontFamily, {bool useGoogleFonts = true}) {\r\n    _primaryFontFamily = fontFamily;\r\n    _useGoogleFonts = useGoogleFonts;\r\n  }\r\n\r\n  /// Méthode principale pour obtenir un TextStyle avec la police configurée\r\n  static TextStyle getFont({\r\n    required double fontSize,\r\n    FontWeight fontWeight = FontWeight.normal,\r\n    Color? color,\r\n    double? height,\r\n    double? letterSpacing,\r\n    TextDecoration? decoration,\r\n    FontStyle? fontStyle,\r\n  }) {\r\n    // Si on utilise Google Fonts\r\n    if (_useGoogleFonts) {\r\n      // Appel dynamique à la méthode GoogleFonts correspondante\r\n      return _getGoogleFont(\r\n        fontSize: fontSize,\r\n        fontWeight: fontWeight,\r\n        color: color,\r\n        height: height,\r\n        letterSpacing: letterSpacing,\r\n        decoration: decoration,\r\n        fontStyle: fontStyle,\r\n      );\r\n    }\r\n    // Sinon, on utilise une police locale\r\n    else {\r\n      return TextStyle(\r\n        fontFamily: _primaryFontFamily,\r\n        fontSize: fontSize,\r\n        fontWeight: fontWeight,\r\n        color: color,\r\n        height: height,\r\n        letterSpacing: letterSpacing,\r\n        decoration: decoration,\r\n        fontStyle: fontStyle,\r\n      );\r\n    }\r\n  }\r\n\r\n  /// Méthode pour obtenir un TextTheme complet avec la police configurée\r\n  static TextTheme getTextTheme(TextTheme baseTheme) {\r\n    if (_useGoogleFonts) {\r\n      // Appel dynamique à la méthode GoogleFonts correspondante\r\n      switch (_primaryFontFamily.toLowerCase()) {\r\n        case 'inter':\r\n          return GoogleFonts.interTextTheme(baseTheme);\r\n        case 'worksans':\r\n        case 'work sans':\r\n          return GoogleFonts.workSansTextTheme(baseTheme);\r\n        case 'roboto':\r\n          return GoogleFonts.robotoTextTheme(baseTheme);\r\n        case 'lato':\r\n          return GoogleFonts.latoTextTheme(baseTheme);\r\n        case 'poppins':\r\n          return GoogleFonts.poppinsTextTheme(baseTheme);\r\n      // Ajoutez d'autres polices courantes au besoin\r\n        default:\r\n        // Fallback: on utilise une technique générique mais moins optimisée\r\n          return baseTheme.apply(fontFamily: _primaryFontFamily);\r\n      }\r\n    } else {\r\n      return baseTheme.apply(fontFamily: _primaryFontFamily);\r\n    }\r\n  }\r\n\r\n  /// Méthode privée qui appelle dynamiquement la méthode GoogleFonts appropriée\r\n  static TextStyle _getGoogleFont({\r\n    required double fontSize,\r\n    FontWeight fontWeight = FontWeight.normal,\r\n    Color? color,\r\n    double? height,\r\n    double? letterSpacing,\r\n    TextDecoration? decoration,\r\n    FontStyle? fontStyle,\r\n  }) {\r\n    // Paramètres communs à toutes les polices\r\n    final Map<String, dynamic> textStyleParams = {\r\n      'fontSize': fontSize,\r\n      'fontWeight': fontWeight,\r\n      'color': color,\r\n      'height': height,\r\n      'letterSpacing': letterSpacing,\r\n      'decoration': decoration,\r\n      'fontStyle': fontStyle,\r\n    };\r\n\r\n    // Appel dynamique en fonction de la police choisie\r\n    switch (_primaryFontFamily.toLowerCase()) {\r\n      case 'inter':\r\n        return GoogleFonts.inter(\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n      case 'worksans':\r\n      case 'work sans':\r\n        return GoogleFonts.workSans(\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n      case 'poppins':\r\n        return GoogleFonts.poppins(\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n    // Ajoutez d'autres polices au besoin\r\n      default:\r\n      // Fallback pour les polices non listées\r\n        return TextStyle(\r\n          fontFamily: _primaryFontFamily,\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 5162,
        "last_modified": "2025-04-16T13:25:27.4492059",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_interactions.dart",
      "content": "// lib/core/theme/app_interactions.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_touch_ripple/flutter_touch_ripple.dart';\r\n\r\nclass AppInteractions {\r\n  static Widget addCircularRipple({\r\n    required Widget child,\r\n    required VoidCallback? onTap,\r\n    Color? rippleColor,\r\n  }) {\r\n    return TouchRipple(\r\n      onTap: onTap,\r\n      rippleColor: rippleColor?.withAlpha(20),\r\n      rippleScale: 1.8,\r\n      // Plus grand maintenant qu'on a le clipping\r\n      rippleBlurRadius: 3.0,\r\n      previewDuration: const Duration(milliseconds: 300),\r\n      tappableDuration: const Duration(milliseconds: 300),\r\n      focusColor: Colors.transparent,\r\n      hoverColor: Colors.transparent,\r\n      useFocusEffect: false,\r\n      useHoverEffect: false,\r\n      rippleBorderRadius: BorderRadius.circular(100),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  /// Durée très courte (100ms) - Pour micro-interactions\r\n  static const Duration durationFast = Duration(milliseconds: 100);\r\n\r\n  /// Durée courte (200ms) - Pour la plupart des interactions simples\r\n  static const Duration durationShort = Duration(milliseconds: 200);\r\n\r\n  /// Durée standard (300ms) - Pour les animations standards\r\n  static const Duration durationMedium = Duration(milliseconds: 300);\r\n\r\n  /// Durée longue (400ms) - Pour les transitions plus complexes\r\n  static const Duration durationLong = Duration(milliseconds: 400);\r\n\r\n  /// Durée très longue (600ms) - Pour les animations d'entrée/sortie d'écran\r\n  static const Duration durationXLong = Duration(milliseconds: 600);\r\n\r\n  // COURBES D'ANIMATION\r\n\r\n  /// Standard pour la plupart des animations\r\n  static const Curve standardEasing = Curves.easeInOut;\r\n\r\n  /// Pour les éléments qui entrent à l'écran\r\n  static const Curve inEasing = Curves.easeOut;\r\n\r\n  /// Pour les éléments qui sortent de l'écran\r\n  static const Curve outEasing = Curves.easeIn;\r\n\r\n  /// Pour les animations emphathiques (rebonds)\r\n  static const Curve emphasisEasing = Curves.elasticOut;\r\n\r\n  /// Pour les déplacements naturels (accélération puis décélération)\r\n  static const Curve naturalEasing = Curves.easeInOutCubic;\r\n\r\n  /// Pour un effet de ressort réaliste\r\n  static const Curve springEasing = Curves.elasticOut;\r\n\r\n  // DÉLAIS\r\n\r\n  /// Délai court pour décaler légèrement des animations\r\n  static const Duration delayShort = Duration(milliseconds: 50);\r\n\r\n  /// Délai moyen pour séquencer des animations\r\n  static const Duration delayMedium = Duration(milliseconds: 150);\r\n\r\n  /// Délai long pour séparer clairement des animations\r\n  static const Duration delayLong = Duration(milliseconds: 300);\r\n\r\n  // MÉTHODES D'ANIMATION\r\n\r\n  /// Crée une animation fade-in\r\n  static Widget fadeIn({\r\n    required Widget child,\r\n    Duration duration = durationMedium,\r\n    Curve curve = inEasing,\r\n    Duration delay = Duration.zero,\r\n  }) {\r\n    return TweenAnimationBuilder<double>(\r\n      tween: Tween<double>(begin: 0.0, end: 1.0),\r\n      duration: duration,\r\n      curve: curve,\r\n      builder: (context, value, child) => Opacity(\r\n        opacity: value,\r\n        child: child,\r\n      ),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  /// Crée une animation slide-in depuis le bas\r\n  static Widget slideInFromBottom({\r\n    required Widget child,\r\n    Duration duration = durationMedium,\r\n    Curve curve = inEasing,\r\n    double offset = 50.0,\r\n  }) {\r\n    return TweenAnimationBuilder<double>(\r\n      tween: Tween<double>(begin: offset, end: 0.0),\r\n      duration: duration,\r\n      curve: curve,\r\n      builder: (context, value, child) => Transform.translate(\r\n        offset: Offset(0, value),\r\n        child: child,\r\n      ),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  /// Crée une animation combinée fade-in et slide-in\r\n  static Widget fadeSlideIn({\r\n    required Widget child,\r\n    Duration duration = durationMedium,\r\n    Curve curve = inEasing,\r\n    double offset = 30.0,\r\n    Duration delay = Duration.zero,\r\n  }) {\r\n    return TweenAnimationBuilder<double>(\r\n      tween: Tween<double>(begin: 0.0, end: 1.0),\r\n      duration: duration,\r\n      curve: curve,\r\n      builder: (context, value, child) => Opacity(\r\n        opacity: value,\r\n        child: Transform.translate(\r\n          offset: Offset(0, offset * (1 - value)),\r\n          child: child,\r\n        ),\r\n      ),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n\r\n  /// Effet de ripple personnalisé pour les interactions tactiles\r\n  static Widget withRipple({\r\n    required Widget child,\r\n    required VoidCallback onTap,\r\n    Color? splashColor,\r\n    BorderRadius? borderRadius,\r\n    Duration duration = durationShort,\r\n  }) {\r\n    return Material(\r\n      color: Colors.transparent,\r\n      child: InkWell(\r\n        onTap: onTap,\r\n        splashColor: splashColor,\r\n        borderRadius: borderRadius,\r\n        child: child,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Animation séquentielle pour les listes d'éléments\r\n  static List<Widget> staggeredList({\r\n    required List<Widget> children,\r\n    Duration initialDelay = Duration.zero,\r\n    Duration staggerDelay = delayShort,\r\n    Duration itemDuration = durationMedium,\r\n    Curve curve = inEasing,\r\n    double offset = 30.0,\r\n  }) {\r\n    List<Widget> result = [];\r\n\r\n    for (int i = 0; i < children.length; i++) {\r\n      final delay = initialDelay + (staggerDelay * i);\r\n      result.add(\r\n        AnimatedBuilder(\r\n          animation: Listenable.merge([]),  // Dummy animation\r\n          builder: (context, _) {\r\n            return FutureBuilder(\r\n              future: Future.delayed(delay),\r\n              builder: (context, snapshot) {\r\n                if (snapshot.connectionState == ConnectionState.done) {\r\n                  return fadeSlideIn(\r\n                    child: children[i],\r\n                    duration: itemDuration,\r\n                    curve: curve,\r\n                    offset: offset,\r\n                  );\r\n                } else {\r\n                  return Opacity(opacity: 0, child: children[i]);\r\n                }\r\n              },\r\n            );\r\n          },\r\n        ),\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // TRANSITIONS DE PAGE\r\n\r\n  /// Transition de page avec fade\r\n  static PageRouteBuilder<T> fadeTransition<T>({\r\n    required Widget page,\r\n    Duration duration = durationLong,\r\n  }) {\r\n    return PageRouteBuilder<T>(\r\n      pageBuilder: (context, animation, secondaryAnimation) => page,\r\n      transitionDuration: duration,\r\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\r\n        return FadeTransition(\r\n          opacity: animation,\r\n          child: child,\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  /// Transition de page avec slide depuis la droite\r\n  static PageRouteBuilder<T> slideTransition<T>({\r\n    required Widget page,\r\n    Duration duration = durationLong,\r\n  }) {\r\n    return PageRouteBuilder<T>(\r\n      pageBuilder: (context, animation, secondaryAnimation) => page,\r\n      transitionDuration: duration,\r\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\r\n        const begin = Offset(1.0, 0.0);\r\n        const end = Offset.zero;\r\n        final tween = Tween(begin: begin, end: end);\r\n        final offsetAnimation = animation.drive(tween);\r\n\r\n        return SlideTransition(\r\n          position: offsetAnimation,\r\n          child: child,\r\n        );\r\n      },\r\n    );\r\n  }\r\n}\r\n",
      "info": {
        "size": 7337,
        "last_modified": "2025-04-16T13:25:27.4553447",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_theme.dart",
      "content": "// lib/core/theme/app_theme.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'app_colors.dart';\r\nimport 'app_typography.dart';\r\nimport 'app_dimensions.dart';\r\nimport 'app_fonts.dart';\r\nimport 'package:flutter/services.dart';\r\n\r\n/// Configuration complète du thème de l'application Lyra\r\n///\r\n/// Cette classe centralisée définit l'apparence globale de l'application\r\n/// en intégrant les couleurs, typographies et dimensions définies ailleurs.\r\nclass AppTheme {\r\n  // Empêche l'instanciation de la classe\r\n  AppTheme._();\r\n\r\n  /// Génère le thème clair de l'application\r\n  static ThemeData lightTheme(BuildContext context) {\r\n    return _buildTheme(context, Brightness.light);\r\n  }\r\n\r\n  /// Génère le thème sombre de l'application\r\n  static ThemeData darkTheme(BuildContext context) {\r\n    return _buildTheme(context, Brightness.dark);\r\n  }\r\n\r\n  /// Construit le thème avec la luminosité spécifiée\r\n  static ThemeData _buildTheme(BuildContext context, Brightness brightness) {\r\n    final isDark = brightness == Brightness.dark;\r\n    final colorScheme = isDark ? AppColors.darkColorScheme : AppColors.lightColorScheme;\r\n\r\n\r\n    // Construction du thème de base\r\n    return ThemeData(\r\n      useMaterial3: true,\r\n      brightness: brightness,\r\n      colorScheme: colorScheme,\r\n\r\n      // Couleurs de l'application\r\n      primaryColor: colorScheme.primary,\r\n      scaffoldBackgroundColor: colorScheme.background,\r\n      canvasColor: colorScheme.background,\r\n\r\n      // Configuration de la barre d'état\r\n      appBarTheme: AppBarTheme(\r\n        backgroundColor: colorScheme.surface,\r\n        foregroundColor: colorScheme.onSurface,\r\n        elevation: AppDimensions.elevationS,\r\n        systemOverlayStyle: isDark\r\n            ? SystemUiOverlayStyle.light.copyWith(\r\n          statusBarColor: Colors.transparent,\r\n        )\r\n            : SystemUiOverlayStyle.dark.copyWith(\r\n          statusBarColor: Colors.transparent,\r\n        ),\r\n        centerTitle: false,\r\n        iconTheme: IconThemeData(\r\n          color: colorScheme.onSurface,\r\n          size: AppDimensions.iconSizeM,\r\n        ),\r\n        titleTextStyle: context.titleLarge,\r\n      ),\r\n\r\n      // Configuration des cartes\r\n      cardTheme: CardTheme(\r\n        color: colorScheme.surface,\r\n        elevation: AppDimensions.elevationS,\r\n        margin: EdgeInsets.zero,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n        ),\r\n        clipBehavior: Clip.hardEdge,\r\n      ),\r\n\r\n      // Configuration de l'élévation\r\n      elevatedButtonTheme: ElevatedButtonThemeData(\r\n        style: ElevatedButton.styleFrom(\r\n          backgroundColor: colorScheme.primary,\r\n          foregroundColor: colorScheme.onPrimary,\r\n          elevation: AppDimensions.elevationXs,\r\n          padding: AppDimensions.paddingHorizontalS.add(AppDimensions.paddingVerticalXs),\r\n          shape: RoundedRectangleBorder(\r\n            borderRadius: AppDimensions.borderRadiusS,\r\n          ),\r\n          minimumSize: Size(0, AppDimensions.buttonHeightM),\r\n          textStyle: context.buttonStyle,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du bouton texte\r\n      textButtonTheme: TextButtonThemeData(\r\n        style: TextButton.styleFrom(\r\n          foregroundColor: colorScheme.primary,\r\n          padding: AppDimensions.paddingHorizontalS.add(AppDimensions.paddingVerticalXxs),\r\n          shape: RoundedRectangleBorder(\r\n            borderRadius: AppDimensions.borderRadiusS,\r\n          ),\r\n          minimumSize: Size(0, AppDimensions.buttonHeightM),\r\n          textStyle: context.buttonStyle,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du bouton avec contour\r\n      outlinedButtonTheme: OutlinedButtonThemeData(\r\n        style: OutlinedButton.styleFrom(\r\n          foregroundColor: colorScheme.primary,\r\n          side: BorderSide(\r\n            color: colorScheme.primary,\r\n            width: AppDimensions.borderWidthThin,\r\n          ),\r\n          padding: AppDimensions.paddingHorizontalS.add(AppDimensions.paddingVerticalXs),\r\n          shape: RoundedRectangleBorder(\r\n            borderRadius: AppDimensions.borderRadiusS,\r\n          ),\r\n          minimumSize: Size(0, AppDimensions.buttonHeightM),\r\n          textStyle: context.buttonStyle,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du bouton flottant d'action\r\n      floatingActionButtonTheme: FloatingActionButtonThemeData(\r\n        backgroundColor: colorScheme.primary,\r\n        foregroundColor: colorScheme.onPrimary,\r\n        elevation: AppDimensions.elevationM,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusCircular,\r\n        ),\r\n      ),\r\n\r\n      // Configuration de la barre inférieure\r\n      bottomNavigationBarTheme: BottomNavigationBarThemeData(\r\n        backgroundColor: colorScheme.surface,\r\n        selectedItemColor: colorScheme.primary,\r\n        unselectedItemColor: colorScheme.onSurface.withOpacity(0.6),\r\n        elevation: AppDimensions.elevationM,\r\n        type: BottomNavigationBarType.fixed,\r\n        showSelectedLabels: true,\r\n        showUnselectedLabels: true,\r\n      ),\r\n\r\n      // Configuration des champs de saisie\r\n      inputDecorationTheme: InputDecorationTheme(\r\n        filled: true,\r\n        fillColor: isDark\r\n            ? AppColors.neutral800.withOpacity(0.5)\r\n            : AppColors.neutral100,\r\n        border: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide.none,\r\n        ),\r\n        enabledBorder: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide.none,\r\n        ),\r\n        focusedBorder: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide(\r\n            color: colorScheme.primary,\r\n            width: AppDimensions.borderWidthThin,\r\n          ),\r\n        ),\r\n        errorBorder: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide(\r\n            color: colorScheme.error,\r\n            width: AppDimensions.borderWidthThin,\r\n          ),\r\n        ),\r\n        contentPadding: AppDimensions.paddingS,\r\n        hintStyle: context.bodyMedium,\r\n        labelStyle: context.labelMedium,\r\n        errorStyle: context.labelSmall\r\n            .copyWith(color: colorScheme.error),\r\n      ),\r\n\r\n      // Configuration des listes\r\n      listTileTheme: ListTileThemeData(\r\n        contentPadding: AppDimensions.paddingHorizontalS,\r\n        minLeadingWidth: AppDimensions.space8,\r\n        minVerticalPadding: AppDimensions.space3,\r\n        tileColor: Colors.transparent,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du SnackBar\r\n      snackBarTheme: SnackBarThemeData(\r\n        backgroundColor: isDark\r\n            ? AppColors.neutral800\r\n            : AppColors.neutral900,\r\n        contentTextStyle: AppFonts.getFont(\r\n          fontSize: 14,\r\n          color: Colors.white,\r\n        ),\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n        ),\r\n        behavior: SnackBarBehavior.floating,\r\n        elevation: AppDimensions.elevationM,\r\n      ),\r\n\r\n      // Configuration des onglets\r\n      tabBarTheme: TabBarTheme(\r\n        labelColor: colorScheme.primary,\r\n        unselectedLabelColor: colorScheme.onSurface.withOpacity(0.7),\r\n        indicatorColor: colorScheme.primary,\r\n        labelStyle: context.labelMedium,\r\n        unselectedLabelStyle: context.labelMedium,\r\n      ),\r\n\r\n      // Configuration des diviseurs\r\n      dividerTheme: DividerThemeData(\r\n        color: isDark\r\n            ? AppColors.neutral700\r\n            : AppColors.neutral300,\r\n        thickness: 1,\r\n        space: AppDimensions.space2,\r\n      ),\r\n\r\n      // Configuration du switch\r\n      switchTheme: SwitchThemeData(\r\n        thumbColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.selected)) {\r\n            return colorScheme.primary;\r\n          }\r\n          return isDark ? AppColors.neutral400 : AppColors.neutral500;\r\n        }),\r\n        trackColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.selected)) {\r\n            return colorScheme.primary.withOpacity(0.5);\r\n          }\r\n          return isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n        }),\r\n      ),\r\n\r\n      // Configuration du thème des icônes\r\n      iconTheme: IconThemeData(\r\n        color: colorScheme.onSurface,\r\n        size: AppDimensions.iconSizeM,\r\n      ),\r\n\r\n      // Configuration des dialogues\r\n      dialogTheme: DialogTheme(\r\n        backgroundColor: colorScheme.surface,\r\n        elevation: AppDimensions.elevationL,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusL,\r\n        ),\r\n      ),\r\n\r\n      // Typographie complète\r\n      textTheme: AppTypography.createTextTheme(context.isDark),\r\n    );\r\n  }\r\n\r\n  /// Configure les styles de l'application pour les versions iOS et Android\r\n  static void setupSystemUI({required bool isDarkMode}) {\r\n    // Configurer la barre d'état\r\n    SystemChrome.setSystemUIOverlayStyle(\r\n      isDarkMode\r\n          ? SystemUiOverlayStyle.light.copyWith(\r\n        statusBarColor: Colors.transparent,\r\n        systemNavigationBarColor: AppColors.backgroundDark,\r\n        systemNavigationBarIconBrightness: Brightness.light,\r\n      )\r\n          : SystemUiOverlayStyle.dark.copyWith(\r\n        statusBarColor: Colors.transparent,\r\n        systemNavigationBarColor: AppColors.background,\r\n        systemNavigationBarIconBrightness: Brightness.dark,\r\n      ),\r\n    );\r\n\r\n    // Orienter l'application en mode portrait uniquement\r\n    SystemChrome.setPreferredOrientations([\r\n      DeviceOrientation.portraitUp,\r\n      DeviceOrientation.portraitDown,\r\n    ]);\r\n  }\r\n}",
      "info": {
        "size": 9944,
        "last_modified": "2025-04-16T13:25:27.4623739",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_typography.dart",
      "content": "// lib/core/theme/app_typography.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:google_fonts/google_fonts.dart';\r\nimport 'app_colors.dart';\r\nimport 'app_fonts.dart';\r\n\r\n/// Système typographique simplifié de l'application\r\n///\r\n/// Définit 9 styles principaux (3 niveaux pour chaque catégorie)\r\n/// et prend en compte les modes clair/sombre automatiquement.\r\nclass AppTypography {\r\n\r\n  // Paramètres communs\r\n  static const double _lineHeightNormal = 1.5;\r\n  static const double _lineHeightCompact = 1.3;\r\n  static const double _letterSpacingNormal = 0.0;\r\n\r\n  // TITRES (3 niveaux)\r\n\r\n  /// Grand titre (ex: titres de page)\r\n  static TextStyle titleLarge({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 24,\r\n    fontWeight: FontWeight.bold,\r\n    letterSpacing: -0.5,\r\n    color: isDark ? AppColors.neutral50 : AppColors.neutral900,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Titre moyen (ex: titres de section)\r\n  static TextStyle titleMedium({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 20,\r\n    fontWeight: FontWeight.w600,\r\n    letterSpacing: -0.25,\r\n    color: isDark ? AppColors.neutral50 : AppColors.neutral900,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Petit titre (ex: titres de carte/élément)\r\n  static TextStyle titleSmall({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 16,\r\n    fontWeight: FontWeight.w600,\r\n    letterSpacing: 0,\r\n    color: isDark ? AppColors.neutral50 : AppColors.neutral900,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  // CORPS DE TEXTE (3 niveaux)\r\n\r\n  /// Grand texte (ex: contenu important)\r\n  static TextStyle bodyLarge({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 16,\r\n    fontWeight: FontWeight.normal,\r\n    letterSpacing: _letterSpacingNormal,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightNormal,\r\n  );\r\n\r\n  /// Texte moyen (ex: contenu standard)\r\n  static TextStyle bodyMedium({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.normal,\r\n    letterSpacing: _letterSpacingNormal,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightNormal,\r\n  );\r\n\r\n  /// Petit texte (ex: notes secondaires)\r\n  static TextStyle bodySmall({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 12,\r\n    fontWeight: FontWeight.normal,\r\n    letterSpacing: _letterSpacingNormal,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightNormal,\r\n  );\r\n\r\n  // LABELS (3 niveaux)\r\n\r\n  /// Grand label (ex: grands chips/filtres)\r\n  static TextStyle labelLarge({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.w500,\r\n    letterSpacing: 0.1,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Label moyen (ex: boutons, chips)\r\n  static TextStyle labelMedium({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 12,\r\n    fontWeight: FontWeight.w500,\r\n    letterSpacing: 0.1,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Petit label (ex: petites annotations)\r\n  static TextStyle labelSmall({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 10,\r\n    fontWeight: FontWeight.w500,\r\n    letterSpacing: 0.1,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  // STYLES SPÉCIAUX COURANTS\r\n\r\n  /// Style pour les boutons\r\n  static TextStyle buttonStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.w600,\r\n    letterSpacing: 0.1,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Style pour les chips normaux\r\n  static TextStyle chipLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.w500,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n    height: _lineHeightCompact,\r\n    letterSpacing: 0.1,\r\n  );\r\n\r\n  /// Style pour les chips sélectionnés\r\n  static TextStyle chipSelectedLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    fontWeight: FontWeight.bold,\r\n    color: AppColors.primary,\r\n  );\r\n\r\n  /// Style pour les titres de carte d'activité\r\n  static TextStyle cardTitleStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 16,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    color: Colors.white,\r\n    fontWeight: FontWeight.bold,\r\n  );\r\n\r\n  /// Style pour les catégories de carte d'activité\r\n  static TextStyle cardCategoryStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    color: Colors.white,\r\n  );\r\n\r\n  /// Style pour les sous-titres de carte d'activité\r\n  static TextStyle cardSubtitleStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 13,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    color: Colors.white.withOpacity(0.8),\r\n  );\r\n\r\n  /// Style pour les items normaux dans la navigation\r\n  static TextStyle itemLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n    // isSecondary: true,\r\n  );\r\n\r\n  /// Style pour les items sélectionnés dans la navigation\r\n  static TextStyle itemSelectedLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n      fontSize: 14,\r\n      color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    fontWeight: FontWeight.bold,\r\n    color: AppColors.primary,\r\n  );\r\n\r\n  // HELPERS\r\n\r\n  /// Obtient la couleur appropriée pour le texte corps selon le mode et l'importance\r\n  static Color _getBodyColor(bool isDark, bool isSecondary) {\r\n    if (isSecondary) {\r\n      return isDark ? AppColors.neutral400 : AppColors.neutral600;\r\n    } else {\r\n      return isDark ? AppColors.neutral100 : AppColors.neutral900;\r\n    }\r\n  }\r\n\r\n  /// Crée un TextTheme complet pour le ThemeData\r\n  static TextTheme createTextTheme(bool isDark) {\r\n    final baseTheme = TextTheme(\r\n      // Titres\r\n      headlineLarge: titleLarge(isDark: isDark),\r\n      headlineMedium: titleMedium(isDark: isDark),\r\n      headlineSmall: titleSmall(isDark: isDark),\r\n\r\n      // Corps\r\n      bodyLarge: bodyLarge(isDark: isDark),\r\n      bodyMedium: bodyMedium(isDark: isDark),\r\n      bodySmall: bodySmall(isDark: isDark),\r\n\r\n      // Divers\r\n      titleLarge: titleLarge(isDark: isDark),\r\n      titleMedium: titleMedium(isDark: isDark),\r\n      titleSmall: titleSmall(isDark: isDark),\r\n      labelLarge: labelLarge(isDark: isDark),\r\n      labelMedium: labelMedium(isDark: isDark),\r\n      labelSmall: labelSmall(isDark: isDark),\r\n    );\r\n    return AppFonts.getTextTheme(baseTheme);\r\n  }\r\n}\r\n\r\n/// Extension sur BuildContext pour faciliter l'accès aux thèmes et typographies\r\nextension ThemeHelperExtension on BuildContext {\r\n  /// Indique si le thème actuel est en mode sombre\r\n  bool get isDark =>\r\n      Theme\r\n          .of(this)\r\n          .brightness == Brightness.dark;\r\n\r\n  /// Accès rapide aux styles typographiques en tenant compte du thème actuel\r\n\r\n  // Titres\r\n  TextStyle get titleLarge => AppTypography.titleLarge(isDark: isDark);\r\n\r\n  TextStyle get titleMedium => AppTypography.titleMedium(isDark: isDark);\r\n\r\n  TextStyle get titleSmall => AppTypography.titleSmall(isDark: isDark);\r\n\r\n  // Corps de texte\r\n  TextStyle get bodyLarge => AppTypography.bodyLarge(isDark: isDark);\r\n\r\n  TextStyle get bodyMedium => AppTypography.bodyMedium(isDark: isDark);\r\n\r\n  TextStyle get bodySmall => AppTypography.bodySmall(isDark: isDark);\r\n\r\n  // Labels\r\n  TextStyle get labelLarge => AppTypography.labelLarge(isDark: isDark);\r\n\r\n  TextStyle get labelMedium => AppTypography.labelMedium(isDark: isDark);\r\n\r\n  TextStyle get labelSmall => AppTypography.labelSmall(isDark: isDark);\r\n\r\n  // Corps de texte secondaire\r\n  TextStyle get bodyLargeSecondary =>\r\n      AppTypography.bodyLarge(isDark: isDark, isSecondary: true);\r\n\r\n  TextStyle get bodyMediumSecondary =>\r\n      AppTypography.bodyMedium(isDark: isDark, isSecondary: true);\r\n\r\n  TextStyle get bodySmallSecondary =>\r\n      AppTypography.bodySmall(isDark: isDark, isSecondary: true);\r\n\r\n  // Styles spéciaux\r\n  TextStyle get buttonStyle => AppTypography.buttonStyle(isDark: isDark);\r\n\r\n  TextStyle get chipLabel => AppTypography.chipLabelStyle(isDark: isDark);\r\n\r\n  TextStyle get chipSelectedLabel =>\r\n      AppTypography.chipSelectedLabelStyle(isDark: isDark);\r\n\r\n  TextStyle get cardTitle => AppTypography.cardTitleStyle(isDark: isDark);\r\n\r\n  TextStyle get cardCategory => AppTypography.cardCategoryStyle(isDark: isDark);\r\n\r\n  TextStyle get cardSubtitle => AppTypography.cardSubtitleStyle(isDark: isDark);\r\n\r\n  TextStyle get itemLabel => AppTypography.itemLabelStyle(isDark: isDark);\r\n\r\n  TextStyle get itemSelectedLabel =>\r\n      AppTypography.itemSelectedLabelStyle(isDark: isDark);\r\n}",
      "info": {
        "size": 9142,
        "last_modified": "2025-04-16T13:25:27.4684179",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_button.dart",
      "content": "// lib/core/theme/atoms/app_button.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../theme/app_colors.dart';\r\nimport '../../theme/app_dimensions.dart';\r\nimport '../../theme/app_interactions.dart';\r\nimport '../../theme/app_typography.dart';\r\n\r\n/// Enum définissant les différentes variantes de boutons\r\nenum AppButtonVariant {\r\n  primary,\r\n  secondary,\r\n  outlined,\r\n  text,\r\n  error,\r\n  success,\r\n  category,\r\n}\r\n\r\n/// Enum définissant les différentes tailles de boutons\r\nenum AppButtonSize {\r\n  small,\r\n  medium,\r\n  large,\r\n}\r\n\r\n/// Bouton personnalisé réutilisable suivant le design system de Lyra\r\n///\r\n/// Composant atomique fondamental pour toutes les actions utilisateur.\r\nclass AppButton extends StatelessWidget {\r\n  /// Label du bouton\r\n  final String label;\r\n\r\n  /// Fonction appelée quand le bouton est pressé\r\n  final VoidCallback? onPressed;\r\n\r\n  /// Variante stylistique du bouton\r\n  final AppButtonVariant variant;\r\n\r\n  /// Taille du bouton\r\n  final AppButtonSize size;\r\n\r\n  /// Icône à afficher avant le texte (optionnel)\r\n  final IconData? leadingIcon;\r\n\r\n  /// Icône à afficher après le texte (optionnel)\r\n  final IconData? trailingIcon;\r\n\r\n  /// Si true, le bouton prendra toute la largeur disponible\r\n  final bool isFullWidth;\r\n\r\n  /// Indique si le bouton est en état de chargement\r\n  final bool isLoading;\r\n\r\n  /// Style personnalisé pour le texte du bouton (optionnel)\r\n  final TextStyle? customTextStyle;\r\n\r\n  /// Couleur de catégorie (utilisée uniquement avec AppButtonVariant.category)\r\n  final Color? categoryColor;\r\n\r\n  /// Ombre personnalisée (optionnel)\r\n  final List<BoxShadow>? customShadow;\r\n\r\n  /// Radius personnalisé pour les coins (optionnel)\r\n  final BorderRadius? customBorderRadius;\r\n\r\n  const AppButton({\r\n    Key? key,\r\n    required this.label,\r\n    required this.onPressed,\r\n    this.variant = AppButtonVariant.primary,\r\n    this.size = AppButtonSize.medium,\r\n    this.leadingIcon,\r\n    this.trailingIcon,\r\n    this.isFullWidth = false,\r\n    this.isLoading = false,\r\n    this.customTextStyle,\r\n    this.categoryColor,\r\n    this.customShadow,\r\n    this.customBorderRadius,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    // Déterminer si le bouton est désactivé\r\n    final bool isDisabled = onPressed == null || isLoading;\r\n\r\n    // Appliquer les dimensions en fonction de la taille choisie\r\n    final double height = _getHeight();\r\n    final EdgeInsets padding = _getPadding();\r\n    final double iconSize = _getIconSize();\r\n\r\n    // Configurer les couleurs et styles en fonction de la variante\r\n    final ButtonStyle buttonStyle = _getButtonStyle(context, isDisabled);\r\n\r\n    // Construire le contenu du bouton (texte et/ou icônes)\r\n    Widget buttonContent = _buildButtonContent(context, iconSize, isDisabled);\r\n\r\n    // Ajouter l'indicateur de chargement si nécessaire\r\n    if (isLoading) {\r\n      buttonContent = Stack(\r\n        alignment: Alignment.center,\r\n        children: [\r\n          Opacity(opacity: 0, child: buttonContent),\r\n          SizedBox(\r\n            height: iconSize,\r\n            width: iconSize,\r\n            child: CircularProgressIndicator(\r\n              strokeWidth: 2,\r\n              valueColor: AlwaysStoppedAnimation<Color>(_getButtonContentColor(context, isDisabled)),\r\n            ),\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    // Créer le bouton final avec tous les attributs configurés\r\n    return SizedBox(\r\n      height: height,\r\n      width: isFullWidth ? double.infinity : null,\r\n      child: variant == AppButtonVariant.text\r\n          ? TextButton(\r\n        onPressed: isDisabled ? null : onPressed,\r\n        style: buttonStyle,\r\n        child: buttonContent,\r\n      )\r\n          : ElevatedButton(\r\n        onPressed: isDisabled ? null : onPressed,\r\n        style: buttonStyle,\r\n        child: buttonContent,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Construit le contenu interne du bouton (texte et icônes)\r\n  Widget _buildButtonContent(BuildContext context, double iconSize, bool isDisabled) {\r\n    final TextStyle textStyle = customTextStyle ??\r\n        _getTextStyle(context, isDisabled);\r\n\r\n    // Liste des éléments à afficher horizontalement\r\n    final List<Widget> rowChildren = [];\r\n\r\n    // Ajouter l'icône de gauche si présente\r\n    if (leadingIcon != null) {\r\n      rowChildren.add(\r\n        Icon(\r\n          leadingIcon,\r\n          size: iconSize,\r\n          color: textStyle.color,\r\n        ),\r\n      );\r\n      rowChildren.add(SizedBox(width: AppDimensions.space2));\r\n    }\r\n\r\n    // Ajouter le texte\r\n    rowChildren.add(\r\n      Text(\r\n        label,\r\n        style: textStyle,\r\n      ),\r\n    );\r\n\r\n    // Ajouter l'icône de droite si présente\r\n    if (trailingIcon != null) {\r\n      rowChildren.add(SizedBox(width: AppDimensions.space2));\r\n      rowChildren.add(\r\n        Icon(\r\n          trailingIcon,\r\n          size: iconSize,\r\n          color: textStyle.color,\r\n        ),\r\n      );\r\n    }\r\n\r\n    // Retourner la rangée complète\r\n    return Row(\r\n      mainAxisSize: MainAxisSize.min,\r\n      mainAxisAlignment: MainAxisAlignment.center,\r\n      children: rowChildren,\r\n    );\r\n  }\r\n\r\n  /// Détermine la hauteur du bouton selon sa taille\r\n  double _getHeight() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return AppDimensions.buttonHeightS;\r\n      case AppButtonSize.medium:\r\n        return AppDimensions.buttonHeightM;\r\n      case AppButtonSize.large:\r\n        return AppDimensions.buttonHeightL;\r\n    }\r\n  }\r\n\r\n  /// Détermine le padding interne du bouton selon sa taille\r\n  EdgeInsets _getPadding() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return EdgeInsets.symmetric(\r\n          horizontal: AppDimensions.space3,\r\n          vertical: AppDimensions.space1,\r\n        );\r\n      case AppButtonSize.medium:\r\n        return EdgeInsets.symmetric(\r\n          horizontal: AppDimensions.space4,\r\n          vertical: AppDimensions.space2,\r\n        );\r\n      case AppButtonSize.large:\r\n        return EdgeInsets.symmetric(\r\n          horizontal: AppDimensions.space5,\r\n          vertical: AppDimensions.space2,\r\n        );\r\n    }\r\n  }\r\n\r\n  /// Détermine la taille des icônes selon la taille du bouton\r\n  double _getIconSize() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return AppDimensions.iconSizeS;\r\n      case AppButtonSize.medium:\r\n        return AppDimensions.iconSizeM;\r\n      case AppButtonSize.large:\r\n        return AppDimensions.iconSizeM;\r\n    }\r\n  }\r\n\r\n  /// Configuration complète du style du bouton selon sa variante\r\n  ButtonStyle _getButtonStyle(BuildContext context, bool isDisabled) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Border radius selon la taille\r\n    final BorderRadius borderRadius = customBorderRadius ?? _getBorderRadius();\r\n\r\n    // Couleur de fond selon la variante\r\n    final Color backgroundColor = _getBackgroundColor(context, isDisabled);\r\n\r\n    // Couleur du contenu (texte et icônes)\r\n    final Color contentColor = _getButtonContentColor(context, isDisabled);\r\n\r\n    // Gérer le cas spécial du bouton outlined\r\n    if (variant == AppButtonVariant.outlined) {\r\n      return ButtonStyle(\r\n        backgroundColor: MaterialStateProperty.all(Colors.transparent),\r\n        foregroundColor: MaterialStateProperty.all(contentColor),\r\n        overlayColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.pressed)) {\r\n            return contentColor.withOpacity(0.1);\r\n          }\r\n          if (states.contains(MaterialState.hovered)) {\r\n            return contentColor.withOpacity(0.05);\r\n          }\r\n          return null;\r\n        }),\r\n        side: MaterialStateProperty.all(\r\n          BorderSide(\r\n            color: isDisabled\r\n                ? (isDark ? AppColors.neutral700 : AppColors.neutral300)\r\n                : contentColor,\r\n            width: 1.0,\r\n          ),\r\n        ),\r\n        shape: MaterialStateProperty.all(\r\n          RoundedRectangleBorder(borderRadius: borderRadius),\r\n        ),\r\n        padding: MaterialStateProperty.all(_getPadding()),\r\n        elevation: MaterialStateProperty.all(0),\r\n      );\r\n    }\r\n\r\n    // Gérer le cas du bouton texte\r\n    if (variant == AppButtonVariant.text) {\r\n      return ButtonStyle(\r\n        backgroundColor: MaterialStateProperty.all(Colors.transparent),\r\n        foregroundColor: MaterialStateProperty.all(contentColor),\r\n        overlayColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.pressed)) {\r\n            return contentColor.withOpacity(0.1);\r\n          }\r\n          if (states.contains(MaterialState.hovered)) {\r\n            return contentColor.withOpacity(0.05);\r\n          }\r\n          return null;\r\n        }),\r\n        shape: MaterialStateProperty.all(\r\n          RoundedRectangleBorder(borderRadius: borderRadius),\r\n        ),\r\n        padding: MaterialStateProperty.all(_getPadding()),\r\n        elevation: MaterialStateProperty.all(0),\r\n      );\r\n    }\r\n\r\n    // Style pour les autres variantes (primary, secondary, etc.)\r\n    return ButtonStyle(\r\n      backgroundColor: MaterialStateProperty.all(backgroundColor),\r\n      foregroundColor: MaterialStateProperty.all(contentColor),\r\n      overlayColor: MaterialStateProperty.resolveWith((states) {\r\n        if (states.contains(MaterialState.pressed)) {\r\n          return Colors.black.withOpacity(0.1);\r\n        }\r\n        return null;\r\n      }),\r\n      shape: MaterialStateProperty.all(\r\n        RoundedRectangleBorder(borderRadius: borderRadius),\r\n      ),\r\n      padding: MaterialStateProperty.all(_getPadding()),\r\n      elevation: MaterialStateProperty.resolveWith((states) {\r\n        if (states.contains(MaterialState.disabled)) {\r\n          return 0;\r\n        }\r\n        if (states.contains(MaterialState.pressed)) {\r\n          return 1;\r\n        }\r\n        return variant == AppButtonVariant.primary ? 2 : 0;\r\n      }),\r\n      shadowColor: MaterialStateProperty.all(\r\n        variant == AppButtonVariant.primary\r\n            ? colorScheme.primary.withOpacity(0.5)\r\n            : Colors.black.withOpacity(0.3),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Obtient le style de texte approprié selon la variante et l'état\r\n  TextStyle _getTextStyle(BuildContext context, bool isDisabled) {\r\n    // Utiliser le style de bouton standard comme base\r\n    final baseStyle = context.buttonStyle;\r\n\r\n    // Adapter selon la taille du bouton\r\n    TextStyle adjustedStyle = baseStyle;\r\n    if (size == AppButtonSize.small) {\r\n      adjustedStyle = baseStyle.copyWith(\r\n        fontSize: 14,\r\n      );\r\n    } else if (size == AppButtonSize.large) {\r\n      adjustedStyle = baseStyle.copyWith(\r\n        fontSize: 16,\r\n      );\r\n    }\r\n\r\n    // Appliquer la couleur selon l'état et la variante\r\n    return adjustedStyle.copyWith(\r\n      color: _getButtonContentColor(context, isDisabled),\r\n    );\r\n  }\r\n\r\n  /// Obtient la couleur d'arrière-plan selon la variante\r\n  Color _getBackgroundColor(BuildContext context, bool isDisabled) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Si le bouton est désactivé, il a une couleur grisée\r\n    if (isDisabled) {\r\n      return isDark ? AppColors.neutral800 : AppColors.neutral200;\r\n    }\r\n\r\n    // Sinon, choisir la couleur selon la variante\r\n    switch (variant) {\r\n      case AppButtonVariant.primary:\r\n        return colorScheme.primary;\r\n      case AppButtonVariant.secondary:\r\n        return colorScheme.secondary;\r\n      case AppButtonVariant.outlined:\r\n        return Colors.transparent;\r\n      case AppButtonVariant.text:\r\n        return Colors.transparent;\r\n      case AppButtonVariant.error:\r\n        return colorScheme.error;\r\n      case AppButtonVariant.success:\r\n        return AppColors.success;\r\n      case AppButtonVariant.category:\r\n        return categoryColor ?? AppColors.primary;\r\n    }\r\n  }\r\n\r\n  /// Obtient la couleur du contenu (texte/icônes) selon la variante\r\n  Color _getButtonContentColor(BuildContext context, bool isDisabled) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Si le bouton est désactivé\r\n    if (isDisabled) {\r\n      if (variant == AppButtonVariant.outlined || variant == AppButtonVariant.text) {\r\n        return isDark ? AppColors.neutral600 : AppColors.neutral400;\r\n      }\r\n      return isDark ? AppColors.neutral500 : AppColors.neutral500;\r\n    }\r\n\r\n    // Pour les variantes transparentes\r\n    if (variant == AppButtonVariant.outlined || variant == AppButtonVariant.text) {\r\n      switch (variant) {\r\n        case AppButtonVariant.outlined:\r\n        case AppButtonVariant.text:\r\n          if (variant == AppButtonVariant.error) {\r\n            return colorScheme.error;\r\n          } else if (variant == AppButtonVariant.success) {\r\n            return AppColors.success;\r\n          } else if (variant == AppButtonVariant.category) {\r\n            return categoryColor ?? colorScheme.primary;\r\n          } else {\r\n            return colorScheme.primary;\r\n          }\r\n        default:\r\n          return colorScheme.primary;\r\n      }\r\n    }\r\n\r\n    // Pour les variantes avec fond coloré (texte généralement blanc)\r\n    return Colors.white;\r\n  }\r\n\r\n  /// Obtient le border radius selon la taille du bouton\r\n  BorderRadius _getBorderRadius() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return AppDimensions.borderRadiusS;\r\n      case AppButtonSize.medium:\r\n        return AppDimensions.borderRadiusM;\r\n      case AppButtonSize.large:\r\n        return AppDimensions.borderRadiusM;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 13760,
        "last_modified": "2025-04-16T13:25:27.4749708",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_card.dart",
      "content": "// lib/core/theme/atoms/app_card.dart",
      "info": {
        "size": 37,
        "last_modified": "2025-04-16T13:25:27.4820061",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_input.dart",
      "content": "// lib/core/theme/atoms/app_input.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter/services.dart';\r\nimport '../../theme/app_colors.dart';\r\nimport '../../theme/app_dimensions.dart';\r\nimport '../../theme/app_typography.dart';\r\n\r\n/// Types de champs d'entrée disponibles\r\nenum AppInputType {\r\n  text,\r\n  email,\r\n  password,\r\n  number,\r\n  phone,\r\n  search,\r\n  multiline,\r\n}\r\n\r\n/// Variantes visuelles des champs\r\nenum AppInputVariant {\r\n  filled,    // Fond coloré\r\n  outlined,  // Bordure visible\r\n  underlined, // Seulement une ligne en dessous\r\n  plain,     // Sans décoration (transparent)\r\n}\r\n\r\n/// Tailles disponibles\r\nenum AppInputSize {\r\n  small,\r\n  medium,\r\n  large,\r\n}\r\n\r\n/// Champ d'entrée réutilisable suivant le design system de Lyra\r\nclass AppInput extends StatefulWidget {\r\n  /// Controlleur du champ (optionnel)\r\n  final TextEditingController? controller;\r\n\r\n  /// Libellé du champ\r\n  final String? label;\r\n\r\n  /// Texte d'indication quand le champ est vide\r\n  final String? placeholder;\r\n\r\n  /// Type du champ d'entrée\r\n  final AppInputType type;\r\n\r\n  /// Variante visuelle\r\n  final AppInputVariant variant;\r\n\r\n  /// Taille du champ\r\n  final AppInputSize size;\r\n\r\n  /// Icône à afficher à gauche (optionnel)\r\n  final IconData? prefixIcon;\r\n\r\n  /// Icône à afficher à droite (optionnel)\r\n  final IconData? suffixIcon;\r\n\r\n  /// Action à effectuer quand on appuie sur l'icône de droite\r\n  final VoidCallback? onSuffixIconPressed;\r\n\r\n  /// Formatters pour le texte\r\n  final List<TextInputFormatter>? inputFormatters;\r\n\r\n  /// Si le champ doit être en lecture seule\r\n  final bool readOnly;\r\n\r\n  /// Si le champ doit être désactivé\r\n  final bool disabled;\r\n\r\n  /// Si le contenu doit être centré\r\n  final bool isCentered;\r\n\r\n  /// Couleur de fond personnalisée\r\n  final Color? backgroundColor;\r\n\r\n  /// Texte d'erreur à afficher en dessous du champ\r\n  final String? errorText;\r\n\r\n  /// Texte d'aide à afficher en dessous du champ\r\n  final String? helperText;\r\n\r\n  /// Fonction appelée quand le texte change\r\n  final ValueChanged<String>? onChanged;\r\n\r\n  /// Fonction appelée quand le champ perd le focus\r\n  final VoidCallback? onFieldSubmitted;\r\n\r\n  /// Nombre maximum de caractères\r\n  final int? maxLength;\r\n\r\n  /// Nombre maximum de lignes (pour multiline)\r\n  final int? maxLines;\r\n\r\n  /// Nombre minimum de lignes (pour multiline)\r\n  final int? minLines;\r\n\r\n  /// Validation personnalisée\r\n  final String? Function(String?)? validator;\r\n\r\n  /// Action du clavier\r\n  final TextInputAction? textInputAction;\r\n\r\n  /// Si le champ doit recevoir le focus automatiquement\r\n  final bool autofocus;\r\n\r\n  /// Focus node personnalisé\r\n  final FocusNode? focusNode;\r\n\r\n  const AppInput({\r\n    Key? key,\r\n    this.controller,\r\n    this.label,\r\n    this.placeholder,\r\n    this.type = AppInputType.text,\r\n    this.variant = AppInputVariant.filled,\r\n    this.size = AppInputSize.medium,\r\n    this.prefixIcon,\r\n    this.suffixIcon,\r\n    this.onSuffixIconPressed,\r\n    this.inputFormatters,\r\n    this.readOnly = false,\r\n    this.disabled = false,\r\n    this.isCentered = false,\r\n    this.backgroundColor,\r\n    this.errorText,\r\n    this.helperText,\r\n    this.onChanged,\r\n    this.onFieldSubmitted,\r\n    this.maxLength,\r\n    this.maxLines,\r\n    this.minLines,\r\n    this.validator,\r\n    this.textInputAction,\r\n    this.autofocus = false,\r\n    this.focusNode,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  State<AppInput> createState() => _AppInputState();\r\n}\r\n\r\nclass _AppInputState extends State<AppInput> {\r\n  bool _obscureText = true;\r\n  late FocusNode _focusNode;\r\n  bool _isFocused = false;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _focusNode = widget.focusNode ?? FocusNode();\r\n    _focusNode.addListener(_handleFocusChange);\r\n\r\n    if (widget.autofocus) {\r\n      Future.delayed(Duration.zero, () {\r\n        _focusNode.requestFocus();\r\n      });\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    if (widget.focusNode == null) {\r\n      _focusNode.removeListener(_handleFocusChange);\r\n      _focusNode.dispose();\r\n    }\r\n    super.dispose();\r\n  }\r\n\r\n  void _handleFocusChange() {\r\n    setState(() {\r\n      _isFocused = _focusNode.hasFocus;\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n\r\n    // Configuration du clavier\r\n    final TextInputType keyboardType = _getKeyboardType();\r\n\r\n    // Déterminer si l'icône mot de passe doit être affichée\r\n    final bool isPassword = widget.type == AppInputType.password;\r\n\r\n    // Icônes à afficher\r\n    Widget? prefixIconWidget = widget.prefixIcon != null\r\n        ? Icon(\r\n      widget.prefixIcon,\r\n      color: _getIconColor(context),\r\n      size: _getIconSize(),\r\n    )\r\n        : null;\r\n\r\n    Widget? suffixIconWidget;\r\n\r\n    if (isPassword) {\r\n      suffixIconWidget = IconButton(\r\n        icon: Icon(\r\n          _obscureText ? Icons.visibility_outlined : Icons.visibility_off_outlined,\r\n          color: _getIconColor(context),\r\n          size: _getIconSize(),\r\n        ),\r\n        onPressed: () {\r\n          setState(() {\r\n            _obscureText = !_obscureText;\r\n          });\r\n        },\r\n      );\r\n    } else if (widget.suffixIcon != null) {\r\n      suffixIconWidget = IconButton(\r\n        icon: Icon(\r\n          widget.suffixIcon,\r\n          color: _getIconColor(context),\r\n          size: _getIconSize(),\r\n        ),\r\n        onPressed: widget.onSuffixIconPressed,\r\n      );\r\n    }\r\n\r\n    // Style du texte\r\n    final TextStyle textStyle = _getTextStyle(context);\r\n\r\n    // Style du placeholder\r\n    final TextStyle placeholderStyle = _getPlaceholderStyle(context);\r\n\r\n    // Hauteur du champ\r\n    final double height = _getHeight();\r\n\r\n    // Couleurs et bordures selon la variante\r\n    final InputDecoration decoration = _getInputDecoration(\r\n      context,\r\n      prefixIconWidget,\r\n      suffixIconWidget,\r\n      isDark,\r\n      placeholderStyle,\r\n    );\r\n\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      mainAxisSize: MainAxisSize.min,\r\n      children: [\r\n        // Libellé au-dessus (si présent)\r\n        if (widget.label != null) ...[\r\n          Text(\r\n            widget.label!,\r\n            style: context.labelMedium,\r\n          ),\r\n          SizedBox(height: AppDimensions.space2),\r\n        ],\r\n\r\n        // Le champ lui-même\r\n        SizedBox(\r\n          height: widget.type == AppInputType.multiline ? null : height,\r\n          child: TextFormField(\r\n            controller: widget.controller,\r\n            focusNode: _focusNode,\r\n            obscureText: isPassword && _obscureText,\r\n            readOnly: widget.readOnly,\r\n            enabled: !widget.disabled,\r\n            textAlign: widget.isCentered ? TextAlign.center : TextAlign.start,\r\n            style: textStyle,\r\n            keyboardType: keyboardType,\r\n            textInputAction: widget.textInputAction,\r\n            maxLength: widget.maxLength,\r\n            maxLines: widget.type == AppInputType.multiline\r\n                ? widget.maxLines ?? 5\r\n                : 1,\r\n            minLines: widget.type == AppInputType.multiline\r\n                ? widget.minLines ?? 3\r\n                : 1,\r\n            inputFormatters: _getInputFormatters(),\r\n            decoration: decoration,\r\n            onChanged: widget.onChanged,\r\n            onFieldSubmitted: (value) {\r\n              if (widget.onFieldSubmitted != null) {\r\n                widget.onFieldSubmitted!();\r\n              }\r\n            },\r\n            validator: widget.validator,\r\n            autovalidateMode: AutovalidateMode.onUserInteraction,\r\n          ),\r\n        ),\r\n\r\n        // Texte d'aide sous le champ (si présent)\r\n        if (widget.helperText != null && widget.errorText == null) ...[\r\n          SizedBox(height: AppDimensions.space1),\r\n          Text(\r\n            widget.helperText!,\r\n            style: context.labelSmall,\r\n          ),\r\n        ],\r\n      ],\r\n    );\r\n  }\r\n\r\n  TextInputType _getKeyboardType() {\r\n    switch (widget.type) {\r\n      case AppInputType.email:\r\n        return TextInputType.emailAddress;\r\n      case AppInputType.number:\r\n        return TextInputType.number;\r\n      case AppInputType.phone:\r\n        return TextInputType.phone;\r\n      case AppInputType.multiline:\r\n        return TextInputType.multiline;\r\n      default:\r\n        return TextInputType.text;\r\n    }\r\n  }\r\n\r\n  List<TextInputFormatter>? _getInputFormatters() {\r\n    if (widget.inputFormatters != null) {\r\n      return widget.inputFormatters;\r\n    }\r\n\r\n    // Formatters par défaut selon le type\r\n    switch (widget.type) {\r\n      case AppInputType.number:\r\n        return [FilteringTextInputFormatter.digitsOnly];\r\n      case AppInputType.phone:\r\n        return [FilteringTextInputFormatter.digitsOnly];\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  double _getHeight() {\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return AppDimensions.inputHeightS;\r\n      case AppInputSize.medium:\r\n        return AppDimensions.inputHeightM;\r\n      case AppInputSize.large:\r\n        return AppDimensions.inputHeightL;\r\n    }\r\n  }\r\n\r\n  double _getIconSize() {\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return AppDimensions.iconSizeS;\r\n      case AppInputSize.medium:\r\n        return AppDimensions.iconSizeM;\r\n      case AppInputSize.large:\r\n        return AppDimensions.iconSizeM;\r\n    }\r\n  }\r\n\r\n  BorderRadius _getBorderRadius() {\r\n    if (widget.variant == AppInputVariant.underlined) {\r\n      return BorderRadius.zero;\r\n    }\r\n\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return AppDimensions.borderRadiusS;\r\n      case AppInputSize.medium:\r\n        return AppDimensions.borderRadiusM;\r\n      case AppInputSize.large:\r\n        return AppDimensions.borderRadiusM;\r\n    }\r\n  }\r\n\r\n  TextStyle _getTextStyle(BuildContext context) {\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return context.bodySmall;\r\n      case AppInputSize.medium:\r\n        return context.bodyMedium;\r\n      case AppInputSize.large:\r\n        return context.bodyLarge;\r\n    }\r\n  }\r\n\r\n  TextStyle _getPlaceholderStyle(BuildContext context) {\r\n    final baseStyle = _getTextStyle(context);\r\n    return baseStyle.copyWith(\r\n      color: Theme.of(context).brightness == Brightness.dark\r\n          ? AppColors.neutral500\r\n          : AppColors.neutral500,\r\n      fontWeight: FontWeight.normal,\r\n    );\r\n  }\r\n\r\n  Color _getIconColor(BuildContext context) {\r\n    final bool hasError = widget.errorText != null;\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n\r\n    if (hasError) {\r\n      return Theme.of(context).colorScheme.error;\r\n    } else if (widget.disabled) {\r\n      return isDark ? AppColors.neutral600 : AppColors.neutral400;\r\n    } else if (_isFocused) {\r\n      return Theme.of(context).colorScheme.primary;\r\n    } else {\r\n      return isDark ? AppColors.neutral500 : AppColors.neutral600;\r\n    }\r\n  }\r\n\r\n  InputDecoration _getInputDecoration(\r\n      BuildContext context,\r\n      Widget? prefixIconWidget,\r\n      Widget? suffixIconWidget,\r\n      bool isDark,\r\n      TextStyle placeholderStyle,\r\n      ) {\r\n    final bool hasError = widget.errorText != null;\r\n\r\n    // Couleurs selon l'état\r\n    Color fillColor;\r\n    Color borderColor;\r\n\r\n    if (widget.disabled) {\r\n      fillColor = isDark ? AppColors.neutral800.withOpacity(0.5) : AppColors.neutral200;\r\n      borderColor = isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n    } else if (hasError) {\r\n      fillColor = isDark\r\n          ? AppColors.errorDark.withOpacity(0.1)\r\n          : AppColors.errorLight.withOpacity(0.1);\r\n      borderColor = Theme.of(context).colorScheme.error;\r\n    } else if (_isFocused) {\r\n      fillColor = isDark\r\n          ? AppColors.neutral800.withOpacity(0.7)\r\n          : AppColors.neutral100;\r\n      borderColor = Theme.of(context).colorScheme.primary;\r\n    } else {\r\n      fillColor = widget.backgroundColor ?? (isDark\r\n          ? AppColors.neutral800.withOpacity(0.5)\r\n          : AppColors.neutral100);\r\n      borderColor = isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n    }\r\n\r\n    // Configurations spécifiques à la variante\r\n    final BorderRadius borderRadius = _getBorderRadius();\r\n\r\n    switch (widget.variant) {\r\n      case AppInputVariant.filled:\r\n        return InputDecoration(\r\n          filled: true,\r\n          fillColor: fillColor,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide.none,\r\n          ),\r\n          enabledBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide.none,\r\n          ),\r\n          focusedBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide.none,\r\n          ),\r\n          errorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedErrorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n        );\r\n\r\n      case AppInputVariant.outlined:\r\n        return InputDecoration(\r\n          filled: false,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          enabledBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.primary,\r\n              width: 2,\r\n            ),\r\n          ),\r\n          errorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedErrorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 2,\r\n            ),\r\n          ),\r\n        );\r\n\r\n      case AppInputVariant.underlined:\r\n        return InputDecoration(\r\n          filled: false,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          enabledBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.primary,\r\n              width: 2,\r\n            ),\r\n          ),\r\n          errorBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedErrorBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 2,\r\n            ),\r\n          ),\r\n        );\r\n\r\n      case AppInputVariant.plain:\r\n        return InputDecoration(\r\n          filled: false,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: InputBorder.none,\r\n          enabledBorder: InputBorder.none,\r\n          focusedBorder: InputBorder.none,\r\n          errorBorder: InputBorder.none,\r\n          focusedErrorBorder: InputBorder.none,\r\n        );\r\n    }\r\n  }\r\n\r\n  EdgeInsets _getContentPadding() {\r\n    final double verticalPadding = widget.size == AppInputSize.small\r\n        ? AppDimensions.space2\r\n        : AppDimensions.space3;\r\n\r\n    final double horizontalPadding = widget.prefixIcon != null || widget.suffixIcon != null\r\n        ? AppDimensions.space2\r\n        : AppDimensions.space4;\r\n\r\n    return EdgeInsets.symmetric(\r\n      vertical: verticalPadding,\r\n      horizontal: horizontalPadding,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 17923,
        "last_modified": "2025-04-16T13:25:27.4880056",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_text.dart",
      "content": "// lib/core/theme/atoms/app_text.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../theme/app_typography.dart';\r\nimport '../../theme/app_colors.dart';\r\n\r\n/// Variantes de style de texte disponibles\r\nenum AppTextVariant {\r\n  displayLarge,\r\n  displayMedium,\r\n  displaySmall,\r\n  headlineLarge,\r\n  headlineMedium,\r\n  headlineSmall,\r\n  titleLarge,\r\n  titleMedium,\r\n  titleSmall,\r\n  bodyLarge,\r\n  bodyMedium,\r\n  bodySmall,\r\n  labelLarge,\r\n  labelMedium,\r\n  labelSmall,\r\n  button,\r\n  link,\r\n  price,\r\n  category,\r\n}\r\n\r\n/// Composant texte réutilisable suivant le design system de Lyra\r\n///\r\n/// Permet d'appliquer facilement les styles typographiques de l'application\r\n/// avec des options supplémentaires (couleur, alignement, etc).\r\nclass AppText extends StatelessWidget {\r\n  /// Le texte à afficher\r\n  final String text;\r\n\r\n  /// La variante de style à appliquer\r\n  final AppTextVariant variant;\r\n\r\n  /// Si le texte doit être affiché en secondaire (grisé)\r\n  final bool isSecondary;\r\n\r\n  /// Couleur personnalisée (optionnel)\r\n  final Color? color;\r\n\r\n  /// Alignement du texte\r\n  final TextAlign? textAlign;\r\n\r\n  /// Nombre maximum de lignes\r\n  final int? maxLines;\r\n\r\n  /// Comportement lors du dépassement\r\n  final TextOverflow? overflow;\r\n\r\n  /// Style personnalisé supplémentaire à appliquer\r\n  final TextStyle? style;\r\n\r\n  /// Si le texte doit être en gras\r\n  final bool isBold;\r\n\r\n  /// Si le texte doit être en italique\r\n  final bool isItalic;\r\n\r\n  /// Si le texte doit avoir un soulignement\r\n  final bool isUnderlined;\r\n\r\n  const AppText(\r\n      this.text, {\r\n        Key? key,\r\n        required this.variant,\r\n        this.isSecondary = false,\r\n        this.color,\r\n        this.textAlign,\r\n        this.maxLines,\r\n        this.overflow,\r\n        this.style,\r\n        this.isBold = false,\r\n        this.isItalic = false,\r\n        this.isUnderlined = false,\r\n      }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Text(\r\n      text,\r\n      style: _getStyle(context).copyWith(\r\n        color: color,\r\n        fontWeight: isBold ? FontWeight.bold : null,\r\n        fontStyle: isItalic ? FontStyle.italic : null,\r\n        decoration: isUnderlined ? TextDecoration.underline : null,\r\n      ),\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: overflow ?? (maxLines != null ? TextOverflow.ellipsis : null),\r\n    );\r\n  }\r\n\r\n  TextStyle _getStyle(BuildContext context) {\r\n    final baseStyle = _getBaseStyle(context);\r\n\r\n    if (style != null) {\r\n      return baseStyle.merge(style);\r\n    }\r\n\r\n    return baseStyle;\r\n  }\r\n\r\n  TextStyle _getBaseStyle(BuildContext context) {\r\n    // Cas spécial pour les variantes avec paramètres additionnels\r\n    if (variant == AppTextVariant.category && color != null) {\r\n      return context.labelMedium.copyWith(\r\n        color: color,\r\n        fontWeight: FontWeight.w600,\r\n      );\r\n    }\r\n\r\n    // Utilisation du pattern match pour une meilleure gestion des cas\r\n    return switch (variant) {\r\n    // Titres (regroupés par taille)\r\n      AppTextVariant.displayLarge ||\r\n      AppTextVariant.headlineLarge ||\r\n      AppTextVariant.titleLarge => context.titleLarge,\r\n\r\n      AppTextVariant.displayMedium ||\r\n      AppTextVariant.headlineMedium ||\r\n      AppTextVariant.titleMedium => context.titleMedium,\r\n\r\n      AppTextVariant.displaySmall ||\r\n      AppTextVariant.headlineSmall ||\r\n      AppTextVariant.titleSmall => context.titleSmall,\r\n\r\n    // Corps - utilise l'extension avec gestion du isSecondary\r\n      AppTextVariant.bodyLarge => isSecondary ? context.bodyLargeSecondary : context.bodyLarge,\r\n      AppTextVariant.bodyMedium => isSecondary ? context.bodyMediumSecondary : context.bodyMedium,\r\n      AppTextVariant.bodySmall => isSecondary ? context.bodySmallSecondary : context.bodySmall,\r\n\r\n    // Labels - même logique que les corps\r\n      AppTextVariant.labelLarge => isSecondary\r\n          ? AppTypography.labelLarge(isDark: context.isDark, isSecondary: true)\r\n          : context.labelLarge,\r\n      AppTextVariant.labelMedium => isSecondary\r\n          ? AppTypography.labelMedium(isDark: context.isDark, isSecondary: true)\r\n          : context.labelMedium,\r\n      AppTextVariant.labelSmall => isSecondary\r\n          ? AppTypography.labelSmall(isDark: context.isDark, isSecondary: true)\r\n          : context.labelSmall,\r\n\r\n    // Styles spéciaux\r\n      AppTextVariant.button => context.buttonStyle,\r\n      AppTextVariant.link => context.labelMedium.copyWith(\r\n        color: AppColors.primary,\r\n        decoration: TextDecoration.underline,\r\n      ),\r\n      AppTextVariant.price => context.titleSmall.copyWith(\r\n        fontWeight: FontWeight.bold,\r\n      ),\r\n      AppTextVariant.category => context.labelMedium.copyWith(\r\n        color: color ?? AppColors.primary,\r\n        fontWeight: FontWeight.w600,\r\n      )\r\n    };\r\n  }\r\n\r\n  /// Constructeurs de commodité pour les variantes communes\r\n\r\n  /// Titre principal (grand)\r\n  static Widget displayLarge(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.displayLarge,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isBold: isBold,\r\n    );\r\n  }\r\n\r\n  /// Titre de section\r\n  static Widget headline(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.headlineMedium,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isBold: isBold,\r\n    );\r\n  }\r\n\r\n  /// Titre d'élément (par ex. carte)\r\n  static Widget title(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        int? maxLines,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.titleMedium,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: TextOverflow.ellipsis,\r\n      style: style,\r\n      isBold: isBold,\r\n    );\r\n  }\r\n\r\n  /// Texte courant\r\n  static Widget body(\r\n      String text, {\r\n        bool isSecondary = false,\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        int? maxLines,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n        bool isItalic = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.bodyMedium,\r\n      isSecondary: isSecondary,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: maxLines != null ? TextOverflow.ellipsis : null,\r\n      style: style,\r\n      isBold: isBold,\r\n      isItalic: isItalic,\r\n    );\r\n  }\r\n\r\n  /// Petit texte / légende\r\n  static Widget caption(\r\n      String text, {\r\n        bool isSecondary = true,\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        int? maxLines,\r\n        TextStyle? style,\r\n        bool isItalic = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.labelMedium,\r\n      isSecondary: isSecondary,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: maxLines != null ? TextOverflow.ellipsis : null,\r\n      style: style,\r\n      isItalic: isItalic,\r\n    );\r\n  }\r\n\r\n  /// Affichage du prix\r\n  static Widget price(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.price,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isBold: true,\r\n    );\r\n  }\r\n\r\n  /// Texte cliquable\r\n  static Widget link(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        VoidCallback? onTap,\r\n        TextStyle? style,\r\n      }) {\r\n    final linkText = AppText(\r\n      text,\r\n      variant: AppTextVariant.link,\r\n      color: color ?? AppColors.primary,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isUnderlined: true,\r\n    );\r\n\r\n    if (onTap != null) {\r\n      return GestureDetector(\r\n        onTap: onTap,\r\n        child: linkText,\r\n      );\r\n    }\r\n\r\n    return linkText;\r\n  }\r\n\r\n  /// Texte de catégorie\r\n  static Widget category(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.category,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 8633,
        "last_modified": "2025-04-16T13:25:27.4950423",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\pages\\empty_trips_test_page.dart",
      "content": "// lib/features/empty_trips/presentation/pages/empty_trips_test_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../state/test/empty_trips_test_provider.dart';\r\nimport '../state/test/route_optimization_test_provider.dart';\r\nimport '../state/test/empty_trip_generation_test_provider.dart';\r\nimport '../state/test/available_time_test_provider.dart';\r\n\r\nclass EmptyTripsTestPage extends ConsumerWidget {\r\n  const EmptyTripsTestPage({Key? key}) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final emptyTripsState = ref.watch(emptyTripsTestProvider);\r\n    final routeOptState = ref.watch(routeOptimizationTestProvider);\r\n    final emptyTripGenerationState = ref.watch(emptyTripGenerationTestProvider);\r\n    final availableTimeState = ref.watch(availableTimeTestProvider);\r\n\r\n    return Scaffold(\r\n      appBar: AppBar(title: const Text('Test Empty Trips')),\r\n      body: Padding(\r\n        padding: const EdgeInsets.all(16.0),\r\n        child: Column(\r\n          children: [\r\n            // Boutons de test\r\n            Wrap(\r\n              spacing: 8, // Espacement horizontal entre les boutons\r\n              runSpacing: 8, // Espacement vertical entre les lignes de boutons\r\n              children: [\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(emptyTripsTestProvider.notifier).testSuperwowManagement(),\r\n                  child: const Text('SuperWow'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(routeOptimizationTestProvider.notifier).testRouteOptimization(),\r\n                  child: const Text('Routes'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(emptyTripGenerationTestProvider.notifier).testEmptyTripGeneration(),\r\n                  child: const Text('Empty Trips'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testMealBreaksCalculation(),\r\n                  child: const Text('Pause repas'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testSuperWowDuration(),\r\n                  child: const Text('Durées SW'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testAvailableTimePerDay(),\r\n                  child: const Text('Temps Dispo/Jour'),\r\n                ),ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testGetFilteredActivities(),\r\n                  child: const Text('Activités Filtrées'),\r\n                ),\r\n              ],\r\n            ),\r\n            const SizedBox(height: 16),\r\n            // Contenu du test\r\n            Expanded( // Ajout d'Expanded ici\r\n              child: SingleChildScrollView(\r\n                child: Column(\r\n                  children: [\r\n                    // Résultat SuperWow Management\r\n                    emptyTripsState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text('Erreur SuperWow: $error', style: const TextStyle(color: Colors.red)),\r\n                    ),\r\n                    // Résultat Route Optimization\r\n                    routeOptState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text('Erreur Route: $error', style: const TextStyle(color: Colors.red)),\r\n                    ),\r\n                    // Résultat Empty Trip Generation\r\n                    emptyTripGenerationState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text('Erreur Empty Trip Generation: $error', style: const TextStyle(color: Colors.red)),\r\n                    ),\r\n                    availableTimeState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text(\r\n                          'Erreur Available Time: $error',\r\n                          style: const TextStyle(color: Colors.red)\r\n                      ),\r\n                    ),\r\n                  ],\r\n                ),\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  // Fonction pour afficher le contenu en fonction de l'état (séparée pour plus de clarté)\r\n  Widget _buildContent(Map<String, dynamic> data) {\r\n    if (data['testType'] == 'superwow_management') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Text('Ville de départ: ${data['departureCity']}'),\r\n          Text('Nombre de SuperWow: ${data['totalSuperWows']}'),\r\n          const SizedBox(height: 16),\r\n          Text('SuperWow le plus proche: ${data['closestSuperWow']['name']}'),\r\n          Text('Score: ${data['closestSuperWow']['score']}'),\r\n          const SizedBox(height: 16),\r\n          const Text('Top 3 paires:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ...data['top3Pairs'].map<Widget>((pair) => Padding(\r\n            padding: const EdgeInsets.only(left: 16, top: 8),\r\n            child: Text('${pair['sw1']} → ${pair['sw2']} (${pair['distance']}, ${pair['duration']})'),\r\n          )).toList(),\r\n        ],\r\n      );\r\n    } else if (data['testType'] == 'route_optimization') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Text('Origine: ${data['origin']}'),\r\n          Text('Destination: ${data['destination']}'),\r\n          Text('Point intermédiaire: ${data['waypoint']}'),\r\n          const SizedBox(height: 16),\r\n          const Text('Route:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Status: ${data['route']['status']}'),\r\n          Text('Polyline: ${data['route']['polyline']}'),\r\n          const SizedBox(height: 16),\r\n          Text('Temps de trajet: ${data['travelTime']}'),\r\n          const SizedBox(height: 16),\r\n          const Text('Évaluation détour:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Status: ${data['detourEvaluation']['status']}'),\r\n          Text('Faisable: ${data['detourEvaluation']['feasible']}'),\r\n        ],\r\n      );\r\n    } else if (data['testType'] == 'empty_trip_generation') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Génération Empty Trips'),\r\n          const SizedBox(height: 16),\r\n          const Text('Half-Day Trips:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(), // Important pour désactiver le scroll de ListView\r\n            itemCount: data['halfDayTrips'].length,\r\n            itemBuilder: (context, index) {\r\n              final trip = data['halfDayTrips'][index];\r\n              return Padding(\r\n                padding: const EdgeInsets.only(left: 16, top: 8),\r\n                child: Text('ID: ${trip['id']}\\nSW: ${trip['sw1Id']}\\nGeohash: ${trip['geohash']}'),\r\n              );\r\n            },\r\n          ),\r\n          const SizedBox(height: 16),\r\n          const Text('Full-Day Trips:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(), // Important pour désactiver le scroll de ListView\r\n            itemCount: data['fullDayTrips'].length,\r\n            itemBuilder: (context, index) {\r\n              final trip = data['fullDayTrips'][index];\r\n              return Padding(\r\n                padding: const EdgeInsets.only(left: 16, top: 8),\r\n                child: Text('ID: ${trip['id']}\\nSW1: ${trip['sw1Id']}\\nSW2: ${trip['sw2Id']}\\nGeohash: ${trip['geohash']}'),\r\n              );\r\n            },\r\n          ),\r\n\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'bonus_activities') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Bonus Activities', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 16),\r\n          Text('Nombre d\\'activités générées: ${data['bonusActivities'].length}'),\r\n\r\n          const SizedBox(height: 16),\r\n          const Text('Statistiques de distance:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Distance moyenne: ${data['distanceStats']['averageDistance'].toStringAsFixed(2)} km'),\r\n          Text('Distance min: ${data['distanceStats']['minDistance'].toStringAsFixed(2)} km'),\r\n          Text('Distance max: ${data['distanceStats']['maxDistance'].toStringAsFixed(2)} km'),\r\n\r\n          const SizedBox(height: 16),\r\n          const Text('Statistiques de malus:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Malus moyen: ${data['malusStats']['averageMalus']} minutes'),\r\n          Text('Malus min: ${data['malusStats']['minMalus']} minutes'),\r\n          Text('Malus max: ${data['malusStats']['maxMalus']} minutes'),\r\n\r\n          const SizedBox(height: 16),\r\n          const Text('Activités:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['bonusActivities'].length,\r\n            itemBuilder: (context, index) {\r\n              final activity = data['bonusActivities'][index];\r\n              return Padding(\r\n                padding: const EdgeInsets.only(left: 16, top: 8),\r\n                child: Text(\r\n                    'ID: ${activity.id}\\n'\r\n                        'Malus: ${activity.malusVolOiseau.minutes} minutes'\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'meal_breaks') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Pauses Repas', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 16),\r\n          Text('Trip ID: ${data['tripId']}'),\r\n          Text('Période: ${data['dates']['start']} -> ${data['dates']['end']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(8.0),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text(test['case']),\r\n                      Text('Horaires: ${test['input']['start']}-${test['input']['end']}'),\r\n                      Text('Pause calculée: ${test['result']} minutes'),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'superwow_duration') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Durées SuperWow', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Style de voyage du trip: ${data['tripStyle']}',\r\n              style: const TextStyle(fontSize: 16, color: Colors.blue)),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.only(bottom: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text(test['case'], style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      const SizedBox(height: 8),\r\n                      Text('SuperWow IDs: ${(test['input']['superWowIds'] as List).join(\", \")}'),\r\n                      Text('Style de voyage: ${test['input']['style']}'),\r\n                      const Divider(),\r\n                      Text(\r\n                        'Durée calculée: ${test['result']} minutes',\r\n                        style: const TextStyle(color: Colors.blue),\r\n                      ),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'available_time_per_day') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test du Temps Disponible par Jour',\r\n              style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Trip ID: ${data['tripId']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.only(bottom: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text('Empty Trip: ${test['emptyTripId']}',\r\n                          style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      Text('Type: ${test['type']}'),\r\n                      const Divider(),\r\n                      ...(test['timeByDate'] as Map<String, dynamic>).entries.map(\r\n                            (entry) => Text(\r\n                          'Date ${entry.key}: ${entry.value} minutes',\r\n                          style: const TextStyle(color: Colors.blue),\r\n                        ),\r\n                      ),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }    else if (data['testType'] == 'bonus_activities_generation') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test de Génération des Bonus Activities',\r\n              style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Trip: ${data['tripId']}'),\r\n          Text('Période: ${data['tripDates']['start']} → ${data['tripDates']['end']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.symmetric(vertical: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text('Empty Trip: ${test['emptyTripId']} (${test['type']})',\r\n                          style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      const Divider(),\r\n                      const Text('Activités par jour:',\r\n                          style: TextStyle(fontWeight: FontWeight.bold)),\r\n                      ...(test['resultsByDate'] as Map<String, dynamic>)\r\n                          .entries.map((dateEntry) => Column(\r\n                        crossAxisAlignment: CrossAxisAlignment.start,\r\n                        children: [\r\n                          Text(dateEntry.key,\r\n                              style: const TextStyle(fontWeight: FontWeight.w500)),\r\n                          ...(dateEntry.value as List).map((activity) => Padding(\r\n                            padding: const EdgeInsets.only(left: 16),\r\n                            child: Text(\r\n                              'ID: ${activity['activityId']} - Malus: ${activity['malus']} min',\r\n                            ),\r\n                          )),\r\n                          const SizedBox(height: 8),\r\n                        ],\r\n                      )),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'filtered_activities') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Activités Filtrées',\r\n              style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Trip ID: ${data['tripId']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.only(bottom: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text('Empty Trip: ${test['emptyTripId']}',\r\n                          style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      Text('Type: ${test['type']}'),\r\n                      const Divider(),\r\n                      ...(test['activities'] as Map<String, dynamic>).entries.map((dateEntry) {\r\n                        final activities = dateEntry.value as List;\r\n                        return Column(\r\n                          crossAxisAlignment: CrossAxisAlignment.start,\r\n                          children: [\r\n                            Text(\r\n                                'Date: ${dateEntry.key}',\r\n                                style: const TextStyle(fontWeight: FontWeight.w500)\r\n                            ),\r\n                            Text('${activities.length} activités trouvées'),\r\n                            ...activities.map((act) => Padding(\r\n                              padding: const EdgeInsets.only(left: 16),\r\n                              child: Text(\r\n                                '${act['name']} (${act['geohash5']})',\r\n                                style: const TextStyle(fontSize: 12),\r\n                              ),\r\n                            )),\r\n                            const SizedBox(height: 8),\r\n                          ],\r\n                        );\r\n                      }),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    return const Text('Type de test inconnu');\r\n  }\r\n}",
      "info": {
        "size": 20331,
        "last_modified": "2025-04-16T13:25:27.5172739",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/test/available_time_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/available_time_calculation.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/bonus_activity_generation.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/potential_activities.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/bonus_activities_cache.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/neighbor_geohashes.service.dart';\r\nimport '../../../../../core/adapters/trip/trip_adapter.dart';\r\nimport '../../../../../core/adapters/supabase/empty_daily_trip.adapter.dart';\r\nimport '../../../../../core/domain/models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../../../core/domain/models/trip_designer/trip/activity_model.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/geometry_calculation.port.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/neighbor_geohashes.port.dart';\r\nimport './available_time_test_state.dart';\r\n\r\nclass AvailableTimeTestNotifier extends StateNotifier<AvailableTimeTestState> {\r\n  final AvailableTimeCalculationService _service;\r\n  final BonusActivityGenerationService _bonusService;\r\n  final TripAdapter _tripAdapter;\r\n  final EmptyDailyTripAdapter _emptyTripAdapter;\r\n  final PotentialActivitiesService _potentialActivitiesService;\r\n  final BonusActivitiesCacheService _cacheService;\r\n  final GeometryCalculationPort _geometryPort;\r\n  final NeighborGeohashesPort _neighborGeohashesPort;\r\n  static const String TEST_TRIP_ID = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n\r\n  AvailableTimeTestNotifier(\r\n      this._service,\r\n      this._bonusService,\r\n      this._tripAdapter,\r\n      this._potentialActivitiesService,\r\n      this._cacheService,\r\n      this._geometryPort,\r\n      this._neighborGeohashesPort,\r\n      ) : _emptyTripAdapter = EmptyDailyTripAdapter(Supabase.instance.client),\r\n        super(const AvailableTimeTestState.initial());\r\n\r\n  Future<void> testMealBreaksCalculation() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print('🔍 Début du test des pauses repas');\r\n\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n      print('📅 Dates du voyage: ${trip.startDate} -> ${trip.endDate}');\r\n\r\n      final dailyHours = trip.activityHours.daily_hours;\r\n      print('📋 Horaires journaliers récupérés: ${dailyHours.length} jours');\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (var entry in dailyHours.entries) {\r\n        final date = entry.key;\r\n        final hours = entry.value;\r\n\r\n        if (hours['start'] != null && hours['end'] != null) {\r\n          final hoursMap = {\r\n            'start': hours['start']!,\r\n            'end': hours['end']!,\r\n          };\r\n\r\n          final result = _service.calculateMealBreaksDuration(hoursMap,trip.travelStyle?.name ?? 'balanced');\r\n          tests.add({\r\n            'case': 'Jour: $date',\r\n            'input': hoursMap,\r\n            'result': result,\r\n          });\r\n          print('📊 $date: ${hours['start']}-${hours['end']} => $result min de pause');\r\n        } else {\r\n          print('⚠️ $date: Horaires non définis');\r\n        }\r\n      }\r\n\r\n      final testResults = <String, dynamic>{\r\n        'testType': 'meal_breaks',\r\n        'tripId': TEST_TRIP_ID,\r\n        'dates': {\r\n          'start': trip.startDate.toString(),\r\n          'end': trip.endDate.toString(),\r\n        },\r\n        'tests': tests\r\n      };\r\n\r\n      state = AvailableTimeTestState.success(testResults);\r\n      print('✅ Test terminé');\r\n    } catch (e) {\r\n      print('❌ Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testSuperWowDuration() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print('🔍 Test du calcul de durée des SuperWow');\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n      print('🎯 Travel Style du trip: ${trip.travelStyle?.name}');\r\n\r\n      final emptyTripIds = [\r\n        '16ce0368-acb2-42ea-9dc0-2e71ff78f384',\r\n        '1e41d5f2-7c24-4dbc-a8c5-b3c5db8ac12d',\r\n        '3496302f-bd36-4a7a-9e27-2cba8ad9d80e',\r\n      ];\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (final emptyTripId in emptyTripIds) {\r\n        print('📋 Test pour empty trip: $emptyTripId');\r\n\r\n        final response = await Supabase.instance.client\r\n            .from('empty_daily_trips')\r\n            .select('type, sw1_id, sw2_id')\r\n            .eq('id', emptyTripId)\r\n            .single();\r\n\r\n        final List<String> superWowIds = [response['sw1_id']];\r\n        if (response['sw2_id'] != null) {\r\n          superWowIds.add(response['sw2_id']);\r\n        }\r\n\r\n        print('🎯 SuperWow IDs trouvés: $superWowIds');\r\n\r\n        final duration = await _service.calculateSuperWowDuration(\r\n          superWowIds: superWowIds,\r\n          travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n        );\r\n\r\n        tests.add({\r\n          'case': 'EmptyTrip: $emptyTripId (${response['type']})',\r\n          'input': {\r\n            'style': trip.travelStyle?.name ?? 'balanced',\r\n            'superWowIds': superWowIds,\r\n          },\r\n          'result': duration,\r\n        });\r\n        print('⏱ ${trip.travelStyle?.name} => $duration minutes');\r\n      }\r\n\r\n      state = AvailableTimeTestState.success({\r\n        'testType': 'superwow_duration',\r\n        'tripStyle': trip.travelStyle?.name ?? 'balanced',\r\n        'tests': tests,\r\n      });\r\n      print('✅ Test terminé');\r\n    } catch (e) {\r\n      print('❌ Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testAvailableTimePerDay() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print('🔍 Début du test du temps disponible par jour');\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n\r\n      final emptyTripIds = [\r\n        '16ce0368-acb2-42ea-9dc0-2e71ff78f384',\r\n        '1e41d5f2-7c24-4dbc-a8c5-b3c5db8ac12d',\r\n        '3496302f-bd36-4a7a-9e27-2cba8ad9d80e',\r\n      ];\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (final etId in emptyTripIds) {\r\n        final emptyTrip = await _emptyTripAdapter.getEmptyTrip(etId);\r\n\r\n        final timeByDate = await _service.calculateAvailableTimeForEmptyTrip(\r\n          emptyTrip: emptyTrip,\r\n          dailyHours: trip.activityHours.daily_hours,\r\n          travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n        );\r\n\r\n        tests.add({\r\n          'emptyTripId': etId,\r\n          'type': emptyTrip.type.toString().split('.').last,\r\n          'timeByDate': Map.fromEntries(\r\n              timeByDate.entries.map((e) => MapEntry(e.key.toString(), e.value))\r\n          ),\r\n        });\r\n\r\n        for (var entry in timeByDate.entries) {\r\n          print('⏱ [$etId] ${entry.key} => ${entry.value} minutes dispos');\r\n        }\r\n      }\r\n\r\n      state = AvailableTimeTestState.success({\r\n        'testType': 'available_time_per_day',\r\n        'tripId': TEST_TRIP_ID,\r\n        'tests': tests,\r\n      });\r\n      print('✅ Test terminé');\r\n    } catch (e) {\r\n      print('❌ Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testGetFilteredActivities() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print('🔍 Test récupération activités filtrées');\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n      final emptyTripIds = [\r\n        '16ce0368-acb2-42ea-9dc0-2e71ff78f384',\r\n        '1e41d5f2-7c24-4dbc-a8c5-b3c5db8ac12d',\r\n        '3496302f-bd36-4a7a-9e27-2cba8ad9d80e',\r\n      ];\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (final etId in emptyTripIds) {\r\n        print('\\n📋 Test pour empty trip: $etId');\r\n        final emptyTrip = await _emptyTripAdapter.getEmptyTrip(etId);\r\n\r\n        // 1. Temps disponible\r\n        final availableTime = await _service.calculateAvailableTimeForEmptyTrip(\r\n          emptyTrip: emptyTrip,\r\n          dailyHours: trip.activityHours.daily_hours,\r\n          travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n        );\r\n\r\n        // 2. Activités filtrées\r\n        final activities = await _potentialActivitiesService.getFilteredActivitiesForEmptyTrip(\r\n          emptyTrip: emptyTrip,\r\n          tripId: trip.id,\r\n          availableTimeByDate: availableTime,\r\n        );\r\n\r\n        // 3. Vérifier le cache\r\n        final cachedActivities = await _cacheService.getCachedBonusActivities(etId);\r\n\r\n        if (cachedActivities.isEmpty) {\r\n          final List<Map<String, dynamic>> activitiesToCache = []; // Correction ici\r\n          // Traiter chaque activité par date\r\n          for (var dateActivities in activities.values) {\r\n            for (var activity in dateActivities) {\r\n              final malus = await _calculateMalus(activity, emptyTrip);\r\n              activitiesToCache.add({\r\n                'id': activity.id,\r\n                'malus': malus,\r\n              });\r\n            }\r\n          }\r\n\r\n          if (activitiesToCache.isNotEmpty) {\r\n            await _cacheService.cacheEmptyTripBonusActivities(\r\n              emptyTripId: etId,\r\n              bonusActivities: activitiesToCache,\r\n            );\r\n            print('💾 Cached ${activitiesToCache.length} activities for $etId');\r\n          }\r\n        } else {\r\n          print('📦 Found ${cachedActivities.length} cached activities for $etId');\r\n        }\r\n\r\n        tests.add({\r\n          'emptyTripId': etId,\r\n          'type': emptyTrip.type.toString().split('.').last,\r\n          'activities': activities.map((date, acts) =>\r\n              MapEntry(date, acts.map((a) => {\r\n                'id': a.id,\r\n                'name': a.name,\r\n                'geohash5': a.geohash5,\r\n              }).toList())\r\n          ),\r\n        });\r\n      }\r\n\r\n      state = AvailableTimeTestState.success({\r\n        'testType': 'filtered_activities',\r\n        'tripId': TEST_TRIP_ID,\r\n        'tests': tests,\r\n      });\r\n      print('✅ Test terminé');\r\n    } catch (e) {\r\n      print('❌ Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<int> _calculateMalus(Activity activity, EmptyDailyTrip emptyTrip) async {\r\n    try {\r\n      print('🔍 Calculating malus for:');\r\n      print('  Activity: ${activity.id} (${activity.name})');\r\n      print('  Location: ${activity.geohash5}');\r\n      print('  EmptyTrip: ${emptyTrip.id}');\r\n\r\n      final neighbors = await _neighborGeohashesPort.getNeighborGeohashes(emptyTrip.id);\r\n      final neighbor = neighbors[activity.geohash5];\r\n      if (neighbor != null) {\r\n        final distance = neighbor['distance_to_route'];\r\n        final closestGeohash = neighbor['closest_route_geohash5'];\r\n      }\r\n\r\n      if (neighbor == null) {\r\n        print('⚠️ No matching neighbor found');\r\n        return 3000; // 30km par défaut\r\n      }\r\n\r\n      final malus = (neighbor['distance_to_route'] as int) ~/ 100; // 1min par 100m\r\n      print('  Distance to route: ${neighbor['distance_to_route']}m');\r\n      print('  Malus: $malus minutes');\r\n      return malus;\r\n    } catch (e) {\r\n      print('❌ Error: $e');\r\n      return 3000; // 30km par défaut en cas d'erreur\r\n    }\r\n  }\r\n\r\n  Future<int> _calculateVolOiseauMalus({\r\n    required double lat,\r\n    required double lng,\r\n    required String geohash5,\r\n  }) async {\r\n    final response = await Supabase.instance.client.rpc(\r\n      'calculate_vol_oiseau_minutes',\r\n      params: {\r\n        'point1_lat': lat,\r\n        'point1_lng': lng,\r\n        'geohash5': geohash5,\r\n      },\r\n    );\r\n\r\n    return (response as num).toInt();\r\n  }\r\n}\r\n\r\n",
      "info": {
        "size": 12081,
        "last_modified": "2025-04-16T13:25:27.5288549",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/test/available_time_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\n// Imports de vos services / adapters\r\nimport '../../../../../core/domain/services/designer/empty_trips/available_time_calculation.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/bonus_activity_generation.service.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/bonus_activities_cache.provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/neighbor_geohashes.provider.dart';\r\nimport '../../../../../core/adapters/trip/trip_adapter.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/distance_calculation_provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/geometry_calculation.provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/potential_activities.provider.dart';\r\n\r\nimport './available_time_test_notifier.dart';\r\nimport './available_time_test_state.dart';\r\n\r\nfinal availableTimeTestProvider = StateNotifierProvider<AvailableTimeTestNotifier, AvailableTimeTestState>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  final service = AvailableTimeCalculationService(supabase);\r\n  final tripAdapter = TripAdapter(supabase);\r\n  final potentialActivitiesService = ref.watch(potentialActivitiesProvider);\r\n  final cacheService = ref.watch(bonusActivitiesCacheProvider);\r\n  final geometryPort = ref.watch(geometryCalculationPortProvider);\r\n  final neighborGeohashesService = ref.watch(neighborGeohashesProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n\r\n  final bonusService = BonusActivityGenerationService(\r\n    geometryPort,\r\n    distanceService,\r\n    service,\r\n  );\r\n\r\n  return AvailableTimeTestNotifier(\r\n    service,\r\n    bonusService,\r\n    tripAdapter,\r\n    potentialActivitiesService,\r\n    cacheService,\r\n    geometryPort,\r\n    neighborGeohashesService,\r\n  );\r\n});",
      "info": {
        "size": 2073,
        "last_modified": "2025-04-16T13:25:27.5353717",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/test/available_time_test_state.dart\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'available_time_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass AvailableTimeTestState with _$AvailableTimeTestState {\r\n  const factory AvailableTimeTestState.initial() = _Initial;\r\n  const factory AvailableTimeTestState.loading() = _Loading;\r\n  const factory AvailableTimeTestState.success(Map<String, dynamic> data) = _Success;\r\n  const factory AvailableTimeTestState.error(Object error) = _Error;\r\n}",
      "info": {
        "size": 552,
        "last_modified": "2025-04-16T13:25:27.5424124",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'available_time_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$AvailableTimeTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $AvailableTimeTestStateCopyWith<$Res> {\n  factory $AvailableTimeTestStateCopyWith(AvailableTimeTestState value,\n          $Res Function(AvailableTimeTestState) then) =\n      _$AvailableTimeTestStateCopyWithImpl<$Res, AvailableTimeTestState>;\n}\n\n/// @nodoc\nclass _$AvailableTimeTestStateCopyWithImpl<$Res,\n        $Val extends AvailableTimeTestState>\n    implements $AvailableTimeTestStateCopyWith<$Res> {\n  _$AvailableTimeTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements AvailableTimeTestState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements AvailableTimeTestState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl implements _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data) : _data = data;\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success implements AvailableTimeTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.error);\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements AvailableTimeTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n\n  Object get error;\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18575,
        "last_modified": "2025-04-16T13:25:27.5484124",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trips_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/superwow_management.port.dart';\r\nimport 'empty_trips_test_state.dart';\r\n\r\nclass EmptyTripsTestNotifier extends StateNotifier<EmptyTripsTestState> {\r\n  final SupabaseClient _supabase;\r\n  final SuperWowManagementPort _superwowManagementPort;\r\n\r\n  EmptyTripsTestNotifier(\r\n      this._supabase,\r\n      this._superwowManagementPort,\r\n      ) : super(const EmptyTripsTestState.initial());\r\n\r\n// lib/features/empty_trips/presentation/state/empty_trips_test_notifier.dart\r\n\r\n  Future<void> testSuperwowManagement() async {\r\n    state = const EmptyTripsTestState.loading();\r\n\r\n    try {\r\n      print('🌟 Test de gestion des SuperWow');\r\n      final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n\r\n      // Récupérer point de départ\r\n      final tripResponse = await _supabase\r\n          .from('trips')\r\n          .select('departure_city_id, cities!trips_departure_city_id_fkey(lat, lon, city_name)')\r\n          .eq('id', tripId)\r\n          .single();\r\n\r\n      final departurePoint = LatLng(\r\n        tripResponse['cities']['lat'].toDouble(),\r\n        tripResponse['cities']['lon'].toDouble(),\r\n      );\r\n      print('📍 Point de départ: ${tripResponse['cities']['city_name']}');\r\n\r\n      // Récupérer tous les SuperWows\r\n      final superWows = await _superwowManagementPort.getTripSuperWows(tripId);\r\n      print('✅ ${superWows.length} SuperWow récupérés');\r\n\r\n      if (superWows.isEmpty) {\r\n        throw Exception('Aucun SuperWow trouvé pour ce trip');\r\n      }\r\n\r\n      // Générer toutes les paires optimisées\r\n      final optimizedPairs = await _superwowManagementPort.generateOptimizedPairs(\r\n        tripId,\r\n        superWows,\r\n        departurePoint,\r\n      );\r\n\r\n      // Organiser les résultats par SW de départ\r\n      final pairsByStartingSW = <String, List<Map<String, dynamic>>>{};\r\n      for (final pair in optimizedPairs) {\r\n        final sw1 = superWows.firstWhere((sw) => sw.id == pair.sw1Id);\r\n        final sw2 = superWows.firstWhere((sw) => sw.id == pair.sw2Id);\r\n\r\n        if (!pairsByStartingSW.containsKey(sw1.id)) {\r\n          pairsByStartingSW[sw1.id] = [];\r\n        }\r\n\r\n        pairsByStartingSW[sw1.id]!.add({\r\n          'sw1Name': sw1.activityData['name'],\r\n          'sw2Name': sw2.activityData['name'],\r\n          'distance': '${(pair.distanceInKm).toStringAsFixed(2)} km',\r\n          'duration': '${pair.travelTime.inMinutes} minutes',\r\n          'sw1Preferences': sw1.activityData['moment_preferences'],\r\n          'sw2Preferences': sw2.activityData['moment_preferences'],\r\n        });\r\n      }\r\n\r\n      state = EmptyTripsTestState.success({\r\n        'testType': 'superwow_management',\r\n        'departureCity': tripResponse['cities']['city_name'],\r\n        'totalSuperWows': superWows.length,\r\n        'optimizedPairs': pairsByStartingSW.entries.map((entry) {\r\n          final sw = superWows.firstWhere((sw) => sw.id == entry.key);\r\n          return {\r\n            'startingSW': sw.activityData['name'],\r\n            'pairs': entry.value,\r\n          };\r\n        }).toList(),\r\n      });\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur dans le test de gestion SuperWow: $e');\r\n      state = EmptyTripsTestState.error(e);\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 3500,
        "last_modified": "2025-04-16T13:25:27.5549292",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trips_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/ports/providers/infrastructure_providers.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/superwow_management.provider.dart';\r\nimport 'empty_trips_test_notifier.dart';\r\nimport 'empty_trips_test_state.dart';\r\n\r\nfinal emptyTripsTestProvider = StateNotifierProvider<EmptyTripsTestNotifier, EmptyTripsTestState>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final superwowManagement = ref.watch(superwowManagementPortProvider);\r\n  return EmptyTripsTestNotifier(supabase, superwowManagement);\r\n});",
      "info": {
        "size": 702,
        "last_modified": "2025-04-16T13:25:27.5619644",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trips_test_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'empty_trips_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass EmptyTripsTestState with _$EmptyTripsTestState {\r\n  const factory EmptyTripsTestState.initial() = _Initial;\r\n  const factory EmptyTripsTestState.loading() = _Loading;\r\n  const factory EmptyTripsTestState.success(Map<String, dynamic> data) = _Success;\r\n  const factory EmptyTripsTestState.error(Object error) = _Error;\r\n}",
      "info": {
        "size": 525,
        "last_modified": "2025-04-16T13:25:27.5684818",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'empty_trips_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$EmptyTripsTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $EmptyTripsTestStateCopyWith<$Res> {\n  factory $EmptyTripsTestStateCopyWith(\n          EmptyTripsTestState value, $Res Function(EmptyTripsTestState) then) =\n      _$EmptyTripsTestStateCopyWithImpl<$Res, EmptyTripsTestState>;\n}\n\n/// @nodoc\nclass _$EmptyTripsTestStateCopyWithImpl<$Res, $Val extends EmptyTripsTestState>\n    implements $EmptyTripsTestStateCopyWith<$Res> {\n  _$EmptyTripsTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements EmptyTripsTestState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements EmptyTripsTestState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl implements _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data) : _data = data;\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success implements EmptyTripsTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.error);\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements EmptyTripsTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n\n  Object get error;\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18469,
        "last_modified": "2025-04-16T13:25:27.5752006",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trip_generation_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/empty_trip_generation.service.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/neighbor_geohashes.port.dart';\r\nimport 'empty_trip_generation_test_state.dart';\r\n\r\nclass EmptyTripGenerationTestNotifier extends StateNotifier<EmptyTripGenerationTestState> {\r\n  final EmptyTripGenerationService _emptyTripGenerationService;\r\n  final NeighborGeohashesPort _neighborGeohashesPort;\r\n\r\n  EmptyTripGenerationTestNotifier(\r\n      this._emptyTripGenerationService,\r\n      this._neighborGeohashesPort,\r\n      ) : super(const EmptyTripGenerationTestState.initial());\r\n\r\n  Future<void> testEmptyTripGeneration() async {\r\n    state = const EmptyTripGenerationTestState.loading();\r\n\r\n    try {\r\n      print('🏗️ Test de génération des Empty Trips et leurs voisins');\r\n      final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n\r\n      final result = await _emptyTripGenerationService.generateEmptyTrips(tripId);\r\n      print('✓ Empty trips générés');\r\n\r\n      // Vérifier les neighbors pour chaque empty trip\r\n      for (final trip in [...result.halfDayTrips, ...result.fullDayTrips]) {\r\n        final neighbors = await _neighborGeohashesPort.getNeighborGeohashes(trip.id);\r\n        print('📍 ${trip.id}: ${neighbors.length} voisins trouvés');\r\n      }\r\n\r\n      state = EmptyTripGenerationTestState.success({\r\n        'testType': 'empty_trip_generation',\r\n        'halfDayTrips': result.halfDayTrips.map((trip) => {\r\n          'id': trip.id,\r\n          'sw1Id': trip.sw1Id,\r\n          'geohash': trip.departureGeohash5,\r\n          'neighbor_count': trip.traversedGeohashes.length,\r\n        }).toList(),\r\n        'fullDayTrips': result.fullDayTrips.map((trip) => {\r\n          'id': trip.id,\r\n          'sw1Id': trip.sw1Id,\r\n          'sw2Id': trip.sw2Id,\r\n          'geohash': trip.departureGeohash5,\r\n          'neighbor_count': trip.traversedGeohashes.length,\r\n        }).toList(),\r\n      });\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur dans le test de génération: $e');\r\n      state = EmptyTripGenerationTestState.error(e);\r\n    }\r\n  }}",
      "info": {
        "size": 2269,
        "last_modified": "2025-04-16T13:25:27.5812704",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trip_generation_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/empty_trip_generation.provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/neighbor_geohashes.provider.dart';\r\nimport 'empty_trip_generation_test_notifier.dart';\r\nimport 'empty_trip_generation_test_state.dart';\r\n\r\nfinal emptyTripGenerationTestProvider = StateNotifierProvider<EmptyTripGenerationTestNotifier, EmptyTripGenerationTestState>((ref) {\r\n  final emptyTripGenerationService = ref.watch(emptyTripGenerationServiceProvider);\r\n  final neighborGeohashesPort = ref.watch(neighborGeohashesProvider);\r\n\r\n  return EmptyTripGenerationTestNotifier(\r\n    emptyTripGenerationService,\r\n    neighborGeohashesPort,\r\n  );\r\n});",
      "info": {
        "size": 858,
        "last_modified": "2025-04-16T13:25:27.5872711",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trip_generation_test_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'empty_trip_generation_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass EmptyTripGenerationTestState with _$EmptyTripGenerationTestState {\r\n  const factory EmptyTripGenerationTestState.initial() = _Initial;\r\n\r\n  const factory EmptyTripGenerationTestState.loading() = _Loading;\r\n\r\n  const factory EmptyTripGenerationTestState.success(\r\n      Map<String, dynamic> data) = _Success;\r\n\r\n  const factory EmptyTripGenerationTestState.error(Object error) = _Error;\r\n\r\n  const EmptyTripGenerationTestState._();\r\n\r\n}",
      "info": {
        "size": 660,
        "last_modified": "2025-04-16T13:25:27.5943078",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'empty_trip_generation_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$EmptyTripGenerationTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $EmptyTripGenerationTestStateCopyWith<$Res> {\n  factory $EmptyTripGenerationTestStateCopyWith(\n          EmptyTripGenerationTestState value,\n          $Res Function(EmptyTripGenerationTestState) then) =\n      _$EmptyTripGenerationTestStateCopyWithImpl<$Res,\n          EmptyTripGenerationTestState>;\n}\n\n/// @nodoc\nclass _$EmptyTripGenerationTestStateCopyWithImpl<$Res,\n        $Val extends EmptyTripGenerationTestState>\n    implements $EmptyTripGenerationTestStateCopyWith<$Res> {\n  _$EmptyTripGenerationTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl extends _Initial {\n  const _$InitialImpl() : super._();\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial extends EmptyTripGenerationTestState {\n  const factory _Initial() = _$InitialImpl;\n  const _Initial._() : super._();\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl extends _Loading {\n  const _$LoadingImpl() : super._();\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading extends EmptyTripGenerationTestState {\n  const factory _Loading() = _$LoadingImpl;\n  const _Loading._() : super._();\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl extends _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data)\n      : _data = data,\n        super._();\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success extends EmptyTripGenerationTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n  const _Success._() : super._();\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl extends _Error {\n  const _$ErrorImpl(this.error) : super._();\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error extends EmptyTripGenerationTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n  const _Error._() : super._();\n\n  Object get error;\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18966,
        "last_modified": "2025-04-16T13:25:27.6003077",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/route_optimization_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/route_optimization.port.dart';\r\nimport 'route_optimization_test_state.dart';\r\n\r\nclass RouteOptimizationTestNotifier extends StateNotifier<RouteOptimizationTestState> {\r\n  final RouteOptimizationPort _routeOptimizationPort;\r\n\r\n  RouteOptimizationTestNotifier(this._routeOptimizationPort)\r\n      : super(const RouteOptimizationTestState.initial());\r\n\r\n  Future<void> testRouteOptimization() async {\r\n    state = const RouteOptimizationTestState.loading();\r\n\r\n    try {\r\n      print('🗺️ Test d\\'optimisation des routes');\r\n\r\n      // Points de test en Dordogne\r\n      final origin = const LatLng(45.1909, 0.7167);      // Périgueux\r\n      final destination = const LatLng(44.8883, 1.2162);  // Sarlat\r\n      final waypoint = const LatLng(44.9171, 1.0669);     // Les Eyzies\r\n\r\n      final optimizedRoute = await _routeOptimizationPort.getOptimizedRoute(\r\n        origin,\r\n        destination,\r\n        [waypoint],\r\n      );\r\n\r\n      final travelTime = await _routeOptimizationPort.getTravelTime(\r\n        origin,\r\n        destination,\r\n      );\r\n\r\n      final detourEvaluation = await _routeOptimizationPort.evaluateDetour(\r\n        origin,\r\n        destination,\r\n        waypoint,\r\n        const Duration(minutes: 30),\r\n      );\r\n\r\n      state = RouteOptimizationTestState.success({\r\n        'testType': 'route_optimization',\r\n        'origin': 'Périgueux',\r\n        'destination': 'Sarlat',\r\n        'waypoint': 'Les Eyzies',\r\n        'route': {\r\n          ...optimizedRoute,\r\n          'polyline': (optimizedRoute['polyline'] != null)\r\n              ? '${optimizedRoute['polyline'].toString().substring(0, 50)}...'\r\n              : 'Pas de polyline',\r\n        },\r\n        'travelTime': '${travelTime.inMinutes} minutes',\r\n        'detourEvaluation': detourEvaluation,\r\n      });\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur dans le test d\\'optimisation des routes: $e');\r\n      state = RouteOptimizationTestState.error(e);\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2208,
        "last_modified": "2025-04-16T13:25:27.607416",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/route_optimization_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/route_optimization.provider.dart';\r\nimport 'route_optimization_test_notifier.dart';\r\nimport 'route_optimization_test_state.dart';\r\n\r\nfinal routeOptimizationTestProvider = StateNotifierProvider<RouteOptimizationTestNotifier, RouteOptimizationTestState>((ref) {\r\n  final routeOptimization = ref.watch(routeOptimizationPortProvider);\r\n  return RouteOptimizationTestNotifier(routeOptimization);\r\n});",
      "info": {
        "size": 604,
        "last_modified": "2025-04-16T13:25:27.6129334",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/route_optimization_test_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\npart 'route_optimization_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass RouteOptimizationTestState with _$RouteOptimizationTestState {\r\n  const factory RouteOptimizationTestState.initial() = _Initial;\r\n  const factory RouteOptimizationTestState.loading() = _Loading;\r\n  const factory RouteOptimizationTestState.success(Map<String, dynamic> data) = _Success;\r\n  const factory RouteOptimizationTestState.error(Object error) = _Error;\r\n\r\n  const RouteOptimizationTestState._();\r\n\r\n}",
      "info": {
        "size": 624,
        "last_modified": "2025-04-16T13:25:27.6199336",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'route_optimization_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$RouteOptimizationTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $RouteOptimizationTestStateCopyWith<$Res> {\n  factory $RouteOptimizationTestStateCopyWith(RouteOptimizationTestState value,\n          $Res Function(RouteOptimizationTestState) then) =\n      _$RouteOptimizationTestStateCopyWithImpl<$Res,\n          RouteOptimizationTestState>;\n}\n\n/// @nodoc\nclass _$RouteOptimizationTestStateCopyWithImpl<$Res,\n        $Val extends RouteOptimizationTestState>\n    implements $RouteOptimizationTestStateCopyWith<$Res> {\n  _$RouteOptimizationTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl extends _Initial {\n  const _$InitialImpl() : super._();\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial extends RouteOptimizationTestState {\n  const factory _Initial() = _$InitialImpl;\n  const _Initial._() : super._();\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl extends _Loading {\n  const _$LoadingImpl() : super._();\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading extends RouteOptimizationTestState {\n  const factory _Loading() = _$LoadingImpl;\n  const _Loading._() : super._();\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl extends _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data)\n      : _data = data,\n        super._();\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success extends RouteOptimizationTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n  const _Success._() : super._();\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl extends _Error {\n  const _$ErrorImpl(this.error) : super._();\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error extends RouteOptimizationTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n  const _Error._() : super._();\n\n  Object get error;\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18888,
        "last_modified": "2025-04-16T13:25:27.6260997",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\pages\\home_page.dart",
      "content": "// lib/features/home/presentation/pages/home_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:collection/collection.dart';\r\nimport '../widgets/navigation/lyra_navigation.dart';\r\nimport '../../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../../core/common/utils/activity_mapper.dart';\r\nimport '../../../../../core/domain/models/config/home_section_config.dart';\r\nimport '../../../search/application/state/home_activities_state.dart';\r\nimport '../../../search/presentation/pages/subcategory_page.dart';\r\nimport '../../../search/application/state/selected_subcategory_state.dart';\r\nimport '../../../shared_ui/presentation/widgets/shimmer/shimmer_section.dart';\r\nimport '../../../shared_ui/presentation/widgets/sections/activity_section.dart';\r\n\r\n\r\nclass HomePage extends ConsumerWidget {\r\n  const HomePage({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n\r\n    return Stack(\r\n      children: [\r\n        // Page d'accueil\r\n        AnimatedOpacity(\r\n          duration: const Duration(milliseconds: 200),\r\n          opacity: selectedSubcategory == null ? 1.0 : 0.0,\r\n          child: IgnorePointer(\r\n            ignoring: selectedSubcategory != null,\r\n            child: const HomeContent(),\r\n          ),\r\n        ),\r\n        // Page de sous-catégorie\r\n        AnimatedOpacity(\r\n          duration: const Duration(milliseconds: 200),\r\n          opacity: selectedSubcategory != null ? 1.0 : 0.0,\r\n          child: IgnorePointer(\r\n            ignoring: selectedSubcategory == null,\r\n            child: const SubcategoryPage(),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n}\r\n\r\n// lib/features/home/presentation/pages/home_page.dart\r\n\r\nclass HomeContent extends ConsumerWidget {\r\n  const HomeContent({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final sectionsAsync = ref.watch(homeSectionsConfigProvider);\r\n\r\n    return LyraNavigation(\r\n      child: sectionsAsync.when(\r\n        loading: () => _buildLoadingShimmer(),\r\n        error: (error, stack) => Center(\r\n          child: Text('Erreur de chargement des sections: $error'),\r\n        ),\r\n        data: (sections) => SingleChildScrollView(\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: sections\r\n                .toList()\r\n                .sorted((a, b) => a.priority.compareTo(b.priority))\r\n                .map((section) => _buildSectionWithActivities(ref, section))\r\n                .toList(),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSectionWithActivities(WidgetRef ref, HomeSectionConfig section) {\r\n    return Consumer(\r\n      builder: (context, ref, child) {\r\n        final activitiesAsync = ref.watch(sectionActivitiesProvider(section));\r\n\r\n        return activitiesAsync.when(\r\n          loading: () => ShimmerSection(isFirstSection: false),\r\n          error: (error, stack) => const SizedBox.shrink(), // On cache la section en erreur\r\n          data: (activities) => ActivitySection(\r\n            title: section.title,\r\n            activities: ActivityMapper.mapToActivityCards(activities),\r\n            isFirstSection: false, // À gérer si nécessaire\r\n          ),\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingShimmer() => SingleChildScrollView(\r\n    child: Column(\r\n      children: List.generate(\r\n        3,\r\n            (index) => ShimmerSection(isFirstSection: index == 0),\r\n      ),\r\n    ),\r\n  );\r\n}",
      "info": {
        "size": 3653,
        "last_modified": "2025-04-16T13:25:27.6552136",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\city_picker.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/city_picker.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../search/application/state/selected_city_state.dart';\r\nimport '../../../../search/application/state/place_details_notifier.dart';\r\nimport '../../../../../core/adapters/cache/hive_adapters.dart';\r\nimport 'city_picker_modal.dart';\r\n\r\nclass CityPicker extends ConsumerWidget {\r\n  const CityPicker({super.key});\r\n\r\n  void _showCityPicker(BuildContext context, WidgetRef ref) {\r\n    // Réinitialiser l'état du détail de lieu avant d'ouvrir le modal\r\n    ref.read(placeDetailsNotifierProvider.notifier).reset();\r\n\r\n    // Ouvrir directement le modal sans vérification supplémentaire\r\n    showModalBottomSheet(\r\n      context: context,\r\n      isScrollControlled: true,\r\n      backgroundColor: Colors.transparent,\r\n      builder: (context) => const CityPickerModal(),\r\n    );\r\n  }\r\n\r\n  String _formatCityName(String? cityName) {\r\n    if (cityName == null) return 'Paris';\r\n    return cityName.length > 14 ? '${cityName.substring(0, 14)}...' : cityName;\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return Material(\r\n      color: Colors.transparent,\r\n      child: InkWell(\r\n        onTap: () => _showCityPicker(context, ref),\r\n        borderRadius: BorderRadius.circular(4),\r\n        splashColor: Colors.white.withOpacity(0.1),\r\n        highlightColor: Colors.white.withOpacity(0.1),\r\n        child: Padding(\r\n          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),\r\n          child: Row(\r\n            mainAxisSize: MainAxisSize.min,\r\n            children: [\r\n              Text(\r\n                _formatCityName(ref.watch(selectedCityProvider)?.cityName),\r\n                style: Theme.of(context).textTheme.bodyMedium?.copyWith(\r\n                  color: Colors.white,\r\n                  shadows: [],\r\n                ),\r\n              ),\r\n              const SizedBox(width: 4),\r\n              const Icon(\r\n                Icons.arrow_drop_down,\r\n                color: Colors.white,\r\n                size: 20,\r\n              ),\r\n            ],\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2289,
        "last_modified": "2025-04-16T13:25:27.6664384",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\city_picker_modal.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/city_picker_modal.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/domain/models/location/place_details.dart';\r\nimport '../../../../../core/domain/models/shared/city_model.dart';\r\nimport '../../../../../core/common/utils/geohash.dart';\r\nimport '../../../../search/application/state/city_search_provider.dart';\r\nimport '../../../../search/application/state/selected_city_state.dart';\r\nimport '../../../../search/application/state/place_details_notifier.dart';\r\nimport '../../../../search/application/state/place_details_state.dart';\r\nimport '../../../../search/application/state/place_search_notifier.dart';\r\nimport '../../../../search/presentation/widgets/location/location_search_bar.dart';\r\nimport '../../../../search/presentation/widgets/location/current_location_button.dart';\r\n\r\nclass CityPickerModal extends ConsumerStatefulWidget {\r\n  const CityPickerModal({Key? key}) : super(key: key);\r\n\r\n  @override\r\n  ConsumerState<CityPickerModal> createState() => _CityPickerModalState();\r\n}\r\n\r\nclass _CityPickerModalState extends ConsumerState<CityPickerModal> {\r\n  final searchController = TextEditingController();\r\n\r\n  @override\r\n  void dispose() {\r\n    searchController.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      height: MediaQuery.of(context).size.height * 0.8,\r\n      decoration: BoxDecoration(\r\n        color: Theme.of(context).scaffoldBackgroundColor,\r\n        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),\r\n      ),\r\n      child: Column(\r\n        children: [\r\n          // Drag indicator\r\n          const SizedBox(height: 8),\r\n          Container(\r\n            width: 40,\r\n            height: 4,\r\n            decoration: BoxDecoration(\r\n              color: Colors.grey.shade300,\r\n              borderRadius: BorderRadius.circular(2),\r\n            ),\r\n          ),\r\n          const SizedBox(height: 16),\r\n\r\n          // Enhanced Search bar with Google Places integration\r\n          Padding(\r\n            padding: const EdgeInsets.symmetric(horizontal: 20),\r\n            child: Row(\r\n              children: [\r\n                IconButton(\r\n                  icon: const Icon(LucideIcons.arrowLeft),\r\n                  onPressed: () => Navigator.pop(context),\r\n                ),\r\n                Expanded(\r\n                  child: LocationSearchBar(\r\n                    initialQuery: searchController.text,\r\n                    onLocationButtonPressed: (_) {\r\n                      // Demander la position actuelle et convertir en City\r\n                      ref.read(placeDetailsNotifierProvider.notifier)\r\n                          .getCurrentLocation();\r\n                    },\r\n                    onSubmitted: (placeId) {\r\n                      // Charger les détails du lieu\r\n                      ref.read(placeDetailsNotifierProvider.notifier)\r\n                          .getLocationDetails(placeId);\r\n                    },\r\n                  ),\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n          const SizedBox(height: 20),\r\n\r\n          // Location details state handling\r\n          Expanded(\r\n            child: Consumer(\r\n              builder: (context, ref, child) {\r\n                final placeDetailsState = ref.watch(placeDetailsNotifierProvider);\r\n\r\n                return placeDetailsState.when(\r\n                  initial: () => _buildSearchResults(),\r\n\r\n                  loading: () => const Center(\r\n                    child: Column(\r\n                      mainAxisSize: MainAxisSize.min,\r\n                      children: [\r\n                        CircularProgressIndicator(),\r\n                        SizedBox(height: 16),\r\n                        Text('Chargement des détails...'),\r\n                      ],\r\n                    ),\r\n                  ),\r\n\r\n                  loaded: (details) {\r\n                    // Créer le geohash correct\r\n                    final String geohash5 = Geohash.encode(\r\n                        details.location.latitude,\r\n                        details.location.longitude\r\n                    );\r\n\r\n                    // Création de l'objet City\r\n                    final city = City(\r\n                      id: details.placeId,\r\n                      cityName: details.name,\r\n                      lat: details.location.latitude,\r\n                      lon: details.location.longitude,\r\n                      geohash5: geohash5,\r\n                      createdAt: DateTime.now(),\r\n                      updatedAt: DateTime.now(),\r\n                    );\r\n\r\n                    // Logs de debug structurés\r\n                    print('📍 VILLE SÉLECTIONNÉE: ${details.name}');\r\n                    print('  └─ Latitude: ${details.location.latitude}');\r\n                    print('  └─ Longitude: ${details.location.longitude}');\r\n                    print('  └─ Geohash: $geohash5');\r\n\r\n                    // Mettre à jour le state et fermer le modal\r\n                    WidgetsBinding.instance.addPostFrameCallback((_) {\r\n                      ref.read(selectedCityProvider.notifier).state = city;\r\n                      Navigator.pop(context);\r\n                    });\r\n\r\n                    return const SizedBox.shrink();\r\n                  },\r\n\r\n                  error: (message) => Column(\r\n                    children: [\r\n                      // Message d'erreur amélioré\r\n                      Padding(\r\n                        padding: const EdgeInsets.all(20),\r\n                        child: Container(\r\n                          padding: const EdgeInsets.all(16),\r\n                          decoration: BoxDecoration(\r\n                            color: Colors.red.shade50,\r\n                            borderRadius: BorderRadius.circular(12),\r\n                            border: Border.all(color: Colors.red.shade200),\r\n                          ),\r\n                          child: Column(\r\n                            crossAxisAlignment: CrossAxisAlignment.start,\r\n                            children: [\r\n                              Row(\r\n                                children: [\r\n                                  Icon(Icons.error_outline, color: Colors.red.shade700),\r\n                                  const SizedBox(width: 12),\r\n                                  Expanded(\r\n                                    child: Text(\r\n                                      'Erreur de recherche',\r\n                                      style: TextStyle(\r\n                                        color: Colors.red.shade700,\r\n                                        fontWeight: FontWeight.bold,\r\n                                        fontSize: 16,\r\n                                      ),\r\n                                    ),\r\n                                  ),\r\n                                ],\r\n                              ),\r\n                              const SizedBox(height: 8),\r\n                              Text(\r\n                                message,\r\n                                style: TextStyle(color: Colors.red.shade700),\r\n                              ),\r\n                              const SizedBox(height: 8),\r\n                              Text(\r\n                                'Veuillez réessayer ou choisir une autre ville.',\r\n                                style: TextStyle(color: Colors.red.shade700),\r\n                              ),\r\n                            ],\r\n                          ),\r\n                        ),\r\n                      ),\r\n\r\n                      // Résultats de recherche alternatifs\r\n                      Expanded(child: _buildSearchResults()),\r\n                    ],\r\n                  ),\r\n                );\r\n              },\r\n            ),\r\n          ),        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSearchResults() {\r\n    // Garde la fonctionnalité existante de recherche de villes\r\n    final query = searchController.text;\r\n    if (query.isEmpty) {\r\n      return Padding(\r\n        padding: const EdgeInsets.symmetric(horizontal: 20),\r\n        child: Column(\r\n          crossAxisAlignment: CrossAxisAlignment.start,\r\n          children: [\r\n            // Bouton pour utiliser la position actuelle uniquement\r\n            Card(\r\n              shape: RoundedRectangleBorder(\r\n                borderRadius: BorderRadius.circular(12),\r\n              ),\r\n              child: CurrentLocationButton(\r\n                onLocationSelected: () {\r\n                  ref.read(placeDetailsNotifierProvider.notifier)\r\n                      .getCurrentLocation();\r\n                },\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      );\r\n    }\r\n\r\n    final citiesAsync = ref.watch(citiesSearchResultsProvider(query));\r\n\r\n    return citiesAsync.when(\r\n      data: (cities) => ListView.builder(\r\n        padding: const EdgeInsets.symmetric(horizontal: 20),\r\n        itemCount: cities.take(10).length,\r\n        itemBuilder: (context, index) {\r\n          final city = cities[index];\r\n          return Container(\r\n            margin: const EdgeInsets.only(bottom: 8),\r\n            decoration: BoxDecoration(\r\n              color: AppColors.neutral200,\r\n              borderRadius: BorderRadius.circular(12),\r\n            ),\r\n            child: ListTile(\r\n              title: Text(\r\n                city.cityName,\r\n                style: const TextStyle(fontSize: 16),\r\n              ),\r\n              onTap: () {\r\n                ref.read(selectedCityProvider.notifier).state = city;\r\n                Navigator.pop(context);\r\n              },\r\n            ),\r\n          );\r\n        },\r\n      ),\r\n      loading: () => Center(\r\n        child: Column(\r\n          mainAxisAlignment: MainAxisAlignment.center,\r\n          children: [\r\n            const CircularProgressIndicator(),\r\n            const SizedBox(height: 8),\r\n            Text(\r\n              'Recherche en cours...',\r\n              style: Theme.of(context).textTheme.bodyMedium,\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n      error: (_, __) => const SizedBox.shrink(),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 10386,
        "last_modified": "2025-04-16T13:25:27.6729551",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\lyra_footer.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/lyra_footer.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport 'package:glossy/glossy.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\n\r\n\r\nclass LyraFooter extends StatelessWidget {\r\n  const LyraFooter({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return SizedBox(\r\n      height: AppDimensions.bottomNavBarHeight,\r\n      child: GlossyContainer(\r\n        width: double.infinity,\r\n        height: AppDimensions.bottomNavBarHeight,\r\n        strengthX: 5,\r\n        strengthY: 5,\r\n        opacity: 0.3,\r\n        border: Border.all(color: Colors.transparent),\r\n        color: AppColors.neutral900,\r\n        child: Container(\r\n          color: Color.fromRGBO(\r\n            AppColors.neutral900.red,\r\n            AppColors.neutral900.green,\r\n            AppColors.neutral900.blue,\r\n            0.7,\r\n          ),\r\n          child: SafeArea(\r\n            top: false,\r\n            child: Row(\r\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\r\n              children: [\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.home,\r\n                  label: 'Home',\r\n                  isSelected: true,\r\n                ),\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.heart,\r\n                  label: 'Favoris',\r\n                ),\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.sparkles,\r\n                  label: 'Wow',\r\n                ),\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.user,\r\n                  label: 'Profil',\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildFooterItem(\r\n      BuildContext context, {\r\n        required IconData icon,\r\n        required String label,\r\n        bool isSelected = false,\r\n      }) {\r\n    final color = isSelected\r\n        ? AppColors.accent // Utilise la couleur corail pour l'item sélectionné\r\n        : Colors.white;// Les autres items restent en blanc\r\n    return Expanded(  // Ajout pour une meilleure distribution de l'espace\r\n      child: InkWell(\r\n        onTap: () {},\r\n        child: SizedBox(  // Assure une hauteur fixe\r\n          height: AppDimensions.bottomNavBarHeight - MediaQuery.of(context).padding.bottom,\r\n          child: Column(\r\n            mainAxisAlignment: MainAxisAlignment.center,  // Centre verticalement\r\n            mainAxisSize: MainAxisSize.min,\r\n            children: [\r\n              const SizedBox(height: 8),\r\n              Icon(icon, color: color),\r\n              const SizedBox(height: 1),\r\n              Text(\r\n                label,\r\n                style: isSelected\r\n                    ? context.labelMedium.copyWith(\r\n                    fontWeight: FontWeight.bold,\r\n                    color: Theme.of(context).colorScheme.primary\r\n                ) // Style pour l'item sélectionné\r\n                    : context.labelMedium.copyWith(\r\n                    color: AppColors.neutral500\r\n                ),\r\n              ),// Style par défaut\r\n            ],\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3455,
        "last_modified": "2025-04-16T13:25:27.6799914",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\lyra_header.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/lyra_header.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:glossy/glossy.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport 'package:flutter_svg/flutter_svg.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/adapters/supabase/database_adapter.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../home/presentation/widgets/navigation/city_picker.dart';\r\nimport 'subcategories_list.dart';\r\n\r\n\r\n\r\n\r\nclass LyraHeader extends StatelessWidget {\r\n  final String? title;\r\n\r\n  const LyraHeader({\r\n    super.key,\r\n    this.title,\r\n  });\r\n\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      mainAxisSize: MainAxisSize.min,\r\n      children: [\r\n        GlossyContainer(\r\n          width: double.infinity,\r\n          height: MediaQuery.of(context).padding.top + 55,\r\n          strengthX: 5,\r\n          strengthY: 5,\r\n          opacity: 0.1,\r\n          border: Border.all(color: Colors.transparent),\r\n          color: AppColors.neutral900,\r\n          child: Container(\r\n            color: AppColors.neutral900,\r\n            padding: EdgeInsets.only(top: MediaQuery.of(context).padding.top),\r\n            child: _buildMainHeader(context),\r\n          ),\r\n        ),\r\n        Container(\r\n          color: AppColors.neutral900,\r\n          padding: const EdgeInsets.only(bottom: 8),  // Ajout du padding bottom\r\n          child: SizedBox(\r\n            height: 50,\r\n            child: const SubcategoriesList(),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n\r\n  Widget _buildMainHeader(BuildContext context) {\r\n    return Padding(\r\n      padding: EdgeInsets.only(\r\n        left: AppDimensions.spacingM,\r\n        right: AppDimensions.spacingXs,\r\n        bottom: AppDimensions.spacingS,\r\n        top: 8,  // Ajout pour descendre le header de 8px\r\n      ),\r\n      child: Row(\r\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\r\n        children: [\r\n          // Logo\r\n          SvgPicture.network(\r\n            '${SupabaseService.client.storage.from('images').getPublicUrl('branding/light.svg')}',\r\n            height: 55,\r\n          ),\r\n\r\n          // Ville au centre\r\n          Expanded(  // Wrap avec Expanded\r\n            child: Center(  // Centrer le contenu\r\n              child: Row(\r\n                mainAxisSize: MainAxisSize.min,  // Prendre la taille minimale nécessaire\r\n                children: [\r\n                  const Icon(\r\n                    LucideIcons.mapPin,\r\n                    size: 16,\r\n                    color: Colors.white,\r\n                    shadows: [], // Pas d'ombre\r\n                  ),\r\n                  const SizedBox(width: 4),\r\n                  const CityPicker(),\r\n                ],\r\n              ),\r\n            ),\r\n          ),\r\n\r\n// Boutons à droite\r\n          Padding(\r\n            padding: EdgeInsets.zero,\r\n            child: Row(\r\n              mainAxisSize: MainAxisSize.min,\r\n              children: [\r\n                IconButton(\r\n                  icon: const Icon(\r\n                    LucideIcons.slidersHorizontal,\r\n                    color: Colors.white,\r\n                    size: AppDimensions.iconSizeM,\r\n                  ),\r\n                  visualDensity: VisualDensity.compact,\r\n                  padding: EdgeInsets.zero,\r\n                  onPressed: () {},\r\n                ),\r\n                IconButton(\r\n                  icon: const Icon(\r\n                    LucideIcons.search,\r\n                    color: Colors.white,\r\n                    size: AppDimensions.iconSizeM,\r\n                  ),\r\n                  visualDensity: VisualDensity.compact,\r\n                  padding: EdgeInsets.zero,\r\n                  constraints: const BoxConstraints(\r\n                    minWidth: AppDimensions.iconSizeM,\r\n                    maxWidth: AppDimensions.iconSizeM,\r\n                  ),\r\n                  onPressed: () {},\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4143,
        "last_modified": "2025-04-16T13:25:27.6865065",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\lyra_navigation.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/lyra_navigation.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'lyra_header.dart';\r\nimport 'lyra_footer.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\n\r\n\r\n// Provider pour la visibilité du header\r\nfinal headerVisibilityProvider = StateProvider<bool>((ref) => true);\r\n\r\nclass LyraNavigation extends ConsumerWidget {  // était StatelessWidget avant\r\n  final Widget child;\r\n  final String? title;\r\n\r\n  const LyraNavigation({\r\n    super.key,\r\n    required this.child,\r\n    this.title,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {  // Ajout de WidgetRef\r\n    final headerVisible = ref.watch(headerVisibilityProvider);\r\n\r\n    return Scaffold(\r\n      body: Stack(\r\n        children: [\r\n          CustomScrollView(\r\n            slivers: [\r\n              SliverToBoxAdapter(\r\n                child: SizedBox(height: MediaQuery.of(context).padding.top + 90),\r\n              ),\r\n              SliverToBoxAdapter(\r\n                child: child,\r\n              ),\r\n              const SliverToBoxAdapter(\r\n                child: SizedBox(height: 80),\r\n              ),\r\n            ],\r\n          ),\r\n          AnimatedPositioned(\r\n            duration: const Duration(milliseconds: 600),\r\n            curve: Curves.easeOutSine,\r\n            top: headerVisible ? 0 : -(MediaQuery.of(context).padding.top + 90),\r\n            left: 0,\r\n            right: 0,\r\n            child: Container(\r\n              color: AppColors.neutral900, // Même couleur que le header\r\n              child: LyraHeader(\r\n                title: title,\r\n              ),\r\n            ),\r\n          ),\r\n          const Positioned(\r\n            bottom: 0,\r\n            left: 0,\r\n            right: 0,\r\n            child: LyraFooter(),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1912,
        "last_modified": "2025-04-16T13:25:27.6930227",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\subcategories_list.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/subcategories_list.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/domain/models/shared/subcategory_model.dart';\r\nimport '../../../../../core/domain/ports/providers/search/subcategory_search_provider.dart';\r\nimport '../../../../../core/common/constants/subcategory_icons.dart';\r\nimport '../../../../search/application/state/selected_subcategory_state.dart';\r\n\r\nclass SubcategoriesList extends ConsumerWidget {\r\n  const SubcategoriesList({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return SizedBox(\r\n      height: 35,\r\n      child: _buildContent(context, ref),\r\n    );\r\n  }\r\n\r\n  Widget _buildContent(BuildContext context, WidgetRef ref) {\r\n    final subcategoriesAsync = ref.watch(subcategoriesProvider);\r\n\r\n    return SingleChildScrollView(\r\n      scrollDirection: Axis.horizontal,\r\n      padding: const EdgeInsets.symmetric(horizontal: 8),\r\n      clipBehavior: Clip.none, // Pour éviter le clipping des ombres/effets\r\n      child: ConstrainedBox(\r\n        constraints: const BoxConstraints(maxWidth: double.infinity),\r\n        child: Row(\r\n          mainAxisSize: MainAxisSize.min, // Le Row s'adapte à la largeur de son contenu\r\n          children: [\r\n            _buildCategoryChip(\r\n              context,\r\n              ref,\r\n              icon: LucideIcons.compass,\r\n              label: 'Explorer',\r\n              subcategory: null,\r\n            ),\r\n            ...subcategoriesAsync.when(\r\n              data: (subcategories) => subcategories.map((subcategory) {\r\n                final isSelected = ref.watch(selectedSubcategoryProvider) == subcategory;\r\n                return _buildCategoryChip(\r\n                  context,\r\n                  ref,\r\n                  icon: SubcategoryIcons.getIcon(subcategory.icon),\r\n                  label: subcategory.name,\r\n                  subcategory: subcategory,\r\n                  isSelected: isSelected,\r\n                );\r\n              }),\r\n              loading: () => [\r\n                Padding(\r\n                  padding: const EdgeInsets.symmetric(horizontal: 16),\r\n                  child: SizedBox(\r\n                    width: 20,\r\n                    height: 20,\r\n                    child: CircularProgressIndicator(\r\n                      color: AppColors.neutral200,\r\n                      strokeWidth: 2,\r\n                    ),\r\n                  ),\r\n                )\r\n              ],\r\n              error: (_, __) => [\r\n                Icon(LucideIcons.alertCircle, color: AppColors.neutral200)\r\n              ],\r\n            ),\r\n            const SizedBox(width: 8), // Espace à droite pour compenser\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildCategoryChip(\r\n      BuildContext context,\r\n      WidgetRef ref, {\r\n        required IconData icon,\r\n        required String label,\r\n        Subcategory? subcategory,\r\n        bool? isSelected,\r\n      }) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n    final selected = subcategory == null\r\n        ? selectedSubcategory == null // \"Explorer\" est sélectionné seulement si aucune sous-catégorie n'est sélectionnée\r\n        : subcategory.id == selectedSubcategory?.id;\r\n\r\n    if (subcategory == null) {\r\n      return Padding(\r\n        padding: const EdgeInsets.symmetric(horizontal: 1),\r\n        child: IntrinsicWidth(\r\n          child: GestureDetector(\r\n            onTap: () {\r\n              ref.read(selectedSubcategoryProvider.notifier).reset();\r\n            },\r\n            child: Container(\r\n              // Supprimez width: double.infinity pour laisser la largeur s'ajuster\r\n              height: 30,\r\n              decoration: BoxDecoration(\r\n                color: selected ? AppColors.neutral200 : AppColors.neutral800,\r\n                borderRadius: BorderRadius.circular(20),\r\n              ),\r\n              child: Padding(\r\n                padding: const EdgeInsets.symmetric(horizontal: 16),\r\n                child: Center(\r\n                  child: Row(\r\n                    mainAxisSize: MainAxisSize.min,\r\n                    mainAxisAlignment: MainAxisAlignment.center,\r\n                    children: [\r\n                      Icon(\r\n                        icon,\r\n                        size: 16,\r\n                        color: selected ? AppColors.neutral900 : Colors.white,\r\n                      ),\r\n                      const SizedBox(width: 8),\r\n                      Text(\r\n                        label,\r\n                        style: selected\r\n                            ? context.chipSelectedLabel\r\n                            : context.chipLabel,\r\n                      ),\r\n                    ],\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n\r\n    return Padding(\r\n      padding: const EdgeInsets.symmetric(horizontal: 4),\r\n      child: IntrinsicWidth(\r\n        child: GestureDetector(\r\n          onTap: () {\r\n            ref.read(selectedSubcategoryProvider.notifier).selectSubcategory(subcategory);\r\n          },\r\n          child: Container(\r\n            // Supprimez également width: double.infinity ici\r\n            height: 32,\r\n            decoration: BoxDecoration(\r\n              color: selected ? AppColors.neutral200 : AppColors.neutral800,\r\n              borderRadius: BorderRadius.circular(20),\r\n            ),\r\n            child: Padding(\r\n              padding: const EdgeInsets.symmetric(horizontal: 16),\r\n              child: Center(\r\n                child: Row(\r\n                  mainAxisSize: MainAxisSize.min,\r\n                  mainAxisAlignment: MainAxisAlignment.center,\r\n                  children: [\r\n                    Icon(\r\n                      icon,\r\n                      size: 16,\r\n                      color: selected ? AppColors.neutral900 : Colors.white,\r\n                    ),\r\n                    const SizedBox(width: 8),\r\n                    Text(\r\n                      label,\r\n                      style: selected\r\n                          ? context.chipSelectedLabel\r\n                          : context.chipLabel,\r\n                    ),\r\n                  ],\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 6548,
        "last_modified": "2025-04-16T13:25:27.6990228",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\services\\city_selection_service.dart",
      "content": "// lib/features/search/application/services/city_selection_service.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../../../core/domain/models/shared/city_model.dart';\r\nimport '../../../../core/domain/models/location/place_details.dart';\r\nimport '../../../../core/domain/services/location/enhanced_location_service.dart';\r\nimport '../../../../core/domain/ports/providers/location/location_providers.dart';\r\nimport '../state/selected_city_state.dart';\r\n\r\n/// Service qui gère la logique de sélection de ville et la récupération de ses coordonnées\r\nclass CitySelectionService {\r\n  final EnhancedLocationService _locationService;\r\n  final Ref _ref;\r\n\r\n  CitySelectionService(this._locationService, this._ref);\r\n\r\n  /// Sélectionne une ville à partir de son place_id Google\r\n  /// et met à jour les providers associés\r\n  Future<bool> selectCityByPlaceId(String placeId) async {\r\n    try {\r\n      // Récupérer les détails complets du lieu (incluant lat/lng)\r\n      final placeDetailsResult = await _locationService.getPlaceDetails(placeId);\r\n\r\n      if (placeDetailsResult.isError) {\r\n        print('❌ Erreur lors de la récupération des détails: ${placeDetailsResult.asError!.error}');\r\n        return false;\r\n      }\r\n\r\n      // Extraire l'objet PlaceDetails du Result\r\n      final placeDetails = placeDetailsResult.asValue!.value;\r\n\r\n      // Créer un objet City avec les coordonnées\r\n      final city = City(\r\n        id: placeId,\r\n        cityName: placeDetails.name,\r\n        lat: placeDetails.location.latitude,\r\n        lon: placeDetails.location.longitude,\r\n        geohash5: '', // À générer si nécessaire\r\n        createdAt: DateTime.now(),\r\n        updatedAt: DateTime.now(),\r\n      );\r\n\r\n      // Mettre à jour le provider de ville sélectionnée\r\n      _ref.read(selectedCityProvider.notifier).state = city;\r\n\r\n      print('✅ Ville sélectionnée: ${city.cityName} (${city.lat}, ${city.lon})');\r\n      return true;\r\n    } catch (e) {\r\n      print('❌ Erreur lors de la sélection de la ville: $e');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /// Récupère les coordonnées de la ville actuellement sélectionnée\r\n  /// ou null si aucune ville n'est sélectionnée\r\n  LatLng? getSelectedCityCoordinates() {\r\n    final city = _ref.read(selectedCityProvider);\r\n    if (city == null) return null;\r\n\r\n    return LatLng(city.lat, city.lon);\r\n  }\r\n}\r\n\r\n// Provider pour accéder au service\r\nfinal citySelectionServiceProvider = Provider<CitySelectionService>((ref) {\r\n  final locationService = ref.watch(enhancedLocationServiceProvider);\r\n  return CitySelectionService(locationService, ref);\r\n});",
      "info": {
        "size": 2750,
        "last_modified": "2025-04-16T13:25:27.7271696",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\activity_details_state.dart",
      "content": "// lib/features/search/application/state/activity_details_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../core/domain/ports/search/activity_details_port.dart';\r\nimport '../../../../core/adapters/supabase/database_adapter.dart';\r\nimport '../../../../core/adapters/supabase/search/activity_details_adapter.dart';\r\n\r\npart 'activity_details_state.freezed.dart';\r\n\r\n@freezed\r\nclass ActivityDetailsState with _$ActivityDetailsState {\r\n  const factory ActivityDetailsState.initial() = _Initial;\r\n  const factory ActivityDetailsState.loading() = _Loading;\r\n  const factory ActivityDetailsState.loaded(ActivityDetails details) = _Loaded;\r\n  const factory ActivityDetailsState.error(String message) = _Error;\r\n}\r\n\r\nclass ActivityDetailsNotifier extends StateNotifier<ActivityDetailsState> {\r\n  final ActivityDetailsPort _port;\r\n\r\n  ActivityDetailsNotifier(this._port) : super(const ActivityDetailsState.initial());\r\n\r\n  Future<void> loadActivityDetails(String activityId) async {\r\n    print('StateNotifier: Loading details for activity: $activityId');\r\n    state = const ActivityDetailsState.loading();\r\n    try {\r\n      print('StateNotifier: Calling port.getActivityDetails');\r\n      final details = await _port.getActivityDetails(activityId);\r\n      print('StateNotifier: Got details successfully');\r\n      state = ActivityDetailsState.loaded(details);\r\n    } catch (e) {\r\n      print('StateNotifier: Error loading details: $e');\r\n      state = ActivityDetailsState.error(e.toString());\r\n    }\r\n  }\r\n}\r\n\r\n// Un seul provider qui combine tout\r\nfinal activityDetailsProvider = StateNotifierProvider.autoDispose<ActivityDetailsNotifier, ActivityDetailsState>((ref) {\r\n  return ActivityDetailsNotifier(\r\n      ActivityDetailsAdapter(SupabaseService.client)\r\n  );\r\n});",
      "info": {
        "size": 1938,
        "last_modified": "2025-04-16T13:25:27.7397191",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\activity_details_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_details_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$ActivityDetailsState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityDetailsStateCopyWith<$Res> {\n  factory $ActivityDetailsStateCopyWith(ActivityDetailsState value,\n          $Res Function(ActivityDetailsState) then) =\n      _$ActivityDetailsStateCopyWithImpl<$Res, ActivityDetailsState>;\n}\n\n/// @nodoc\nclass _$ActivityDetailsStateCopyWithImpl<$Res,\n        $Val extends ActivityDetailsState>\n    implements $ActivityDetailsStateCopyWith<$Res> {\n  _$ActivityDetailsStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements ActivityDetailsState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements ActivityDetailsState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadedImplCopyWith<$Res> {\n  factory _$$LoadedImplCopyWith(\n          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =\n      __$$LoadedImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({ActivityDetails details});\n\n  $ActivityDetailsCopyWith<$Res> get details;\n}\n\n/// @nodoc\nclass __$$LoadedImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$LoadedImpl>\n    implements _$$LoadedImplCopyWith<$Res> {\n  __$$LoadedImplCopyWithImpl(\n      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? details = null,\n  }) {\n    return _then(_$LoadedImpl(\n      null == details\n          ? _value.details\n          : details // ignore: cast_nullable_to_non_nullable\n              as ActivityDetails,\n    ));\n  }\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $ActivityDetailsCopyWith<$Res> get details {\n    return $ActivityDetailsCopyWith<$Res>(_value.details, (value) {\n      return _then(_value.copyWith(details: value));\n    });\n  }\n}\n\n/// @nodoc\n\nclass _$LoadedImpl implements _Loaded {\n  const _$LoadedImpl(this.details);\n\n  @override\n  final ActivityDetails details;\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.loaded(details: $details)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$LoadedImpl &&\n            (identical(other.details, details) || other.details == details));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, details);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loaded(details);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loaded?.call(details);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(details);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loaded(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loaded?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loaded implements ActivityDetailsState {\n  const factory _Loaded(final ActivityDetails details) = _$LoadedImpl;\n\n  ActivityDetails get details;\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({String message});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? message = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == message\n          ? _value.message\n          : message // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.message);\n\n  @override\n  final String message;\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.error(message: $message)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            (identical(other.message, message) || other.message == message));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, message);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return error(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return error?.call(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(message);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements ActivityDetailsState {\n  const factory _Error(final String message) = _$ErrorImpl;\n\n  String get message;\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18644,
        "last_modified": "2025-04-16T13:25:27.746252",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\city_search_provider.dart",
      "content": "// lib/features/search/application/state/city_search_provider.dart\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../../../core/adapters/supabase/search/city_search_adapter.dart';\r\nimport '../../../../core/domain/models/shared/city_model.dart';\r\nimport '../../../../core/adapters/supabase/database_adapter.dart';\r\n\r\nfinal citySearchAdapter = CitySearchAdapter(SupabaseService.client);\r\n\r\nfinal citySearchProvider = Provider<CitySearchAdapter>((ref) => citySearchAdapter);\r\n\r\nfinal citiesSearchResultsProvider = FutureProvider.family<List<City>, String?>((ref, query) async {\r\n  print('DEBUG: Searching cities with query: $query');\r\n  try {\r\n    final citySearchAdapter = ref.read(citySearchProvider);\r\n    final results = await citySearchAdapter.searchCities(query);\r\n    print('DEBUG: Found ${results.length} cities');\r\n    return results;\r\n  } catch (e) {\r\n    print('DEBUG: Error in citiesSearchResultsProvider: $e');\r\n    rethrow;\r\n  }\r\n});",
      "info": {
        "size": 951,
        "last_modified": "2025-04-16T13:25:27.7532897",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\home_activities_state.dart",
      "content": "// lib/features/search/application/state/home_activities_state.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../../../../core/domain/models/activity/search/searchable_activity.dart';\r\nimport '../../../../core/domain/models/config/home_section_config.dart';\r\nimport '../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport '../state/selected_city_state.dart';\r\nimport '../../domain/providers/search_providers.dart';\r\n\r\n// Provider pour les activités d'une section spécifique\r\nfinal sectionActivitiesProvider = FutureProvider.autoDispose.family<List<SearchableActivity>, HomeSectionConfig>(\r\n      (ref, section) async {\r\n    const latitude = 44.8333;\r\n    const longitude = 0.7333;\r\n\r\n    final selectedCity = ref.watch(selectedCityProvider);\r\n    if (selectedCity == null) return [];\r\n\r\n    final useCase = ref.watch(searchProvidersModule.firstWhere(\r\n            (provider) => provider is Provider<GetActivitiesUseCase>\r\n    ) as Provider<GetActivitiesUseCase>);\r\n\r\n    try {\r\n      final activities = await useCase.executeQuery(\r\n          latitude: latitude,\r\n          longitude: longitude,\r\n          cityId: selectedCity.id,\r\n          queryFilter: section.queryFilter\r\n      );\r\n\r\n      // Cache des distances\r\n      ref.read(activityDistancesProvider.notifier).cacheDistances(\r\n          activities,\r\n          LatLng(latitude, longitude)\r\n      );\r\n\r\n      return activities;\r\n    } catch (e) {\r\n      return [];\r\n    }\r\n  },\r\n);\r\n\r\n// Provider principal qui combine les résultats des sections\r\nfinal homeActivitiesProvider = FutureProvider.autoDispose<Map<String, List<SearchableActivity>>>((ref) async {\r\n  final sections = await ref.watch(homeSectionsConfigProvider.future);\r\n  final results = <String, List<SearchableActivity>>{};\r\n\r\n  // Charger les sections en parallèle\r\n  await Future.wait(\r\n    sections.map((section) async {\r\n      final activities = await ref.watch(sectionActivitiesProvider(section).future);\r\n      results[section.id.toString()] = activities;\r\n    }),\r\n  );\r\n\r\n  return results;\r\n});",
      "info": {
        "size": 2319,
        "last_modified": "2025-04-16T13:25:27.7603436",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_details_notifier.dart",
      "content": "// lib/features/search/application/state/place_details_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../../../core/domain/models/location/place_details.dart';\r\nimport '../../../../core/domain/services/location/enhanced_location_service.dart';\r\nimport '../../../../core/domain/ports/providers/location/location_providers.dart';\r\nimport 'place_details_state.dart';\r\n\r\nclass PlaceDetailsNotifier extends StateNotifier<PlaceDetailsState> {\r\n  final EnhancedLocationService _locationService;\r\n\r\n  PlaceDetailsNotifier(this._locationService)\r\n      : super(const PlaceDetailsState.initial());\r\n\r\n  Future<void> getLocationDetails(String placeId) async {\r\n    state = const PlaceDetailsState.loading();\r\n\r\n    final result = await _locationService.getPlaceDetails(placeId);\r\n\r\n    if (result.isError) {\r\n      state = PlaceDetailsState.error(\r\n          result.asError!.error.toString()\r\n      );\r\n      return;\r\n    }\r\n\r\n    state = PlaceDetailsState.loaded(result.asValue!.value);\r\n  }\r\n\r\n  Future<void> getCurrentLocation() async {\r\n    state = const PlaceDetailsState.loading();\r\n\r\n    final locationResult = await _locationService.getCurrentLocation();\r\n\r\n    if (locationResult.isError) {\r\n      state = PlaceDetailsState.error(\r\n          locationResult.asError!.error.toString()\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Pour la géolocalisation directe, on crée un PlaceDetails simplifié\r\n    // avec les coordonnées obtenues\r\n    final userLocation = locationResult.asValue!.value;\r\n    final placeDetails = PlaceDetails(\r\n      placeId: 'current_location',\r\n      formattedAddress: 'Position actuelle',\r\n      name: 'Ma position',\r\n      location: userLocation,\r\n      lastUpdated: DateTime.now(),\r\n    );\r\n\r\n    state = PlaceDetailsState.loaded(placeDetails);\r\n  }\r\n\r\n  void reset() {\r\n    state = const PlaceDetailsState.initial();\r\n  }\r\n}\r\n\r\n// Provider pour le notifier\r\nfinal placeDetailsNotifierProvider = StateNotifierProvider<PlaceDetailsNotifier, PlaceDetailsState>((ref) {\r\n  final locationService = ref.watch(enhancedLocationServiceProvider);\r\n  return PlaceDetailsNotifier(locationService);\r\n});",
      "info": {
        "size": 2190,
        "last_modified": "2025-04-16T13:25:27.7663754",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_details_state.dart",
      "content": "// lib/features/search/application/state/place_details_state.dart (précédemment selected_location_state.dart)\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../../../../core/domain/models/location/place_details.dart';\r\n\r\npart 'place_details_state.freezed.dart';\r\n\r\n@freezed\r\nclass PlaceDetailsState with _$PlaceDetailsState {\r\n  const factory PlaceDetailsState.initial() = _Initial;\r\n  const factory PlaceDetailsState.loading() = _Loading;\r\n  const factory PlaceDetailsState.loaded(PlaceDetails location) = _Loaded;\r\n  const factory PlaceDetailsState.error(String message) = _Error;\r\n}",
      "info": {
        "size": 613,
        "last_modified": "2025-04-16T13:25:27.7729582",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_details_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_details_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$PlaceDetailsState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceDetailsStateCopyWith<$Res> {\n  factory $PlaceDetailsStateCopyWith(\n          PlaceDetailsState value, $Res Function(PlaceDetailsState) then) =\n      _$PlaceDetailsStateCopyWithImpl<$Res, PlaceDetailsState>;\n}\n\n/// @nodoc\nclass _$PlaceDetailsStateCopyWithImpl<$Res, $Val extends PlaceDetailsState>\n    implements $PlaceDetailsStateCopyWith<$Res> {\n  _$PlaceDetailsStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements PlaceDetailsState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements PlaceDetailsState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadedImplCopyWith<$Res> {\n  factory _$$LoadedImplCopyWith(\n          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =\n      __$$LoadedImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({PlaceDetails location});\n\n  $PlaceDetailsCopyWith<$Res> get location;\n}\n\n/// @nodoc\nclass __$$LoadedImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$LoadedImpl>\n    implements _$$LoadedImplCopyWith<$Res> {\n  __$$LoadedImplCopyWithImpl(\n      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? location = null,\n  }) {\n    return _then(_$LoadedImpl(\n      null == location\n          ? _value.location\n          : location // ignore: cast_nullable_to_non_nullable\n              as PlaceDetails,\n    ));\n  }\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $PlaceDetailsCopyWith<$Res> get location {\n    return $PlaceDetailsCopyWith<$Res>(_value.location, (value) {\n      return _then(_value.copyWith(location: value));\n    });\n  }\n}\n\n/// @nodoc\n\nclass _$LoadedImpl implements _Loaded {\n  const _$LoadedImpl(this.location);\n\n  @override\n  final PlaceDetails location;\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.loaded(location: $location)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$LoadedImpl &&\n            (identical(other.location, location) ||\n                other.location == location));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, location);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loaded(location);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loaded?.call(location);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(location);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loaded(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loaded?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loaded implements PlaceDetailsState {\n  const factory _Loaded(final PlaceDetails location) = _$LoadedImpl;\n\n  PlaceDetails get location;\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({String message});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? message = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == message\n          ? _value.message\n          : message // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.message);\n\n  @override\n  final String message;\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.error(message: $message)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            (identical(other.message, message) || other.message == message));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, message);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return error(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return error?.call(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(message);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements PlaceDetailsState {\n  const factory _Error(final String message) = _$ErrorImpl;\n\n  String get message;\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18520,
        "last_modified": "2025-04-16T13:25:27.7789672",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_search_notifier.dart",
      "content": "// lib/features/search/application/state/place_search_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../../../core/domain/models/location/place_suggestion.dart';\r\nimport '../../../../core/domain/services/location/enhanced_location_service.dart';\r\nimport '../../../../core/domain/ports/providers/location/location_providers.dart';\r\nimport '../../../../core/common/exceptions/location_exceptions.dart';\r\nimport 'place_search_state.dart';\r\n\r\nclass PlaceSearchNotifier extends StateNotifier<PlaceSearchState> {\r\n  final EnhancedLocationService _locationService;\r\n\r\n  PlaceSearchNotifier(this._locationService)\r\n      : super(const PlaceSearchState.initial());\r\n\r\n  void searchLocation(String query) {\r\n    if (query.isEmpty) {\r\n      state = const PlaceSearchState.initial();\r\n      return;\r\n    }\r\n\r\n    if (query.length < 3) {\r\n      state = const PlaceSearchState.noResults();\r\n      return;\r\n    }\r\n\r\n    state = const PlaceSearchState.loading();\r\n\r\n    _locationService.searchPlacesWithDebounce(\r\n      query,\r\n          (Result<List<PlaceSuggestion>> result) {\r\n        if (result.isError) {\r\n          state = PlaceSearchState.error(\r\n              result.asError!.error.toString()\r\n          );\r\n          return;\r\n        }\r\n\r\n        final suggestions = result.asValue!.value;\r\n\r\n        if (suggestions.isEmpty) {\r\n          state = const PlaceSearchState.noResults();\r\n        } else {\r\n          state = PlaceSearchState.loaded(suggestions);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  void cancelSearch() {\r\n    _locationService.cancelSearch();\r\n    state = const PlaceSearchState.initial();\r\n  }\r\n\r\n  void reset() {\r\n    cancelSearch();\r\n  }\r\n}\r\n\r\n// Provider pour le notifier\r\nfinal placeSearchNotifierProvider = StateNotifierProvider<PlaceSearchNotifier, PlaceSearchState>((ref) {\r\n  final locationService = ref.watch(enhancedLocationServiceProvider);\r\n  return PlaceSearchNotifier(locationService);\r\n});",
      "info": {
        "size": 1987,
        "last_modified": "2025-04-16T13:25:27.7860215",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_search_state.dart",
      "content": "// lib/features/search/application/state/place_search_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../../../../core/domain/models/location/place_suggestion.dart';\r\n\r\npart 'place_search_state.freezed.dart';\r\n\r\n@freezed\r\nclass PlaceSearchState with _$PlaceSearchState {\r\n  const factory PlaceSearchState.initial() = _Initial;\r\n  const factory PlaceSearchState.loading() = _Loading;\r\n  const factory PlaceSearchState.loaded(List<PlaceSuggestion> suggestions) = _Loaded;\r\n  const factory PlaceSearchState.noResults() = _NoResults;\r\n  const factory PlaceSearchState.error(String message) = _Error;\r\n}",
      "info": {
        "size": 634,
        "last_modified": "2025-04-16T13:25:27.7920848",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_search_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_search_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$PlaceSearchState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceSearchStateCopyWith<$Res> {\n  factory $PlaceSearchStateCopyWith(\n          PlaceSearchState value, $Res Function(PlaceSearchState) then) =\n      _$PlaceSearchStateCopyWithImpl<$Res, PlaceSearchState>;\n}\n\n/// @nodoc\nclass _$PlaceSearchStateCopyWithImpl<$Res, $Val extends PlaceSearchState>\n    implements $PlaceSearchStateCopyWith<$Res> {\n  _$PlaceSearchStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements PlaceSearchState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements PlaceSearchState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadedImplCopyWith<$Res> {\n  factory _$$LoadedImplCopyWith(\n          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =\n      __$$LoadedImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({List<PlaceSuggestion> suggestions});\n}\n\n/// @nodoc\nclass __$$LoadedImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$LoadedImpl>\n    implements _$$LoadedImplCopyWith<$Res> {\n  __$$LoadedImplCopyWithImpl(\n      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? suggestions = null,\n  }) {\n    return _then(_$LoadedImpl(\n      null == suggestions\n          ? _value._suggestions\n          : suggestions // ignore: cast_nullable_to_non_nullable\n              as List<PlaceSuggestion>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$LoadedImpl implements _Loaded {\n  const _$LoadedImpl(final List<PlaceSuggestion> suggestions)\n      : _suggestions = suggestions;\n\n  final List<PlaceSuggestion> _suggestions;\n  @override\n  List<PlaceSuggestion> get suggestions {\n    if (_suggestions is EqualUnmodifiableListView) return _suggestions;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_suggestions);\n  }\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.loaded(suggestions: $suggestions)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$LoadedImpl &&\n            const DeepCollectionEquality()\n                .equals(other._suggestions, _suggestions));\n  }\n\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, const DeepCollectionEquality().hash(_suggestions));\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return loaded(suggestions);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return loaded?.call(suggestions);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(suggestions);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return loaded(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loaded?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loaded implements PlaceSearchState {\n  const factory _Loaded(final List<PlaceSuggestion> suggestions) = _$LoadedImpl;\n\n  List<PlaceSuggestion> get suggestions;\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$NoResultsImplCopyWith<$Res> {\n  factory _$$NoResultsImplCopyWith(\n          _$NoResultsImpl value, $Res Function(_$NoResultsImpl) then) =\n      __$$NoResultsImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$NoResultsImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$NoResultsImpl>\n    implements _$$NoResultsImplCopyWith<$Res> {\n  __$$NoResultsImplCopyWithImpl(\n      _$NoResultsImpl _value, $Res Function(_$NoResultsImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$NoResultsImpl implements _NoResults {\n  const _$NoResultsImpl();\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.noResults()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$NoResultsImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return noResults();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return noResults?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (noResults != null) {\n      return noResults();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return noResults(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return noResults?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (noResults != null) {\n      return noResults(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _NoResults implements PlaceSearchState {\n  const factory _NoResults() = _$NoResultsImpl;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({String message});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? message = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == message\n          ? _value.message\n          : message // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.message);\n\n  @override\n  final String message;\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.error(message: $message)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            (identical(other.message, message) || other.message == message));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, message);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return error(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return error?.call(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(message);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements PlaceSearchState {\n  const factory _Error(final String message) = _$ErrorImpl;\n\n  String get message;\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 23503,
        "last_modified": "2025-04-16T13:25:27.7980843",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\section_activities_provider.dart",
      "content": "// lib/features/search/application/state/section_activities_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../core/domain/models/activity/search/searchable_activity.dart';\r\nimport '../../../../core/domain/models/config/home_section_config.dart';\r\nimport '../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../state/selected_city_state.dart';\r\nimport '../../domain/providers/search_providers.dart';\r\n\r\nfinal sectionActivitiesProvider = FutureProvider.family<List<SearchableActivity>, HomeSectionConfig>((ref, section) async {\r\n  final selectedCity = ref.watch(selectedCityProvider);\r\n  if (selectedCity == null) return [];\r\n\r\n  // Utiliser les coordonnées de la ville sélectionnée et non des valeurs fixes\r\n  final latitude = selectedCity.lat;\r\n  final longitude = selectedCity.lon;\r\n\r\n  print('🔍 Recherche d\\'activités pour section: ${section.title}');\r\n  print('📍 Coordonnées utilisées: ($latitude, $longitude)');\r\n  print('🏙️ Ville: ${selectedCity.cityName}, ID: ${selectedCity.id}');\r\n\r\n  final useCase = ref.watch(searchProvidersModule.firstWhere(\r\n          (provider) => provider is Provider<GetActivitiesUseCase>\r\n  ) as Provider<GetActivitiesUseCase>);\r\n\r\n  try {\r\n    final activities = await useCase.executeQuery(\r\n        latitude: latitude,\r\n        longitude: longitude,\r\n        cityId: selectedCity.id,\r\n        queryFilter: section.queryFilter\r\n    );\r\n\r\n    print('✅ ${activities.length} activités trouvées pour la section ${section.title}');\r\n\r\n    // Cache des distances\r\n    ref.read(activityDistancesProvider.notifier).cacheDistances(\r\n        activities,\r\n        LatLng(latitude, longitude)\r\n    );\r\n\r\n    return activities;\r\n  } catch (e, stack) {\r\n    print('❌ Erreur lors de la recherche d\\'activités: $e');\r\n    print('📜 Stack trace: $stack');\r\n    return [];\r\n  }\r\n});",
      "info": {
        "size": 2053,
        "last_modified": "2025-04-16T13:25:27.8051323",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\selected_city_state.dart",
      "content": "// lib/features/search/application/state/selected_city_state.dart\r\n\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../../../core/domain/models/shared/city_model.dart';\r\n\r\nfinal selectedCityProvider = StateProvider<City?>((ref) => null);",
      "info": {
        "size": 243,
        "last_modified": "2025-04-16T13:25:27.8122688",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\selected_subcategory_state.dart",
      "content": "// lib/features/search/application/state/selected_subcategory_state.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/domain/models/shared/subcategory_model.dart';\r\n\r\nclass SelectedSubcategoryState extends StateNotifier<Subcategory?> {\r\n  SelectedSubcategoryState() : super(null);\r\n\r\n  void selectSubcategory(Subcategory? subcategory) {\r\n    state = subcategory;\r\n  }\r\n\r\n  void reset() {\r\n    state = null;\r\n  }\r\n}\r\n\r\nfinal selectedSubcategoryProvider = StateNotifierProvider<SelectedSubcategoryState, Subcategory?>((ref) {\r\n  return SelectedSubcategoryState();\r\n});",
      "info": {
        "size": 607,
        "last_modified": "2025-04-16T13:25:27.818269",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\subcategory_activities_state.dart",
      "content": "// lib/features/search/application/state/subcategory_activities_state.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../../../../core/domain/models/activity/search/searchable_activity.dart';\r\nimport '../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport '../../../../core/domain/models/config/subcategory_section_config.dart';\r\nimport '../state/selected_city_state.dart';\r\nimport '../../domain/providers/search_providers.dart';\r\nimport '../../application/state/selected_subcategory_state.dart';\r\n\r\n// Provider granulaire pour une section spécifique\r\nfinal subcategorySectionActivitiesProvider = FutureProvider.autoDispose.family<List<SearchableActivity>, SubcategorySectionConfig>(\r\n      (ref, section) async {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n    final selectedCity = ref.watch(selectedCityProvider);\r\n    if (selectedSubcategory == null || selectedCity == null) return [];\r\n\r\n    final useCase = ref.watch(searchProvidersModule.firstWhere(\r\n            (provider) => provider is Provider<GetActivitiesUseCase>\r\n    ) as Provider<GetActivitiesUseCase>);\r\n\r\n    try {\r\n      print('🔍 Loading activities for section: ${section.title}');\r\n      final activities = await useCase.executeQuery(\r\n          latitude: selectedCity.lat,\r\n          longitude: selectedCity.lon,\r\n          cityId: selectedCity.id,\r\n          queryFilter: section.queryFilter,\r\n          subcategoryId: selectedSubcategory.id\r\n      );\r\n\r\n      // Cache des distances\r\n      ref.read(activityDistancesProvider.notifier).cacheDistances(\r\n          activities,\r\n          LatLng(selectedCity.lat, selectedCity.lon)\r\n      );\r\n\r\n      print('✅ Loaded ${activities.length} activities for section ${section.title}');\r\n      return activities;\r\n    } catch (e, stack) {\r\n      print('❌ Error loading activities for section ${section.title}: $e');\r\n      print('📜 Stack trace: $stack');\r\n      return [];\r\n    }\r\n  },\r\n);\r\n\r\n// Provider principal qui combine les résultats des sections\r\nfinal subcategoryActivitiesProvider = FutureProvider.autoDispose<Map<String, List<SearchableActivity>>>((ref) async {\r\n  final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n  final selectedCity = ref.watch(selectedCityProvider);\r\n\r\n  if (selectedSubcategory == null || selectedCity == null) return {};\r\n\r\n  final sections = await ref.watch(subcategorySectionsConfigProvider(selectedSubcategory.id).future);\r\n  final results = <String, List<SearchableActivity>>{};\r\n\r\n  // Chargement parallèle des sections\r\n  await Future.wait(\r\n    sections.map((section) async {\r\n      final activities = await ref.watch(subcategorySectionActivitiesProvider(section).future);\r\n      results[section.id] = activities;\r\n    }),\r\n  );\r\n\r\n  return results;\r\n});",
      "info": {
        "size": 3061,
        "last_modified": "2025-04-16T13:25:27.8249546",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\domain\\providers\\search_providers.dart",
      "content": "// lib/features/search/domain/providers/search_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/adapters/supabase/search/activity_search_adapter.dart';\r\nimport '../../../../core/domain/ports/search/activity_search_port.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../../../../core/adapters/supabase/database_adapter.dart';\r\n\r\nfinal searchProvidersModule = <Override>[\r\n  // Providers existants\r\n  Provider<ActivitySearchPort>((ref) {\r\n    return ActivitySearchAdapter(SupabaseService.client);\r\n  }),\r\n\r\n  Provider<GetActivitiesUseCase>((ref) {\r\n    return GetActivitiesUseCase(ref.watch(\r\n      Provider<ActivitySearchPort>((ref) =>\r\n          ActivitySearchAdapter(SupabaseService.client)\r\n      ),\r\n    ));\r\n  }),\r\n];",
      "info": {
        "size": 823,
        "last_modified": "2025-04-16T13:25:27.8419848",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\pages\\subcategory_page.dart",
      "content": "// lib/features/search/presentation/pages/subcategory_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:collection/collection.dart';\r\nimport '../../../../../core/common/utils/activity_mapper.dart';\r\nimport '../../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../../core/domain/models/config/subcategory_section_config.dart';\r\nimport '../../../home/presentation/widgets/navigation/lyra_navigation.dart';\r\nimport '../../application/state/selected_subcategory_state.dart';\r\nimport '../../application/state/subcategory_activities_state.dart';\r\nimport '../../../shared_ui/presentation/widgets/shimmer/shimmer_section.dart';\r\nimport '../../../shared_ui/presentation/widgets/sections/activity_section.dart';\r\n\r\n\r\n\r\nclass SubcategoryPage extends ConsumerWidget {\r\n  const SubcategoryPage({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n    final sectionsAsync = ref.watch(subcategorySectionsConfigProvider(selectedSubcategory?.id));\r\n\r\n    return LyraNavigation(\r\n      child: sectionsAsync.when(\r\n        loading: () => _buildLoadingShimmer(),\r\n        error: (error, stack) => Center(\r\n          child: Text('Erreur de chargement des sections: $error'),\r\n        ),\r\n        data: (sections) => SingleChildScrollView(\r\n          child: Column(\r\n            children: sections\r\n                .sorted((a, b) => a.priority.compareTo(b.priority))\r\n                .map((section) => _buildSectionWithActivities(ref, section))\r\n                .toList(),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSectionWithActivities(WidgetRef ref, SubcategorySectionConfig section) {\r\n    return Consumer(\r\n      builder: (context, ref, child) {\r\n        final activitiesAsync = ref.watch(subcategorySectionActivitiesProvider(section));\r\n\r\n        return activitiesAsync.when(\r\n          loading: () => ShimmerSection(isFirstSection: false),\r\n          error: (error, stack) => const SizedBox.shrink(),\r\n          data: (activities) => ActivitySection(\r\n            title: section.title,\r\n            activities: ActivityMapper.mapToActivityCards(activities),\r\n            isFirstSection: false,\r\n          ),\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingShimmer() => Column(\r\n    children: List.generate(\r\n      3,\r\n          (index) => ShimmerSection(isFirstSection: index == 0),\r\n    ),\r\n  );\r\n}",
      "info": {
        "size": 2548,
        "last_modified": "2025-04-16T13:25:27.8585798",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\location\\current_location_button.dart",
      "content": "// lib/features/search/presentation/widgets/location/current_location_button.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\n\r\nclass CurrentLocationButton extends ConsumerWidget {\r\n  final VoidCallback? onLocationSelected;\r\n\r\n  const CurrentLocationButton({\r\n    Key? key,\r\n    this.onLocationSelected,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return InkWell(\r\n      onTap: onLocationSelected,\r\n      child: Container(\r\n        padding: const EdgeInsets.symmetric(\r\n          horizontal: 16,\r\n          vertical: 12,\r\n        ),\r\n        child: Row(\r\n          children: [\r\n            Icon(\r\n              Icons.my_location,\r\n              color: AppColors.neutral200,\r\n              size: 20,\r\n            ),\r\n            const SizedBox(width: 12),\r\n            Expanded(\r\n              child: Column(\r\n                crossAxisAlignment: CrossAxisAlignment.start,\r\n                mainAxisSize: MainAxisSize.min,\r\n                children: const [\r\n                  Text(\r\n                    'Utiliser ma position actuelle',\r\n                    style: TextStyle(\r\n                      fontSize: 15,\r\n                      fontWeight: FontWeight.w500,\r\n                    ),\r\n                  ),\r\n                  SizedBox(height: 2),\r\n                  Text(\r\n                    'Position GPS de mon appareil',\r\n                    style: TextStyle(\r\n                      fontSize: 13,\r\n                      color: Colors.grey,\r\n                    ),\r\n                  ),\r\n                ],\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1763,
        "last_modified": "2025-04-16T13:25:27.8711264",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\location\\location_search_bar.dart",
      "content": "// lib/features/search/presentation/widgets/location/location_search_bar.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../application/state/place_search_notifier.dart';\r\nimport '../../../application/state/place_search_state.dart';\r\nimport '../../../application/services/city_selection_service.dart';\r\nimport 'location_suggestions_list.dart';\r\n\r\nclass LocationSearchBar extends ConsumerStatefulWidget {\r\n  final String? initialQuery;\r\n  final Function(BuildContext)? onLocationButtonPressed;\r\n  final Function(String)? onSubmitted;\r\n\r\n  const LocationSearchBar({\r\n    Key? key,\r\n    this.initialQuery,\r\n    this.onLocationButtonPressed,\r\n    this.onSubmitted,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  ConsumerState<LocationSearchBar> createState() => _LocationSearchBarState();\r\n}\r\n\r\nclass _LocationSearchBarState extends ConsumerState<LocationSearchBar> {\r\n  late TextEditingController _textController;\r\n  final FocusNode _focusNode = FocusNode();\r\n  bool _showSuggestions = false;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _textController = TextEditingController(text: widget.initialQuery);\r\n\r\n    _focusNode.addListener(() {\r\n      if (_focusNode.hasFocus) {\r\n        setState(() {\r\n          _showSuggestions = true;\r\n        });\r\n\r\n        // Déclenche la recherche si un texte est déjà présent\r\n        if (_textController.text.isNotEmpty) {\r\n          ref.read(placeSearchNotifierProvider.notifier)\r\n              .searchLocation(_textController.text);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _textController.dispose();\r\n    _focusNode.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      mainAxisSize: MainAxisSize.min,\r\n      children: [\r\n        Container(\r\n          decoration: BoxDecoration(\r\n            color: Colors.white,\r\n            borderRadius: BorderRadius.circular(12),\r\n            boxShadow: [\r\n              BoxShadow(\r\n                color: Colors.black.withOpacity(0.1),\r\n                blurRadius: 8,\r\n                offset: const Offset(0, 2),\r\n              ),\r\n            ],\r\n          ),\r\n          child: TextField(\r\n            controller: _textController,\r\n            focusNode: _focusNode,\r\n            decoration: InputDecoration(\r\n              hintText: 'Rechercher une ville',\r\n              hintStyle: TextStyle(color: Colors.grey),\r\n              border: InputBorder.none,\r\n              contentPadding: const EdgeInsets.symmetric(\r\n                horizontal: 16,\r\n                vertical: 14,\r\n              ),\r\n              suffixIcon: Row(\r\n                mainAxisSize: MainAxisSize.min,\r\n                children: [\r\n                  // Bouton pour effacer le texte\r\n                  if (_textController.text.isNotEmpty)\r\n                    IconButton(\r\n                      icon: const Icon(Icons.clear, size: 20),\r\n                      onPressed: () {\r\n                        _textController.clear();\r\n                        ref.read(placeSearchNotifierProvider.notifier).reset();\r\n                      },\r\n                    ),\r\n                ],\r\n              ),\r\n            ),\r\n            onChanged: (value) {\r\n              ref.read(placeSearchNotifierProvider.notifier)\r\n                  .searchLocation(value);\r\n            },\r\n            onSubmitted: (value) {\r\n              if (widget.onSubmitted != null && value.isNotEmpty) {\r\n                // Nous passons l'ID de lieu au widget parent\r\n                // mais nous devons d'abord le trouver à partir de l'état\r\n                final searchState = ref.read(placeSearchNotifierProvider);\r\n                searchState.whenOrNull(\r\n                  loaded: (suggestions) {\r\n                    if (suggestions.isNotEmpty) {\r\n                      widget.onSubmitted!(suggestions.first.placeId);\r\n                    }\r\n                  },\r\n                );\r\n              }\r\n            },\r\n          ),\r\n        ),\r\n\r\n        // Liste des suggestions\r\n        if (_showSuggestions)\r\n          LocationSuggestionsList(\r\n            onSuggestionSelected: (suggestion) async {\r\n              _textController.text = suggestion.primaryText;\r\n              setState(() {\r\n                _showSuggestions = false;\r\n              });\r\n              _focusNode.unfocus();\r\n\r\n              // Utiliser le service de sélection de ville pour récupérer les détails complets\r\n              final cityService = ref.read(citySelectionServiceProvider);\r\n              final success = await cityService.selectCityByPlaceId(suggestion.placeId);\r\n\r\n              if (success && widget.onSubmitted != null) {\r\n                // Maintenant, le placeId et les coordonnées sont disponibles via le selectedCityProvider\r\n                widget.onSubmitted!(suggestion.placeId);\r\n              }\r\n            },\r\n            onOutsideTap: () {\r\n              setState(() {\r\n                _showSuggestions = false;\r\n              });\r\n              _focusNode.unfocus();\r\n            },\r\n          ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 5320,
        "last_modified": "2025-04-16T13:25:27.878189",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\location\\location_suggestions_list.dart",
      "content": "// lib/features/search/presentation/widgets/location/location_suggestions_list.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/models/location/place_suggestion.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../application/state/place_search_notifier.dart';\r\nimport '../../../application/state/place_search_state.dart';\r\n\r\nclass LocationSuggestionsList extends ConsumerWidget {\r\n  final Function(PlaceSuggestion) onSuggestionSelected;\r\n  final VoidCallback onOutsideTap;\r\n\r\n  const LocationSuggestionsList({\r\n    Key? key,\r\n    required this.onSuggestionSelected,\r\n    required this.onOutsideTap,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final searchState = ref.watch(placeSearchNotifierProvider);\r\n\r\n    return Stack(\r\n      children: [\r\n        // Zone de tap pour fermer les suggestions\r\n        Positioned.fill(\r\n          child: GestureDetector(\r\n            onTap: onOutsideTap,\r\n            behavior: HitTestBehavior.opaque,\r\n            child: Container(color: Colors.transparent),\r\n          ),\r\n        ),\r\n\r\n        // Liste des suggestions\r\n        Container(\r\n          margin: const EdgeInsets.only(top: 4),\r\n          decoration: BoxDecoration(\r\n            color: Colors.white,\r\n            borderRadius: BorderRadius.circular(8),\r\n            boxShadow: [\r\n              BoxShadow(\r\n                color: Colors.black.withOpacity(0.1),\r\n                blurRadius: 8,\r\n                offset: const Offset(0, 2),\r\n              ),\r\n            ],\r\n          ),\r\n          child: ClipRRect(\r\n            borderRadius: BorderRadius.circular(8),\r\n            child: Material(\r\n              color: Colors.transparent,\r\n              child: searchState.when(\r\n                initial: () => const SizedBox.shrink(),\r\n                loading: () => const Center(\r\n                  child: Padding(\r\n                    padding: EdgeInsets.all(16.0),\r\n                    child: CircularProgressIndicator(),\r\n                  ),\r\n                ),\r\n                loaded: (suggestions) => ListView.separated(\r\n                  shrinkWrap: true,\r\n                  padding: EdgeInsets.zero,\r\n                  itemCount: suggestions.length,\r\n                  physics: const ClampingScrollPhysics(),\r\n                  separatorBuilder: (context, index) => const Divider(height: 1),\r\n                  itemBuilder: (context, index) {\r\n                    final suggestion = suggestions[index];\r\n\r\n                    return InkWell(\r\n                      onTap: () => onSuggestionSelected(suggestion),\r\n                      child: Padding(\r\n                        padding: const EdgeInsets.symmetric(\r\n                          horizontal: 16,\r\n                          vertical: 12,\r\n                        ),\r\n                        child: Row(\r\n                          children: [\r\n                            Icon(\r\n                              suggestion.isFromCache\r\n                                  ? Icons.history\r\n                                  : Icons.location_on_outlined,\r\n                              size: 20,\r\n                              color: AppColors.accent,\r\n                            ),\r\n                            const SizedBox(width: 12),\r\n                            Expanded(\r\n                              child: Column(\r\n                                crossAxisAlignment: CrossAxisAlignment.start,\r\n                                mainAxisSize: MainAxisSize.min,\r\n                                children: [\r\n                                  Text(\r\n                                    suggestion.primaryText,\r\n                                    style: const TextStyle(\r\n                                      fontWeight: FontWeight.w500,\r\n                                    ),\r\n                                    maxLines: 1,\r\n                                    overflow: TextOverflow.ellipsis,\r\n                                  ),\r\n                                  if (suggestion.secondaryText != null)\r\n                                    Text(\r\n                                      suggestion.secondaryText!,\r\n                                      style: TextStyle(\r\n                                        color: Colors.grey[600],\r\n                                        fontSize: 13,\r\n                                      ),\r\n                                      maxLines: 1,\r\n                                      overflow: TextOverflow.ellipsis,\r\n                                    ),\r\n                                ],\r\n                              ),\r\n                            ),\r\n                          ],\r\n                        ),\r\n                      ),\r\n                    );\r\n                  },\r\n                ),\r\n                noResults: () => Padding(\r\n                  padding: const EdgeInsets.all(16.0),\r\n                  child: Center(\r\n                    child: Column(\r\n                      mainAxisSize: MainAxisSize.min,\r\n                      children: [\r\n                        Icon(Icons.search_off, color: Colors.grey[400]),\r\n                        const SizedBox(height: 8),\r\n                        Text(\r\n                          'Aucun résultat trouvé',\r\n                          style: TextStyle(color: Colors.grey[600]),\r\n                        ),\r\n                      ],\r\n                    ),\r\n                  ),\r\n                ),\r\n                error: (message) => Padding(\r\n                  padding: const EdgeInsets.all(16.0),\r\n                  child: Center(\r\n                    child: Column(\r\n                      mainAxisSize: MainAxisSize.min,\r\n                      children: [\r\n                        Icon(Icons.error_outline, color: Colors.red[400]),\r\n                        const SizedBox(height: 8),\r\n                        Text(\r\n                          'Erreur: $message',\r\n                          style: TextStyle(color: Colors.red[600]),\r\n                        ),\r\n                      ],\r\n                    ),\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 6357,
        "last_modified": "2025-04-16T13:25:27.8842249",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\subcategory_sections_view.dart",
      "content": "// lib/features/search/presentation/widgets/subcategory_sections_view.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../application/state/selected_subcategory_state.dart';\r\nimport '../../../../../core/domain/models/config/subcategory_section_config.dart';\r\nimport '../../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\n\r\nclass SubcategorySectionsView extends ConsumerWidget {\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n\r\n    return ref.watch(subcategorySectionsConfigProvider(selectedSubcategory?.id)).when(\r\n      data: (sections) => ListView.builder(\r\n        physics: const NeverScrollableScrollPhysics(),\r\n        shrinkWrap: true,\r\n        itemCount: sections.length,\r\n        itemBuilder: (context, index) {\r\n          final section = sections[index];\r\n          return _buildSection(section);\r\n        },\r\n      ),\r\n      loading: () => _buildLoadingState(),\r\n      error: (error, stack) => _buildErrorState(error),\r\n    );\r\n  }\r\n\r\n  Widget _buildErrorState(Object error) {\r\n    return Center(\r\n      child: Padding(\r\n        padding: const EdgeInsets.all(16),\r\n        child: Text(\r\n          'Erreur de chargement: $error',\r\n          style: const TextStyle(color: Colors.red),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingState() {\r\n    return Column(\r\n      children: List.generate(\r\n        3, // Nombre de sections en chargement\r\n            (index) => Padding(\r\n          padding: EdgeInsets.only(\r\n            top: index == 0 ? 8 : 24,\r\n          ),\r\n          child: _buildShimmerSection(),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSection(SubcategorySectionConfig section) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        Padding(\r\n          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n          child: Text(\r\n            section.title,\r\n            style: const TextStyle(\r\n              fontSize: 18,\r\n              fontWeight: FontWeight.bold,\r\n            ),\r\n          ),\r\n        ),\r\n        SizedBox(\r\n          height: 200,\r\n          child: ListView.builder(\r\n            scrollDirection: Axis.horizontal,\r\n            padding: const EdgeInsets.symmetric(horizontal: 8),\r\n            itemBuilder: (context, index) => Padding(\r\n              padding: const EdgeInsets.symmetric(horizontal: 8),\r\n              child: _buildLoadingCard(), // Remplacé ShimmerLoading par une méthode helper\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingCard() {\r\n    return Container(\r\n      width: 280,\r\n      decoration: BoxDecoration(\r\n        color: Colors.grey[300],\r\n        borderRadius: BorderRadius.circular(8),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildShimmerSection() {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        Padding(\r\n          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n          child: Container(\r\n            width: 150,\r\n            height: 24,\r\n            color: Colors.grey[300],\r\n          ),\r\n        ),\r\n        SizedBox(\r\n          height: 200,\r\n          child: ListView.builder(\r\n            scrollDirection: Axis.horizontal,\r\n            padding: const EdgeInsets.symmetric(horizontal: 8),\r\n            itemCount: 3,\r\n            itemBuilder: (context, index) => Padding(\r\n              padding: const EdgeInsets.symmetric(horizontal: 8),\r\n              child: _buildLoadingCard(),\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3713,
        "last_modified": "2025-04-16T13:25:27.8962643",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\pages\\activity_details_page.dart",
      "content": "// lib/features/shared_ui/presentation/pages/activity_details_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/theme/app_colors.dart';\r\nimport '../../../../core/domain/models/shared/activity_image_model.dart';\r\nimport '../../../search/application/state/activity_details_state.dart';\r\nimport '../widgets/buttons/back_button_widget.dart';\r\nimport '../widgets/carousels/activity_images_carousel.dart';\r\nimport '../widgets/activity_details/activity_details_content.dart';\r\nimport '../widgets/activity_details/sections/info_buttons_section.dart';\r\n\r\nclass ActivityDetailsPage extends ConsumerStatefulWidget {\r\n  final String activityId;\r\n  final String imageUrl;\r\n  final String title;\r\n  final VoidCallback onClose;\r\n\r\n  const ActivityDetailsPage({\r\n    super.key,\r\n    required this.activityId,\r\n    required this.imageUrl,\r\n    required this.title,\r\n    required this.onClose,\r\n  });\r\n\r\n  @override\r\n  ConsumerState<ActivityDetailsPage> createState() => _ActivityDetailsPageState();\r\n}\r\n\r\nclass _ActivityDetailsPageState extends ConsumerState<ActivityDetailsPage> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    print('ActivityDetailsPage initState for activity: ${widget.activityId}');\r\n    // Charger les détails après le build initial\r\n    Future.microtask(() {\r\n      print('Loading details in microtask for: ${widget.activityId}');\r\n      ref.read(activityDetailsProvider.notifier).loadActivityDetails(\r\n          widget.activityId);\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final detailsState = ref.watch(activityDetailsProvider);\r\n\r\n    return Scaffold(\r\n      body: CustomScrollView(\r\n        slivers: [\r\n          SliverAppBar(\r\n            expandedHeight: 300,\r\n            pinned: true,\r\n            backgroundColor: AppColors.neutral900,\r\n            flexibleSpace: FlexibleSpaceBar(\r\n              background: detailsState.when(\r\n                initial: () => Image.network(widget.imageUrl, fit: BoxFit.cover),\r\n                loading: () => const Center(child: CircularProgressIndicator()),\r\n                error: (message) => Center(child: Text('Error: $message')),\r\n                loaded: (details) => ActivityImagesCarousel(\r\n                  images: details.images ?? [\r\n                    ActivityImage(\r\n                      id: '0',\r\n                      mobileUrl: widget.imageUrl,\r\n                      isMain: true,\r\n                    )\r\n                  ],\r\n                ),\r\n              ),\r\n            ),\r\n            leading: Padding(\r\n              padding: const EdgeInsets.only(left: 16),\r\n              child: BackButtonWidget(onPressed: widget.onClose),\r\n            ),\r\n          ),\r\n          SliverToBoxAdapter(\r\n            child: detailsState.when(\r\n              initial: () => const SizedBox.shrink(),\r\n              loading: () => const Center(child: CircularProgressIndicator()),\r\n              error: (message) => Center(child: Text('Error: $message')),\r\n              loaded: (details) => ActivityDetailsContent(details: details),\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n      bottomNavigationBar: detailsState.when(\r\n        initial: () => null,\r\n        loading: () => null,\r\n        error: (_) => null,\r\n        loaded: (details) => Container(\r\n          decoration: BoxDecoration(\r\n            color: AppColors.neutral900,\r\n            boxShadow: [\r\n              BoxShadow(\r\n                color: Colors.black.withAlpha(25),\r\n                offset: const Offset(0, -2),\r\n                blurRadius: 4,\r\n              ),\r\n            ],\r\n          ),\r\n          child: SafeArea(\r\n            child: InfoButtonsSection(details: details),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3806,
        "last_modified": "2025-04-16T13:25:27.918456",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\activity_details_content.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/activity_details_content.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport 'sections/title_section.dart';\r\nimport 'sections/location_section.dart';\r\nimport 'sections/info_icons_section.dart';\r\nimport 'sections/schedule_section.dart';\r\nimport 'sections/description_section.dart';\r\n\r\n\r\nclass ActivityDetailsContent extends StatelessWidget {\r\n  final ActivityDetails details;\r\n  final double? distance;\r\n\r\n\r\n  const ActivityDetailsContent({\r\n    super.key,\r\n    required this.details,\r\n    this.distance,\r\n  });\r\n// Dans activity_details_content.dart :\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Padding(\r\n      padding: const EdgeInsets.fromLTRB(20, 32, 20, 20),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          // Barre de poignée optionnelle pour indiquer que c'est scrollable\r\n          Center(\r\n            child: Container(\r\n              width: 40,\r\n              height: 4,\r\n              margin: const EdgeInsets.only(bottom: 24),\r\n              decoration: BoxDecoration(\r\n                color: Colors.grey.withOpacity(0.3),\r\n                borderRadius: BorderRadius.circular(2),\r\n              ),\r\n            ),\r\n          ),\r\n          TitleSection(details: details),\r\n          const SizedBox(height: 12),\r\n          LocationSection(details: details, distance: distance),\r\n          const SizedBox(height: 12),\r\n          InfoIconsSection(details: details),\r\n          const SizedBox(height: 16),\r\n          ScheduleSection(details: details),\r\n          const SizedBox(height: 16),\r\n          DescriptionSection(details: details),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1817,
        "last_modified": "2025-04-16T13:25:27.9320423",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\description_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/description_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass DescriptionSection extends StatefulWidget {\r\n  final ActivityDetails details;\r\n\r\n  const DescriptionSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  State<DescriptionSection> createState() => _DescriptionSectionState();\r\n}\r\n\r\nclass _DescriptionSectionState extends State<DescriptionSection> {\r\n  bool _isExpanded = false;\r\n  static const int _maxLines = 5;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (widget.details.description == null || widget.details.description!.isEmpty) {\r\n      return const SizedBox.shrink();\r\n    }\r\n\r\n    return Container(\r\n      padding: const EdgeInsets.symmetric(horizontal: 20),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Text(\r\n            widget.details.description!,\r\n            style: context.bodyMedium,\r\n            maxLines: _isExpanded ? null : _maxLines,\r\n            overflow: _isExpanded ? null : TextOverflow.ellipsis,\r\n          ),\r\n          if (_shouldShowReadMore())\r\n            Padding(\r\n              padding: const EdgeInsets.only(top: 8),\r\n              child: GestureDetector(\r\n                onTap: () => setState(() => _isExpanded = !_isExpanded),\r\n                child: Text(\r\n                  _isExpanded ? 'Voir moins' : 'Lire la suite',\r\n                  style: context.bodyMedium.copyWith(\r\n                    color: AppColors.accent,\r\n                    fontWeight: FontWeight.w600,\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  bool _shouldShowReadMore() {\r\n    final TextPainter textPainter = TextPainter(\r\n      text: TextSpan(\r\n        text: widget.details.description,\r\n        style: context.bodyMedium,\r\n      ),\r\n      maxLines: _maxLines,\r\n      textDirection: TextDirection.ltr,\r\n    )..layout(maxWidth: MediaQuery.of(context).size.width - 40);\r\n\r\n    return textPainter.didExceedMaxLines;\r\n  }\r\n}",
      "info": {
        "size": 2309,
        "last_modified": "2025-04-16T13:25:27.938045",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\info_buttons_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/info_buttons_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../../core/theme/app_interactions.dart';\r\nimport '../../../../../../core/domain/services/shared/external_launcher_service.dart';\r\n\r\nclass InfoButtonsSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const InfoButtonsSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return ClipRect(  // Empêche l'onde de déborder du footer\r\n        child: Container(\r\n        padding: const EdgeInsets.symmetric(horizontal: 20),\r\n    child: Row(\r\n    mainAxisAlignment: MainAxisAlignment.spaceAround,\r\n    children: [\r\n          _buildInfoButton(\r\n            context,\r\n            icon: details.googlePlaceId != null && details.googlePlaceId!.isNotEmpty\r\n                ? LucideIcons.map  // Icône pour voir la fiche Google Maps\r\n                : LucideIcons.navigation2,  // Icône pour l'itinéraire\r\n            label: details.googlePlaceId != null && details.googlePlaceId!.isNotEmpty\r\n                ? 'Fiche Maps'\r\n                : 'Itinéraire',\r\n            onTap: () => _onNavigationTap(context),\r\n          ),\r\n          _buildInfoButton(\r\n            context,\r\n            icon: LucideIcons.phone,\r\n            label: 'Appeler',\r\n            onTap: details.contactPhone != null\r\n                ? () => _onPhoneTap(context, details.contactPhone!)\r\n                : null,\r\n          ),\r\n          _buildInfoButton(\r\n            context,\r\n            icon: LucideIcons.globe,\r\n            label: 'Site web',\r\n            onTap: details.contactWebsite != null\r\n                ? () => _onWebsiteTap(context, details.contactWebsite!)\r\n                : null,\r\n          ),\r\n        ],\r\n      ),\r\n        ),\r\n    );\r\n  }\r\n\r\n  Widget _buildInfoButton(\r\n      BuildContext context, {\r\n        required IconData icon,\r\n        required String label,\r\n        VoidCallback? onTap,\r\n      }) {\r\n    final content = Padding(\r\n      padding: const EdgeInsets.all(8.0),\r\n      child: Column(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: [\r\n          Icon(\r\n            icon,\r\n            color: AppColors.neutral200,\r\n            size: 24,\r\n          ),\r\n          const SizedBox(height: 4),\r\n          Text(\r\n            label,\r\n            style: context.bodyMedium.copyWith(\r\n              color: AppColors.neutral200,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n\r\n    return AppInteractions.addCircularRipple(\r\n      onTap: onTap,\r\n      rippleColor: AppColors.neutral200,\r\n      child: Opacity(\r\n        opacity: onTap != null ? 1.0 : 0.5,\r\n        child: content,\r\n      ),\r\n    );\r\n  }\r\n\r\n  void _showError(BuildContext context, String message) {\r\n    ScaffoldMessenger.of(context).showSnackBar(\r\n      SnackBar(\r\n        content: Text(message),\r\n        backgroundColor: AppColors.warning,\r\n        behavior: SnackBarBehavior.floating,\r\n        margin: const EdgeInsets.all(8),\r\n        duration: const Duration(seconds: 3),\r\n      ),\r\n    );\r\n  }\r\n\r\n  void _onNavigationTap(BuildContext context) async {\r\n    try {\r\n      await ExternalLauncherService.openMap(\r\n        details.latitude,\r\n        details.longitude,\r\n        details.name,\r\n        context,\r\n        placeId: details.googlePlaceId,\r\n      );\r\n    } catch (e) {\r\n      _showError(context, e.toString());\r\n    }\r\n  }\r\n\r\n  Future<void> _onPhoneTap(BuildContext context, String phone) async {\r\n    try {\r\n      await ExternalLauncherService.openPhone(phone);\r\n    } catch (e) {\r\n      _showError(context, e.toString());\r\n    }\r\n  }\r\n\r\n\r\n  Future<void> _onWebsiteTap(BuildContext context, String website) async {\r\n    try {\r\n      await ExternalLauncherService.openCustomTab(context, website);\r\n    } catch (e) {\r\n      _showError(context, e.toString());\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 4168,
        "last_modified": "2025-04-16T13:25:27.9440823",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\info_icons_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/info_icons_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\n\r\nclass InfoIconsSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const InfoIconsSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    print('Details: kidFriendly=${details.kidFriendly}, wheelchairAccessible=${details.wheelchairAccessible}, bookingRequired=${details.bookingRequired}');\r\n\r\n\r\n    final List<Widget> icons = [];\r\n\r\n    if (details.kidFriendly ?? false) {\r\n      icons.add(\r\n        buildInfoIcon(\r\n          context,\r\n          icon: LucideIcons.baby,\r\n          tooltip: 'Adapté aux enfants',\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (details.wheelchairAccessible != null) {\r\n      icons.add(\r\n        buildInfoIcon(\r\n          context,\r\n          icon: LucideIcons.accessibility,\r\n          tooltip: 'Accessible PMR',\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (details.bookingRequired ?? false) {\r\n      icons.add(\r\n        buildInfoIcon(\r\n          context,\r\n          icon: LucideIcons.calendar,\r\n          tooltip: 'Réservation requise',\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (icons.isEmpty) return const SizedBox.shrink();\r\n\r\n    return Padding(\r\n      padding: const EdgeInsets.symmetric(vertical: 8),\r\n      child: Row(\r\n        children: icons.map((icon) => Padding(\r\n          padding: const EdgeInsets.only(right: 16),\r\n          child: icon,\r\n        )).toList(),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget buildInfoIcon(\r\n      BuildContext context, {\r\n        required IconData icon,\r\n        required String tooltip,\r\n      }) {\r\n    return GestureDetector(\r\n      onTap: () {\r\n        final overlay = OverlayEntry(\r\n          builder: (context) => Positioned(\r\n            top: MediaQuery.of(context).size.height / 2,\r\n            left: MediaQuery.of(context).size.width / 4,\r\n            child: Material(\r\n              color: Colors.transparent,\r\n              child: Container(\r\n                padding: const EdgeInsets.symmetric(\r\n                  horizontal: 16,\r\n                  vertical: 8,\r\n                ),\r\n                decoration: BoxDecoration(\r\n                  color: AppColors.neutral900,\r\n                  borderRadius: BorderRadius.circular(8),\r\n                  boxShadow: [\r\n                    BoxShadow(\r\n                      color: Colors.black.withAlpha(25),\r\n                      blurRadius: 4,\r\n                    ),\r\n                  ],\r\n                ),\r\n                child: Text(\r\n                  tooltip,\r\n                  style: TextStyle(\r\n                    color: AppColors.neutral200,\r\n                    fontSize: 14,\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        );\r\n\r\n        Overlay.of(context).insert(overlay);\r\n        Future.delayed(const Duration(seconds: 4), () {\r\n          overlay.remove();\r\n        });\r\n      },\r\n      child: Column(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: [\r\n          Icon(\r\n            icon,\r\n            size: 24,\r\n            color: AppColors.neutral200,\r\n          ),\r\n          const SizedBox(height: 4),\r\n          Text(\r\n            tooltip,\r\n            style: const TextStyle(\r\n              color: AppColors.neutral200,\r\n              fontSize: 10,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3633,
        "last_modified": "2025-04-16T13:25:27.9511214",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\location_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/location_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass LocationSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n  final double? distance;\r\n\r\n  const LocationSection({\r\n    super.key,\r\n    required this.details,\r\n    this.distance,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      padding: const EdgeInsets.symmetric(horizontal: 20),\r\n      child: Row(\r\n        children: [\r\n          const Icon(\r\n            LucideIcons.mapPin,\r\n            size: 20,\r\n            color: AppColors.neutral200,\r\n          ),\r\n          const SizedBox(width: 8),\r\n          Expanded(\r\n            child: Column(\r\n              crossAxisAlignment: CrossAxisAlignment.start,\r\n              children: [\r\n                if (details.address != null)\r\n                  Text(\r\n                    _buildFullAddress(),\r\n                    style: const TextStyle(\r\n                      fontSize: 16,\r\n                      color: AppColors.neutral200,\r\n                    ),\r\n                  ),\r\n                if (distance != null)\r\n                  Text(\r\n                    distance! / 1000 <= 100\r\n                        ? '~${((distance! / 1000 / 10).round() * 10)} km'\r\n                        : '~${((distance! / 1000 / 50).round() * 50)} km',\r\n                    style: context.bodyMedium,\r\n                  ),\r\n              ],\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  String _buildFullAddress() {\r\n\r\n    final List<String> addressParts = [];\r\n\r\n    if (details.address != null && details.address!.isNotEmpty) {\r\n      addressParts.add(details.address!);\r\n    }\r\n    if (details.postalCode != null && details.postalCode!.isNotEmpty) {\r\n      addressParts.add(details.postalCode!);\r\n    }\r\n    if (details.city != null && details.city!.isNotEmpty) {\r\n      addressParts.add(details.city!);\r\n    }\r\n\r\n    return addressParts.join(', ');\r\n  }\r\n}",
      "info": {
        "size": 2270,
        "last_modified": "2025-04-16T13:25:27.9571559",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\schedule_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/schedule_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass OpeningHours {\r\n  final String open;\r\n  final String close;\r\n\r\n  OpeningHours({required this.open, required this.close});\r\n\r\n  factory OpeningHours.fromJson(Map<String, dynamic> json) {\r\n    return OpeningHours(\r\n      open: json['open'] as String,\r\n      close: json['close'] as String,\r\n    );\r\n  }\r\n}\r\n\r\nfinal Map<String, String> _daysInFrench = {\r\n  'monday': 'Lundi',\r\n  'tuesday': 'Mardi',\r\n  'wednesday': 'Mercredi',\r\n  'thursday': 'Jeudi',\r\n  'friday': 'Vendredi',\r\n  'saturday': 'Samedi',\r\n  'sunday': 'Dimanche',\r\n};\r\n\r\nclass ScheduleSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const ScheduleSection({super.key, required this.details});\r\n\r\n  List<Widget> _buildOpeningHours(Map<String, dynamic> hours) {\r\n    final List<Widget> scheduleWidgets = [];\r\n\r\n    _daysInFrench.forEach((dayEn, dayFr) {\r\n      if (hours.containsKey(dayEn)) {\r\n        final List<dynamic> dayHours = hours[dayEn] as List<dynamic>;\r\n        if (dayHours.isNotEmpty) {\r\n          // Gérer le cas où il y a plusieurs horaires dans une journée\r\n          for (var hour in dayHours) {\r\n            final openingHours = OpeningHours.fromJson(hour as Map<String, dynamic>);\r\n            scheduleWidgets.add(\r\n              Padding(\r\n                padding: const EdgeInsets.only(bottom: 8),\r\n                child: Row(\r\n                  children: [\r\n                    SizedBox(\r\n                      width: 100,\r\n                      child: Text(\r\n                        dayFr,\r\n                        style: const TextStyle(\r\n                          color: AppColors.neutral200,\r\n                          fontWeight: FontWeight.w500,\r\n                        ),\r\n                      ),\r\n                    ),\r\n                    Text(\r\n                      '${openingHours.open} - ${openingHours.close}',\r\n                      style: const TextStyle(\r\n                        color: AppColors.neutral200,\r\n                      ),\r\n                    ),\r\n                  ],\r\n                ),\r\n              ),\r\n            );\r\n          }\r\n        } else {\r\n          scheduleWidgets.add(\r\n            Padding(\r\n              padding: const EdgeInsets.only(bottom: 8),\r\n              child: Row(\r\n                children: [\r\n                  SizedBox( // On utilise un SizedBox pour garder l'alignement\r\n                    width: 100,\r\n                    child: Text( // On affiche le jour en français\r\n                      dayFr,\r\n                      style: const TextStyle(\r\n                        color: AppColors.neutral200,\r\n                        fontWeight: FontWeight.w500,\r\n                      ),\r\n                    ),\r\n                  ),\r\n                  const Text(\r\n                    'Fermé',\r\n                    style: TextStyle(\r\n                      color: AppColors.neutral200,\r\n                      fontStyle: FontStyle.italic,\r\n                    ),\r\n                  ),\r\n                ],\r\n              ),\r\n            ),\r\n          );\r\n        }\r\n      }\r\n    });\r\n\r\n    return scheduleWidgets;\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (details.currentOpeningHours == null || details.currentOpeningHours!.isEmpty) {\r\n      return const SizedBox.shrink();\r\n    }\r\n\r\n    return Container(\r\n      padding: const EdgeInsets.symmetric(horizontal: 20),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Row(\r\n            children: [\r\n              const Icon(\r\n                LucideIcons.clock,\r\n                color: AppColors.neutral200,\r\n                size: 20,\r\n              ),\r\n              const SizedBox(width: 8),\r\n              Text(\r\n                'Horaires d\\'ouverture',\r\n                style: context.bodyMedium,\r\n              ),\r\n            ],\r\n          ),\r\n          const SizedBox(height: 12),\r\n          ..._buildOpeningHours(details.currentOpeningHours!),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4381,
        "last_modified": "2025-04-16T13:25:27.9631871",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\title_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/title_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass TitleSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const TitleSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      width: double.infinity,\r\n      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),\r\n      child: Text(\r\n        details.name,\r\n        style: context.bodyMedium,\r\n        maxLines: 2,\r\n        overflow: TextOverflow.ellipsis,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 788,
        "last_modified": "2025-04-16T13:25:27.9702095",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\atoms.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/atoms.dart\r\n\r\n/// Fichier d'exportation regroupant tous les composants atomiques\r\n///\r\n/// Les atomes sont les composants les plus simples et fondamentaux du design system,\r\n/// qui ne peuvent pas être décomposés davantage.\r\n\r\nexport '../../../../core/theme/atoms/app_button.dart';\r\nexport '../../../../core/theme/atoms/app_text.dart';\r\nexport '../../../../core/theme/atoms/app_input.dart';\r\nexport '../../../../core/theme/atoms/app_card.dart';",
      "info": {
        "size": 494,
        "last_modified": "2025-04-16T13:25:27.9873034",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\buttons\\back_button_widget.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/buttons/back_button_widget.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\n\r\nclass BackButtonWidget extends StatelessWidget {\r\n  final VoidCallback onPressed;\r\n  final double size;\r\n  final EdgeInsets padding;\r\n\r\n  const BackButtonWidget({\r\n    super.key,\r\n    required this.onPressed,\r\n    this.size = 40,\r\n    this.padding = const EdgeInsets.all(8),\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      decoration: BoxDecoration(\r\n        color: Colors.white,\r\n        shape: BoxShape.circle,\r\n        boxShadow: [\r\n          BoxShadow(\r\n            color: Colors.black.withOpacity(0.1),\r\n            blurRadius: 8,\r\n            offset: const Offset(0, 2),\r\n          ),\r\n        ],\r\n      ),\r\n      child: Material(\r\n        color: Colors.transparent,\r\n        child: InkWell(\r\n          onTap: onPressed,\r\n          customBorder: const CircleBorder(),\r\n          child: Padding(\r\n            padding: padding,\r\n            child: Icon(\r\n              LucideIcons.arrowLeft,\r\n              size: size * 0.5,\r\n              color: AppColors.neutral900,\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1369,
        "last_modified": "2025-04-16T13:25:27.993341",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_card.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_card.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport 'activity_card_info.dart';\r\nimport 'activity_card_image.dart';\r\n\r\nclass ActivityCard extends StatelessWidget {\r\n  final String imageUrl;\r\n  final String title;\r\n  final String city;\r\n  final String category;\r\n  final IconData categoryIcon;\r\n  final String activityId;\r\n  final double activityLat;\r\n  final double activityLng;\r\n  final double userLat;\r\n  final double userLng;\r\n  final double? distance;\r\n  final DateTime? date;\r\n  final bool isFavorite;\r\n  final VoidCallback? onTap;\r\n  final VoidCallback? onFavoritePress;\r\n\r\n  const ActivityCard({\r\n    super.key,\r\n    required this.imageUrl,\r\n    required this.title,\r\n    required this.city,\r\n    required this.category,\r\n    required this.categoryIcon,\r\n    required this.activityId,\r\n    required this.activityLat,\r\n    required this.activityLng,\r\n    required this.userLat,\r\n    required this.userLng,\r\n    this.distance,\r\n    this.date,\r\n    this.isFavorite = false,\r\n    this.onTap,\r\n    this.onFavoritePress,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: onTap,\r\n      child: Container(\r\n        width: AppDimensions.space32 * 5,\r\n        height: AppDimensions.space32 * 7,\r\n        clipBehavior: Clip.hardEdge,\r\n        decoration: BoxDecoration(\r\n          borderRadius: BorderRadius.circular(AppDimensions.radiusM),\r\n        ),\r\n        child: Column(\r\n          children: [\r\n            // Image section (55% de la hauteur)\r\n            SizedBox(\r\n              height: AppDimensions.space32 * 3,\r\n              child: Stack(\r\n                fit: StackFit.expand,\r\n                children: [\r\n                  ActivityCardImage(imageUrl: imageUrl,title: title,),\r\n                  Positioned(\r\n                    top: AppDimensions.space3,\r\n                    right: AppDimensions.space3,\r\n                    child: _ActivityFavoriteButton(\r\n                      isFavorite: isFavorite,\r\n                      onPressed: onFavoritePress,\r\n                    ),\r\n                  ),\r\n                ],\r\n              ),\r\n            ),\r\n            // Info section (45% de la hauteur)\r\n            SizedBox(\r\n              height: AppDimensions.space32  * 0.25,\r\n              child: Consumer(\r\n                builder: (context, ref, child) {\r\n                  final calculatedDistance = ref.watch(activityDistancesProvider)[activityId];\r\n                  return ActivityCardInfo(\r\n                    category: category,\r\n                    categoryIcon: categoryIcon,\r\n                    city: city,\r\n                    calculatedDistance: calculatedDistance ?? distance,\r\n                    date: date,\r\n                  );\r\n                },\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _ActivityFavoriteButton extends StatelessWidget {\r\n  final bool isFavorite;\r\n  final VoidCallback? onPressed;\r\n\r\n  const _ActivityFavoriteButton({\r\n    required this.isFavorite,\r\n    this.onPressed,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return IconButton(\r\n      icon: Icon(\r\n        isFavorite ? Icons.favorite : Icons.favorite_border,\r\n        color: isFavorite ? AppColors.accent : Colors.white,\r\n      ),\r\n      onPressed: onPressed,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3650,
        "last_modified": "2025-04-16T13:25:28.0043744",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_card_image.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_card_image.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:cached_network_image/cached_network_image.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_filters.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\n\r\n\r\nclass ActivityCardImage extends StatelessWidget {\r\n  final String imageUrl;\r\n  final String title;\r\n\r\n  const ActivityCardImage({\r\n    super.key,\r\n    required this.imageUrl,\r\n    required this.title,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (imageUrl.isEmpty) {\r\n      return const _EmptyImagePlaceholder();\r\n    }\r\n\r\n    return ColorFiltered(\r\n      colorFilter: AppFilters.desaturate,\r\n      child: Stack(\r\n        fit: StackFit.expand,\r\n        children: [\r\n          CachedNetworkImage(\r\n            imageUrl: imageUrl,\r\n            fit: BoxFit.cover,\r\n            memCacheWidth: 600,\r\n            memCacheHeight: 480,\r\n            maxWidthDiskCache: 1200,\r\n            errorWidget: (context, error, stackTrace) {\r\n              print('DEBUG: Erreur de chargement image: $error');\r\n              return const _ErrorImagePlaceholder();\r\n            },\r\n            placeholder: (context, url) => const _LoadingImagePlaceholder(),\r\n            fadeInDuration: const Duration(milliseconds: 300),\r\n            fadeOutDuration: const Duration(milliseconds: 300),\r\n          ),\r\n          Container(\r\n            color: AppFilters.beigeOverlay,\r\n          ),\r\n          Positioned(\r\n            left: 12,\r\n            bottom: 8,\r\n            right: 12,\r\n            child: Text(\r\n              title,\r\n              style: context.titleMedium.copyWith(\r\n                shadows: [\r\n                  const Shadow(\r\n                    offset: Offset(0, 0),\r\n                    blurRadius: 75.0,\r\n                    color: Color.fromRGBO(0, 0, 0, 0.85),\r\n                  ),\r\n                ],\r\n              ),\r\n              maxLines: 2,\r\n              overflow: TextOverflow.ellipsis,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _EmptyImagePlaceholder extends StatelessWidget {\r\n  const _EmptyImagePlaceholder();\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: Colors.grey,\r\n      child: const Center(\r\n        child: Icon(Icons.image_not_supported),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _ErrorImagePlaceholder extends StatelessWidget {\r\n  const _ErrorImagePlaceholder();\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: Colors.grey,\r\n      child: const Center(\r\n        child: Icon(Icons.error),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _LoadingImagePlaceholder extends StatelessWidget {\r\n  const _LoadingImagePlaceholder();\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: AppColors.neutral900.withOpacity(0.1),\r\n      child: const Center(\r\n        child: CircularProgressIndicator(\r\n          strokeWidth: 2,\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3094,
        "last_modified": "2025-04-16T13:25:28.0114036",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_card_info.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_card_info.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\n\r\nclass ActivityCardInfo extends StatelessWidget {\r\n  final String category;\r\n  final IconData categoryIcon;\r\n  final String city;\r\n  final double? calculatedDistance;\r\n  final DateTime? date;\r\n\r\n  const ActivityCardInfo({\r\n    super.key,\r\n    required this.category,\r\n    required this.categoryIcon,\r\n    required this.city,\r\n    this.calculatedDistance,\r\n    this.date,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: AppColors.neutral800,\r\n      padding: const EdgeInsets.all(12),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\r\n        children: [\r\n          Row(\r\n            children: [\r\n              Icon(\r\n                  categoryIcon,\r\n                  size: 16,\r\n                  color: Colors.white\r\n              ),\r\n              const SizedBox(width: 4),\r\n              Text(\r\n                category,\r\n                style: context.titleSmall,\r\n              ),\r\n              const Spacer(),\r\n              if (date != null)\r\n                Text(\r\n                  _formatDate(date!),\r\n                  style: context.titleSmall,\r\n                )\r\n              else if (calculatedDistance != null) ...[\r\n                Text(\r\n                  calculatedDistance! / 1000 <= 100\r\n                      ? '~${((calculatedDistance! / 1000 / 10).round() * 10)} km'\r\n                      : '~${((calculatedDistance! / 1000 / 50).round() * 50)} km',\r\n                  style: context.bodySmall,\r\n                ),\r\n              ],\r\n            ],\r\n          ),\r\n          const SizedBox(height: 4),\r\n          Row(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              const SizedBox(width: 8),\r\n              Text(\r\n                _formatCity(city),\r\n                style: context.bodyMedium,\r\n                maxLines: 1,\r\n              ),\r\n            ],\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  String _formatCity(String city) {\r\n    return city.length > 15 ? '${city.substring(0, 15)}...' : city;\r\n  }\r\n\r\n  String _formatDate(DateTime date) {\r\n    return '${date.day}/${date.month}/${date.year}';\r\n  }\r\n}",
      "info": {
        "size": 2467,
        "last_modified": "2025-04-16T13:25:28.0174039",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_container.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_container.dart\r\n\r\nimport 'package:animations/animations.dart';\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport 'activity_card.dart';\r\nimport '../../pages/activity_details_page.dart';\r\nimport '../../../../home/presentation/widgets/navigation/lyra_navigation.dart';\r\n\r\nclass ActivityContainer extends ConsumerWidget {\r\n  static const _transitionDuration = Duration(milliseconds: 350);\r\n  static const _closedElevation = 0.0;\r\n\r\n  final ActivityCard card;\r\n  final bool headerVisible;\r\n  final VoidCallback? onHeaderVisibilityChanged;\r\n\r\n  const ActivityContainer({\r\n    super.key,\r\n    required this.card,\r\n    this.headerVisible = true,\r\n    this.onHeaderVisibilityChanged,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return OpenContainer(\r\n      transitionDuration: _transitionDuration,\r\n      transitionType: ContainerTransitionType.fadeThrough,\r\n      openBuilder: (context, closeContainer) {\r\n        // On enlève la modification directe du state ici\r\n        return WillPopScope(\r\n          onWillPop: () async {\r\n            ref.read(headerVisibilityProvider.notifier).state = true;\r\n            closeContainer();\r\n            return false;\r\n          },\r\n          child: ActivityDetailsPage(\r\n            activityId: card.activityId,\r\n            imageUrl: card.imageUrl,\r\n            title: card.title,\r\n            onClose: () {\r\n              closeContainer();\r\n              // Délai avant de réafficher le header\r\n              Future.delayed(\r\n                const Duration(milliseconds: 200), // Démarre après la moitié de l'animation de la card\r\n                    () => ref.read(headerVisibilityProvider.notifier).state = true,\r\n              );\r\n            },\r\n          ),\r\n        );\r\n      },\r\n      closedBuilder: (context, openContainer) {\r\n        return MouseRegion(\r\n          cursor: SystemMouseCursors.click,\r\n          child: GestureDetector(\r\n            behavior: HitTestBehavior.opaque,\r\n            onTap: () {\r\n              // On déplace la modification du state dans le onTap\r\n              ref.read(headerVisibilityProvider.notifier).state = false;\r\n              onHeaderVisibilityChanged?.call();\r\n              openContainer();\r\n            },\r\n            child: card,\r\n          ),\r\n        );\r\n      },\r\n      closedShape: RoundedRectangleBorder(\r\n        borderRadius: BorderRadius.circular(AppDimensions.radiusM),\r\n      ),\r\n      openShape: const RoundedRectangleBorder(),\r\n      closedElevation: _closedElevation,\r\n      closedColor: Colors.transparent,\r\n      middleColor: Colors.transparent,\r\n      openColor: Colors.transparent,\r\n      useRootNavigator: true,\r\n      clipBehavior: Clip.antiAlias,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2887,
        "last_modified": "2025-04-16T13:25:28.0240554",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\carousels\\activity_images_carousel.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/carousels/activity_images_carousel.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:cached_network_image/cached_network_image.dart';\r\nimport '../../../../../core/domain/models/shared/activity_image_model.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\n\r\nclass ActivityImagesCarousel extends StatefulWidget {\r\n  final List<ActivityImage> images;\r\n  final double height;\r\n\r\n  const ActivityImagesCarousel({\r\n    super.key,\r\n    required this.images,\r\n    this.height = 300,\r\n  });\r\n\r\n  @override\r\n  State<ActivityImagesCarousel> createState() => _ActivityImagesCarouselState();\r\n}\r\n\r\nclass _ActivityImagesCarouselState extends State<ActivityImagesCarousel> {\r\n  late final PageController _pageController;\r\n  int _currentPage = 0;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _pageController = PageController();\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _pageController.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Stack(\r\n      children: [\r\n        // PageView avec les images\r\n        PageView.builder(\r\n          controller: _pageController,\r\n          onPageChanged: (index) {\r\n            setState(() => _currentPage = index);\r\n          },\r\n          itemCount: widget.images.length,\r\n          itemBuilder: (context, index) {\r\n            return CachedNetworkImage(\r\n              imageUrl: widget.images[index].mobileUrl ?? '',\r\n              fit: BoxFit.cover,\r\n              errorWidget: (context, url, error) => Container(\r\n                color: AppColors.neutral900.withAlpha(25),\r\n                child: const Icon(Icons.error),\r\n              ),\r\n            );\r\n          },\r\n        ),\r\n\r\n        // Indicateurs de page sur l'image\r\n        if (widget.images.length > 1)\r\n          Positioned(\r\n            bottom: 16,\r\n            left: 0,\r\n            right: 0,\r\n            child: Row(\r\n              mainAxisAlignment: MainAxisAlignment.center,\r\n              children: List.generate(\r\n                widget.images.length,\r\n                    (index) => Padding(\r\n                  padding: const EdgeInsets.symmetric(horizontal: 4),\r\n                  child: CircleAvatar(\r\n                    radius: 4,\r\n                    backgroundColor: _currentPage == index\r\n                        ? Colors.white\r\n                        : Colors.white.withAlpha(128),\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2570,
        "last_modified": "2025-04-16T13:25:28.0365699",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\index.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/index.dart\r\n\r\n/// Fichier d'exportation pour faciliter l'import des widgets partagés\r\n///\r\n/// Permet d'importer tous les widgets ou une catégorie spécifique en une seule ligne:\r\n/// ```dart\r\n/// import 'package:lyra/shared/widgets/index.dart'; // Tout importer\r\n/// // ou\r\n/// import 'package:lyra/shared/widgets/atoms.dart'; // Importer seulement les atomes\r\n/// ```\r\n\r\n// Exportation par catégorie\r\nexport 'atoms.dart';\r\nexport 'molecules.dart';\r\nexport 'organisms.dart';\r\nexport 'templates.dart';\r\n\r\n// Exportation directe des widgets individuels pour simplifier l'accès\r\n// Atomes\r\nexport '../../../../core/theme/atoms/app_button.dart';\r\nexport '../../../../core/theme/atoms/app_text.dart';\r\nexport '../../../../core/theme/atoms/app_input.dart';\r\nexport '../../../../core/theme/atoms/app_card.dart';\r\n\r\n// Molécules\r\nexport 'molecules/filter_chip.dart';\r\n\r\n// Organismes\r\n\r\n\r\n// Templates\r\n",
      "info": {
        "size": 948,
        "last_modified": "2025-04-16T13:25:28.0480863",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\molecules\\filter_chip.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/molecules/filter_chip.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/theme/app_interactions.dart';\r\n\r\n/// Types de puces disponibles\r\nenum FilterChipType {\r\n  standard,       // Puce standard\r\n  choice,         // Puce de choix (une seule sélectionnable à la fois)\r\n  action,         // Puce d'action (déclenche une action)\r\n  category,       // Puce de catégorie (avec couleur personnalisée)\r\n}\r\n\r\n/// Puce de filtre réutilisable pour l'application\r\n///\r\n/// Composant moléculaire permettant à l'utilisateur de filtrer des contenus\r\n/// ou de faire des sélections.\r\nclass AppFilterChip extends StatelessWidget {\r\n  /// Libellé de la puce\r\n  final String label;\r\n\r\n  /// Si la puce est sélectionnée\r\n  final bool selected;\r\n\r\n  /// Type de puce\r\n  final FilterChipType type;\r\n\r\n  /// Fonction appelée quand la puce est pressée\r\n  final VoidCallback? onPressed;\r\n\r\n  /// Icône à afficher à gauche (optionnel)\r\n  final IconData? icon;\r\n\r\n  /// Couleur personnalisée de la puce\r\n  final Color? color;\r\n\r\n  /// Si la puce est désactivée\r\n  final bool disabled;\r\n\r\n  /// Si la puce doit avoir une ombre\r\n  final bool hasShadow;\r\n\r\n  /// Marges externes\r\n  final EdgeInsets? margin;\r\n\r\n  const AppFilterChip({\r\n    Key? key,\r\n    required this.label,\r\n    this.selected = false,\r\n    this.type = FilterChipType.standard,\r\n    this.onPressed,\r\n    this.icon,\r\n    this.color,\r\n    this.disabled = false,\r\n    this.hasShadow = false,\r\n    this.margin,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Déterminer la couleur principale de la puce\r\n    Color chipColor = color ?? colorScheme.primary;\r\n    if (type == FilterChipType.category && color == null) {\r\n      // Si c'est une puce de catégorie mais sans couleur spécifiée, utiliser la primaire\r\n      chipColor = colorScheme.primary;\r\n    }\r\n\r\n    // Configurer les couleurs selon l'état\r\n    Color backgroundColor;\r\n    Color textColor;\r\n    Color borderColor;\r\n\r\n    if (disabled) {\r\n      // Puce désactivée\r\n      backgroundColor = isDark ? AppColors.neutral800 : AppColors.neutral200;\r\n      textColor = isDark ? AppColors.neutral600 : AppColors.neutral500;\r\n      borderColor = Colors.transparent;\r\n    } else if (selected) {\r\n      // Puce sélectionnée\r\n      backgroundColor = chipColor;\r\n      textColor = Colors.white;\r\n      borderColor = Colors.transparent;\r\n    } else {\r\n      // Puce non sélectionnée\r\n      backgroundColor = isDark ? AppColors.neutral800.withOpacity(0.5) : AppColors.neutral100;\r\n      textColor = isDark ? AppColors.neutral200 : AppColors.neutral800;\r\n      borderColor = isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n    }\r\n\r\n    // Style du texte\r\n    final TextStyle textStyle = context.labelMedium.copyWith(\r\n      color: textColor,\r\n      fontWeight: selected ? FontWeight.bold : FontWeight.normal,\r\n    );\r\n\r\n    // Icône à afficher\r\n    Widget? iconWidget;\r\n    if (icon != null) {\r\n      iconWidget = Icon(\r\n        icon,\r\n        size: 16,\r\n        color: textColor,\r\n      );\r\n    }\r\n\r\n    // Effets de décoration\r\n    BoxDecoration decoration = BoxDecoration(\r\n      color: backgroundColor,\r\n      borderRadius: AppDimensions.borderRadiusXl,\r\n      border: !selected\r\n          ? Border.all(color: borderColor, width: 1)\r\n          : null,\r\n    );\r\n\r\n    // Ajouter une ombre si demandé\r\n    if (hasShadow && !disabled) {\r\n      decoration = decoration.copyWith(\r\n        boxShadow: [\r\n          BoxShadow(\r\n            color: isDark\r\n                ? Colors.black.withOpacity(0.2)\r\n                : Colors.black.withOpacity(0.1),\r\n            blurRadius: 4,\r\n            offset: Offset(0, 1),\r\n            spreadRadius: 0,\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    // Construire le contenu de la puce\r\n    Widget chipContent = Container(\r\n      padding: EdgeInsets.symmetric(\r\n        horizontal: AppDimensions.space3,\r\n        vertical: AppDimensions.space2,\r\n      ),\r\n      decoration: decoration,\r\n      child: Row(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: [\r\n          if (iconWidget != null) ...[\r\n            iconWidget,\r\n            SizedBox(width: AppDimensions.space2),\r\n          ],\r\n          Text(\r\n            label,\r\n            style: textStyle,\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n\r\n    // Appliquer les marges si spécifiées\r\n    if (margin != null) {\r\n      chipContent = Padding(\r\n        padding: margin!,\r\n        child: chipContent,\r\n      );\r\n    }\r\n\r\n    // Rendre la puce interactive si elle n'est pas désactivée\r\n    if (!disabled && onPressed != null) {\r\n      return GestureDetector(\r\n        onTap: onPressed,\r\n        child: chipContent,\r\n      );\r\n    }\r\n\r\n    return chipContent;\r\n  }\r\n\r\n  /// Crée une liste horizontale scrollable de puces de filtre\r\n  static Widget horizontalList({\r\n    required List<AppFilterChip> chips,\r\n    EdgeInsets? padding,\r\n    double spacing = 8.0,\r\n    double height = 40.0,\r\n    bool showScrollbar = true,\r\n  }) {\r\n    return Builder(\r\n      builder: (context) {\r\n        final ScrollController scrollController = ScrollController();\r\n\r\n        return Container(\r\n          height: height,\r\n          child: showScrollbar\r\n              ? Scrollbar(\r\n            controller: scrollController,\r\n            thumbVisibility: true,\r\n            thickness: 4,\r\n            radius: Radius.circular(8),\r\n            child: _buildChipList(chips, scrollController, padding, spacing),\r\n          )\r\n              : _buildChipList(chips, scrollController, padding, spacing),\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  static Widget _buildChipList(\r\n      List<AppFilterChip> chips,\r\n      ScrollController scrollController,\r\n      EdgeInsets? padding,\r\n      double spacing,\r\n      ) {\r\n    return ListView.separated(\r\n      controller: scrollController,\r\n      scrollDirection: Axis.horizontal,\r\n      padding: padding ?? EdgeInsets.symmetric(\r\n        horizontal: AppDimensions.space4,\r\n        vertical: AppDimensions.space2,\r\n      ),\r\n      itemCount: chips.length,\r\n      separatorBuilder: (context, index) => SizedBox(width: spacing),\r\n      itemBuilder: (context, index) => chips[index],\r\n    );\r\n  }\r\n\r\n  /// Crée une grille responsive de puces de filtre\r\n  static Widget grid({\r\n    required List<AppFilterChip> chips,\r\n    EdgeInsets? padding,\r\n    double spacing = 8.0,\r\n    double runSpacing = 8.0,\r\n  }) {\r\n    return Padding(\r\n      padding: padding ?? EdgeInsets.all(AppDimensions.space4),\r\n      child: Wrap(\r\n        spacing: spacing,\r\n        runSpacing: runSpacing,\r\n        children: chips,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 6980,
        "last_modified": "2025-04-16T13:25:28.0541605",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\molecules.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/molecules.dart\r\n\r\n/// Fichier d'exportation regroupant tous les composants moléculaires\r\n///\r\n/// Les molécules sont des groupes d'atomes fonctionnant ensemble comme une unité.\r\n/// Par exemple, une search_bar combine un input avec un bouton.\r\n\r\nexport 'molecules/filter_chip.dart';\r\n",
      "info": {
        "size": 334,
        "last_modified": "2025-04-16T13:25:28.065882",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\organisms.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/organisme.dart\r\n\r\n/// Fichier d'exportation regroupant tous les composants organismiques\r\n///\r\n/// Les organismes sont des assemblages complexes de molécules et atomes qui forment\r\n/// une section distincte de l'interface, comme une liste d'activités ou un header.\r\n\r\n",
      "info": {
        "size": 317,
        "last_modified": "2025-04-16T13:25:28.0729055",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\sections\\activity_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/sections/activity_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../cards/activity_card.dart';\r\nimport '../cards/activity_container.dart';\r\n\r\nclass ActivitySection extends StatelessWidget {\r\n  final String title;\r\n  final List<ActivityCard> activities;\r\n  final bool isFirstSection;\r\n  final VoidCallback? onActivityOpen;  // Nouveau callback pour gérer le header\r\n\r\n  const ActivitySection({\r\n    super.key,\r\n    required this.title,\r\n    required this.activities,\r\n    this.isFirstSection = false,\r\n    this.onActivityOpen,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Padding(\r\n      padding: EdgeInsets.only(\r\n        top: isFirstSection ? 8 : 24,\r\n      ).add(const EdgeInsets.only(top: 20)),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Padding(\r\n            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n            child: Text(\r\n              title,\r\n              style: Theme.of(context).textTheme.titleMedium,\r\n            ),\r\n          ),\r\n          SizedBox(\r\n            height: AppDimensions.space32 * 5,\r\n            child: ListView.builder(\r\n              scrollDirection: Axis.horizontal,\r\n              padding: const EdgeInsets.symmetric(horizontal: 16),\r\n              itemCount: activities.length,\r\n              itemExtent: AppDimensions.space32 * 7 + 16,\r\n              cacheExtent: AppDimensions.space32 * 7 * 2,\r\n              clipBehavior: Clip.none,\r\n              keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,\r\n              itemBuilder: (context, index) {\r\n                final activity = activities[index];\r\n                return Padding(\r\n                  key: ValueKey('activity-${activity.activityId}'),\r\n                  padding: const EdgeInsets.only(right: 16),\r\n                  child: ActivityContainer(\r\n                    card: activity,\r\n                    headerVisible: isFirstSection && index == 0,\r\n                    onHeaderVisibilityChanged: onActivityOpen,\r\n                  ),\r\n                );\r\n              },\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2300,
        "last_modified": "2025-04-16T13:25:28.0789147",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\shimmer\\shimmer_loading.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/shimmer/shimmer_loading.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\n\r\n/// Composant moderne pour créer un effet de chargement brillant (shimmer)\r\n///\r\n/// Ce widget peut être utilisé de deux façons :\r\n/// 1. Comme conteneur avec un effet de chargement (ShimmerLoading.container)\r\n/// 2. Pour envelopper n'importe quel widget avec un effet shimmer (ShimmerLoading.child)\r\nclass ShimmerLoading extends StatefulWidget {\r\n  final Widget child;\r\n  final bool isLoading;\r\n  final Duration duration;\r\n\r\n  const ShimmerLoading._({\r\n    Key? key,\r\n    required this.child,\r\n    required this.isLoading,\r\n    this.duration = const Duration(milliseconds: 1500),\r\n  }) : super(key: key);\r\n\r\n  /// Crée un conteneur avec effet shimmer aux dimensions spécifiées\r\n  static Widget container({\r\n    Key? key,\r\n    required double width,\r\n    required double height,\r\n    BorderRadius? borderRadius,\r\n    EdgeInsets? margin,\r\n    bool isLoading = true,\r\n    Duration duration = const Duration(milliseconds: 1500),\r\n  }) {\r\n    return ShimmerLoading._(\r\n      key: key,\r\n      isLoading: isLoading,\r\n      duration: duration,\r\n      child: Container(\r\n        width: width,\r\n        height: height,\r\n        margin: margin,\r\n        decoration: BoxDecoration(\r\n          borderRadius: borderRadius ?? BorderRadius.circular(AppDimensions.radiusM),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n\r\n  /// Enveloppe n'importe quel widget avec un effet shimmer\r\n  static Widget wrap({\r\n    Key? key,\r\n    required Widget child,\r\n    bool isLoading = true,\r\n    Duration duration = const Duration(milliseconds: 1500),\r\n  }) {\r\n    return ShimmerLoading._(\r\n      key: key,\r\n      isLoading: isLoading,\r\n      duration: duration,\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  @override\r\n  State<ShimmerLoading> createState() => _ShimmerLoadingState();\r\n}\r\n\r\nclass _ShimmerLoadingState extends State<ShimmerLoading> with SingleTickerProviderStateMixin {\r\n  late AnimationController _controller;\r\n  late Animation<double> _animation;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _controller = AnimationController(\r\n      vsync: this,\r\n      duration: widget.duration,\r\n    );\r\n\r\n    _animation = Tween<double>(begin: -2, end: 2).animate(\r\n      CurvedAnimation(\r\n        parent: _controller,\r\n        curve: Curves.easeInOutSine,\r\n      ),\r\n    );\r\n\r\n    if (widget.isLoading) {\r\n      _controller.repeat();\r\n    }\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(ShimmerLoading oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n\r\n    if (widget.isLoading != oldWidget.isLoading) {\r\n      if (widget.isLoading) {\r\n        _controller.repeat();\r\n      } else {\r\n        _controller.stop();\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _controller.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (!widget.isLoading) {\r\n      return widget.child;\r\n    }\r\n\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final baseColor = isDark ? AppColors.shimmerBaseDark : AppColors.shimmerBaseLight;\r\n    final highlightColor = isDark ? AppColors.shimmerHighlightDark : AppColors.shimmerHighlightLight;\r\n\r\n    return AnimatedBuilder(\r\n      animation: _animation,\r\n      builder: (context, child) {\r\n        return ShaderMask(\r\n          blendMode: BlendMode.srcATop,\r\n          shaderCallback: (bounds) {\r\n            return LinearGradient(\r\n              colors: [\r\n                baseColor,\r\n                highlightColor,\r\n                baseColor,\r\n              ],\r\n              stops: const [0.0, 0.5, 1.0],\r\n              begin: Alignment(_animation.value, -0.5),\r\n              end: Alignment(_animation.value + 1, 0.5),\r\n              tileMode: TileMode.clamp,\r\n            ).createShader(bounds);\r\n          },\r\n          child: child,\r\n        );\r\n      },\r\n      child: Container(\r\n        color: baseColor,\r\n        child: widget.child,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4103,
        "last_modified": "2025-04-16T13:25:28.0911455",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\shimmer\\shimmer_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/shimmer/shimmer_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'shimmer_skeletons.dart';\r\n\r\n/// Widget pour afficher une section de shimmer (titre + liste horizontale de cartes)\r\n///\r\n/// Cette classe maintient la compatibilité avec l'ancienne implémentation\r\n/// mais utilise la nouvelle API ShimmerSkeletons sous le capot.\r\nclass ShimmerSection extends StatelessWidget {\r\n  /// Si cette section est la première de la page (affecte le padding supérieur)\r\n  final bool isFirstSection;\r\n\r\n  /// Nombre d'éléments shimmer à afficher dans la liste\r\n  final int itemCount;\r\n\r\n  const ShimmerSection({\r\n    super.key,\r\n    required this.isFirstSection,\r\n    this.itemCount = 3,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    // Utilise directement ShimmerSkeletons.section qui reproduit l'ancien comportement\r\n    return ShimmerSkeletons.section(\r\n      isFirstSection: isFirstSection,\r\n      itemCount: itemCount,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1016,
        "last_modified": "2025-04-16T13:25:28.0981463",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\shimmer\\shimmer_skeletons.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/shimmer/shimmer_skeletons.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport 'shimmer_loading.dart';\r\n\r\n/// Widgets préfabriqués pour les cas d'usage courants du shimmer\r\nclass ShimmerSkeletons {\r\n  /// Squelette pour une carte d'activité\r\n  static Widget activityCard({\r\n    double? width,\r\n    double? height,\r\n    EdgeInsets? margin,\r\n  }) {\r\n    return ClipRRect(\r\n      borderRadius: BorderRadius.circular(AppDimensions.radiusM),\r\n      child: ShimmerLoading.container(\r\n        width: width ?? AppDimensions.space32 * 5, // Largeur standard comme dans l'ancien code\r\n        height: height ?? AppDimensions.space32 * 7, // Hauteur standard comme dans l'ancien code\r\n        margin: margin,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Squelette pour un texte court (titre ou label)\r\n  static Widget text({\r\n    double width = 200,\r\n    double height = 24,\r\n    EdgeInsets? margin,\r\n  }) {\r\n    return ClipRRect(\r\n      borderRadius: BorderRadius.circular(AppDimensions.radiusS),\r\n      child: ShimmerLoading.container(\r\n        width: width,\r\n        height: height,\r\n        margin: margin ?? EdgeInsets.symmetric(vertical: AppDimensions.spacingXs),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Squelette pour un paragraphe (plusieurs lignes de texte)\r\n  static Widget paragraph({\r\n    required int lines,\r\n    double width = double.infinity,\r\n    double lineHeight = 16,\r\n    double lastLineWidth = 0.66,\r\n    EdgeInsets? margin,\r\n  }) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: List.generate(\r\n        lines,\r\n            (index) => Padding(\r\n          padding: EdgeInsets.only(bottom: AppDimensions.spacingXs),\r\n          child: ClipRRect(\r\n            borderRadius: BorderRadius.circular(AppDimensions.radiusXs),\r\n            child: ShimmerLoading.container(\r\n              width: index == lines - 1 && lines > 1\r\n                  ? (width is double ? width * lastLineWidth : width)\r\n                  : width,\r\n              height: lineHeight,\r\n              margin: index == lines - 1 ? null : EdgeInsets.only(bottom: AppDimensions.spacingXs),\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Squelette pour une liste d'activités (compatible avec l'ancien ShimmerSection)\r\n  static Widget activityList({\r\n    required int itemCount,\r\n    double itemWidth = 280,\r\n    double itemHeight = 380,\r\n    double spacing = 16,\r\n    EdgeInsets? padding,\r\n    bool showTitle = true,\r\n    double titleWidth = 200,\r\n    double titleHeight = 24,\r\n  }) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        // Titre en shimmer (si demandé)\r\n        if (showTitle)\r\n          Padding(\r\n            padding: EdgeInsets.symmetric(\r\n              horizontal: AppDimensions.spacingM,\r\n              vertical: AppDimensions.spacingS,\r\n            ),\r\n            child: text(\r\n              width: titleWidth,\r\n              height: titleHeight,\r\n            ),\r\n          ),\r\n\r\n        // Liste de cartes en shimmer\r\n        SizedBox(\r\n          height: itemHeight,\r\n          child: ListView.builder(\r\n            scrollDirection: Axis.horizontal,\r\n            padding: padding ?? EdgeInsets.all(AppDimensions.spacingM),\r\n            itemCount: itemCount,\r\n            itemBuilder: (context, index) => Padding(\r\n              padding: EdgeInsets.only(\r\n                right: index < itemCount - 1 ? spacing : 0,\r\n              ),\r\n              child: activityCard(\r\n                width: itemWidth,\r\n                height: itemHeight,\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n\r\n  /// Squelette pour une section complète (remplacement direct de ShimmerSection)\r\n  static Widget section({\r\n    bool isFirstSection = false,\r\n    int itemCount = 3,\r\n  }) {\r\n    return Padding(\r\n      padding: EdgeInsets.only(\r\n        top: isFirstSection ? AppDimensions.spacingS : AppDimensions.spacingL,\r\n      ),\r\n      child: activityList(\r\n        itemCount: itemCount,\r\n        itemWidth: AppDimensions.space32 * 5,\r\n        itemHeight: AppDimensions.space32 * 7,\r\n        padding: EdgeInsets.symmetric(horizontal: AppDimensions.spacingM),\r\n        showTitle: true,\r\n        titleWidth: AppDimensions.space32 * 3.5,\r\n        titleHeight: AppDimensions.iconSizeM,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4483,
        "last_modified": "2025-04-16T13:25:28.104661",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\templates.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/templates.dart\r\n\r\n/// Fichier d'exportation regroupant tous les templates\r\n///\r\n/// Les templates sont des mises en page de niveau supérieur qui regroupent\r\n/// des organismes dans un contexte de page. Ils définissent la structure\r\n/// générale des écrans sans contenu spécifique.\r\n\r\n\r\n",
      "info": {
        "size": 339,
        "last_modified": "2025-04-16T13:25:28.116263",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\pages\\trip_test_page.dart",
      "content": "import 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:travel_in_perigord_app/core/domain/models/trip_designer/trip/trip_model.dart';\r\nimport 'package:travel_in_perigord_app/features/trip/presentation/state/trip_test_provider.dart';\r\nimport '../../../../core/common/enums/trip_enums.dart';\r\n\r\nclass TripTestPage extends ConsumerStatefulWidget {\r\n  const TripTestPage({super.key});\r\n\r\n  @override\r\n  ConsumerState<TripTestPage> createState() => _TripTestPageState();\r\n}\r\n\r\nclass _TripTestPageState extends ConsumerState<TripTestPage> {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final state = ref.watch(tripTestProvider);\r\n\r\n    return Scaffold(\r\n      appBar: AppBar(title: const Text('Trip Tests')),\r\n      body: SafeArea(\r\n        child: SingleChildScrollView(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.stretch,\r\n            children: [\r\n              Wrap(\r\n                spacing: 8,\r\n                runSpacing: 8,\r\n                children: [\r\n                  ElevatedButton(\r\n                    onPressed: () =>\r\n                        ref.read(tripTestProvider.notifier).testGoogleMaps(),\r\n                    child: const Text('Add Cities'),\r\n                  ),\r\n                  ElevatedButton(\r\n                    onPressed: () =>\r\n                        ref.read(tripTestProvider.notifier).testTripCreation(),\r\n                    child: const Text('Create Trip'),\r\n                  ),\r\n                  ElevatedButton(\r\n                    onPressed: () =>\r\n                        ref.read(tripTestProvider.notifier).testActivityFiltering(),\r\n                    child: const Text('Activity Filtering'),\r\n                  ),\r\n              ElevatedButton(\r\n                onPressed: () =>\r\n                    ref.read(tripTestProvider.notifier).testActivityScoring(),\r\n                child: const Text('Scoring'),\r\n              ),\r\n              ElevatedButton(\r\n                onPressed: () => ref.read(tripTestProvider.notifier).testRouteOptimization(),\r\n                child: const Text('Route Optimization'),\r\n              ),\r\n                  ElevatedButton(\r\n                    onPressed: () => ref.read(tripTestProvider.notifier).testDailyTrip(),\r\n                    child: const Text('Daily Trip'),\r\n                  ),\r\n                ],\r\n              ),\r\n\r\n              const SizedBox(height: 20),\r\n              const SizedBox(height: 20),\r\n              if (state.isLoading)\r\n                const Center(child: CircularProgressIndicator())\r\n              else if (state.error.isNotEmpty)\r\n                Padding(\r\n                  padding: const EdgeInsets.all(16.0),\r\n                  child: Text(\r\n                    state.error,\r\n                    style: const TextStyle(color: Colors.red),\r\n                    textAlign: TextAlign.center,\r\n                  ),\r\n                )\r\n              else if (state.testResults != null)\r\n                  _buildTestResults(state.testResults!),\r\n            ],\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildTestResults(Map<String, dynamic> results) {\r\n    if (results['testType'] == 'trip') {\r\n      final trip = results['tripDetails'] as Trip;\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Voyage créé avec succès:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('ID: ${trip.id}'),\r\n              Text('Titre: ${trip.title}'),\r\n              Text('Ville de départ: ${trip.departureCity?.cityName ?? \"Non définie\"}'),\r\n              Text('Dates: ${trip.startDate.toString()} - ${trip.endDate.toString()}'),\r\n              Text('Style: ${trip.travelStyle?.value ?? \"Non défini\"}'),\r\n              const SizedBox(height: 8),\r\n              Text('Groupe:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              Text('Type: ${trip.travelGroup.type}'),\r\n              Text('Adultes: ${trip.travelGroup.members.adults}'),\r\n              if (trip.travelGroup.members.children.isNotEmpty)\r\n                Text('Enfants: ${trip.travelGroup.members.children.join(\", \")} ans'),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'hours') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test des horaires:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              if (results['result'] is String)\r\n                Text(results['result'])\r\n              else ...[\r\n                Text('Nombre de jours: ${results['result']['numberOfDays']}'),\r\n                const SizedBox(height: 8),\r\n                Text('Exemple d\\'horaires:',\r\n                    style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                ...results['result']['sampleDays'].entries.take(3).map(\r\n                      (entry) => Text(\r\n                    '${entry.key}: ${entry.value['opens_at']} - ${entry.value['closes_at']}',\r\n                  ),\r\n                ),\r\n              ],\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'route_optimization') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test d\\'optimisation des routes:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Distance totale: ${results['route']['readable_distance']}'),\r\n              Text('Durée totale: ${results['route']['readable_duration']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Ordre des waypoints: ${results['route']['waypoint_order']}'),\r\n              Text('Temps de trajet direct: ${results['travelTime']} minutes'),\r\n              const SizedBox(height: 8),\r\n              Text('Évaluation du détour:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              Text('Status: ${results['detourEvaluation']['status']}'),\r\n              Text('Faisable: ${results['detourEvaluation']['feasible']}'),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'daily_trip') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test Daily Trip:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('ID: ${results['dailyTrip']['id']}'),\r\n              Text('Type: ${results['dailyTrip']['type']}'),\r\n              Text('Distance: ${results['dailyTrip']['distance']}'),\r\n              Text('Durée: ${results['dailyTrip']['duration']}'),\r\n              Text('Nombre de SuperWow: ${results['dailyTrip']['superwows']}'),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'superwow_management') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test SuperWow Management:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Ville de départ: ${results['departureCity']}'),\r\n              Text('Total SuperWow: ${results['totalSuperWows']}'),\r\n              const SizedBox(height: 8),\r\n              Text('SuperWow le plus proche:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              Text('Nom: ${results['closestSuperWow']['name']}'),\r\n              Text('Score: ${results['closestSuperWow']['score']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Top 3 paires:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              ...results['top3Pairs'].map<Widget>((pair) =>\r\n                  Padding(\r\n                    padding: const EdgeInsets.only(left: 8, top: 4),\r\n                    child: Column(\r\n                      crossAxisAlignment: CrossAxisAlignment.start,\r\n                      children: [\r\n                        Text('${pair['sw1']} → ${pair['sw2']}'),\r\n                        Text('Distance: ${pair['distance']} - Durée: ${pair['duration']}'),\r\n                        const SizedBox(height: 4),\r\n                      ],\r\n                    ),\r\n                  ),\r\n              ).toList(),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'half_day_generation') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test Half-Day Generation:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Ville de départ: ${results['departureCity']}'),\r\n              Text('Total trajets générés: ${results['totalTrips']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Trajets:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              ...results['trips'].map<Widget>((trip) =>\r\n                  Padding(\r\n                    padding: const EdgeInsets.only(left: 8, top: 4),\r\n                    child: Column(\r\n                      crossAxisAlignment: CrossAxisAlignment.start,\r\n                      children: [\r\n                        Text(trip['superWow']),\r\n                        Text('Distance: ${trip['distance']} - Durée: ${trip['duration']}'),\r\n                        const SizedBox(height: 4),\r\n                      ],\r\n                    ),\r\n                  ),\r\n              ).toList(),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'full_day_generation') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test Full-Day Generation:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Ville de départ: ${results['departureCity']}'),\r\n              Text('Total trajets générés: ${results['totalTrips']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Trajets:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              ...results['trips'].map<Widget>((trip) =>\r\n                  Padding(\r\n                    padding: const EdgeInsets.only(left: 8, top: 4),\r\n                    child: Column(\r\n                      crossAxisAlignment: CrossAxisAlignment.start,\r\n                      children: [\r\n                        Text('${trip['sw1']} → ${trip['sw2']}'),\r\n                        Text('Distance: ${trip['distance']} - Durée: ${trip['duration']}'),\r\n                        const SizedBox(height: 4),\r\n                      ],\r\n                    ),\r\n                  ),\r\n              ).toList(),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    return Container(\r\n      padding: const EdgeInsets.all(16),\r\n      decoration: BoxDecoration(\r\n        border: Border.all(color: Colors.grey),\r\n        borderRadius: BorderRadius.circular(8),\r\n      ),\r\n      child: Text(results.toString()),\r\n    );\r\n  }\r\n}\r\n",
      "info": {
        "size": 12296,
        "last_modified": "2025-04-16T13:25:28.1398969",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\state\\trip_test_notifier.dart",
      "content": "// features/trip/presentation/state/trip_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:uuid/uuid.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../../core/domain/use_cases/create_trip_use_case.dart';\r\nimport '../../../../core/domain/use_cases/process_activities_use_case.dart';\r\nimport '../../../../core/domain/ports/geocoding_port.dart';\r\nimport '../../../../core/domain/ports/activity_hours_port.dart';\r\nimport '../../../../core/domain/ports/activity_scoring_port.dart';\r\nimport '../../../../core/domain/ports/empty_trips/route_optimization.port.dart';\r\nimport '../../../../core/domain/ports/trip_activities_port.dart';\r\nimport '../../../../core/domain/ports/empty_trips/superwow_management.port.dart';\r\nimport '../../../../core/domain/ports/daily_trip_generation_port.dart';\r\nimport '../../../../core/domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../../../core/domain/models/scored_activity.dart';\r\nimport '../../../../core/domain/models/trip_designer/trip/daily_trip.dart';\r\nimport '../../../../core/common/enums/trip_enums.dart';\r\nimport 'trip_test_state.dart';\r\nimport '../../../../core/common/exceptions/exceptions.dart';\r\n\r\nclass TripTestNotifier extends StateNotifier<TripTestState> {\r\n  final CreateTripUseCase _createTripUseCase;\r\n  final ProcessActivitiesUseCase _processActivitiesUseCase;\r\n  final GeocodingPort _geocodingPort;\r\n  final ActivityHoursPort _activityHoursPort;\r\n  final ActivityScoringPort _activityScoringPort;\r\n  final RouteOptimizationPort _routeOptimizationPort;\r\n  final TripActivitiesPort _tripActivitiesPort;\r\n  final SupabaseClient _supabase;\r\n  final SuperWowManagementPort _superwowManagementPort;\r\n\r\n  TripTestNotifier(\r\n      this._createTripUseCase,\r\n      this._processActivitiesUseCase,\r\n      this._geocodingPort,\r\n      this._activityHoursPort,\r\n      this._activityScoringPort,\r\n      this._routeOptimizationPort,\r\n      this._tripActivitiesPort,\r\n      this._supabase,\r\n      this._superwowManagementPort,\r\n      ) : super(TripTestState());\r\n\r\n  Future<void> testGoogleMaps() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print('Début du test Google Maps');\r\n      final singleResult = await _geocodingPort.getCity('Sarlat-la-Canéda');\r\n      final cities = ['Périgueux', 'Bergerac', 'Montignac', 'Les Eyzies'];\r\n\r\n      // Utiliser map au lieu de Future.wait pour gérer les erreurs individuellement\r\n      final multipleResults = await Future.wait(\r\n        cities.map((city) async {\r\n          try {\r\n            return await _geocodingPort.getCity(city);\r\n          } on DataException catch (e) {\r\n            print('Erreur pour la ville $city: $e');\r\n            return null; // Retourner null en cas d'erreur\r\n          }\r\n        }),\r\n      );\r\n\r\n      _setSuccessState({\r\n        'testType': 'cities',\r\n        'singleCityTest': {\r\n          'city': 'Sarlat-la-Canéda',\r\n          'success': singleResult != null,\r\n          'details': singleResult.toJson(),\r\n        },\r\n        'multipleCitiesTest': {\r\n          'cities': multipleResults.map((city) => city?.toJson()).toList(),\r\n          'success': multipleResults.every((result) => result != null),\r\n        },\r\n      });\r\n      print('Test Google Maps terminé avec succès');\r\n    } catch (e) {\r\n      print('Erreur lors du test Google Maps : $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testTripCreation() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      final trip = await _createTripUseCase.execute(CreateTripParams(\r\n        userId: \"123e4567-e89b-12d3-a456-426614174000\",\r\n        title: \"Test Trip to Dordogne\",\r\n        startDate: DateTime.now(),\r\n        endDate: DateTime.now().add(const Duration(days: 5)),\r\n        departureCityName: \"Sarlat-la-Canéda\",\r\n        travelGroup: TravelGroup(\r\n          type: \"family\",\r\n          members: TravelGroupMembers(\r\n            pmr: false,\r\n            adults: 2,\r\n            seniors: false,\r\n            children: [7, 10],\r\n            teenagers: [],\r\n          ),\r\n          physicalCondition: \"moderate\",\r\n        ),\r\n        activityHours: ActivityHours(\r\n          start: \"10:00\",\r\n          end: \"18:00\",\r\n          daily_hours: {\r\n            DateTime.now().toIso8601String().split('T')[0]: {\r\n              'start': '10:00',\r\n              'end': '14:00'\r\n            },\r\n            DateTime.now().add(Duration(days: 1)).toIso8601String().split('T')[0]: {\r\n              'start': '09:00',\r\n              'end': '18:00'\r\n            },\r\n            DateTime.now().add(Duration(days: 2)).toIso8601String().split('T')[0]: {\r\n              'start': null,\r\n              'end': null\r\n            },\r\n            DateTime.now().add(Duration(days: 3)).toIso8601String().split('T')[0]: {\r\n              'start': '10:00',\r\n              'end': '20:00'\r\n            },\r\n            DateTime.now().add(Duration(days: 4)).toIso8601String().split('T')[0]: {\r\n              'start': '14:00',\r\n              'end': '22:00'\r\n            },\r\n          },\r\n        ),\r\n        dailyBudget: 150.00,\r\n        travelStyle: TravelStyle.balanced,\r\n        preferredMoment: PreferredMoment.morning,\r\n        transportMode: \"car\",\r\n      ));\r\n\r\n      _setSuccessState({\r\n        'testType': 'trip',\r\n        'tripDetails': trip,\r\n      });\r\n    } catch (e, stackTrace) {\r\n      print('Erreur détaillée: $e'); // Ajout du print\r\n      print('Stack trace: $stackTrace'); // Ajout du print\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testActivityHours() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      // Utilisons un ID d'activité existant dans la base\r\n      final activityId = \"votre_id_activite\"; // À remplacer par un ID valide\r\n\r\n      // Test sur une période de 7 jours\r\n      final startDate = DateTime.now();\r\n      final endDate = startDate.add(const Duration(days: 7));\r\n\r\n      print('🕒 Test de récupération des horaires');\r\n      print('Activité ID: $activityId');\r\n      print('Période: $startDate - $endDate');\r\n\r\n      final openingDays = await _activityHoursPort.getActivityHours(\r\n        activityId,\r\n        startDate,\r\n        endDate,\r\n      );\r\n\r\n      if (openingDays == null) {\r\n        _setSuccessState({\r\n          'testType': 'hours',\r\n          'result': 'Aucun horaire trouvé pour cette période',\r\n        });\r\n        return;\r\n      }\r\n\r\n      _setSuccessState({\r\n        'testType': 'hours',\r\n        'result': {\r\n          'numberOfDays': openingDays.availableDays.length,\r\n          'sampleDays': openingDays.availableDays,\r\n        },\r\n      });\r\n    } catch (e) {\r\n      print('❌ Erreur lors du test des horaires: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testActivityFiltering() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print('🔍 Début du test de filtrage des activités');\r\n      final tripId = \"fd60d18c-116f-4e48-be32-0112a83a8a1b\"; // ID de test\r\n\r\n      print('📥 Processing des activités...');\r\n      final activities = await _processActivitiesUseCase.execute(tripId);\r\n      print('✅ ${activities.length} activités traitées');\r\n\r\n      _setSuccessState({\r\n        'testType': 'filtering',\r\n        'totalActivities': activities.length,\r\n        'activities': activities.map((a) => {\r\n          'id': a.id,\r\n          'name': a.name,\r\n          'geohash': a.geohash,\r\n          'exclusionReason': a.exclusionReason,\r\n        }).toList(),\r\n      });\r\n    } catch (e, stackTrace) {\r\n      print('❌ Erreur dans le test de filtrage: $e');\r\n      print('Stack trace: $stackTrace');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testActivityScoring() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      final userId = \"123e4567-e89b-12d3-a456-426614174000\";\r\n      final tripId = \"fd60d18c-116f-4e48-be32-0112a83a8a1b\";\r\n\r\n      print('🎯 Test du scoring des activités');\r\n\r\n      // 1. D'abord récupérer les activités filtrées\r\n      final activities = await _processActivitiesUseCase.execute(tripId);\r\n      print('✅ ${activities.length} activités récupérées après filtrage');\r\n\r\n      // 2. Calculer les scores (utilise le cache user_activities_score)\r\n      final scoredActivities = await _activityScoringPort.scoreActivities(userId, activities);\r\n      print('📊 Scores calculés ou récupérés du cache');\r\n\r\n      print('🗄️ Début sauvegarde dans trip_activities');\r\n\r\n      // Convertir les activités scorées au format attendu\r\n      final activitiesToSave = scoredActivities\r\n          .where((a) => a.subcategoryScore > 0)  // Ajout du filtre ici\r\n          .map((a) => ScoredActivity(\r\n        id: a.activity.id,\r\n        totalScore: a.totalScore,\r\n        subcategoryScore: a.subcategoryScore,\r\n        isSuperwow: a.isSuperWow,\r\n        activityData: {\r\n          'id': a.activity.id,\r\n          'geohash': a.activity.geohash,\r\n          'name': a.activity.name,\r\n        },\r\n      )).toList();\r\n\r\n      // Séparer les SuperWow des activités normales\r\n      final superwows = activitiesToSave.where((a) => a.isSuperwow).toList();\r\n      final normalActivities = activitiesToSave.where((a) => !a.isSuperwow).toList();\r\n\r\n      // Sauvegarder les deux types d'activités\r\n      await _tripActivitiesPort.saveFilteredActivities(\r\n        tripId: tripId,\r\n        activities: superwows,\r\n        isSuperwow: true,\r\n      );\r\n\r\n      await _tripActivitiesPort.saveFilteredActivities(\r\n        tripId: tripId,\r\n        activities: normalActivities,\r\n        isSuperwow: false,\r\n      );\r\n\r\n      print('✅ Sauvegarde terminée');\r\n\r\n      _setSuccessState({\r\n        'testType': 'scoring',\r\n        'totalActivities': scoredActivities.length,\r\n        'superwowCount': superwows.length,\r\n        'normalActivities': normalActivities.length,\r\n        'activities': scoredActivities.map((a) => {\r\n          'name': a.activity.name,\r\n          'totalScore': a.totalScore,\r\n          'subcategoryScore': a.subcategoryScore,\r\n          'isSuperWow': a.isSuperWow,\r\n        }).toList(),\r\n      });\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur dans le test de scoring: $e');\r\n      print('Détails de l\\'erreur: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testDailyTrip() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print('🗓️ Test de création d\\'un Daily Trip');\r\n\r\n      // Test avec les données de notre trajet d'exemple Périgueux-Sarlat\r\n      final testTrip = DailyTrip(\r\n        id: const Uuid().v4(),  // Génération d'un nouvel UUID\r\n        type: DailyTripType.full_day,\r\n        date: DateTime.now(),\r\n        startPoint: const LatLng(45.1909, 0.7167),  // Périgueux\r\n        endPoint: const LatLng(44.8883, 1.2162),    // Sarlat\r\n        superWowIds: [\r\n          '1d6a2c9e-b8a9-4a2a-b1e2-d8f6a1b03df9',  // Exemple d'ID de SuperWow\r\n          'e31cf556-f916-410f-94f3-1b830a0bfa12'\r\n        ],\r\n        totalDuration: const Duration(hours: 3),\r\n        totalDistance: 72630,  // ~72.63 km\r\n      );\r\n\r\n      // On essaie d'insérer dans Supabase\r\n      final result = await _supabase.from('daily_trips').insert(\r\n          testTrip.toJson()..addAll({\r\n            'trip_id': 'fd60d18c-116f-4e48-be32-0112a83a8a1b',  // ID du trip test\r\n          })\r\n      ).select();\r\n\r\n      print('✅ Daily Trip créé avec succès');\r\n\r\n      _setSuccessState({\r\n        'testType': 'daily_trip',\r\n        'dailyTrip': {\r\n          'id': testTrip.id,\r\n          'type': testTrip.type.toString(),\r\n          'distance': '${(testTrip.totalDistance / 1000).toStringAsFixed(2)} km',\r\n          'duration': '${testTrip.totalDuration.inMinutes} minutes',\r\n          'superwows': testTrip.superWowIds.length,\r\n        }\r\n      });\r\n\r\n    } catch (e) {\r\n      print('❌ Erreur dans le test de Daily Trip: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testRouteOptimization() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print('🗺️ Test d\\'optimisation des routes');\r\n\r\n      // Test avec des coordonnées de la Dordogne\r\n      final origin = LatLng(45.1909, 0.7167);      // Périgueux\r\n      final destination = LatLng(44.8883, 1.2162);  // Sarlat\r\n      final waypoint = LatLng(44.9171, 1.0669);     // Les Eyzies\r\n\r\n      // Test du calcul de route optimisée\r\n      final optimizedRoute = await _routeOptimizationPort.getOptimizedRoute(\r\n        origin,\r\n        destination,\r\n        [waypoint],\r\n      );\r\n\r\n      // Vérification des données retournées\r\n      if (optimizedRoute['status'] != 'OK') {\r\n        throw Exception('Status de la route non valide: ${optimizedRoute['status']}');\r\n      }\r\n\r\n      print('📍 Distance totale: ${(optimizedRoute['distance'] / 1000).toStringAsFixed(2)} km');\r\n      print('⏱️ Durée totale: ${(optimizedRoute['duration'] / 60).toStringAsFixed(0)} minutes');\r\n      print('🔄 Ordre des waypoints: ${optimizedRoute['waypoint_order']}');\r\n\r\n      // Test du temps de trajet\r\n      final travelTime = await _routeOptimizationPort.getTravelTime(\r\n        origin,\r\n        destination,\r\n      );\r\n\r\n      // Test d'évaluation d'un détour\r\n      final detourEvaluation = await _routeOptimizationPort.evaluateDetour(\r\n        origin,\r\n        destination,\r\n        waypoint,\r\n        Duration(minutes: 30),\r\n      );\r\n\r\n      _setSuccessState({\r\n        'testType': 'route_optimization',\r\n        'route': {\r\n          ...optimizedRoute,\r\n          'readable_distance': '${(optimizedRoute['distance'] / 1000).toStringAsFixed(2)} km',\r\n          'readable_duration': '${(optimizedRoute['duration'] / 60).toStringAsFixed(0)} minutes',\r\n        },\r\n        'travelTime': travelTime.inMinutes,\r\n        'detourEvaluation': detourEvaluation,\r\n      });\r\n    } catch (e) {\r\n      print('❌ Erreur dans le test d\\'optimisation des routes: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  // Future<void> testHalfDayTripGeneration() async {\r\n  //   _setLoadingState();\r\n  //\r\n  //   try {\r\n  //     print('🗓️ Test génération des half-day trips');\r\n  //\r\n  //     // Récupérer les informations du trip et de la ville de départ\r\n  //     final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n  //     final tripResponse = await _supabase\r\n  //         .from('trips')\r\n  //         .select('departure_city_id, cities!trips_departure_city_id_fkey(lat, lon, city_name), active_exploration_types')\r\n  //         .eq('id', tripId)\r\n  //         .single();\r\n  //\r\n  //     final departurePoint = LatLng(\r\n  //       tripResponse['cities']['lat'].toDouble(),\r\n  //       tripResponse['cities']['lon'].toDouble(),\r\n  //     );\r\n  //\r\n  //     // Pour ce test, on utilise le même point d'arrivée que de départ\r\n  //     final arrivalPoint = departurePoint;\r\n  //\r\n  //     // Récupérer les SuperWow\r\n  //     final superWows = await _superwowManagementPort.getTripSuperWows(tripId);\r\n  //     print('✅ ${superWows.length} SuperWow récupérés');\r\n  //\r\n  //     // Générer les half-day trips\r\n  //     final halfDayTrips = await _dailyTripGenerationPort.generateHalfDayTrips(\r\n  //       tripId: tripId,\r\n  //       superWows: superWows,\r\n  //       departurePoint: departurePoint,\r\n  //       arrivalPoint: arrivalPoint,\r\n  //     );\r\n  //\r\n  //     _setSuccessState({\r\n  //       'testType': 'half_day_generation',\r\n  //       'departureCity': tripResponse['cities']['city_name'],\r\n  //       'totalTrips': halfDayTrips.length,\r\n  //       'trips': halfDayTrips.map((trip) => {\r\n  //         'id': trip.id,\r\n  //         'distance': '${(trip.totalDistance / 1000).toStringAsFixed(2)} km',\r\n  //         'duration': '${trip.totalDuration.inMinutes} minutes',\r\n  //         'superWow': superWows\r\n  //             .firstWhere((sw) => sw.id == trip.superWowIds.first)\r\n  //             .activityData['name'],\r\n  //       }).toList(),\r\n  //     });\r\n  //\r\n  //   } catch (e) {\r\n  //     print('❌ Erreur dans le test de génération: $e');\r\n  //     _setErrorState(e);\r\n  //   }\r\n  // }\r\n  //\r\n  // Future<void> testFullDayTripGeneration() async {\r\n  //   _setLoadingState();\r\n  //\r\n  //   try {\r\n  //     print('🌞 Test génération des full-day trips');\r\n  //\r\n  //     // Récupérer les informations du trip et de la ville de départ\r\n  //     final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n  //     final tripResponse = await _supabase\r\n  //         .from('trips')\r\n  //         .select('departure_city_id, cities!trips_departure_city_id_fkey(lat, lon, city_name), active_exploration_types')\r\n  //         .eq('id', tripId)\r\n  //         .single();\r\n  //\r\n  //     final departurePoint = LatLng(\r\n  //       tripResponse['cities']['lat'].toDouble(),\r\n  //       tripResponse['cities']['lon'].toDouble(),\r\n  //     );\r\n  //\r\n  //     // Convertir le JSON en liste d'ExplorationType\r\n  //     final explorationTypes = (tripResponse['active_exploration_types'] as List)\r\n  //         .map((type) => ExplorationType.values.firstWhere(\r\n  //             (e) => e.value == type.toString(),\r\n  //         orElse: () => ExplorationType.around_me))\r\n  //         .toList();\r\n  //\r\n  //     // Obtenir les limites combinées\r\n  //     final (minTime, maxTime) = ExplorationTypeExtension.getCombinedTimeLimits(explorationTypes);\r\n  //     print('⏱️ Limites de temps combinées: $minTime-$maxTime minutes');\r\n  //\r\n  //     // Pour ce test, point d'arrivée = point de départ\r\n  //     final arrivalPoint = departurePoint;\r\n  //\r\n  //     // Récupérer les SuperWow\r\n  //     final superWows = await _superwowManagementPort.getTripSuperWows(tripId);\r\n  //     print('✅ ${superWows.length} SuperWow récupérés');\r\n  //\r\n  //     // Préférences horaires\r\n  //     final momentPreferences = {\r\n  //       \"evening\": false,\r\n  //       \"morning\": true,\r\n  //       \"afternoon\": true\r\n  //     };\r\n  //\r\n  //     // Générer les full-day trips\r\n  //\r\n  //     final fullDayTrips = await _dailyTripGenerationPort.generateFullDayTrips(\r\n  //       tripId: tripId,\r\n  //       superWows: superWows,\r\n  //       departurePoint: departurePoint,\r\n  //       arrivalPoint: arrivalPoint,\r\n  //       momentPreferences: momentPreferences,\r\n  //     );\r\n  //\r\n  //     _setSuccessState({\r\n  //       'testType': 'full_day_generation',\r\n  //       'departureCity': tripResponse['cities']['city_name'],\r\n  //       'totalTrips': fullDayTrips.length,\r\n  //       'trips': fullDayTrips.map((trip) => {\r\n  //         'id': trip.id,\r\n  //         'sw1': superWows.firstWhere((sw) => sw.id == trip.superWowIds[0]).activityData['name'],\r\n  //         'sw2': superWows.firstWhere((sw) => sw.id == trip.superWowIds[1]).activityData['name'],\r\n  //         'distance': '${(trip.totalDistance / 1000).toStringAsFixed(2)} km',\r\n  //         'duration': '${trip.totalDuration.inMinutes} minutes',\r\n  //       }).toList(),\r\n  //     });\r\n  //\r\n  //   } catch (e) {\r\n  //     print('❌ Erreur dans le test de génération full-day: $e');\r\n  //     _setErrorState(e);\r\n  //   }\r\n  // }\r\n\r\n  // Helper methods to manage state\r\n  void _setLoadingState() {\r\n    state = state.copyWith(isLoading: true, error: '', testResults: null);\r\n  }\r\n\r\n  void _setSuccessState(Map<String, dynamic> testResults) {\r\n    state = state.copyWith(isLoading: false, testResults: testResults);\r\n  }\r\n\r\n  void _setErrorState(dynamic error) {\r\n    state = state.copyWith(\r\n      isLoading: false,\r\n      error: error.toString(),\r\n    );\r\n  }\r\n}\r\n",
      "info": {
        "size": 19410,
        "last_modified": "2025-04-16T13:25:28.1519429",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\state\\trip_test_provider.dart",
      "content": "// features/trip/presentation/state/trip_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/domain/ports/providers/use_case_providers.dart';\r\nimport '../../../../core/domain/ports/providers/service_providers.dart';\r\nimport '../../../../core/domain/ports/providers/port_providers.dart';\r\nimport '../../../../core/domain/ports/providers/scoring_providers.dart';\r\nimport '../../../../core/domain/ports/providers/empty_trips/route_optimization.provider.dart';\r\nimport '../../../../core/domain/ports/providers/trip_activities_providers.dart';\r\nimport '../../../../core/domain/ports/providers/empty_trips/superwow_management.provider.dart';\r\nimport '../../../../core/domain/ports/providers/daily_trip_generation_provider.dart';\r\nimport 'trip_test_notifier.dart';\r\nimport 'trip_test_state.dart';\r\n\r\nfinal tripTestProvider = StateNotifierProvider<TripTestNotifier, TripTestState>((ref) {\r\n  final createTripUseCase = ref.watch(createTripUseCaseProvider);\r\n  final processActivitiesUseCase = ref.watch(processActivitiesUseCaseProvider);\r\n  final geocodingService = ref.watch(geocodingServiceProvider);\r\n  final activityHoursPort = ref.watch(activityHoursPortProvider);\r\n  final activityScoringPort = ref.watch(activityScoringPortProvider);\r\n  final routeOptimizationPort = ref.watch(routeOptimizationPortProvider);\r\n  final tripActivitiesPort = ref.watch(tripActivitiesPortProvider);\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final superwowManagementPort = ref.watch(superwowManagementPortProvider);\r\n\r\n  return TripTestNotifier(\r\n    createTripUseCase,\r\n    processActivitiesUseCase,\r\n    geocodingService,\r\n    activityHoursPort,\r\n    activityScoringPort,\r\n    routeOptimizationPort,\r\n    tripActivitiesPort,\r\n    supabase,\r\n    superwowManagementPort,\r\n  );\r\n});",
      "info": {
        "size": 1820,
        "last_modified": "2025-04-16T13:25:28.1584588",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\state\\trip_test_state.dart",
      "content": "// lib/features/trip/presentation/state/trip_test_state.dart\r\n\r\nclass TripTestState {\r\n  final bool isLoading;\r\n  final String error;\r\n  final Map<String, dynamic>? testResults;\r\n\r\n  TripTestState({\r\n    this.isLoading = false,\r\n    this.error = '',\r\n    this.testResults,\r\n  });\r\n\r\n  TripTestState copyWith({\r\n    bool? isLoading,\r\n    String? error,\r\n    Map<String, dynamic>? testResults,\r\n  }) {\r\n    return TripTestState(\r\n      isLoading: isLoading ?? this.isLoading,\r\n      error: error ?? this.error,\r\n      testResults: testResults ?? this.testResults,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 577,
        "last_modified": "2025-04-16T13:25:28.1649763",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "main.dart",
      "content": "import 'package:flutter/material.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\nimport 'features/home/presentation/pages/home_page.dart';\r\nimport 'features/trip/presentation/pages/trip_test_page.dart';\r\nimport 'features/empty_trips/presentation/pages/empty_trips_test_page.dart';\r\nimport '/core/adapters/supabase/database_adapter.dart';\r\nimport 'core/adapters/cache/hive_adapters.dart';\r\nimport 'core/theme/app_theme.dart';\r\nimport 'core/theme/app_colors.dart';\r\nimport 'core/theme/app_typography.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../core/domain/ports/providers/empty_trips/google_services_config.provider.dart';\r\nimport '../core/domain/services/google_services_config.dart';\r\nimport '../core/adapters/cache/hive_location_cache_adapter.dart';\r\n\r\nvoid main() async {\r\n  try {\r\n    WidgetsFlutterBinding.ensureInitialized();\r\n\r\n    // Initialisation de Hive pour le cache de localisation\r\n    await Hive.initFlutter();\r\n\r\n    // Enregistrement des adaptateurs pour les objets de localisation\r\n    if (!Hive.isAdapterRegistered(userLocationTypeId)) {\r\n      Hive.registerAdapter(UserLocationAdapter());\r\n    }\r\n    if (!Hive.isAdapterRegistered(placeDetailsTypeId)) {\r\n      Hive.registerAdapter(PlaceDetailsAdapter());\r\n    }\r\n    if (!Hive.isAdapterRegistered(placeSuggestionTypeId)) {\r\n      Hive.registerAdapter(PlaceSuggestionAdapter());\r\n    }\r\n\r\n    // Initialisation des boîtes Hive\r\n    final cacheAdapter = HiveLocationCacheAdapter();\r\n    await cacheAdapter.initializeAsync();\r\n    print('✅ Initialisation du cache Hive terminée au démarrage de l\\'application');\r\n\r\n    // Initialisations existantes\r\n    await dotenv.load(fileName: \".env\");\r\n    await SupabaseService.initialize();\r\n    final googleConfig = await GoogleServicesConfig.init();\r\n\r\n    runApp(\r\n        ProviderScope(\r\n            overrides: [\r\n              // Ajout de la surcharge ici\r\n              googleServicesConfigProvider.overrideWithValue(googleConfig),\r\n            ],\r\n            child: const MyApp()\r\n        )\r\n    );\r\n  } catch (e) {\r\n    print('Error initializing app: $e');\r\n  }\r\n}\r\n\r\nclass MyApp extends StatelessWidget {\r\n  const MyApp({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MaterialApp(\r\n      debugShowCheckedModeBanner: false,\r\n      theme: AppTheme.lightTheme(context),  // Utilise le thème clair complet\r\n      darkTheme: AppTheme.darkTheme(context),  // Ajoute le support du thème sombre\r\n      themeMode: ThemeMode.system,  // Ou ThemeMode.light si vous préférez forcer le thème clair\r\n      initialRoute: '/',\r\n      routes: {\r\n        '/': (context) => const HomePage(),\r\n        '/trip-test': (context) => const TripTestPage(),\r\n        '/empty-trips-test': (context) => const EmptyTripsTestPage(),\r\n      },\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2943,
        "last_modified": "2025-04-16T13:25:28.1932974",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    }
  ]
}