{
  "project_info": {
    "name": "lib",
    "path": "D:\\Dev\\LYRA_App\\travel_in_perigord_app\\lib",
    "generated_at": "2025-04-16T13:25:28.2002973",
    "total_files": 264,
    "total_size": 866820
  },
  "structure": {
    "core": {
      "adapters": {
        "cache": {
          "hive_adapters.dart": {
            "type": "file",
            "info": {
              "size": 3408,
              "last_modified": "2025-04-16T13:25:25.9531423",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "hive_location_cache_adapter.dart": {
            "type": "file",
            "info": {
              "size": 6485,
              "last_modified": "2025-04-16T13:25:25.9611649",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "google": {
          "google_ai_studio_service.dart": {
            "type": "file",
            "info": {
              "size": 2768,
              "last_modified": "2025-04-16T13:25:25.9734214",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "route_optimization.adapter.dart": {
            "type": "file",
            "info": {
              "size": 5910,
              "last_modified": "2025-04-16T13:25:25.9799279",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "google_maps": {
          "geocoding_adapter.dart": {
            "type": "file",
            "info": {
              "size": 1772,
              "last_modified": "2025-04-16T13:25:25.9924421",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "maps_adapter.dart": {
            "type": "file",
            "info": {
              "size": 9536,
              "last_modified": "2025-04-16T13:25:25.9999434",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "postgis": {
          "geometry_calculation.adapter.dart": {
            "type": "file",
            "info": {
              "size": 2336,
              "last_modified": "2025-04-16T13:25:26.0119739",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "processing": {
          "activity_hours_adapter.dart": {
            "type": "file",
            "info": {
              "size": 3369,
              "last_modified": "2025-04-16T13:25:26.0250855",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "filter_processing_adapter.dart": {
            "type": "file",
            "info": {
              "size": 1480,
              "last_modified": "2025-04-16T13:25:26.032191",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "supabase": {
          "activity_hours_adapter.dart": {
            "type": "file",
            "info": {
              "size": 2861,
              "last_modified": "2025-04-16T13:25:26.0452277",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_processing_adapter.dart": {
            "type": "file",
            "info": {
              "size": 5906,
              "last_modified": "2025-04-16T13:25:26.0522806",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_scoring_adapter.dart": {
            "type": "file",
            "info": {
              "size": 5177,
              "last_modified": "2025-04-16T13:25:26.0598614",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "config": {
            "remote_config_adapter.dart": {
              "type": "file",
              "info": {
                "size": 4559,
                "last_modified": "2025-04-16T13:25:26.0663808",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "database_adapter.dart": {
            "type": "file",
            "info": {
              "size": 2837,
              "last_modified": "2025-04-16T13:25:26.0789174",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_daily_trip.adapter.dart": {
            "type": "file",
            "info": {
              "size": 3738,
              "last_modified": "2025-04-16T13:25:26.0861912",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_trip_repository.adapter.dart": {
            "type": "file",
            "info": {
              "size": 0,
              "last_modified": "2025-04-16T13:25:26.0932307",
              "mime_type": "application/octet-stream",
              "extension": ".dart"
            }
          },
          "potential_bonus_activity.adapter.dart": {
            "type": "file",
            "info": {
              "size": 2290,
              "last_modified": "2025-04-16T13:25:26.0992299",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "search": {
            "activity_details_adapter.dart": {
              "type": "file",
              "info": {
                "size": 3732,
                "last_modified": "2025-04-16T13:25:26.1063494",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_search_adapter.dart": {
              "type": "file",
              "info": {
                "size": 2510,
                "last_modified": "2025-04-16T13:25:26.1138932",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_cache_adapter.dart": {
              "type": "file",
              "info": {
                "size": 3264,
                "last_modified": "2025-04-16T13:25:26.1209363",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_search_adapter.dart": {
              "type": "file",
              "info": {
                "size": 1278,
                "last_modified": "2025-04-16T13:25:26.1280307",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_search_adapter.dart": {
              "type": "file",
              "info": {
                "size": 1392,
                "last_modified": "2025-04-16T13:25:26.1350733",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "superwow_management.adapter.dart": {
            "type": "file",
            "info": {
              "size": 9684,
              "last_modified": "2025-04-16T13:25:26.1471131",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_activities_adapter.dart": {
            "type": "file",
            "info": {
              "size": 3766,
              "last_modified": "2025-04-16T13:25:26.1531596",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "trip": {
          "trip_adapter.dart": {
            "type": "file",
            "info": {
              "size": 2933,
              "last_modified": "2025-04-16T13:25:26.1657116",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        }
      },
      "common": {
        "constants": {
          "geometry_constants.dart": {
            "type": "file",
            "info": {
              "size": 701,
              "last_modified": "2025-04-16T13:25:26.1827906",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location_constants.dart": {
            "type": "file",
            "info": {
              "size": 1847,
              "last_modified": "2025-04-16T13:25:26.1887908",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "subcategory_icons.dart": {
            "type": "file",
            "info": {
              "size": 1334,
              "last_modified": "2025-04-16T13:25:26.1953039",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_constants.dart": {
            "type": "file",
            "info": {
              "size": 886,
              "last_modified": "2025-04-16T13:25:26.2023369",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "enums": {
          "trip_enums.dart": {
            "type": "file",
            "info": {
              "size": 4680,
              "last_modified": "2025-04-16T13:25:26.2139049",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "exceptions": {
          "calculation_exception.dart": {
            "type": "file",
            "info": {
              "size": 249,
              "last_modified": "2025-04-16T13:25:26.2260226",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "domain_exception.dart": {
            "type": "file",
            "info": {
              "size": 51,
              "last_modified": "2025-04-16T13:25:26.2320717",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_trip_generation_exception.dart": {
            "type": "file",
            "info": {
              "size": 285,
              "last_modified": "2025-04-16T13:25:26.2380712",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "exceptions.dart": {
            "type": "file",
            "info": {
              "size": 423,
              "last_modified": "2025-04-16T13:25:26.245109",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "geometry_calculation_exception.dart": {
            "type": "file",
            "info": {
              "size": 282,
              "last_modified": "2025-04-16T13:25:26.2511463",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "google_api_exception.dart": {
            "type": "file",
            "info": {
              "size": 244,
              "last_modified": "2025-04-16T13:25:26.2576625",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location_exceptions.dart": {
            "type": "file",
            "info": {
              "size": 1271,
              "last_modified": "2025-04-16T13:25:26.2647133",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "route_optimization_exceptions.dart": {
            "type": "file",
            "info": {
              "size": 978,
              "last_modified": "2025-04-16T13:25:26.2712318",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "scoring_exceptions.dart": {
            "type": "file",
            "info": {
              "size": 556,
              "last_modified": "2025-04-16T13:25:26.2782924",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_exception.dart": {
            "type": "file",
            "info": {
              "size": 1153,
              "last_modified": "2025-04-16T13:25:26.2853486",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "utils": {
          "activity_mapper.dart": {
            "type": "file",
            "info": {
              "size": 1032,
              "last_modified": "2025-04-16T13:25:26.2983904",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "date_formatter.dart": {
            "type": "file",
            "info": {
              "size": 1144,
              "last_modified": "2025-04-16T13:25:26.3049075",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "debouncer.dart": {
            "type": "file",
            "info": {
              "size": 519,
              "last_modified": "2025-04-16T13:25:26.3119405",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "geohash.dart": {
            "type": "file",
            "info": {
              "size": 3461,
              "last_modified": "2025-04-16T13:25:26.3179398",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "geo_utils.dart": {
            "type": "file",
            "info": {
              "size": 844,
              "last_modified": "2025-04-16T13:25:26.3245397",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location_formatter.dart": {
            "type": "file",
            "info": {
              "size": 1233,
              "last_modified": "2025-04-16T13:25:26.3310441",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "maps_toolkit_utils.dart": {
            "type": "file",
            "info": {
              "size": 2041,
              "last_modified": "2025-04-16T13:25:26.3370458",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        }
      },
      "domain": {
        "filters": {
          "activity_filter.dart": {
            "type": "file",
            "info": {
              "size": 282,
              "last_modified": "2025-04-16T13:25:26.3551255",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "filter_chain.dart": {
            "type": "file",
            "info": {
              "size": 535,
              "last_modified": "2025-04-16T13:25:26.3611586",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "time_filter.dart": {
            "type": "file",
            "info": {
              "size": 4864,
              "last_modified": "2025-04-16T13:25:26.3686755",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "travel_group_filter.dart": {
            "type": "file",
            "info": {
              "size": 2299,
              "last_modified": "2025-04-16T13:25:26.3742753",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "models": {
          "activity": {
            "base": {
              "activity_base.dart": {
                "type": "file",
                "info": {
                  "size": 1646,
                  "last_modified": "2025-04-16T13:25:26.3863119",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_base.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 16922,
                  "last_modified": "2025-04-16T13:25:26.3933505",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_base.g.dart": {
                "type": "file",
                "info": {
                  "size": 1952,
                  "last_modified": "2025-04-16T13:25:26.4003507",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_interface.dart": {
                "type": "file",
                "info": {
                  "size": 0,
                  "last_modified": "2025-04-16T13:25:26.4074492",
                  "mime_type": "application/octet-stream",
                  "extension": ".dart"
                }
              }
            },
            "search": {
              "searchable_activity.dart": {
                "type": "file",
                "info": {
                  "size": 2748,
                  "last_modified": "2025-04-16T13:25:26.4199672",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "searchable_activity.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 16211,
                  "last_modified": "2025-04-16T13:25:26.4271204",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "searchable_activity.g.dart": {
                "type": "file",
                "info": {
                  "size": 1868,
                  "last_modified": "2025-04-16T13:25:26.4331639",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "search_result.dart": {
                "type": "file",
                "info": {
                  "size": 0,
                  "last_modified": "2025-04-16T13:25:26.4411855",
                  "mime_type": "application/octet-stream",
                  "extension": ".dart"
                }
              }
            },
            "trip": {
              "trip_activity.dart": {
                "type": "file",
                "info": {
                  "size": 0,
                  "last_modified": "2025-04-16T13:25:26.4524634",
                  "mime_type": "application/octet-stream",
                  "extension": ".dart"
                }
              }
            }
          },
          "common_models.dart": {
            "type": "file",
            "info": {
              "size": 651,
              "last_modified": "2025-04-16T13:25:26.4689854",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "config": {
            "app_remote_config.dart": {
              "type": "file",
              "info": {
                "size": 510,
                "last_modified": "2025-04-16T13:25:26.4750017",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "app_remote_config.freezed.dart": {
              "type": "file",
              "info": {
                "size": 7004,
                "last_modified": "2025-04-16T13:25:26.4813668",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "app_remote_config.g.dart": {
              "type": "file",
              "info": {
                "size": 737,
                "last_modified": "2025-04-16T13:25:26.4873663",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_section_config.dart": {
              "type": "file",
              "info": {
                "size": 626,
                "last_modified": "2025-04-16T13:25:26.4938776",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_section_config.freezed.dart": {
              "type": "file",
              "info": {
                "size": 9286,
                "last_modified": "2025-04-16T13:25:26.4998818",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_section_config.g.dart": {
              "type": "file",
              "info": {
                "size": 1013,
                "last_modified": "2025-04-16T13:25:26.5064233",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_section_config.dart": {
              "type": "file",
              "info": {
                "size": 823,
                "last_modified": "2025-04-16T13:25:26.5129588",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_section_config.freezed.dart": {
              "type": "file",
              "info": {
                "size": 10804,
                "last_modified": "2025-04-16T13:25:26.5199506",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_section_config.g.dart": {
              "type": "file",
              "info": {
                "size": 1172,
                "last_modified": "2025-04-16T13:25:26.5260721",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "location": {
            "place_details.dart": {
              "type": "file",
              "info": {
                "size": 693,
                "last_modified": "2025-04-16T13:25:26.5397168",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details.freezed.dart": {
              "type": "file",
              "info": {
                "size": 12172,
                "last_modified": "2025-04-16T13:25:26.5462389",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details.g.dart": {
              "type": "file",
              "info": {
                "size": 1408,
                "last_modified": "2025-04-16T13:25:26.5522903",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_suggestion.dart": {
              "type": "file",
              "info": {
                "size": 557,
                "last_modified": "2025-04-16T13:25:26.5603338",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_suggestion.freezed.dart": {
              "type": "file",
              "info": {
                "size": 8041,
                "last_modified": "2025-04-16T13:25:26.5659497",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_suggestion.g.dart": {
              "type": "file",
              "info": {
                "size": 887,
                "last_modified": "2025-04-16T13:25:26.5732041",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "user_location.dart": {
              "type": "file",
              "info": {
                "size": 548,
                "last_modified": "2025-04-16T13:25:26.5792556",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "user_location.freezed.dart": {
              "type": "file",
              "info": {
                "size": 8457,
                "last_modified": "2025-04-16T13:25:26.5863596",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "user_location.g.dart": {
              "type": "file",
              "info": {
                "size": 1025,
                "last_modified": "2025-04-16T13:25:26.5928727",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "opening_days.dart": {
            "type": "file",
            "info": {
              "size": 989,
              "last_modified": "2025-04-16T13:25:26.6052047",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "scored_activity.dart": {
            "type": "file",
            "info": {
              "size": 1165,
              "last_modified": "2025-04-16T13:25:26.611339",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "shared": {
            "activity_details_model.dart": {
              "type": "file",
              "info": {
                "size": 1441,
                "last_modified": "2025-04-16T13:25:26.6183424",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_details_model.freezed.dart": {
              "type": "file",
              "info": {
                "size": 23571,
                "last_modified": "2025-04-16T13:25:26.6259152",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_details_model.g.dart": {
              "type": "file",
              "info": {
                "size": 2751,
                "last_modified": "2025-04-16T13:25:26.6322028",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_image_model.dart": {
              "type": "file",
              "info": {
                "size": 480,
                "last_modified": "2025-04-16T13:25:26.6382038",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_image_model.freezed.dart": {
              "type": "file",
              "info": {
                "size": 6705,
                "last_modified": "2025-04-16T13:25:26.6452314",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_image_model.g.dart": {
              "type": "file",
              "info": {
                "size": 706,
                "last_modified": "2025-04-16T13:25:26.6514762",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_model.dart": {
              "type": "file",
              "info": {
                "size": 2695,
                "last_modified": "2025-04-16T13:25:26.6585215",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_model.dart": {
              "type": "file",
              "info": {
                "size": 533,
                "last_modified": "2025-04-16T13:25:26.6655501",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_model.freezed.dart": {
              "type": "file",
              "info": {
                "size": 8065,
                "last_modified": "2025-04-16T13:25:26.6720657",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_model.g.dart": {
              "type": "file",
              "info": {
                "size": 848,
                "last_modified": "2025-04-16T13:25:26.6781519",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "trip_designer": {
            "bonus_activities": {
              "potential_bonus_activity.dart": {
                "type": "file",
                "info": {
                  "size": 1642,
                  "last_modified": "2025-04-16T13:25:26.6912315",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "value_objects": {
                "malus_vol_oiseau.dart": {
                  "type": "file",
                  "info": {
                    "size": 527,
                    "last_modified": "2025-04-16T13:25:26.6982164",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "malus_vol_oiseau.freezed.dart": {
                  "type": "file",
                  "info": {
                    "size": 4847,
                    "last_modified": "2025-04-16T13:25:26.7052579",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              }
            },
            "empty_trips": {
              "empty_daily_trip.dart": {
                "type": "file",
                "info": {
                  "size": 1583,
                  "last_modified": "2025-04-16T13:25:26.7232034",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "value_objects": {
                "generation_result.dart": {
                  "type": "file",
                  "info": {
                    "size": 553,
                    "last_modified": "2025-04-16T13:25:26.7302694",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "generation_result.freezed.dart": {
                  "type": "file",
                  "info": {
                    "size": 9186,
                    "last_modified": "2025-04-16T13:25:26.736305",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "superwow_pair.dart": {
                  "type": "file",
                  "info": {
                    "size": 953,
                    "last_modified": "2025-04-16T13:25:26.7433327",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              }
            },
            "processing": {
              "activity_processing_model.dart": {
                "type": "file",
                "info": {
                  "size": 4756,
                  "last_modified": "2025-04-16T13:25:26.7602682",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "scoring": {
              "scoring_activity.dart": {
                "type": "file",
                "info": {
                  "size": 1501,
                  "last_modified": "2025-04-16T13:25:26.771813",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "scoring_config.dart": {
                "type": "file",
                "info": {
                  "size": 417,
                  "last_modified": "2025-04-16T13:25:26.779322",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "scoring_result.dart": {
                "type": "file",
                "info": {
                  "size": 1364,
                  "last_modified": "2025-04-16T13:25:26.7853661",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "trip": {
              "activity_model.dart": {
                "type": "file",
                "info": {
                  "size": 4505,
                  "last_modified": "2025-04-16T13:25:26.7968726",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "daily_trip.dart": {
                "type": "file",
                "info": {
                  "size": 2057,
                  "last_modified": "2025-04-16T13:25:26.8039295",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "trip_model.dart": {
                "type": "file",
                "info": {
                  "size": 6627,
                  "last_modified": "2025-04-16T13:25:26.8099481",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            }
          }
        },
        "ports": {
          "activity_hours_port.dart": {
            "type": "file",
            "info": {
              "size": 330,
              "last_modified": "2025-04-16T13:25:26.8334856",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_processing_port.dart": {
            "type": "file",
            "info": {
              "size": 929,
              "last_modified": "2025-04-16T13:25:26.8384878",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "activity_scoring_port.dart": {
            "type": "file",
            "info": {
              "size": 404,
              "last_modified": "2025-04-16T13:25:26.8459997",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "config": {
            "remote_config_port.dart": {
              "type": "file",
              "info": {
                "size": 478,
                "last_modified": "2025-04-16T13:25:26.8515074",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "daily_trip_generation_port.dart": {
            "type": "file",
            "info": {
              "size": 727,
              "last_modified": "2025-04-16T13:25:26.8637022",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "distance_calculation_port.dart": {
            "type": "file",
            "info": {
              "size": 346,
              "last_modified": "2025-04-16T13:25:26.8702111",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "empty_trips": {
            "available_time_calculation.port.dart": {
              "type": "file",
              "info": {
                "size": 834,
                "last_modified": "2025-04-16T13:25:26.8762728",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "bonus_activities_cache.port.dart": {
              "type": "file",
              "info": {
                "size": 350,
                "last_modified": "2025-04-16T13:25:26.8827789",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "empty_daily_trip.port.dart": {
              "type": "file",
              "info": {
                "size": 1055,
                "last_modified": "2025-04-16T13:25:26.8887828",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "empty_trip_repository.port.dart": {
              "type": "file",
              "info": {
                "size": 68,
                "last_modified": "2025-04-16T13:25:26.8952975",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "geometry_calculation.port.dart": {
              "type": "file",
              "info": {
                "size": 474,
                "last_modified": "2025-04-16T13:25:26.9023451",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "neighbor_geohashes.port.dart": {
              "type": "file",
              "info": {
                "size": 330,
                "last_modified": "2025-04-16T13:25:26.9084206",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "potential_activities.port.dart": {
              "type": "file",
              "info": {
                "size": 456,
                "last_modified": "2025-04-16T13:25:26.9149334",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "route_optimization.port.dart": {
              "type": "file",
              "info": {
                "size": 840,
                "last_modified": "2025-04-16T13:25:26.9289502",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "superwow_management.port.dart": {
              "type": "file",
              "info": {
                "size": 821,
                "last_modified": "2025-04-16T13:25:26.9354588",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "geocoding_port.dart": {
            "type": "file",
            "info": {
              "size": 232,
              "last_modified": "2025-04-16T13:25:26.9469668",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location": {
            "city_cache_port.dart": {
              "type": "file",
              "info": {
                "size": 830,
                "last_modified": "2025-04-16T13:25:26.9534755",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "geolocation_port.dart": {
              "type": "file",
              "info": {
                "size": 518,
                "last_modified": "2025-04-16T13:25:26.9604842",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "location_cache_port.dart": {
              "type": "file",
              "info": {
                "size": 940,
                "last_modified": "2025-04-16T13:25:26.9659934",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_port.dart": {
              "type": "file",
              "info": {
                "size": 325,
                "last_modified": "2025-04-16T13:25:26.9740084",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_port.dart": {
              "type": "file",
              "info": {
                "size": 465,
                "last_modified": "2025-04-16T13:25:26.9805119",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "maps_port.dart": {
            "type": "file",
            "info": {
              "size": 432,
              "last_modified": "2025-04-16T13:25:26.9920234",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "providers": {
            "config": {
              "remote_config_provider.dart": {
                "type": "file",
                "info": {
                  "size": 1583,
                  "last_modified": "2025-04-16T13:25:26.999026",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "daily_trip_generation_provider.dart": {
              "type": "file",
              "info": {
                "size": 844,
                "last_modified": "2025-04-16T13:25:27.0105446",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "empty_trips": {
              "bonus_activities.providers.dart": {
                "type": "file",
                "info": {
                  "size": 2864,
                  "last_modified": "2025-04-16T13:25:27.0165513",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "bonus_activities_cache.provider.dart": {
                "type": "file",
                "info": {
                  "size": 475,
                  "last_modified": "2025-04-16T13:25:27.0235609",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "distance_calculation_provider.dart": {
                "type": "file",
                "info": {
                  "size": 357,
                  "last_modified": "2025-04-16T13:25:27.0300684",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_daily_trip.provider.dart": {
                "type": "file",
                "info": {
                  "size": 480,
                  "last_modified": "2025-04-16T13:25:27.0360733",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation.provider.dart": {
                "type": "file",
                "info": {
                  "size": 1006,
                  "last_modified": "2025-04-16T13:25:27.0420908",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "geometry_calculation.provider.dart": {
                "type": "file",
                "info": {
                  "size": 515,
                  "last_modified": "2025-04-16T13:25:27.0490911",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "google_ai_studio.provider.dart": {
                "type": "file",
                "info": {
                  "size": 552,
                  "last_modified": "2025-04-16T13:25:27.054595",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "google_services_config.provider.dart": {
                "type": "file",
                "info": {
                  "size": 354,
                  "last_modified": "2025-04-16T13:25:27.0616071",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "neighbor_geohashes.provider.dart": {
                "type": "file",
                "info": {
                  "size": 456,
                  "last_modified": "2025-04-16T13:25:27.0671124",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "potential_activities.provider.dart": {
                "type": "file",
                "info": {
                  "size": 466,
                  "last_modified": "2025-04-16T13:25:27.0741319",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization.provider.dart": {
                "type": "file",
                "info": {
                  "size": 734,
                  "last_modified": "2025-04-16T13:25:27.0811966",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "superwow_management.provider.dart": {
                "type": "file",
                "info": {
                  "size": 875,
                  "last_modified": "2025-04-16T13:25:27.0871977",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "infrastructure_providers.dart": {
              "type": "file",
              "info": {
                "size": 280,
                "last_modified": "2025-04-16T13:25:27.0992589",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "location": {
              "location_providers.dart": {
                "type": "file",
                "info": {
                  "size": 3710,
                  "last_modified": "2025-04-16T13:25:27.1052975",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "port_providers.dart": {
              "type": "file",
              "info": {
                "size": 1079,
                "last_modified": "2025-04-16T13:25:27.1173144",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "scoring_providers.dart": {
              "type": "file",
              "info": {
                "size": 579,
                "last_modified": "2025-04-16T13:25:27.1233235",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "search": {
              "activity_distances_provider.dart": {
                "type": "file",
                "info": {
                  "size": 1556,
                  "last_modified": "2025-04-16T13:25:27.1303275",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "distance_providers.dart": {
                "type": "file",
                "info": {
                  "size": 371,
                  "last_modified": "2025-04-16T13:25:27.1358348",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "subcategory_search_provider.dart": {
                "type": "file",
                "info": {
                  "size": 722,
                  "last_modified": "2025-04-16T13:25:27.1433415",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "service_providers.dart": {
              "type": "file",
              "info": {
                "size": 1004,
                "last_modified": "2025-04-16T13:25:27.1548492",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "trip_activities_providers.dart": {
              "type": "file",
              "info": {
                "size": 454,
                "last_modified": "2025-04-16T13:25:27.1608581",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "use_case_providers.dart": {
              "type": "file",
              "info": {
                "size": 735,
                "last_modified": "2025-04-16T13:25:27.1663668",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "search": {
            "activity_details_port.dart": {
              "type": "file",
              "info": {
                "size": 250,
                "last_modified": "2025-04-16T13:25:27.1783814",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_distance_calculation_port.dart": {
              "type": "file",
              "info": {
                "size": 460,
                "last_modified": "2025-04-16T13:25:27.1848912",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_search_port.dart": {
              "type": "file",
              "info": {
                "size": 675,
                "last_modified": "2025-04-16T13:25:27.1913967",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_search_port.dart": {
              "type": "file",
              "info": {
                "size": 227,
                "last_modified": "2025-04-16T13:25:27.1983993",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_search_port.dart": {
              "type": "file",
              "info": {
                "size": 217,
                "last_modified": "2025-04-16T13:25:27.2049068",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "trip_activities_port.dart": {
            "type": "file",
            "info": {
              "size": 359,
              "last_modified": "2025-04-16T13:25:27.2159241",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_port.dart": {
            "type": "file",
            "info": {
              "size": 599,
              "last_modified": "2025-04-16T13:25:27.2229317",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "services": {
          "designer": {
            "empty_trips": {
              "available_time_calculation.service.dart": {
                "type": "file",
                "info": {
                  "size": 8987,
                  "last_modified": "2025-04-16T13:25:27.234443",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "bonus_activities_cache.service.dart": {
                "type": "file",
                "info": {
                  "size": 1893,
                  "last_modified": "2025-04-16T13:25:27.2409504",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "bonus_activity_generation.service.dart": {
                "type": "file",
                "info": {
                  "size": 4244,
                  "last_modified": "2025-04-16T13:25:27.2469497",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "distance_calculation.service.dart": {
                "type": "file",
                "info": {
                  "size": 4333,
                  "last_modified": "2025-04-16T13:25:27.2534555",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation.service.dart": {
                "type": "file",
                "info": {
                  "size": 7477,
                  "last_modified": "2025-04-16T13:25:27.2599605",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "neighbor_geohashes.service.dart": {
                "type": "file",
                "info": {
                  "size": 2725,
                  "last_modified": "2025-04-16T13:25:27.2665166",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "notifier": {
                "potential_bonus_activities.notifier.dart": {
                  "type": "file",
                  "info": {
                    "size": 2030,
                    "last_modified": "2025-04-16T13:25:27.2730234",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              },
              "potential_activities.service.dart": {
                "type": "file",
                "info": {
                  "size": 2776,
                  "last_modified": "2025-04-16T13:25:27.2840375",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "trip_distance_service.dart": {
              "type": "file",
              "info": {
                "size": 1151,
                "last_modified": "2025-04-16T13:25:27.2960534",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "google_services_config.dart": {
            "type": "file",
            "info": {
              "size": 567,
              "last_modified": "2025-04-16T13:25:27.3077319",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "location": {
            "enhanced_location_service.dart": {
              "type": "file",
              "info": {
                "size": 6000,
                "last_modified": "2025-04-16T13:25:27.3142422",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "location_service.dart": {
            "type": "file",
            "info": {
              "size": 1445,
              "last_modified": "2025-04-16T13:25:27.3262555",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "scoring_service.dart": {
            "type": "file",
            "info": {
              "size": 1162,
              "last_modified": "2025-04-16T13:25:27.3317613",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "search": {
            "activity_distance_service.dart": {
              "type": "file",
              "info": {
                "size": 1407,
                "last_modified": "2025-04-16T13:25:27.3387664",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "shared": {
            "external_launcher_service.dart": {
              "type": "file",
              "info": {
                "size": 3249,
                "last_modified": "2025-04-16T13:25:27.350273",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "travel_time_service.dart": {
            "type": "file",
            "info": {
              "size": 1859,
              "last_modified": "2025-04-16T13:25:27.361795",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "trip_service.dart": {
            "type": "file",
            "info": {
              "size": 3773,
              "last_modified": "2025-04-16T13:25:27.3683014",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "use_cases": {
          "create_trip_use_case.dart": {
            "type": "file",
            "info": {
              "size": 2086,
              "last_modified": "2025-04-16T13:25:27.379313",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "process_activities_use_case.dart": {
            "type": "file",
            "info": {
              "size": 1686,
              "last_modified": "2025-04-16T13:25:27.3858231",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "search": {
            "get_activities_use_case.dart": {
              "type": "file",
              "info": {
                "size": 2489,
                "last_modified": "2025-04-16T13:25:27.3923381",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      },
      "theme": {
        "animations": {
          "ripple_animation.dart": {
            "type": "file",
            "info": {
              "size": 2904,
              "last_modified": "2025-04-16T13:25:27.4170352",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        },
        "app_colors.dart": {
          "type": "file",
          "info": {
            "size": 7061,
            "last_modified": "2025-04-16T13:25:27.4291754",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_dimensions.dart": {
          "type": "file",
          "info": {
            "size": 9281,
            "last_modified": "2025-04-16T13:25:27.4366898",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_filters.dart": {
          "type": "file",
          "info": {
            "size": 485,
            "last_modified": "2025-04-16T13:25:27.4432061",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_fonts.dart": {
          "type": "file",
          "info": {
            "size": 5162,
            "last_modified": "2025-04-16T13:25:27.4492059",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_interactions.dart": {
          "type": "file",
          "info": {
            "size": 7337,
            "last_modified": "2025-04-16T13:25:27.4553447",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_theme.dart": {
          "type": "file",
          "info": {
            "size": 9944,
            "last_modified": "2025-04-16T13:25:27.4623739",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "app_typography.dart": {
          "type": "file",
          "info": {
            "size": 9142,
            "last_modified": "2025-04-16T13:25:27.4684179",
            "mime_type": "text/plain",
            "extension": ".dart"
          }
        },
        "atoms": {
          "app_button.dart": {
            "type": "file",
            "info": {
              "size": 13760,
              "last_modified": "2025-04-16T13:25:27.4749708",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "app_card.dart": {
            "type": "file",
            "info": {
              "size": 37,
              "last_modified": "2025-04-16T13:25:27.4820061",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "app_input.dart": {
            "type": "file",
            "info": {
              "size": 17923,
              "last_modified": "2025-04-16T13:25:27.4880056",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          },
          "app_text.dart": {
            "type": "file",
            "info": {
              "size": 8633,
              "last_modified": "2025-04-16T13:25:27.4950423",
              "mime_type": "text/plain",
              "extension": ".dart"
            }
          }
        }
      }
    },
    "features": {
      "empty_trips": {
        "presentation": {
          "pages": {
            "empty_trips_test_page.dart": {
              "type": "file",
              "info": {
                "size": 20331,
                "last_modified": "2025-04-16T13:25:27.5172739",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "state": {
            "test": {
              "available_time_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 12081,
                  "last_modified": "2025-04-16T13:25:27.5288549",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "available_time_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 2073,
                  "last_modified": "2025-04-16T13:25:27.5353717",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "available_time_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 552,
                  "last_modified": "2025-04-16T13:25:27.5424124",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "available_time_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18575,
                  "last_modified": "2025-04-16T13:25:27.5484124",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 3500,
                  "last_modified": "2025-04-16T13:25:27.5549292",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 702,
                  "last_modified": "2025-04-16T13:25:27.5619644",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 525,
                  "last_modified": "2025-04-16T13:25:27.5684818",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trips_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18469,
                  "last_modified": "2025-04-16T13:25:27.5752006",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 2269,
                  "last_modified": "2025-04-16T13:25:27.5812704",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 858,
                  "last_modified": "2025-04-16T13:25:27.5872711",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 660,
                  "last_modified": "2025-04-16T13:25:27.5943078",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "empty_trip_generation_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18966,
                  "last_modified": "2025-04-16T13:25:27.6003077",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_notifier.dart": {
                "type": "file",
                "info": {
                  "size": 2208,
                  "last_modified": "2025-04-16T13:25:27.607416",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_provider.dart": {
                "type": "file",
                "info": {
                  "size": 604,
                  "last_modified": "2025-04-16T13:25:27.6129334",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_state.dart": {
                "type": "file",
                "info": {
                  "size": 624,
                  "last_modified": "2025-04-16T13:25:27.6199336",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "route_optimization_test_state.freezed.dart": {
                "type": "file",
                "info": {
                  "size": 18888,
                  "last_modified": "2025-04-16T13:25:27.6260997",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            }
          }
        }
      },
      "home": {
        "presentation": {
          "pages": {
            "home_page.dart": {
              "type": "file",
              "info": {
                "size": 3653,
                "last_modified": "2025-04-16T13:25:27.6552136",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "widgets": {
            "navigation": {
              "city_picker.dart": {
                "type": "file",
                "info": {
                  "size": 2289,
                  "last_modified": "2025-04-16T13:25:27.6664384",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "city_picker_modal.dart": {
                "type": "file",
                "info": {
                  "size": 10386,
                  "last_modified": "2025-04-16T13:25:27.6729551",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "lyra_footer.dart": {
                "type": "file",
                "info": {
                  "size": 3455,
                  "last_modified": "2025-04-16T13:25:27.6799914",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "lyra_header.dart": {
                "type": "file",
                "info": {
                  "size": 4143,
                  "last_modified": "2025-04-16T13:25:27.6865065",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "lyra_navigation.dart": {
                "type": "file",
                "info": {
                  "size": 1912,
                  "last_modified": "2025-04-16T13:25:27.6930227",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "subcategories_list.dart": {
                "type": "file",
                "info": {
                  "size": 6548,
                  "last_modified": "2025-04-16T13:25:27.6990228",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            }
          }
        }
      },
      "search": {
        "application": {
          "services": {
            "city_selection_service.dart": {
              "type": "file",
              "info": {
                "size": 2750,
                "last_modified": "2025-04-16T13:25:27.7271696",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "state": {
            "activity_details_state.dart": {
              "type": "file",
              "info": {
                "size": 1938,
                "last_modified": "2025-04-16T13:25:27.7397191",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "activity_details_state.freezed.dart": {
              "type": "file",
              "info": {
                "size": 18644,
                "last_modified": "2025-04-16T13:25:27.746252",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "city_search_provider.dart": {
              "type": "file",
              "info": {
                "size": 951,
                "last_modified": "2025-04-16T13:25:27.7532897",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "home_activities_state.dart": {
              "type": "file",
              "info": {
                "size": 2319,
                "last_modified": "2025-04-16T13:25:27.7603436",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_notifier.dart": {
              "type": "file",
              "info": {
                "size": 2190,
                "last_modified": "2025-04-16T13:25:27.7663754",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_state.dart": {
              "type": "file",
              "info": {
                "size": 613,
                "last_modified": "2025-04-16T13:25:27.7729582",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_details_state.freezed.dart": {
              "type": "file",
              "info": {
                "size": 18520,
                "last_modified": "2025-04-16T13:25:27.7789672",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_notifier.dart": {
              "type": "file",
              "info": {
                "size": 1987,
                "last_modified": "2025-04-16T13:25:27.7860215",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_state.dart": {
              "type": "file",
              "info": {
                "size": 634,
                "last_modified": "2025-04-16T13:25:27.7920848",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "place_search_state.freezed.dart": {
              "type": "file",
              "info": {
                "size": 23503,
                "last_modified": "2025-04-16T13:25:27.7980843",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "section_activities_provider.dart": {
              "type": "file",
              "info": {
                "size": 2053,
                "last_modified": "2025-04-16T13:25:27.8051323",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "selected_city_state.dart": {
              "type": "file",
              "info": {
                "size": 243,
                "last_modified": "2025-04-16T13:25:27.8122688",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "selected_subcategory_state.dart": {
              "type": "file",
              "info": {
                "size": 607,
                "last_modified": "2025-04-16T13:25:27.818269",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "subcategory_activities_state.dart": {
              "type": "file",
              "info": {
                "size": 3061,
                "last_modified": "2025-04-16T13:25:27.8249546",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        },
        "domain": {
          "providers": {
            "search_providers.dart": {
              "type": "file",
              "info": {
                "size": 823,
                "last_modified": "2025-04-16T13:25:27.8419848",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        },
        "presentation": {
          "pages": {
            "subcategory_page.dart": {
              "type": "file",
              "info": {
                "size": 2548,
                "last_modified": "2025-04-16T13:25:27.8585798",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "widgets": {
            "location": {
              "current_location_button.dart": {
                "type": "file",
                "info": {
                  "size": 1763,
                  "last_modified": "2025-04-16T13:25:27.8711264",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "location_search_bar.dart": {
                "type": "file",
                "info": {
                  "size": 5320,
                  "last_modified": "2025-04-16T13:25:27.878189",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "location_suggestions_list.dart": {
                "type": "file",
                "info": {
                  "size": 6357,
                  "last_modified": "2025-04-16T13:25:27.8842249",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "subcategory_sections_view.dart": {
              "type": "file",
              "info": {
                "size": 3713,
                "last_modified": "2025-04-16T13:25:27.8962643",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      },
      "shared_ui": {
        "presentation": {
          "pages": {
            "activity_details_page.dart": {
              "type": "file",
              "info": {
                "size": 3806,
                "last_modified": "2025-04-16T13:25:27.918456",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "widgets": {
            "activity_details": {
              "activity_details_content.dart": {
                "type": "file",
                "info": {
                  "size": 1817,
                  "last_modified": "2025-04-16T13:25:27.9320423",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "sections": {
                "description_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 2309,
                    "last_modified": "2025-04-16T13:25:27.938045",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "info_buttons_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 4168,
                    "last_modified": "2025-04-16T13:25:27.9440823",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "info_icons_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 3633,
                    "last_modified": "2025-04-16T13:25:27.9511214",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "location_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 2270,
                    "last_modified": "2025-04-16T13:25:27.9571559",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "schedule_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 4381,
                    "last_modified": "2025-04-16T13:25:27.9631871",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                },
                "title_section.dart": {
                  "type": "file",
                  "info": {
                    "size": 788,
                    "last_modified": "2025-04-16T13:25:27.9702095",
                    "mime_type": "text/plain",
                    "extension": ".dart"
                  }
                }
              }
            },
            "atoms.dart": {
              "type": "file",
              "info": {
                "size": 494,
                "last_modified": "2025-04-16T13:25:27.9873034",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "buttons": {
              "back_button_widget.dart": {
                "type": "file",
                "info": {
                  "size": 1369,
                  "last_modified": "2025-04-16T13:25:27.993341",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "cards": {
              "activity_card.dart": {
                "type": "file",
                "info": {
                  "size": 3650,
                  "last_modified": "2025-04-16T13:25:28.0043744",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_card_image.dart": {
                "type": "file",
                "info": {
                  "size": 3094,
                  "last_modified": "2025-04-16T13:25:28.0114036",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_card_info.dart": {
                "type": "file",
                "info": {
                  "size": 2467,
                  "last_modified": "2025-04-16T13:25:28.0174039",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "activity_container.dart": {
                "type": "file",
                "info": {
                  "size": 2887,
                  "last_modified": "2025-04-16T13:25:28.0240554",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "carousels": {
              "activity_images_carousel.dart": {
                "type": "file",
                "info": {
                  "size": 2570,
                  "last_modified": "2025-04-16T13:25:28.0365699",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "index.dart": {
              "type": "file",
              "info": {
                "size": 948,
                "last_modified": "2025-04-16T13:25:28.0480863",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "molecules": {
              "filter_chip.dart": {
                "type": "file",
                "info": {
                  "size": 6980,
                  "last_modified": "2025-04-16T13:25:28.0541605",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "molecules.dart": {
              "type": "file",
              "info": {
                "size": 334,
                "last_modified": "2025-04-16T13:25:28.065882",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "organisms.dart": {
              "type": "file",
              "info": {
                "size": 317,
                "last_modified": "2025-04-16T13:25:28.0729055",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "sections": {
              "activity_section.dart": {
                "type": "file",
                "info": {
                  "size": 2300,
                  "last_modified": "2025-04-16T13:25:28.0789147",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "shimmer": {
              "shimmer_loading.dart": {
                "type": "file",
                "info": {
                  "size": 4103,
                  "last_modified": "2025-04-16T13:25:28.0911455",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "shimmer_section.dart": {
                "type": "file",
                "info": {
                  "size": 1016,
                  "last_modified": "2025-04-16T13:25:28.0981463",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              },
              "shimmer_skeletons.dart": {
                "type": "file",
                "info": {
                  "size": 4483,
                  "last_modified": "2025-04-16T13:25:28.104661",
                  "mime_type": "text/plain",
                  "extension": ".dart"
                }
              }
            },
            "templates.dart": {
              "type": "file",
              "info": {
                "size": 339,
                "last_modified": "2025-04-16T13:25:28.116263",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      },
      "trip": {
        "presentation": {
          "pages": {
            "trip_test_page.dart": {
              "type": "file",
              "info": {
                "size": 12296,
                "last_modified": "2025-04-16T13:25:28.1398969",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          },
          "state": {
            "trip_test_notifier.dart": {
              "type": "file",
              "info": {
                "size": 19410,
                "last_modified": "2025-04-16T13:25:28.1519429",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "trip_test_provider.dart": {
              "type": "file",
              "info": {
                "size": 1820,
                "last_modified": "2025-04-16T13:25:28.1584588",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            },
            "trip_test_state.dart": {
              "type": "file",
              "info": {
                "size": 577,
                "last_modified": "2025-04-16T13:25:28.1649763",
                "mime_type": "text/plain",
                "extension": ".dart"
              }
            }
          }
        }
      }
    },
    "main.dart": {
      "type": "file",
      "info": {
        "size": 2943,
        "last_modified": "2025-04-16T13:25:28.1932974",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    }
  },
  "files": [
    {
      "path": "core\\adapters\\cache\\hive_adapters.dart",
      "content": "// lib/core/adapters/cache/hive_adapters.dart\r\n\r\nimport 'package:hive/hive.dart';\r\nimport '../../../core/domain/models/location/user_location.dart';\r\nimport '../../../core/domain/models/location/place_details.dart';\r\nimport '../../../core/domain/models/location/place_suggestion.dart';\r\n\r\n// Dfinition des ID d'adaptateurs (doivent tre uniques)\r\nconst int userLocationTypeId = 1;\r\nconst int placeDetailsTypeId = 2;\r\nconst int placeSuggestionTypeId = 3;\r\n\r\n// Adaptateur pour convertir UserLocation en format Hive\r\nclass UserLocationAdapter extends TypeAdapter<UserLocation> {\r\n  @override\r\n  final int typeId = userLocationTypeId;\r\n\r\n  @override\r\n  UserLocation read(BinaryReader reader) {\r\n    final map = reader.readMap();\r\n    return UserLocation(\r\n      latitude: map['latitude'] as double,\r\n      longitude: map['longitude'] as double,\r\n      accuracy: map['accuracy'] as double?,\r\n      isFromGps: map['isFromGps'] as bool? ?? false,\r\n      timestamp: map['timestamp'] != null\r\n          ? DateTime.parse(map['timestamp'] as String)\r\n          : null,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void write(BinaryWriter writer, UserLocation obj) {\r\n    writer.writeMap({\r\n      'latitude': obj.latitude,\r\n      'longitude': obj.longitude,\r\n      'accuracy': obj.accuracy,\r\n      'isFromGps': obj.isFromGps,\r\n      'timestamp': obj.timestamp?.toIso8601String(),\r\n    });\r\n  }\r\n}\r\n\r\n// Adaptateur pour PlaceDetails\r\nclass PlaceDetailsAdapter extends TypeAdapter<PlaceDetails> {\r\n  @override\r\n  final int typeId = placeDetailsTypeId;\r\n\r\n  @override\r\n  PlaceDetails read(BinaryReader reader) {\r\n    final map = reader.readMap();\r\n    return PlaceDetails(\r\n      placeId: map['placeId'] as String,\r\n      name: map['name'] as String,\r\n      formattedAddress: map['formattedAddress'] as String,\r\n      location: map['location'] as UserLocation,\r\n      country: map['country'] as String?,\r\n      administrativeArea: map['administrativeArea'] as String?,\r\n      locality: map['locality'] as String?,\r\n      postalCode: map['postalCode'] as String?,\r\n      lastUpdated: map['lastUpdated'] != null\r\n          ? DateTime.parse(map['lastUpdated'] as String)\r\n          : null,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void write(BinaryWriter writer, PlaceDetails obj) {\r\n    writer.writeMap({\r\n      'placeId': obj.placeId,\r\n      'name': obj.name,\r\n      'formattedAddress': obj.formattedAddress,\r\n      'location': obj.location,\r\n      'country': obj.country,\r\n      'administrativeArea': obj.administrativeArea,\r\n      'locality': obj.locality,\r\n      'postalCode': obj.postalCode,\r\n      'lastUpdated': obj.lastUpdated?.toIso8601String(),\r\n    });\r\n  }\r\n}\r\n\r\n// Adaptateur pour PlaceSuggestion\r\nclass PlaceSuggestionAdapter extends TypeAdapter<PlaceSuggestion> {\r\n  @override\r\n  final int typeId = placeSuggestionTypeId;\r\n\r\n  @override\r\n  PlaceSuggestion read(BinaryReader reader) {\r\n    final map = reader.readMap();\r\n    return PlaceSuggestion(\r\n      placeId: map['placeId'] as String,\r\n      primaryText: map['primaryText'] as String,\r\n      secondaryText: map['secondaryText'] as String?,\r\n      isFromCache: map['isFromCache'] as bool? ?? false,\r\n    );\r\n  }\r\n\r\n  @override\r\n  void write(BinaryWriter writer, PlaceSuggestion obj) {\r\n    writer.writeMap({\r\n      'placeId': obj.placeId,\r\n      'primaryText': obj.primaryText,\r\n      'secondaryText': obj.secondaryText,\r\n      'isFromCache': obj.isFromCache,\r\n    });\r\n  }\r\n}",
      "info": {
        "size": 3408,
        "last_modified": "2025-04-16T13:25:25.9531423",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\cache\\hive_location_cache_adapter.dart",
      "content": "// lib/core/adapters/cache/hive_location_cache_adapter.dart\r\n\r\nimport 'package:hive/hive.dart';\r\nimport 'hive_adapters.dart';\r\nimport '../../domain/ports/location/location_cache_port.dart';\r\nimport '../../domain/models/location/place_suggestion.dart';\r\nimport '../../domain/models/location/place_details.dart';\r\nimport '../../common/constants/location_constants.dart';\r\n\r\nclass HiveLocationCacheAdapter implements LocationCachePort {\r\n  static const String _suggestionsBoxName = 'place_suggestions';\r\n  static const String _detailsBoxName = 'place_details';\r\n\r\n  // Initialiser les botes avec des valeurs par dfaut\r\n  Box<Map>? _suggestionsBox;\r\n  Box<Map>? _detailsBox;\r\n  bool _isInitialized = false;\r\n\r\n  // Modifier cette mthode pour qu'elle soit synchrone\r\n  void initialize() {\r\n    try {\r\n      // Enregistrer les adaptateurs\r\n      if (!Hive.isAdapterRegistered(userLocationTypeId)) {\r\n        Hive.registerAdapter(UserLocationAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeDetailsTypeId)) {\r\n        Hive.registerAdapter(PlaceDetailsAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeSuggestionTypeId)) {\r\n        Hive.registerAdapter(PlaceSuggestionAdapter());\r\n      }\r\n\r\n      // Ouvrir les boxes de manire synchrone si possible, sinon les laisser null\r\n      try {\r\n        if (Hive.isBoxOpen(_suggestionsBoxName)) {\r\n          _suggestionsBox = Hive.box<Map>(_suggestionsBoxName);\r\n        }\r\n        if (Hive.isBoxOpen(_detailsBoxName)) {\r\n          _detailsBox = Hive.box<Map>(_detailsBoxName);\r\n        }\r\n        _isInitialized = true;\r\n        print(' Cache Hive initialis avec succs');\r\n      } catch (e) {\r\n        print(' Impossible d\\'ouvrir les botes Hive de manire synchrone: $e');\r\n        // Ne pas marquer comme initialis\r\n      }\r\n    } catch (e) {\r\n      print(' Erreur lors de l\\'initialisation du cache: $e');\r\n    }\r\n  }\r\n\r\n  // Mthode pour initialiser de manire asynchrone ( appeler au dmarrage de l'app)\r\n  Future<void> initializeAsync() async {\r\n    try {\r\n      // Enregistrer les adaptateurs\r\n      if (!Hive.isAdapterRegistered(userLocationTypeId)) {\r\n        Hive.registerAdapter(UserLocationAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeDetailsTypeId)) {\r\n        Hive.registerAdapter(PlaceDetailsAdapter());\r\n      }\r\n      if (!Hive.isAdapterRegistered(placeSuggestionTypeId)) {\r\n        Hive.registerAdapter(PlaceSuggestionAdapter());\r\n      }\r\n\r\n      // Ouvrir les boxes\r\n      if (!Hive.isBoxOpen(_suggestionsBoxName)) {\r\n        _suggestionsBox = await Hive.openBox<Map>(_suggestionsBoxName);\r\n      } else {\r\n        _suggestionsBox = Hive.box<Map>(_suggestionsBoxName);\r\n      }\r\n\r\n      if (!Hive.isBoxOpen(_detailsBoxName)) {\r\n        _detailsBox = await Hive.openBox<Map>(_detailsBoxName);\r\n      } else {\r\n        _detailsBox = Hive.box<Map>(_detailsBoxName);\r\n      }\r\n\r\n      _isInitialized = true;\r\n      print(' Cache Hive initialis avec succs (async)');\r\n    } catch (e) {\r\n      print(' Erreur lors de l\\'initialisation asynchrone du cache: $e');\r\n    }\r\n  }\r\n\r\n  // Vrifier si les botes sont initialises avant de les utiliser\r\n  bool get isInitialized => _isInitialized && _suggestionsBox != null && _detailsBox != null;\r\n\r\n  // Mettre  jour les mthodes pour vrifier l'initialisation\r\n  @override\r\n  Future<void> savePlaceSuggestion(PlaceSuggestion suggestion) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox == null) return;\r\n\r\n    await _suggestionsBox!.put(\r\n      suggestion.placeId,\r\n      suggestion.toJson(),\r\n    );\r\n  }\r\n\r\n  // Modifier les autres mthodes de la mme faon\r\n  @override\r\n  Future<void> savePlaceSuggestions(List<PlaceSuggestion> suggestions) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox == null) return;\r\n\r\n    final Map<dynamic, Map<String, dynamic>> entries = {\r\n      for (var suggestion in suggestions)\r\n        suggestion.placeId: suggestion.toJson()\r\n    };\r\n\r\n    await _suggestionsBox!.putAll(entries);\r\n  }\r\n\r\n  @override\r\n  Future<List<PlaceSuggestion>> getPlaceSuggestions(String prefix, {int limit = 5}) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox == null) return [];\r\n\r\n    final suggestions = <PlaceSuggestion>[];\r\n\r\n    // Parcourir tous les lments pour trouver ceux correspondant au prfixe\r\n    for (var key in _suggestionsBox!.keys) {\r\n      final data = _suggestionsBox!.get(key);\r\n      if (data == null) continue;\r\n\r\n      try {\r\n        final suggestion = PlaceSuggestion.fromJson(Map<String, dynamic>.from(data));\r\n\r\n        // Vrifier si la suggestion correspond au prfixe (insensible  la casse)\r\n        if (suggestion.primaryText.toLowerCase().contains(prefix.toLowerCase())) {\r\n          suggestions.add(suggestion.copyWith(isFromCache: true));\r\n\r\n          // Limiter le nombre de rsultats\r\n          if (suggestions.length >= limit) break;\r\n        }\r\n      } catch (e) {\r\n        print(' Erreur lors de la conversion d\\'une suggestion: $e');\r\n      }\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  @override\r\n  Future<void> savePlaceDetails(PlaceDetails details) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_detailsBox == null) return;\r\n\r\n    await _detailsBox!.put(\r\n      details.placeId,\r\n      details.toJson(),\r\n    );\r\n\r\n    // Limiter la taille du cache si ncessaire\r\n    if (_detailsBox!.length > LocationConstants.maxCacheEntries) {\r\n      final keysToDelete = _detailsBox!.keys.take(_detailsBox!.length - LocationConstants.maxCacheEntries);\r\n      await _detailsBox!.deleteAll(keysToDelete);\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<PlaceDetails?> getPlaceDetails(String placeId) async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_detailsBox == null) return null;\r\n\r\n    final data = _detailsBox!.get(placeId);\r\n    if (data == null) return null;\r\n\r\n    try {\r\n      return PlaceDetails.fromJson(Map<String, dynamic>.from(data));\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration des dtails: $e');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<void> clearCache() async {\r\n    if (!isInitialized) {\r\n      await initializeAsync();\r\n    }\r\n    if (_suggestionsBox != null) await _suggestionsBox!.clear();\r\n    if (_detailsBox != null) await _detailsBox!.clear();\r\n  }\r\n}",
      "info": {
        "size": 6485,
        "last_modified": "2025-04-16T13:25:25.9611649",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google\\google_ai_studio_service.dart",
      "content": "// core/adapters/google/google_ai_studio_service.dart\r\n\r\n\r\nimport 'package:dio/dio.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../domain/services/google_services_config.dart';\r\nimport '../../common/exceptions/google_api_exception.dart';\r\n\r\n\r\nclass GoogleAIStudioService {\r\n  final Dio _dio = Dio();\r\n  final GoogleServicesConfig _config;\r\n\r\n  GoogleAIStudioService(this._config);\r\n\r\n  // lib/core/adapters/google/google_ai_studio_service.dart\r\n\r\n  Future<Map<String, dynamic>> callMapsDirections({\r\n    required LatLng origin,\r\n    required LatLng destination,\r\n    List<LatLng>? waypoints,\r\n  }) async {\r\n    try {\r\n      final url = 'https://maps.googleapis.com/maps/api/directions/json';\r\n      final params = _buildParams(\r\n        origin: origin,\r\n        destination: destination,\r\n        waypoints: waypoints,\r\n      );\r\n\r\n      print(' API Key utilise: ${_config.aiStudioApiKey}');\r\n      print(' Appel Directions API via AI Studio');\r\n      print(' URL complte: $url');\r\n      print(' Paramtres: $params');\r\n\r\n      final response = await _dio.get(url, queryParameters: params);\r\n\r\n      print(' Rponse reue: ${response.statusCode}');\r\n      print(' Contenu de la rponse: ${response.data}');\r\n\r\n      return response.data;\r\n    } catch (e) {\r\n      String errorMessage = 'Erreur lors de l\\'appel  l\\'API Google Directions';\r\n\r\n      if (e is DioError) {\r\n        errorMessage += ': ${e.response?.statusCode}, ${e.response?.data}';\r\n        print(' Erreur rseau: ${e.message}');\r\n        if (e.response != null) {\r\n          print(' Donnes de rponse: ${e.response?.data}');\r\n        }\r\n      } else {\r\n        errorMessage += ': $e';\r\n      }\r\n\r\n      print(' $errorMessage');\r\n      throw GoogleAPIException(errorMessage);\r\n    }\r\n  }\r\n\r\n  void _validateLatLng(LatLng point, String pointName) {\r\n    if (point.latitude < -90 || point.latitude > 90) {\r\n      throw ArgumentError(\r\n          'Latitude invalide pour $pointName: ${point.latitude}');\r\n    }\r\n    if (point.longitude < -180 || point.longitude > 180) {\r\n      throw ArgumentError(\r\n          'Longitude invalide pour $pointName: ${point.longitude}');\r\n    }\r\n  }\r\n\r\n  Map<String, String> _buildParams({\r\n    required LatLng origin,\r\n    required LatLng destination,\r\n    List<LatLng>? waypoints,\r\n  }) {\r\n    return {\r\n      'origin': '${origin.latitude},${origin.longitude}',  // tait invers\r\n      'destination': '${destination.latitude},${destination.longitude}',  // tait invers\r\n      if (waypoints != null && waypoints.isNotEmpty)\r\n        'waypoints': 'optimize:true|${waypoints.map((w) => '${w.latitude},${w.longitude}').join('|')}',\r\n      'key': _config.aiStudioApiKey,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 2768,
        "last_modified": "2025-04-16T13:25:25.9734214",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google\\route_optimization.adapter.dart",
      "content": " // lib/core/adapters/google/route_optimization.adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../domain/ports/empty_trips/route_optimization.port.dart';\r\nimport '../../domain/services/google_services_config.dart';\r\nimport '../../common/exceptions/route_optimization_exceptions.dart';\r\nimport '../../common/utils/geohash.dart';\r\nimport 'google_ai_studio_service.dart';\r\n\r\n class RouteOptimizationAdapter implements RouteOptimizationPort {\r\n   final SupabaseClient _supabase;\r\n   final GoogleServicesConfig _config;\r\n   final GoogleAIStudioService? _googleService;\r\n\r\n   RouteOptimizationAdapter(this._supabase, this._config, this._googleService);\r\n\r\n   @override\r\n   Future<Map<String, dynamic>> getOptimizedRoute(\r\n       LatLng origin,\r\n       LatLng destination,\r\n       List<LatLng> waypoints,\r\n       ) async {\r\n     try {\r\n       print(' Rcupration du trajet pour ${_formatLatLng(origin)}  ${_formatLatLng(destination)}');\r\n       print(' Dtails de la requte d\\'optimisation:');\r\n       print(' Origine: ${_formatLatLng(origin)}');\r\n       print(' Destination: ${_formatLatLng(destination)}');\r\n       if (waypoints.isNotEmpty) {\r\n         print(' Waypoints:');\r\n         waypoints.forEach((wp) => print('  - ${_formatLatLng(wp)}'));\r\n       }\r\n\r\n       _checkGoogleService();\r\n\r\n       final response = await _googleService!.callMapsDirections(\r\n         origin: origin,\r\n         destination: destination,\r\n         waypoints: waypoints,\r\n       );\r\n\r\n       print(' Rponse API:');\r\n       print('  - Status: ${response['status']}');\r\n       print('  - Routes trouves: ${response['routes']?.length ?? 0}');\r\n\r\n       if (response['status'] != 'OK') {\r\n         print(' Dtails de l\\'erreur:');\r\n         print('  - Status: ${response['status']}');\r\n         print('  - Message d\\'erreur: ${response['error_message'] ?? 'Non spcifi'}');\r\n         throw RouteNotFoundException('Aucun itinraire trouv: ${response['status']}');\r\n       }\r\n\r\n       _checkRouteResponse(response);\r\n\r\n       final route = response['routes'][0];\r\n       final legs = route['legs'] as List;\r\n\r\n       // Calculer les totaux\r\n       int totalDistance = 0;\r\n       int totalDuration = 0;\r\n\r\n       for (var leg in legs) {\r\n         totalDistance += leg['distance']['value'] as int;\r\n         totalDuration += leg['duration']['value'] as int;\r\n       }\r\n\r\n       print(' Distance totale: ${totalDistance}m, Dure totale: ${totalDuration}s');\r\n\r\n       return {\r\n         'status': 'OK',\r\n         'polyline': route['overview_polyline']['points'],\r\n         'traversed_geohashes': Geohash.getGeohashesFromPolyline(route['overview_polyline']['points']),\r\n         'distance': totalDistance,\r\n         'duration': totalDuration,\r\n         'waypoint_order': route['waypoint_order'] ?? [],\r\n       };\r\n     } catch (e) {\r\n       print(' Erreur optimisation route: $e');\r\n       rethrow;\r\n     }\r\n   }\r\n\r\n   @override\r\n   Future<Duration> getTravelTime(\r\n       LatLng origin,\r\n       LatLng destination,\r\n       {DateTime? departureTime}\r\n       ) async {\r\n     try {\r\n       print(' Calcul du temps de trajet entre ${_formatLatLng(origin)}  ${_formatLatLng(destination)}');\r\n\r\n       _checkGoogleService();\r\n\r\n       final response = await _googleService!.callMapsDirections(\r\n         origin: origin,\r\n         destination: destination,\r\n       );\r\n\r\n       _checkRouteResponse(response);\r\n\r\n       final duration = response['routes'][0]['legs'][0]['duration']['value'];\r\n       print(' Dure calcule: ${(duration / 60).round()} minutes');\r\n\r\n       return Duration(seconds: duration);\r\n     } catch (e) {\r\n       print(' Erreur calcul temps de trajet: $e');\r\n       throw TravelTimeCalculationException('Erreur lors du calcul du temps de trajet: $e');\r\n     }\r\n   }\r\n\r\n   @override\r\n   Future<Map<String, dynamic>> evaluateDetour(\r\n       LatLng origin,\r\n       LatLng destination,\r\n       LatLng detourPoint,\r\n       Duration maxDetourTime,\r\n       ) async {\r\n     try {\r\n       print(' valuation dtour via ${_formatLatLng(detourPoint)}');\r\n\r\n       _checkGoogleService();\r\n\r\n       // Route directe\r\n       final directRoute = await getOptimizedRoute(origin, destination, []);\r\n       final directDuration = directRoute['duration'] as int;\r\n\r\n       // Route avec dtour\r\n       final detourRoute = await getOptimizedRoute(origin, destination, [detourPoint]);\r\n       final detourDuration = detourRoute['duration'] as int;\r\n\r\n       final additionalTime = detourDuration - directDuration;\r\n       final isFeasible = Duration(seconds: additionalTime) <= maxDetourTime;\r\n\r\n       return {\r\n         'status': 'OK',\r\n         'additionalTime': additionalTime,\r\n         'feasible': isFeasible,\r\n         'detourRoute': detourRoute,\r\n       };\r\n     } catch (e) {\r\n       print(' Erreur valuation dtour: $e');\r\n       throw RouteNotFoundException('Erreur lors de l\\'valuation du dtour: $e');\r\n     }\r\n   }\r\n\r\n   // Mthodes utilitaires prives\r\n   void _checkGoogleService() {\r\n     if (_googleService == null) {\r\n       throw GoogleAPIException('Service Google AI Studio non initialis');\r\n     }\r\n   }\r\n\r\n   void _checkRouteResponse(Map<String, dynamic> response) {\r\n     if (response['status'] != 'OK') {\r\n       throw RouteNotFoundException('Aucun itinraire trouv: ${response['status']}');\r\n     }\r\n   }\r\n\r\n   String _formatLatLng(LatLng point) {\r\n     return '${point.latitude.toStringAsFixed(6)},${point.longitude.toStringAsFixed(6)}';\r\n   }\r\n\r\n   int _calculateTotalDistance(List legs) {\r\n     return legs.fold(0, (sum, leg) => sum + (leg['distance']['value'] as int));\r\n   }\r\n\r\n   int _calculateTotalDuration(List legs) {\r\n     return legs.fold(0, (sum, leg) => sum + (leg['duration']['value'] as int));\r\n   }\r\n }",
      "info": {
        "size": 5910,
        "last_modified": "2025-04-16T13:25:25.9799279",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google_maps\\geocoding_adapter.dart",
      "content": "// core/adapters/google_maps/geocoding_adapter.dart\r\n\r\nimport '../../domain/ports/geocoding_port.dart';\r\nimport '../../domain/models/shared/city_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../domain/ports/maps_port.dart';\r\nimport '../../domain/services/location_service.dart';\r\n\r\n\r\n\r\nclass GeocodingAdapter implements GeocodingPort {\r\n  final LocationService _locationService;\r\n  final MapsPort _mapsService;\r\n\r\n  GeocodingAdapter(this._locationService, this._mapsService);\r\n\r\n  @override\r\n  Future<City> getCity(String cityName) async {\r\n    try {\r\n      // Chercher d'abord dans notre base\r\n      final existingCity = await _locationService.findCity(cityName);\r\n      if (existingCity != null) return existingCity;\r\n\r\n      // Si la ville n'existe pas, l'enrichir via Google Maps\r\n      final enriched = await _mapsService.enrichCityData(cityName);\r\n      if (!enriched) {\r\n        throw DataException('Impossible de trouver ou crer la ville: $cityName');\r\n      }\r\n\r\n      // Rcuprer la ville nouvellement cre\r\n      final newCity = await _locationService.findCity(cityName);\r\n      if (newCity == null) {\r\n        throw DataException('Ville cre mais non trouve: $cityName');\r\n      }\r\n\r\n      return newCity;\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche/cration de la ville: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<City>> getMultipleCities(List<String> cityNames) async {\r\n    try {\r\n      final cities = <City>[];\r\n      for (final cityName in cityNames) {\r\n        final city = await getCity(cityName);\r\n        cities.add(city);\r\n      }\r\n      return cities;\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche/cration des villes: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1772,
        "last_modified": "2025-04-16T13:25:25.9924421",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\google_maps\\maps_adapter.dart",
      "content": "// core/adapters/google_maps/maps_adapter.dart\r\n\r\nimport 'dart:convert';\r\nimport 'dart:math' show cos, sqrt, pi;\r\nimport 'package:http/http.dart' as http;\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../domain/ports/maps_port.dart';\r\nimport '../../domain/ports/location/place_search_port.dart';\r\nimport '../../domain/ports/location/place_details_port.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/location_exceptions.dart';\r\nimport '../../common/utils/geohash.dart';\r\nimport '../../domain/services/location_service.dart';\r\nimport '../../domain/models/location/place_suggestion.dart';\r\nimport '../../domain/models/location/place_details.dart';\r\nimport '../../domain/models/location/user_location.dart';\r\n\r\n/// Service pour les interactions avec l'API Google Maps\r\n/// Gre la golocalisation et l'enrichissement des donnes de villes\r\nclass GoogleMapsAdapter implements MapsPort, PlaceSearchPort, PlaceDetailsPort {\r\n  final LocationService _locationService;\r\n  final String _apiKey;\r\n  final http.Client _httpClient;\r\n\r\n  static const _DORDOGNE_BOUNDS = {\r\n    'minLat': 44.5,\r\n    'maxLat': 45.7,\r\n    'minLon': 0.0,\r\n    'maxLon': 1.5,\r\n  };\r\n\r\n  // Dfinition des dpartements cibles pour la recherche de lieux\r\n  static const Map<String, Map<String, dynamic>> _TARGET_DEPARTMENTS = {\r\n    'Dordogne': {\r\n      'center': {'lat': 45.1909, 'lng': 0.7214},\r\n      'radius': 80000,\r\n    },\r\n    'Lot': {\r\n      'center': {'lat': 44.6239, 'lng': 1.6094},\r\n      'radius': 50000,\r\n    },\r\n    'Corrze': {\r\n      'center': {'lat': 45.3394, 'lng': 1.8655},\r\n      'radius': 50000,\r\n    },\r\n  };\r\n\r\n  GoogleMapsAdapter(this._locationService, {http.Client? httpClient}) :\r\n        _apiKey = dotenv.env['GOOGLE_MAPS_API_KEY'] ?? '',\r\n        _httpClient = httpClient ?? http.Client() {\r\n    if (_apiKey.isEmpty) {\r\n      throw DataException('Google Maps API key not found in .env file');\r\n    }\r\n  }\r\n\r\n  bool _isInDordogne(double lat, double lon) {\r\n    return lat >= _DORDOGNE_BOUNDS['minLat']! &&\r\n        lat <= _DORDOGNE_BOUNDS['maxLat']! &&\r\n        lon >= _DORDOGNE_BOUNDS['minLon']! &&\r\n        lon <= _DORDOGNE_BOUNDS['maxLon']!;\r\n  }\r\n\r\n  // Implmentation de MapsPort.getPlaceDetails\r\n  @override\r\n  Future<Map<String, dynamic>?> getPlaceDetails(String cityName) async {\r\n    final url = Uri.parse(\r\n        'https://maps.googleapis.com/maps/api/geocode/json?address=${Uri.encodeComponent(cityName.trim())}&key=$_apiKey'\r\n    );\r\n\r\n    try {\r\n      final response = await _httpClient.get(url);\r\n      final data = json.decode(response.body);\r\n\r\n      if (response.statusCode != 200) {\r\n        throw DataException('HTTP error: ${response.statusCode}');\r\n      }\r\n\r\n      if (data['status'] != 'OK' || data['results'].isEmpty) {\r\n        return null;\r\n      }\r\n\r\n      final location = data['results'][0]['geometry']['location'];\r\n\r\n      if (!_isInDordogne(location['lat'], location['lng'])) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        'lat': location['lat'],\r\n        'lon': location['lng'],\r\n        'formatted_address': data['results'][0]['formatted_address'],\r\n      };\r\n    } catch (e) {\r\n      throw DataException('Failed to get place details: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<bool> enrichCityData(String cityName) async {\r\n    try {\r\n      final placeDetails = await getPlaceDetails(cityName);\r\n      if (placeDetails == null) return false;\r\n\r\n      await _locationService.saveCity(\r\n        cityName: cityName,\r\n        lat: placeDetails['lat'] as double,\r\n        lon: placeDetails['lon'] as double,\r\n        geohash5: Geohash.encode(\r\n            placeDetails['lat'] as double,\r\n            placeDetails['lon'] as double\r\n        ),\r\n      );\r\n\r\n      return true;\r\n    } catch (e) {\r\n      throw DataException('Failed to enrich city data: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<String>> enrichMultipleCities(List<String> cityNames) async {\r\n    final successfulCities = <String>[];\r\n    for (final cityName in cityNames) {\r\n      if (await enrichCityData(cityName)) {\r\n        successfulCities.add(cityName);\r\n      }\r\n    }\r\n    return successfulCities;\r\n  }\r\n\r\n  /// Recherche des suggestions de lieux  partir d'un texte de recherche\r\n  @override\r\n  Future<Result<List<PlaceSuggestion>>> searchPlaces(\r\n      String query, {\r\n        UserLocation? locationBias,\r\n        int radius = 50000,\r\n      }) async {\r\n    if (query.isEmpty) {\r\n      return Result.value([]);\r\n    }\r\n\r\n    try {\r\n      // Construction des paramtres de base\r\n      final params = {\r\n        'input': query,\r\n        'types': '(cities)',\r\n        'components': 'country:fr',\r\n        'key': _apiKey,\r\n        'language': 'fr',\r\n      };\r\n\r\n      // Ajout du biais de localisation si fourni\r\n      if (locationBias != null) {\r\n        final circleBias = 'circle:$radius@${locationBias.latitude},${locationBias.longitude}';\r\n        params['locationbias'] = circleBias;\r\n      } else {\r\n        // Utiliser le premier dpartement cible comme biais par dfaut\r\n        final defaultDept = _TARGET_DEPARTMENTS.entries.first;\r\n        final center = defaultDept.value['center'];\r\n        final deptRadius = defaultDept.value['radius'];\r\n\r\n        final circleBias = 'circle:$deptRadius@${center['lat']},${center['lng']}';\r\n        params['locationbias'] = circleBias;\r\n      }\r\n\r\n      final uri = Uri.parse('https://maps.googleapis.com/maps/api/place/autocomplete/json')\r\n          .replace(queryParameters: params);\r\n\r\n      final response = await _httpClient.get(uri);\r\n\r\n      if (response.statusCode != 200) {\r\n        return Result.error(PlacesApiException(\r\n            'Erreur HTTP ${response.statusCode}: ${response.reasonPhrase}'\r\n        ));\r\n      }\r\n\r\n      final data = json.decode(response.body);\r\n\r\n      if (data['status'] != 'OK' && data['status'] != 'ZERO_RESULTS') {\r\n        return Result.error(PlacesApiException(\r\n          'Erreur API Places: ${data['status']}',\r\n          errorCode: data['status'],\r\n        ));\r\n      }\r\n\r\n      final List<dynamic> predictions = data['predictions'] ?? [];\r\n\r\n      final suggestions = predictions.map<PlaceSuggestion>((prediction) {\r\n        final mainText = prediction['structured_formatting']['main_text'] ?? '';\r\n        final secondaryText = prediction['structured_formatting']['secondary_text'] ?? '';\r\n\r\n        return PlaceSuggestion(\r\n          placeId: prediction['place_id'],\r\n          primaryText: mainText,\r\n          secondaryText: secondaryText,\r\n        );\r\n      }).toList();\r\n\r\n      return Result.value(suggestions);\r\n    } catch (e) {\r\n      return Result.error(PlacesApiException(\r\n          'Erreur lors de la recherche de lieux: ${e.toString()}'\r\n      ));\r\n    }\r\n  }\r\n\r\n  /// Implmentation de PlaceDetailsPort.getPlaceDetails\r\n  /// Renomme pour viter le conflit avec MapsPort.getPlaceDetails\r\n  @override\r\n  Future<Result<PlaceDetails>> getPlaceDetailsById(String placeId) async {\r\n    try {\r\n      // Construction des paramtres\r\n      final params = {\r\n        'place_id': placeId,\r\n        'fields': 'name,formatted_address,geometry/location',\r\n        'key': _apiKey,\r\n        'language': 'fr',\r\n      };\r\n\r\n      final uri = Uri.parse('https://maps.googleapis.com/maps/api/place/details/json')\r\n          .replace(queryParameters: params);\r\n\r\n      final response = await _httpClient.get(uri);\r\n\r\n      if (response.statusCode != 200) {\r\n        return Result.error(PlacesApiException(\r\n            'Erreur HTTP ${response.statusCode}: ${response.reasonPhrase}'\r\n        ));\r\n      }\r\n\r\n      final data = json.decode(response.body);\r\n\r\n      if (data['status'] != 'OK') {\r\n        return Result.error(PlacesApiException(\r\n          'Erreur API Place Details: ${data['status']}',\r\n          errorCode: data['status'],\r\n        ));\r\n      }\r\n\r\n      final result = data['result'];\r\n      final geometry = result['geometry'];\r\n      final location = geometry['location'];\r\n\r\n      final placeDetails = PlaceDetails(\r\n        placeId: placeId,\r\n        name: result['name'],\r\n        formattedAddress: result['formatted_address'],\r\n        location: UserLocation(\r\n          latitude: location['lat'],\r\n          longitude: location['lng'],\r\n        ),\r\n        country: null,\r\n        administrativeArea: null,\r\n        locality: null,\r\n        postalCode: null,\r\n        lastUpdated: DateTime.now(),\r\n      );\r\n\r\n      return Result.value(placeDetails);\r\n    } catch (e) {\r\n      print(' Erreur dans getPlaceDetailsById: $e');\r\n      return Result.error(PlacesApiException(\r\n          'Erreur lors de la rcupration des dtails du lieu: ${e.toString()}'\r\n      ));\r\n    }\r\n  }\r\n\r\n  /// Vrifie si un lieu se trouve dans l'un des dpartements cibls\r\n  bool isInTargetDepartments(double lat, double lng) {\r\n    // Vrifie d'abord avec la mthode existante pour la Dordogne\r\n    if (_isInDordogne(lat, lng)) {\r\n      return true;\r\n    }\r\n\r\n    // Vrifie avec les autres dpartements cibls\r\n    for (final dept in _TARGET_DEPARTMENTS.entries) {\r\n      final center = dept.value['center'];\r\n      final radius = dept.value['radius'];\r\n\r\n      // Calcule la distance approximative (en mtres)\r\n      final dLat = (lat - center['lat']) * 111000;\r\n      final dLng = (lng - center['lng']) * 111000 * cos(center['lat'] * pi / 180);\r\n      final distance = sqrt(dLat * dLat + dLng * dLng);\r\n\r\n      if (distance <= radius) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}",
      "info": {
        "size": 9536,
        "last_modified": "2025-04-16T13:25:25.9999434",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\postgis\\geometry_calculation.adapter.dart",
      "content": "// lib/core/adapters/postgis/geometry_calculation.adapter.dart\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/empty_trips/geometry_calculation.port.dart';\r\nimport '../../common/utils/maps_toolkit_utils.dart';\r\nimport '../../common/constants/geometry_constants.dart';\r\nimport '../../common/exceptions/geometry_calculation_exception.dart';\r\n\r\nclass GeometryCalculationAdapter implements GeometryCalculationPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  GeometryCalculationAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<double> calculateDistance(LatLng point1, LatLng point2) async {\r\n    try {\r\n      final response = await _supabase\r\n          .rpc('calculate_distance', params: {\r\n        'lat1': point1.latitude,\r\n        'lng1': point1.longitude,\r\n        'lat2': point2.latitude,\r\n        'lng2': point2.longitude,\r\n      });\r\n\r\n      return response as double;\r\n    } catch (_) {\r\n      // Fallback to Maps Toolkit si PostGIS choue\r\n      return MapsToolkitUtils.calculateHaversineDistance(point1, point2);\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<int> calculateMalusMinutes(double distanceMeters, String travelStyle) async {\r\n    try {\r\n      return MapsToolkitUtils.calculateMalusMinutes(distanceMeters, travelStyle);\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to calculate malus minutes: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<bool> isLocationOnPath(LatLng point, List<LatLng> pathPoints) async {\r\n    try {\r\n      return MapsToolkitUtils.isLocationOnPath(\r\n          point,\r\n          pathPoints,\r\n          toleranceMeters: GeometryConstants.defaultToleranceMeters\r\n      );\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to check location on path: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<bool> isWithinMaxDetour(LatLng point, LatLng start, LatLng end) async {\r\n    try {\r\n      final directDistance = await calculateDistance(start, end);\r\n      final detourDistance = await calculateDistance(start, point) +\r\n          await calculateDistance(point, end);\r\n\r\n      return detourDistance <= (directDistance + (GeometryConstants.maxDetourDistanceKm * 1000));\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to check max detour: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2336,
        "last_modified": "2025-04-16T13:25:26.0119739",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\processing\\activity_hours_adapter.dart",
      "content": "// lib\\core\\adapters\\processing\\activity_hours_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\n\r\n// Extension pour convertir le numro du jour en nom\r\nextension DateTimeExtension on int {\r\n  String toDayName() {\r\n    switch (this) {\r\n      case DateTime.monday: return 'monday';\r\n      case DateTime.tuesday: return 'tuesday';\r\n      case DateTime.wednesday: return 'wednesday';\r\n      case DateTime.thursday: return 'thursday';\r\n      case DateTime.friday: return 'friday';\r\n      case DateTime.saturday: return 'saturday';\r\n      case DateTime.sunday: return 'sunday';\r\n      default: throw Exception('Invalid day of week');\r\n    }\r\n  }\r\n}\r\n\r\nclass OpeningDays {\r\n  final Map<String, Map<String, String>> availableDays; // jour -> {opens_at, closes_at}\r\n\r\n  OpeningDays(this.availableDays);\r\n\r\n  bool get hasOpenDays => availableDays.isNotEmpty;\r\n\r\n  Map<String, String>? getHoursForDay(String day) => availableDays[day];\r\n}\r\n\r\nclass ActivityHoursService {\r\n  final SupabaseClient _supabase;\r\n\r\n  const ActivityHoursService(this._supabase);\r\n\r\n  Future<OpeningDays?> getActivityHours(\r\n      String activityId, DateTime dateStart, DateTime dateEnd) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('activity_hours')\r\n          .select()\r\n          .eq('activity_id', activityId)\r\n          .eq('is_open', true)\r\n          .lte('season_start', dateEnd.toIso8601String())\r\n          .gte('season_end', dateStart.toIso8601String());\r\n\r\n      if (response.isEmpty) {\r\n        print('Aucun horaire trouv pour l\\'activit $activityId');\r\n        return null;\r\n      }\r\n\r\n      final schedule = response[0]['day_of_week'];\r\n      if (schedule == null) {\r\n        print('Structure d\\'horaires invalide pour l\\'activit $activityId');\r\n        return null;\r\n      }\r\n\r\n      // Rsultat pour stocker les jours disponibles\r\n      Map<String, Map<String, String>> availableDays = {};\r\n\r\n      // Vrifier chaque jour du sjour\r\n      for (var d = dateStart;\r\n      d.isBefore(dateEnd.add(Duration(days: 1)));\r\n      d = d.add(Duration(days: 1))) {\r\n\r\n        String dayName = d.weekday.toDayName().toLowerCase();\r\n        print('Vrification pour ${d.toString()} (${dayName})');\r\n\r\n        // Vrifier d'abord les horaires 'all'\r\n        if (schedule['all'] != null) {\r\n          availableDays[dayName] = {\r\n            'opens_at': schedule['all']['opens_at'],\r\n            'closes_at': schedule['all']['closes_at'],\r\n          };\r\n          continue;\r\n        }\r\n\r\n        // Sinon vrifier les horaires spcifiques du jour\r\n        if (schedule[dayName] != null) {\r\n          availableDays[dayName] = {\r\n            'opens_at': schedule[dayName]['opens_at'],\r\n            'closes_at': schedule[dayName]['closes_at'],\r\n          };\r\n        }\r\n      }\r\n\r\n      // Si aucun jour d'ouverture trouv\r\n      if (availableDays.isEmpty) {\r\n        print('Aucun jour d\\'ouverture pendant le sjour pour l\\'activit $activityId');\r\n        return null;\r\n      }\r\n\r\n      print('Jours d\\'ouverture trouvs: ${availableDays.keys.join(', ')}');\r\n      return OpeningDays(availableDays);\r\n\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration des horaires: $e');\r\n      return null;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3369,
        "last_modified": "2025-04-16T13:25:26.0250855",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\processing\\filter_processing_adapter.dart",
      "content": "// core/adapters/processing/filter_processing_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/services/travel_time_service.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../domain/filters/filter_chain.dart';\r\nimport '../../domain/filters/travel_group_filter.dart';\r\nimport '../../domain/filters/time_filter.dart';\r\n\r\nclass FilterProcessingAdapter {\r\n  final ActivityHoursPort _hoursAdapter;\r\n  final SupabaseClient _supabase;  // Ajout pour TravelTimeService\r\n\r\n  FilterProcessingAdapter(this._hoursAdapter, this._supabase);  // Mise  jour constructeur\r\n\r\n  Future<List<ActivityForProcessing>> getFilteredActivities(\r\n      String tripId,\r\n      List<ActivityForProcessing> activities,\r\n      Trip trip\r\n      ) async {\r\n    final filterChain = FilterChain()\r\n      ..addFilter(TravelGroupFilter(trip.travelGroup))\r\n      ..addFilter(TimeFilter(\r\n        tripStartDate: trip.startDate,\r\n        tripEndDate: trip.endDate,\r\n        dailyHours: trip.activityHours.daily_hours,  // Au lieu de tripActivityHours\r\n        hoursService: _hoursAdapter,\r\n        departureGeohash5: trip.departureGeohash5 ?? '',  // Ajout\r\n        travelTimeService: TravelTimeService(_supabase),  // Ajout\r\n      ));\r\n\r\n    return await filterChain.apply(activities);\r\n  }\r\n}",
      "info": {
        "size": 1480,
        "last_modified": "2025-04-16T13:25:26.032191",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\activity_hours_adapter.dart",
      "content": "// core/adapters/supabase/activity_hours_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/models/opening_days.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\n\r\nclass ActivityHoursAdapter implements ActivityHoursPort {\r\n  final SupabaseClient _client;  // On garde _client comme nom de variable\r\n\r\n  ActivityHoursAdapter(SupabaseClient supabase) : _client = supabase;  // On initialise _client\r\n\r\n  @override\r\n  Future<OpeningDays?> getActivityHours(\r\n      String activityId,\r\n      DateTime startDate,\r\n      DateTime endDate,\r\n      ) async {\r\n    try {\r\n      final response = await _client\r\n          .from('activity_hours')\r\n          .select()\r\n          .eq('activity_id', activityId)\r\n          .lte('season_start', endDate.toIso8601String())\r\n          .gte('season_end', startDate.toIso8601String())\r\n          .eq('is_open', true);\r\n\r\n      if (response == null || response.isEmpty) {\r\n        return null;\r\n      }\r\n\r\n      final schedule = response[0]; // Prendre le premier horaire valide\r\n      final dayOfWeek = schedule['day_of_week'] as Map<String, dynamic>;\r\n      final Map<String, Map<String, String>> availableDays = {};\r\n\r\n      // Pour chaque jour entre startDate et endDate\r\n      for (var date = startDate; date.isBefore(endDate.add(const Duration(days: 1))); date = date.add(const Duration(days: 1))) {\r\n        String formattedDate = date.toIso8601String().split('T')[0];\r\n\r\n        // Si \"all\" est dfini, utiliser ces horaires pour tous les jours\r\n        if (dayOfWeek['all'] != null) {\r\n          availableDays[formattedDate] = {\r\n            'opens_at': dayOfWeek['all']['opens_at'],\r\n            'closes_at': dayOfWeek['all']['closes_at'],\r\n          };\r\n        }\r\n        // Sinon, chercher l'horaire spcifique au jour de la semaine\r\n        else {\r\n          String weekday = _getWeekdayName(date.weekday).toLowerCase();\r\n          if (dayOfWeek[weekday] != null) {\r\n            availableDays[formattedDate] = {\r\n              'opens_at': dayOfWeek[weekday]['opens_at'],\r\n              'closes_at': dayOfWeek[weekday]['closes_at'],\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      return OpeningDays(availableDays: availableDays);\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration des horaires: $e');\r\n      throw DataException('Erreur lors de la rcupration des horaires: $e');\r\n    }\r\n  }\r\n\r\n  String _getWeekdayName(int weekday) {\r\n    switch (weekday) {\r\n      case 1: return 'monday';\r\n      case 2: return 'tuesday';\r\n      case 3: return 'wednesday';\r\n      case 4: return 'thursday';\r\n      case 5: return 'friday';\r\n      case 6: return 'saturday';\r\n      case 7: return 'sunday';\r\n      default: throw ArgumentError('Invalid weekday number: $weekday');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2861,
        "last_modified": "2025-04-16T13:25:26.0452277",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\activity_processing_adapter.dart",
      "content": "// core/adapters/supabase/activity_processing_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_processing_port.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../domain/filters/travel_group_filter.dart';\r\nimport '../../domain/filters/time_filter.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/services/travel_time_service.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\nimport '../supabase/activity_hours_adapter.dart';\r\n\r\nclass ActivityProcessingAdapter implements ActivityProcessingPort {\r\n  final SupabaseClient _supabase;\r\n  final ActivityHoursPort _hoursService;\r\n\r\n\r\n  ActivityProcessingAdapter(SupabaseClient supabase) :\r\n        _supabase = supabase,\r\n        _hoursService = ActivityHoursAdapter(supabase);\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> getActivitiesForTrip(String tripId) async {\r\n    try {\r\n      // 1. Rcuprer le trip\r\n      final tripResponse = await _supabase\r\n          .from('trips')\r\n          .select('''\r\n            *,\r\n            cities!trips_departure_city_id_fkey (*)\r\n          ''')\r\n          .eq('id', tripId)\r\n          .single();\r\n\r\n      final trip = Trip.fromJson(tripResponse);\r\n      print(' Types d\\'exploration: ${trip.activeExplorationType}');\r\n\r\n      // 2. Calculer la distance maximale\r\n      final maxDistance = _getMaxDistance(trip.activeExplorationType);\r\n      print(' Distance maximale calcule: $maxDistance km');\r\n\r\n      // 3. Rcuprer les geohash voisins\r\n      final geohash4 = trip.departureGeohash5?.substring(0, 4);\r\n      print(' Geohash4 de dpart: $geohash4');\r\n\r\n      final neighbors = await getGeohashNeighbors(geohash4 ?? '', maxDistance);\r\n      print(' Geohash voisins trouvs: ${neighbors.keys.toList()}');\r\n\r\n      final allGeohashes = [geohash4, ...neighbors.values.expand((e) => e).toList()];\r\n      print(' Recherche des activits dans les geohash: $allGeohashes');\r\n\r\n      final response = await _supabase\r\n          .from('activities')\r\n          .select()\r\n          .inFilter('geohash_4', allGeohashes);\r\n\r\n      print(' Nombre d\\'activits trouves: ${response.length}');\r\n\r\n      return response.map((json) => ActivityForProcessing.fromJson(json)).toList();\r\n    } catch (e) {\r\n      print(' Erreur dans getActivitiesForTrip: $e');\r\n      throw DataException('Erreur lors de la rcupration des activits: $e');\r\n    }\r\n  }\r\n\r\n  double _getMaxDistance(List<ExplorationType> types) {\r\n    double maxDist = 0;\r\n    print(' Calcul de la distance maximale pour les types: ${types.map((t) => t.value).toList()}');\r\n    for (var type in types) {\r\n      final dist = type.maxDistance;\r\n      print('  - Type ${type.value}: $dist km');\r\n      if (dist > maxDist) maxDist = dist;\r\n    }\r\n    print('   Distance max retenue: $maxDist km');\r\n    return maxDist;\r\n  }\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> getFilteredActivities({\r\n    required String tripId,\r\n    required Trip trip,\r\n    required List<ActivityForProcessing> activities,\r\n  }) async {\r\n    try {\r\n      print(' Dbut du filtrage des activits');\r\n      print('Nombre d\\'activits avant filtrage: ${activities.length}');\r\n\r\n      // Crer et appliquer le filtre de temps\r\n      final timeFilter = TimeFilter(\r\n        tripStartDate: trip.startDate,\r\n        tripEndDate: trip.endDate,\r\n        dailyHours: trip.activityHours.daily_hours,\r\n        hoursService: _hoursService,\r\n        departureGeohash5: trip.departureGeohash5 ?? '',  // Ajout\r\n        travelTimeService: TravelTimeService(_supabase),   // Ajout\r\n      );\r\n\r\n      final timeFilteredActivities = await timeFilter.apply(activities);\r\n      print('Nombre d\\'activits aprs filtre temporel: ${timeFilteredActivities.length}');\r\n\r\n      // Crer et appliquer le filtre de groupe\r\n      final groupFilter = TravelGroupFilter(trip.travelGroup);\r\n      final filteredActivities = await groupFilter.apply(timeFilteredActivities);\r\n      print('Nombre d\\'activits aprs tous les filtres: ${filteredActivities.length}');\r\n\r\n      return filteredActivities;\r\n    } catch (e) {\r\n      print(' Erreur lors du filtrage: $e');\r\n      throw DataException('Erreur lors du filtrage des activits: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  double getExplorationRadius(String explorationType) {\r\n    return ExplorationType.values\r\n        .firstWhere(\r\n            (e) => e.value == explorationType,\r\n        orElse: () => ExplorationType.around_me\r\n    ).maxDistance;\r\n  }\r\n\r\n  @override\r\n  Future<Map<String, List<String>>> getGeohashNeighbors(\r\n      String geohash4, double maxDistance) async {\r\n    try {\r\n      print(' Recherche des voisins pour le geohash: $geohash4');\r\n      print(' Distance maximale: $maxDistance km');\r\n\r\n      final response = await _supabase\r\n          .from('geohash_neighbors')\r\n          .select()\r\n          .eq('geohash', geohash4)\r\n          .lte('distance_km', maxDistance)\r\n          .order('distance_km');\r\n\r\n      print(' Rponse brute: $response');\r\n\r\n      Map<String, List<String>> neighbors = {};\r\n      neighbors[geohash4] = [];\r\n\r\n      for (var row in response) {\r\n        final neighborHash = row['neighbor_geohash'] as String;\r\n        final neighbor4 = neighborHash.substring(0, 4);\r\n\r\n        print(' Ajout du voisin: $neighbor4');\r\n        neighbors[geohash4]?.add(neighbor4);\r\n      }\r\n\r\n      print(' Voisins trouvs: ${neighbors.values.expand((e) => e).toList()}');\r\n      return neighbors;\r\n    } catch (e) {\r\n      print(' Erreur dans getGeohashNeighbors: $e');\r\n      throw DataException('Erreur lors de la rcupration des geohash voisins: $e');\r\n    }\r\n  }\r\n}\r\n",
      "info": {
        "size": 5906,
        "last_modified": "2025-04-16T13:25:26.0522806",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\activity_scoring_adapter.dart",
      "content": "// core/adapters/supabase/activity_scoring_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/activity_scoring_port.dart';\r\nimport '../../domain/models/trip_designer/scoring/scoring_activity.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/services/scoring_service.dart';\r\n\r\nclass ActivityScoringAdapter implements ActivityScoringPort {\r\n  final SupabaseClient _client;\r\n  final ScoringService _scoringService;\r\n\r\n  ActivityScoringAdapter(this._client) : _scoringService = ScoringService();\r\n\r\n  @override\r\n  Future<List<ScoredActivity>> scoreActivities(String userId, List<ActivityForProcessing> activities) async {\r\n    try {\r\n      print(' Dbut du scoring des activits pour l\\'utilisateur: $userId');\r\n\r\n      // 1. Rcuprer les prfrences utilisateur\r\n      final preferences = await getUserPreferences(userId);\r\n\r\n      // 2. Rcuprer les scores existants en cache\r\n      final existingScores = await _getCachedScores(userId, activities.map((a) => a.id).toList(), activities);\r\n      final results = <ScoredActivity>[];\r\n\r\n      for (var activity in activities) {\r\n        // Vrifier si un score en cache existe et est toujours valide\r\n        if (existingScores.containsKey(activity.id)) {\r\n          print(' Score en cache trouv pour ${activity.name}');\r\n          results.add(existingScores[activity.id]!);\r\n          continue;\r\n        }\r\n\r\n        print(' Calcul du score pour ${activity.name}');\r\n\r\n        // Calculer les nouveaux scores\r\n        final subcategoryScore = preferences[activity.subcategoryId] ?? 0.0;\r\n        final totalScore = _scoringService.calculateTotalScore(activity, subcategoryScore);\r\n        final isSuperWow = _scoringService.isSuperWow(totalScore, subcategoryScore);\r\n        print(' Activit ${activity.id}: score total=${totalScore}, subcategory=${subcategoryScore}, SuperWow=${isSuperWow}');\r\n\r\n\r\n        // Sauvegarder en cache\r\n        await _saveScore(\r\n          userId,\r\n          activity.id,\r\n          totalScore,\r\n          subcategoryScore,\r\n          isSuperWow,\r\n        );\r\n\r\n        results.add(ScoredActivity(\r\n          activity: activity,\r\n          totalScore: totalScore,\r\n          subcategoryScore: subcategoryScore,\r\n          isSuperWow: isSuperWow,\r\n        ));\r\n      }\r\n\r\n      print(' Scoring termin: ${results.length} activits traites');\r\n      return results;\r\n    } catch (e) {\r\n      print(' Erreur lors du scoring: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<Map<String, double>> getUserPreferences(String userId) async {\r\n    try {\r\n      final response = await _client\r\n          .from('user_subcategory_preferences')\r\n          .select()\r\n          .eq('user_id', userId);\r\n\r\n      final preferences = <String, double>{};\r\n      for (var pref in response) {\r\n        preferences[pref['subcategory_id']] = pref['score']?.toDouble() ?? 0.0;\r\n      }\r\n\r\n      return preferences;\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration des prfrences: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  Future<Map<String, ScoredActivity>> _getCachedScores(\r\n      String userId,\r\n      List<String> activityIds,\r\n      List<ActivityForProcessing> activities  // Ajout du paramtre\r\n      ) async {\r\n    try {\r\n      final response = await _client\r\n          .from('user_activities_score')\r\n          .select()\r\n          .eq('user_id', userId)\r\n          .inFilter('activity_id', activityIds);\r\n\r\n      final cachedScores = <String, ScoredActivity>{};\r\n      for (var score in response) {\r\n        // On ne prend que les scores qui ont encore une priode de validit\r\n        if (score['superwow_validity_period'] != null &&\r\n            DateTime.parse(score['superwow_validity_period']).isBefore(DateTime.now())) {\r\n          continue;\r\n        }\r\n\r\n        cachedScores[score['activity_id']] = ScoredActivity(\r\n          activity: activities.firstWhere((a) => a.id == score['activity_id']),\r\n          totalScore: score['total_score']?.toDouble() ?? 0.0,\r\n          subcategoryScore: score['subcategory_score']?.toDouble() ?? 0.0,\r\n          isSuperWow: score['is_superwow'] ?? false,\r\n        );\r\n      }\r\n\r\n      return cachedScores;\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration des scores en cache: $e');\r\n      return {};\r\n    }\r\n  }\r\n\r\n  Future<void> _saveScore(\r\n      String userId,\r\n      String activityId,\r\n      double totalScore,\r\n      double subcategoryScore,\r\n      bool isSuperWow,\r\n      ) async {\r\n    try {\r\n      await _client.from('user_activities_score').upsert({\r\n        'user_id': userId,\r\n        'activity_id': activityId,\r\n        'total_score': totalScore,\r\n        'subcategory_score': subcategoryScore,\r\n        'is_superwow': isSuperWow,\r\n        'superwow_validity_period': isSuperWow\r\n            ? DateTime.now().add(Duration(days: 7)).toIso8601String()\r\n            : null,\r\n        'updated_at': DateTime.now().toIso8601String(),\r\n      });\r\n    } catch (e) {\r\n      print(' Erreur lors de la sauvegarde du score: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 5177,
        "last_modified": "2025-04-16T13:25:26.0598614",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\config\\remote_config_adapter.dart",
      "content": "// lib/core/adapters/supabase/config/remote_config_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\nimport '../../../domain/models/config/home_section_config.dart';\r\nimport '../../../domain/models/config/app_remote_config.dart';\r\nimport '../../../domain/ports/config/remote_config_port.dart';\r\nimport '../../../domain/models/config/subcategory_section_config.dart';\r\n\r\n\r\nclass SupabaseRemoteConfigAdapter implements RemoteConfigPort {\r\n  final SupabaseClient _client;\r\n\r\n  SupabaseRemoteConfigAdapter(this._client);\r\n\r\n  @override\r\n  Future<List<HomeSectionConfig>> getHomeSections() async {\r\n    try {\r\n      print(' Calling Supabase home_sections');\r\n      final response = await _client\r\n          .from('home_sections')\r\n          .select()\r\n          .order('priority');\r\n      print(' Raw Supabase response: $response');\r\n\r\n      if (response == null) return [];\r\n\r\n      final List<HomeSectionConfig> sections = (response as List).map((data) {\r\n        print(' Processing data: $data');\r\n        return HomeSectionConfig(\r\n          id: data['id']?.toString() ?? '',\r\n          title: data['title']?.toString() ?? '',\r\n          queryFilter: data['query_filter']?.toString() ?? '{}',\r\n          iconUrl: data['icon_url']?.toString(),\r\n          priority: data['priority'] as int? ?? 0,\r\n          minAppVersion: data['min_app_version']?.toString() ?? '1.0.0',\r\n        );\r\n      }).toList();\r\n\r\n      print(' Created sections: $sections');\r\n      return sections;\r\n    } catch (e, stack) {\r\n      print(' Error in getHomeSections: $e');\r\n      print(' Stack trace: $stack');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<AppRemoteConfig>> getAppConfig() async {\r\n    final response = await _client\r\n        .from('app_remote_config')\r\n        .select();\r\n\r\n    return response.map((json) => AppRemoteConfig.fromJson(json)).toList();\r\n  }\r\n\r\n  @override\r\n  Future<List<SubcategorySectionConfig>> getSubcategorySections(String? subcategoryId) async {\r\n    try {\r\n      print(' Calling Supabase subcategory_sections');\r\n\r\n      // Construction de la requte de base\r\n      var query = _client\r\n          .from('subcategory_sections')\r\n          .select();\r\n\r\n      if (subcategoryId != null) {\r\n        // Si un subcategoryId est fourni, on cherche d'abord les configurations spcifiques\r\n        query = query.or('subcategory_id.eq.$subcategoryId,is_default.eq.true');\r\n      } else {\r\n        // Sinon, on ne prend que les configurations par dfaut\r\n        query = query.eq('is_default', true);\r\n      }\r\n\r\n      final response = await query.order('priority');\r\n      print(' Raw Supabase response: $response');\r\n\r\n      if (response == null) return [];\r\n\r\n      final List<SubcategorySectionConfig> sections = (response as List).map((data) {\r\n        print(' Processing data: $data');\r\n        return SubcategorySectionConfig(\r\n          id: data['id']?.toString() ?? '',\r\n          title: data['title']?.toString() ?? '',\r\n          queryFilter: data['query_filter']?.toString() ?? '{}',\r\n          subcategoryId: data['subcategory_id']?.toString(),\r\n          priority: data['priority'] as int? ?? 0,\r\n          minAppVersion: data['min_app_version']?.toString() ?? '1.0.0',\r\n          isDefault: data['is_default'] as bool? ?? false,\r\n        );\r\n      }).toList();\r\n\r\n      // Si on a un subcategoryId, on priorise les configurations spcifiques\r\n      if (subcategoryId != null) {\r\n        // Trier pour avoir les configs spcifiques avant les configs par dfaut\r\n        sections.sort((a, b) {\r\n          if (a.subcategoryId == subcategoryId && b.subcategoryId != subcategoryId) return -1;\r\n          if (a.subcategoryId != subcategoryId && b.subcategoryId == subcategoryId) return 1;\r\n          return a.priority.compareTo(b.priority);\r\n        });\r\n\r\n        // Pour chaque priorit, ne garder que la premire config (spcifique si elle existe, sinon dfaut)\r\n        final uniqueSections = <SubcategorySectionConfig>[];\r\n        final seenPriorities = <int>{};\r\n\r\n        for (var section in sections) {\r\n          if (!seenPriorities.contains(section.priority)) {\r\n            uniqueSections.add(section);\r\n            seenPriorities.add(section.priority);\r\n          }\r\n        }\r\n\r\n        return uniqueSections;\r\n      }\r\n\r\n      print(' Created sections: $sections');\r\n      return sections;\r\n    } catch (e, stack) {\r\n      print(' Error in getSubcategorySections: $e');\r\n      print(' Stack trace: $stack');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n\r\n}",
      "info": {
        "size": 4559,
        "last_modified": "2025-04-16T13:25:26.0663808",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\database_adapter.dart",
      "content": "// lib\\core\\adapters\\supabase\\database_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\n\r\nclass SupabaseService {\r\n  // Initialisation de Supabase\r\n  static Future<void> initialize() async {\r\n    await dotenv.load();\r\n    await Supabase.initialize(\r\n      url: dotenv.env['SUPABASE_URL']!,\r\n      anonKey: dotenv.env['SUPABASE_ANON_KEY']!,\r\n    );\r\n  }\r\n\r\n  // Accs au client Supabase\r\n  static SupabaseClient get client => Supabase.instance.client;\r\n\r\n  // Rcuprer toutes les catgories\r\n  static Future<List<Map<String, dynamic>>> getCategories() async {\r\n    final response = await client\r\n        .from('categories')\r\n        .select()\r\n        .order('name');\r\n    return List<Map<String, dynamic>>.from(response);\r\n  }\r\n\r\n  // Rcuprer les activits par catgorie\r\n  static Future<List<Map<String, dynamic>>> getActivitiesByCategory(String categoryId) async {\r\n    final response = await client\r\n        .from('activities')\r\n        .select()\r\n        .eq('category_id', categoryId)\r\n        .order('name');\r\n    return List<Map<String, dynamic>>.from(response);\r\n  }\r\n\r\n  // Crer un nouveau voyage\r\n  static Future<Map<String, dynamic>> createTrip(Map<String, dynamic> tripData) async {\r\n    final response = await client\r\n        .from('trips')\r\n        .insert(tripData)\r\n        .select()\r\n        .single();\r\n    return response;\r\n  }\r\n\r\n  // Rcuprer les prfrences d'un utilisateur\r\n  static Future<List<Map<String, dynamic>>> getUserPreferences(String userId) async {\r\n    final response = await client\r\n        .from('user_preferences')\r\n        .select('*, categories(*)')\r\n        .eq('user_id', userId);\r\n    return List<Map<String, dynamic>>.from(response);\r\n  }\r\n\r\n  // Rcuprer les activits filtres via les prfrences utilisateur (RPC)\r\n  static Future<List<Map<String, dynamic>>> getFilteredActivitiesByPreferences(String userId) async {\r\n    try {\r\n      final response = await client.rpc(\r\n        'filter_activities_by_preferences',\r\n        params: {'user_uuid': userId},\r\n      );\r\n\r\n      if (response == null) {\r\n        return [];\r\n      }\r\n\r\n      // Vrifie si la rponse est une liste\r\n      if (response is! List) {\r\n        throw Exception('Format de rponse invalide');\r\n      }\r\n\r\n      // Conversion scurise de la rponse\r\n      return response.map((item) {\r\n        if (item is! Map<String, dynamic>) {\r\n          // Conversion explicite si ncessaire\r\n          return Map<String, dynamic>.from(item as Map);\r\n        }\r\n        return item;\r\n      }).toList();\r\n\r\n    } catch (e) {\r\n      print('Erreur lors de la rcupration des activits filtres: $e'); // Pour le dbogage\r\n      throw Exception('Erreur lors de la rcupration des activits : $e');\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 2837,
        "last_modified": "2025-04-16T13:25:26.0789174",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\empty_daily_trip.adapter.dart",
      "content": "// lib/core/adapters/supabase/empty_daily_trip.adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:uuid/uuid.dart';\r\nimport '../../domain/ports/empty_trips/empty_daily_trip.port.dart';\r\nimport '../../domain/models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\n\r\nclass EmptyDailyTripAdapter implements EmptyDailyTripPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  EmptyDailyTripAdapter(this._supabase);\r\n\r\n  EmptyDailyTrip _convertResponseToEmptyTrip(Map<String, dynamic> response) {\r\n    return EmptyDailyTrip(\r\n      id: response['id'],\r\n      type: response['type'] == 'half_day' ? DailyTripType.half_day : DailyTripType.full_day,\r\n      departureGeohash5: response['departure_geohash5'],\r\n      arrivalGeohash5: response['arrival_geohash5'],\r\n      sw1Id: response['sw1_id'],\r\n      sw2Id: response['sw2_id'],\r\n      traversedGeohashes: List<String>.from(response['traversed_geohashes']),\r\n      routePolyline: response['route_polyline'],\r\n      createdAt: DateTime.parse(response['created_at']),\r\n      totalDuration: response['total_duration'],\r\n      totalDistance: response['total_distance'],\r\n    );\r\n  }\r\n\r\n  @override\r\n  Future<EmptyDailyTrip?> findExistingEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n  }) async {\r\n    try {\r\n      var query = _supabase\r\n          .from('empty_daily_trips')\r\n          .select()\r\n          .eq('type', type.toString().split('.').last)\r\n          .eq('departure_geohash5', departureGeohash5)\r\n          .eq('arrival_geohash5', arrivalGeohash5)\r\n          .eq('sw1_id', sw1Id);\r\n\r\n      query = sw2Id == null\r\n          ? query.filter('sw2_id', 'is', null)\r\n          : query.eq('sw2_id', sw2Id);\r\n\r\n      final response = await query;\r\n\r\n      if (response.isEmpty) return null;\r\n\r\n      return _convertResponseToEmptyTrip(response[0]);\r\n    } catch (e) {\r\n      print(' Erreur recherche empty trip: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<EmptyDailyTrip> getEmptyTrip(String emptyTripId) async {\r\n    try {\r\n      print(' Rcupration empty trip: $emptyTripId');\r\n      final response = await _supabase\r\n          .from('empty_daily_trips')\r\n          .select()\r\n          .eq('id', emptyTripId)\r\n          .single();\r\n\r\n      return _convertResponseToEmptyTrip(response);\r\n    } catch (e) {\r\n      print(' Erreur rcupration empty trip: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<EmptyDailyTrip> createEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n    required List<String> traversedGeohashes,\r\n    required String routePolyline,\r\n    required int totalDuration,\r\n    required int totalDistance,\r\n  }) async {\r\n    try {\r\n      final emptyTrip = EmptyDailyTrip(\r\n        id: const Uuid().v4(),\r\n        type: type,\r\n        departureGeohash5: departureGeohash5,\r\n        arrivalGeohash5: arrivalGeohash5,\r\n        sw1Id: sw1Id,\r\n        sw2Id: sw2Id,\r\n        traversedGeohashes: traversedGeohashes,\r\n        routePolyline: routePolyline,\r\n        createdAt: DateTime.now(),\r\n        totalDuration: totalDuration,\r\n        totalDistance: totalDistance,\r\n      );\r\n\r\n      await _supabase.from('empty_daily_trips').insert({\r\n        ...emptyTrip.toJson(),\r\n        'total_distance': emptyTrip.totalDistance,\r\n        'total_duration': emptyTrip.totalDuration,\r\n      });\r\n\r\n      return emptyTrip;\r\n    } catch (e) {\r\n      print(' Erreur cration empty trip: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3738,
        "last_modified": "2025-04-16T13:25:26.0861912",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\empty_trip_repository.adapter.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.0932307",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\potential_bonus_activity.adapter.dart",
      "content": "// lib/core/adapters/supabase/potential_bonus_activity.adapter.dart\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\nimport '../../common/exceptions/geometry_calculation_exception.dart';\r\n\r\nclass PotentialBonusActivityAdapter {\r\n  final SupabaseClient _supabase;\r\n  static const String _tableName = 'trip_potential_bonus_activities';\r\n\r\n  PotentialBonusActivityAdapter(this._supabase);\r\n\r\n  Future<void> savePotentialBonusActivities(\r\n      List<PotentialBonusActivity> activities\r\n      ) async {\r\n    try {\r\n      final batch = activities.map((activity) => activity.toJson()).toList();\r\n\r\n      await _supabase\r\n          .from(_tableName)\r\n          .upsert(\r\n          batch,\r\n          onConflict: 'trip_potential_bonus_unique'\r\n      );\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to save potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<List<PotentialBonusActivity>> getPotentialBonusActivities({\r\n    required String emptyTripId,\r\n  }) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from(_tableName)\r\n          .select()\r\n          .eq('empty_daily_trip_id', emptyTripId);\r\n\r\n      return (response as List)\r\n          .map((json) => PotentialBonusActivity.fromJson(json))\r\n          .toList();\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to get potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> deletePotentialBonusActivities({\r\n    required String emptyTripId,\r\n  }) async {\r\n    try {\r\n      await _supabase\r\n          .from(_tableName)\r\n          .delete()\r\n          .eq('empty_daily_trip_id', emptyTripId);\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to delete potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  Future<void> updatePotentialBonusActivity(\r\n      PotentialBonusActivity activity\r\n      ) async {\r\n    try {\r\n      await _supabase\r\n          .from(_tableName)\r\n          .update(activity.toJson())\r\n          .eq('id', activity.id);\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to update potential bonus activity: $e'\r\n      );\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2290,
        "last_modified": "2025-04-16T13:25:26.0992299",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\activity_details_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/activity_details_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../domain/models/shared/activity_details_model.dart';\r\nimport '../../../domain/models/shared/activity_image_model.dart';\r\nimport '../../../domain/ports/search/activity_details_port.dart';\r\n\r\nclass ActivityDetailsAdapter implements ActivityDetailsPort {\r\n  final SupabaseClient _client;\r\n\r\n  ActivityDetailsAdapter(this._client);\r\n\r\n  @override\r\n  Future<ActivityDetails> getActivityDetails(String activityId) async {\r\n    try {\r\n      print('Fetching details for activity: $activityId');\r\n\r\n      final response = await _client\r\n          .from('activities')\r\n          .select('''\r\n      id,\r\n      name,\r\n      description,\r\n      latitude,\r\n      longitude,\r\n      category_id,\r\n      address,\r\n      city,\r\n      google_place_id,\r\n      base_price,\r\n      min_duration_minutes,\r\n      max_duration_minutes,\r\n      booking_required,\r\n      wheelchair_accessible,\r\n      kid_friendly,\r\n      postal_code,\r\n      contact_phone,\r\n      contact_email,\r\n      contact_website,\r\n      current_opening_hours,\r\n      price_level,\r\n      activities_images(\r\n        id,\r\n        mobile_url,\r\n        is_main\r\n      )\r\n    ''')\r\n          .eq('id', activityId)\r\n          .single();\r\n\r\n      print('Raw response activities_images: ${response['activities_images']}');\r\n\r\n      // Mapper les images directement avec mobile_url\r\n// Initialiser une liste vide par dfaut\r\n      List<ActivityImage> images = [];\r\n\r\n// Vrifier si on a des images avant de traiter\r\n      final rawImages = response['activities_images'];\r\n      if (rawImages != null) {\r\n        images = (rawImages as List)\r\n            .where((img) => img['mobile_url'] != null)\r\n            .map((img) => ActivityImage(\r\n          id: img['id'] ?? '',\r\n          mobileUrl: img['mobile_url'] ?? '',\r\n          isMain: img['is_main'] ?? false,\r\n        ))\r\n            .toList();\r\n      }\r\n\r\n      print('Images trouves: ${images.length}');\r\n\r\n      print('Mapped images: $images');\r\n\r\n      final details = ActivityDetails.fromJson({\r\n        'id': response['id'] ?? '',\r\n        'name': response['name'] ?? '',\r\n        'description': response['description'],\r\n        'latitude': (response['latitude'] ?? 0.0).toDouble(),\r\n        'longitude': (response['longitude'] ?? 0.0).toDouble(),\r\n        'categoryId': response['category_id'] ?? '',\r\n        'postalCode': response['postal_code'],\r\n        'address': response['address'],\r\n        'city': response['city'],\r\n        'googlePlaceId': response['google_place_id'],\r\n        'currentOpeningHours': response['current_opening_hours'],\r\n        'contactPhone': response['contact_phone'],\r\n        'contactEmail': response['contact_email'],\r\n        'contactWebsite': response['contact_website'],\r\n        'bookingRequired': response['booking_required'],\r\n        'kidFriendly': response['kid_friendly'],\r\n        'wheelchairAccessible': response['wheelchair_accessible'],\r\n        'minDurationMinutes': response['min_duration_minutes'],\r\n        'maxDurationMinutes': response['max_duration_minutes'],\r\n        'priceLevel': response['price_level'],\r\n        'basePrice': response['base_price'],\r\n        'images': images.map((img) => {\r\n          'id': img.id,\r\n          'mobileUrl': img.mobileUrl,\r\n          'isMain': img.isMain,\r\n        }).toList(),\r\n      });\r\n\r\n      print('Final details with images: ${details.images?.length} images');\r\n      return details;\r\n    } catch (e, stack) {\r\n      print('Error getting activity details: $e');\r\n      print('Stack trace: $stack');\r\n      throw Exception('Erreur lors de la rcupration des dtails : $e');\r\n    }\r\n  }\r\n}\r\n",
      "info": {
        "size": 3732,
        "last_modified": "2025-04-16T13:25:26.1063494",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\activity_search_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/activity_search_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../domain/ports/search/activity_search_port.dart';\r\nimport '../../../domain/models/activity/search/searchable_activity.dart';\r\n\r\nclass ActivitySearchAdapter implements ActivitySearchPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  ActivitySearchAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<List<SearchableActivity>> getActivitiesWithFilters({\r\n    required double latitude,\r\n    required double longitude,\r\n    required String cityId, // Gard pour compatibilit mais non envoy  Supabase\r\n    double? maxDistance,\r\n    String? categoryId,\r\n    String? subcategoryId,\r\n    bool? isWow,\r\n    double? minRating,\r\n    int? minRatingCount,\r\n    int? maxRatingCount,\r\n    bool? kidFriendly,\r\n    String? orderBy,\r\n    String? orderDirection,\r\n    int? limit,\r\n  }) async {\r\n    try {\r\n      // Crer exactement les paramtres attendus par la fonction SQL\r\n      final params = {\r\n        'p_category_id': categoryId,\r\n        'p_is_wow': isWow,\r\n        'p_kid_friendly': kidFriendly,\r\n        'p_latitude': latitude,\r\n        'p_limit': limit ?? 50,\r\n        'p_longitude': longitude,\r\n        'p_max_distance': maxDistance,\r\n        'p_max_rating_count': maxRatingCount,\r\n        'p_min_rating': minRating,\r\n        'p_min_rating_count': minRatingCount,\r\n        'p_order_by': orderBy ?? 'distance',\r\n        'p_order_direction': orderDirection ?? 'ASC',\r\n        'p_subcategory_id': subcategoryId\r\n      };\r\n\r\n      print(' Calling get_activities_list:');\r\n      print(' Coords: ($latitude, $longitude), max distance: $maxDistance');\r\n      print(' Parameters: $params');\r\n\r\n      final response = await _supabase.rpc(\r\n        'get_activities_list',\r\n        params: params, // Envoyer tous les paramtres\r\n      );\r\n\r\n      print(' Number of activities: ${response?.length ?? 0}');\r\n\r\n      if (response == null) return [];\r\n\r\n      final activities = (response as List)\r\n          .map((data) => SearchableActivity.fromSupabase(\r\n        data as Map<String, dynamic>,\r\n        distanceFromSearch: data['distance']?.toDouble(),\r\n      ))\r\n          .toList();\r\n\r\n      print(' Processed ${activities.length} activities');\r\n      return activities;\r\n    } catch (e, stack) {\r\n      print(' Error fetching activities: $e');\r\n      print(' Stack trace: $stack');\r\n      throw Exception('Failed to fetch activities: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2510,
        "last_modified": "2025-04-16T13:25:26.1138932",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\city_cache_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/city_cache_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:uuid/uuid.dart'; // Ajoutez cette dpendance  pubspec.yaml\r\nimport '../../../domain/ports/location/city_cache_port.dart';\r\nimport '../../../domain/models/shared/city_model.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\nimport '../../../common/utils/geohash.dart';\r\nimport '../../../common/exceptions/location_exceptions.dart';\r\n\r\nclass SupabaseCityCacheAdapter implements CityCachePort {\r\n  final SupabaseClient _supabase;\r\n  final _uuid = Uuid();\r\n\r\n  SupabaseCityCacheAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<City?> getCityByPlaceId(String placeId) async {\r\n    try {\r\n      // Rechercher d'abord par place_id (nouvelle colonne)\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('place_id', placeId)  // Utiliser 'place_id' au lieu de 'id'\r\n          .maybeSingle();\r\n\r\n      if (response == null) return null;\r\n\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration de la ville par place_id: $e');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City?> getCityByName(String cityName) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('city_name', cityName)\r\n          .maybeSingle();\r\n\r\n      if (response == null) return null;\r\n\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration de la ville par nom: $e');\r\n      return null;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City> saveCity({\r\n    required String placeId,\r\n    required String cityName,\r\n    required double lat,\r\n    required double lon,\r\n  }) async {\r\n    try {\r\n      // Gnrer le geohash\r\n      final geohash5 = Geohash.encode(lat, lon);\r\n\r\n      // Gnrer un UUID valide pour la colonne 'id'\r\n      final uuid = _uuid.v4();\r\n\r\n      // Prparer les donnes\r\n      final cityData = {\r\n        'id': uuid,               // UUID gnr pour Supabase\r\n        'place_id': placeId,      // Google Place ID dans une colonne ddie\r\n        'city_name': cityName,\r\n        'lat': lat,\r\n        'lon': lon,\r\n        'geohash_5': geohash5,\r\n      };\r\n\r\n      print(' VILLE  SAUVEGARDER: $cityName');\r\n      print('   Latitude: $lat');\r\n      print('   Longitude: $lon');\r\n      print('   Geohash: $geohash5');\r\n\r\n      // Upsert pour grer  la fois insertion et mise  jour\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .upsert(cityData, onConflict: 'place_id')\r\n          .select()\r\n          .single();\r\n\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      print(' Erreur lors de la sauvegarde de la ville: $e');\r\n      throw LocationException('Erreur lors de la sauvegarde de la ville: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City> savePlaceDetailsAsCity(PlaceDetails placeDetails) async {\r\n    return saveCity(\r\n      placeId: placeDetails.placeId,\r\n      cityName: placeDetails.name,\r\n      lat: placeDetails.location.latitude,\r\n      lon: placeDetails.location.longitude,\r\n    );\r\n  }\r\n}\r\n\r\n",
      "info": {
        "size": 3264,
        "last_modified": "2025-04-16T13:25:26.1209363",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\city_search_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/city_search_adapter.dart\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../domain/models/shared/city_model.dart';\r\nimport '../../../domain/ports/search/city_search_port.dart';\r\n\r\nclass CitySearchAdapter implements CitySearchPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  CitySearchAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<List<City>> searchCities(String? query) async {\r\n    try {\r\n      print('DEBUG: Searching cities with query: $query');\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .ilike('city_name', '%${query ?? ''}%')\r\n          .limit(10);\r\n\r\n      print('DEBUG: Cities response: $response');\r\n      return (response as List).map((json) => City.fromJson(json)).toList();\r\n    } catch (e) {\r\n      print('DEBUG: Error in searchCities: $e');\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<City?> getCityById(String id) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('id', id)\r\n          .single();\r\n\r\n      return response != null ? City.fromJson(response) : null;\r\n    } catch (e) {\r\n      print('Error getting city by id: $e');\r\n      return null;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1278,
        "last_modified": "2025-04-16T13:25:26.1280307",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\search\\subcategory_search_adapter.dart",
      "content": "// lib/core/adapters/supabase/search/subcategory_search_adapter.dart\r\n\r\nimport '../../../domain/ports/search/subcategory_search_port.dart';\r\nimport '../../../domain/models/shared/subcategory_model.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\nclass SubcategorySearchAdapter implements SubcategorySearchPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  SubcategorySearchAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<List<Subcategory>> getSubcategoriesForSearch() async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('activity_subcategories')\r\n          .select('id, name, category_id, icon')\r\n          .lt('priority', 20)\r\n          .order('priority', ascending: true);\r\n\r\n      // Ajouter une vrification et conversion explicite\r\n      final subcategories = (response as List).map((item) {\r\n\r\n        // Assurer que tous les champs requis sont convertis en String\r\n        return {\r\n          'id': item['id'].toString(),\r\n          'name': item['name'].toString(),\r\n          'categoryId': item['category_id'].toString(),\r\n          'description': item['description']?.toString(),\r\n          'icon': item['icon']?.toString() ?? 'activity',\r\n        };\r\n      }).map((json) => Subcategory.fromJson(json)).toList();\r\n\r\n      return subcategories;\r\n    } catch (e, stack) {\r\n      throw Exception('Failed to fetch subcategories');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1392,
        "last_modified": "2025-04-16T13:25:26.1350733",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\superwow_management.adapter.dart",
      "content": "// core/adapters/supabase/superwow_management.adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../domain/ports/empty_trips/superwow_management.port.dart';\r\nimport '../../domain/ports/empty_trips/route_optimization.port.dart';\r\nimport '../../domain/models/trip_designer/empty_trips/value_objects/superwow_pair.dart';\r\nimport '../../domain/models/scored_activity.dart';\r\nimport '../../domain/services/designer/empty_trips/distance_calculation.service.dart';\r\n\r\nclass SuperWowManagementAdapter implements SuperWowManagementPort {\r\n  final SupabaseClient _supabase;\r\n  final RouteOptimizationPort _routeOptimization;\r\n  final DistanceCalculationService _distanceService;\r\n\r\n  SuperWowManagementAdapter(\r\n      this._supabase,\r\n      this._routeOptimization,\r\n      this._distanceService,\r\n      );\r\n\r\n  @override\r\n  Future<List<ScoredActivity>> getTripSuperWows(String tripId) async {\r\n    try {\r\n      print(' Rcupration des SuperWow pour le trip $tripId');\r\n\r\n      final response = await _supabase\r\n          .from('trip_activities')\r\n          .select('*, activity:activities(*)')\r\n          .eq('trip_id', tripId)\r\n          .eq('is_superwow', true)\r\n          .eq('status', 'suggested');\r\n\r\n      print(' ${response.length} SuperWow trouvs');\r\n\r\n      return response.map<ScoredActivity>((data) =>\r\n          ScoredActivity.fromJson({\r\n            ...data['activity'],\r\n            'total_score': data['total_score'],\r\n            'subcategory_score': data['subcategory_score'],\r\n            'is_superwow': data['is_superwow'],\r\n          })\r\n      ).toList();\r\n    } catch (e) {\r\n      print(' Erreur lors de la rcupration des SuperWow: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<ScoredActivity> findClosestSuperWow(\r\n      List<ScoredActivity> superWows,\r\n      LatLng fromPoint,\r\n      ) async {\r\n    try {\r\n      print(' Recherche du SuperWow le plus proche');\r\n\r\n      ScoredActivity? closest;\r\n      double minDistance = double.infinity;\r\n\r\n      for (var sw in superWows) {\r\n        final swLocation = LatLng(\r\n            sw.activityData['latitude'],\r\n            sw.activityData['longitude']\r\n        );\r\n\r\n        final distance = _distanceService.calculateDistance(fromPoint, swLocation);\r\n\r\n        if (distance < minDistance) {\r\n          minDistance = distance;\r\n          closest = sw;\r\n        }\r\n      }\r\n\r\n      if (closest == null) {\r\n        throw Exception('Aucun SuperWow trouv');\r\n      }\r\n\r\n      print(' SuperWow le plus proche trouv: ${closest.activityData['name']}');\r\n      return closest;\r\n    } catch (e) {\r\n      print(' Erreur lors de la recherche du SuperWow le plus proche: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<SuperWowPair>> findTop3NearestPairs(\r\n      String tripId,\r\n      String baseSuperWowId,\r\n      List<ScoredActivity> availableSuperWows,\r\n      ) async {\r\n    try {\r\n      print(' Recherche des 3 SuperWow les plus proches de $baseSuperWowId');\r\n\r\n      final baseSW = availableSuperWows.firstWhere((sw) => sw.id == baseSuperWowId);\r\n      final baseLocation = LatLng(\r\n        baseSW.activityData['latitude'],\r\n        baseSW.activityData['longitude'],\r\n      );\r\n\r\n      final pairs = <SuperWowPair>[];\r\n\r\n      for (var sw in availableSuperWows) {\r\n        if (sw.id == baseSuperWowId) continue;\r\n\r\n        // Chercher d'abord en base\r\n        final existingDistances = await _supabase\r\n            .from('activity_distances')\r\n            .select()\r\n            .or('and(activity_id_1.eq.${baseSuperWowId},activity_id_2.eq.${sw.id}),'\r\n            'and(activity_id_1.eq.${sw.id},activity_id_2.eq.${baseSuperWowId})')\r\n            .limit(1);\r\n\r\n        final swLocation = LatLng(\r\n          sw.activityData['latitude'],\r\n          sw.activityData['longitude'],\r\n        );\r\n\r\n        if (existingDistances.isNotEmpty) {\r\n          print(' Distance en cache trouve pour ${sw.activityData['name']}');\r\n          final cached = existingDistances.first;\r\n\r\n          pairs.add(SuperWowPair(\r\n            sw1Id: baseSuperWowId,\r\n            sw2Id: sw.id,\r\n            sw1Location: baseLocation,\r\n            sw2Location: swLocation,\r\n            distanceBetween: cached['distance_meters'],\r\n            travelTime: Duration(seconds: cached['travel_time_seconds']),\r\n          ));\r\n          continue;\r\n        }\r\n\r\n        // Sinon calculer et sauvegarder\r\n        print(' Calcul distance pour ${sw.activityData['name']}');\r\n        final distance = _distanceService.calculateDistance(baseLocation, swLocation);\r\n        final travelTime = _distanceService.estimateTravelTime(distance);\r\n\r\n        // Sauvegarder avec l'ID le plus petit en premier\r\n        final orderedIds = [baseSuperWowId, sw.id]..sort();\r\n        await _supabase.from('activity_distances').insert({\r\n          'activity_id_1': orderedIds[0],\r\n          'activity_id_2': orderedIds[1],\r\n          'distance_meters': distance.round(),\r\n          'travel_time_seconds': travelTime,\r\n        });\r\n\r\n        pairs.add(SuperWowPair(\r\n          sw1Id: baseSuperWowId,\r\n          sw2Id: sw.id,\r\n          sw1Location: baseLocation,\r\n          sw2Location: swLocation,\r\n          distanceBetween: distance.round(),\r\n          travelTime: Duration(seconds: travelTime),\r\n        ));\r\n      }\r\n\r\n      // Tri et slection des 3 plus proches\r\n      pairs.sort((a, b) => a.distanceBetween.compareTo(b.distanceBetween));\r\n      final top3 = pairs.take(3).toList();\r\n\r\n      print(' ${top3.length} paires de SuperWow trouves');\r\n      return top3;\r\n    } catch (e) {\r\n      print(' Erreur lors de la recherche des paires de SuperWow: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n\r\n  @override\r\n  Future<List<SuperWowPair>> generateOptimizedPairs(\r\n      String tripId,\r\n      List<ScoredActivity> superWows,\r\n      LatLng departurePoint,\r\n      ) async {\r\n    try {\r\n      print(' Gnration des paires optimises de SuperWow');\r\n      final validPairs = <SuperWowPair>[];\r\n      final processedPairs = <String>{};  // Pour viter les doublons\r\n\r\n      // 1. Trier les SW par distance au point de dpart\r\n      final sortedSuperWows = [...superWows];\r\n      sortedSuperWows.sort((a, b) {\r\n        final aLocation = LatLng(\r\n            a.activityData['latitude'],\r\n            a.activityData['longitude']\r\n        );\r\n        final bLocation = LatLng(\r\n            b.activityData['latitude'],\r\n            b.activityData['longitude']\r\n        );\r\n\r\n        final distA = _distanceService.calculateDistance(departurePoint, aLocation);\r\n        final distB = _distanceService.calculateDistance(departurePoint, bLocation);\r\n        return distA.compareTo(distB);\r\n      });\r\n\r\n      // 2. Pour chaque SW, trouver ses paires valides\r\n      for (final sw1 in sortedSuperWows) {\r\n        final sw1Preferences = sw1.activityData['moment_preferences'] as Map<String, dynamic>;\r\n        final sw1Location = LatLng(\r\n            sw1.activityData['latitude'],\r\n            sw1.activityData['longitude']\r\n        );\r\n\r\n        // 3. Dterminer les crneaux valides pour SW2\r\n        List<String> validMoments = [];\r\n        if (sw1Preferences['morning'] == true) {\r\n          validMoments = ['afternoon', 'evening'];\r\n        } else if (sw1Preferences['afternoon'] == true) {\r\n          validMoments = ['evening'];\r\n        } else {\r\n          continue; // Skip si pas de crneau valide pour SW1\r\n        }\r\n\r\n        // 4. Filtrer et trier les SW2 potentiels\r\n        final potentialSW2s = superWows.where((sw2) {\r\n          if (sw2.id == sw1.id) return false;\r\n\r\n          final sw2Preferences = sw2.activityData['moment_preferences'] as Map<String, dynamic>;\r\n          return validMoments.any((moment) => sw2Preferences[moment] == true);\r\n        }).toList();\r\n\r\n        // 5. Trier par distance  SW1\r\n        potentialSW2s.sort((a, b) {\r\n          final aLocation = LatLng(\r\n              a.activityData['latitude'],\r\n              a.activityData['longitude']\r\n          );\r\n          final bLocation = LatLng(\r\n              b.activityData['latitude'],\r\n              b.activityData['longitude']\r\n          );\r\n\r\n          final distA = _distanceService.calculateDistance(sw1Location, aLocation);\r\n          final distB = _distanceService.calculateDistance(sw1Location, bLocation);\r\n          return distA.compareTo(distB);\r\n        });\r\n\r\n        // 6. Prendre les 3 plus proches en vitant les doublons\r\n        for (final sw2 in potentialSW2s.take(3)) {\r\n          final sw2Location = LatLng(\r\n              sw2.activityData['latitude'],\r\n              sw2.activityData['longitude']\r\n          );\r\n\r\n          // Vrifier les doublons\r\n          final pairKey = [sw1.id, sw2.id]..sort();\r\n          final pairId = pairKey.join('-');\r\n          if (processedPairs.contains(pairId)) continue;\r\n          processedPairs.add(pairId);\r\n\r\n          // Calculer distance et temps de trajet\r\n          final distance = _distanceService.calculateDistance(sw1Location, sw2Location);\r\n          final travelTime = _distanceService.estimateTravelTime(distance);\r\n\r\n          validPairs.add(SuperWowPair(\r\n            sw1Id: sw1.id,\r\n            sw2Id: sw2.id,\r\n            sw1Location: sw1Location,\r\n            sw2Location: sw2Location,\r\n            distanceBetween: distance.round(),\r\n            travelTime: Duration(seconds: travelTime),\r\n          ));\r\n        }\r\n      }\r\n\r\n      print(' ${validPairs.length} paires valides gnres');\r\n      return validPairs;\r\n\r\n    } catch (e) {\r\n      print(' Erreur gnration paires optimises: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 9684,
        "last_modified": "2025-04-16T13:25:26.1471131",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\supabase\\trip_activities_adapter.dart",
      "content": "// core/adapters/supabase/trip_activities_adapter.dart\r\n\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/trip_activities_port.dart';\r\nimport '../../domain/models/scored_activity.dart';\r\n\r\nclass TripActivitiesAdapter implements TripActivitiesPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  TripActivitiesAdapter(this._supabase);\r\n\r\n  @override\r\n  Future<void> saveFilteredActivities({\r\n    required String tripId,\r\n    required List<ScoredActivity> activities,\r\n    required bool isSuperwow,\r\n  }) async {\r\n    try {\r\n      print(' Dbut sauvegarde - Trip: $tripId - ${activities.length} activits');\r\n\r\n      final validActivities = activities.where((a) => a.subcategoryScore > 0).toList();\r\n      print(' ${activities.length - validActivities.length} activits ignores (score 0)');\r\n\r\n      // Avant l'upsert, faire un select pour comparer les donnes\r\n      final existingRecords = await _supabase\r\n          .from('trip_activities')\r\n          .select()\r\n          .eq('trip_id', tripId)\r\n          .inFilter('activity_id', validActivities.map((a) => a.id).toList());\r\n\r\n      print(' ${existingRecords.length} activits existantes trouves');\r\n\r\n      // Prparer les nouvelles donnes ou mises  jour\r\n      final batch = validActivities.map((activity) {\r\n        // Chercher l'enregistrement existant\r\n        final existing = existingRecords\r\n            .firstWhere(\r\n              (e) => e['activity_id'] == activity.id,\r\n          orElse: () => {}, // Retourne un objet vide au lieu de null\r\n        );\r\n\r\n        // Vrifier si une mise  jour est ncessaire\r\n        if (existing.isNotEmpty &&\r\n            existing['total_score'] == activity.totalScore &&\r\n            existing['subcategory_score'] == activity.subcategoryScore &&\r\n            existing['is_superwow'] == isSuperwow) {\r\n          print(' Activit ${activity.id} inchange');\r\n          return null;  // Skip cette activit\r\n        }\r\n\r\n        // Nouvelle activit ou mise  jour ncessaire\r\n        final data = {\r\n          'trip_id': tripId,\r\n          'activity_id': activity.id,\r\n          'planned_date': DateTime.now().toIso8601String(),\r\n          'status': 'suggested',\r\n          'priority': isSuperwow ? 1 : 2,\r\n          'total_score': activity.totalScore,\r\n          'subcategory_score': activity.subcategoryScore,\r\n          'is_superwow': isSuperwow,\r\n          'geohash': activity.activityData['geohash'],\r\n          'user_modified': false,\r\n          'updated_at': DateTime.now().toIso8601String(),\r\n        };\r\n\r\n        print(' Prparation activit ${activity.id} : $data');\r\n        return data;\r\n      }).whereType<Map<String, dynamic>>().toList();  // Filtrer les null\r\n\r\n      if (batch.isEmpty) {\r\n        print(' Aucune mise  jour ncessaire');\r\n        return;\r\n      }\r\n\r\n      print(' Mise  jour/insertion de ${batch.length} activits');\r\n      await _supabase.from('trip_activities').upsert(batch);\r\n      print(' Rsultat upsert: Succs');\r\n\r\n    } catch (e) {\r\n      print(' Erreur sauvegarde: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n\r\n\r\n  @override\r\n  Future<List<ScoredActivity>> getSuperwowActivities(String tripId) async {\r\n    final response = await _supabase\r\n        .from('trip_activities')\r\n        .select('*, activity:activities(*)')\r\n        .eq('trip_id', tripId)\r\n        .eq('is_superwow', true)\r\n        .eq('status', 'suggested');\r\n\r\n    return response.map<ScoredActivity>((data) =>\r\n        ScoredActivity.fromJson({\r\n          ...data['activity'],\r\n          'total_score': data['total_score'],\r\n          'subcategory_score': data['subcategory_score'],\r\n          'is_superwow': data['is_superwow'],\r\n        })\r\n    ).toList();\r\n  }\r\n}",
      "info": {
        "size": 3766,
        "last_modified": "2025-04-16T13:25:26.1531596",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\adapters\\trip\\trip_adapter.dart",
      "content": "// core/adapters/supabase/trip_adapter.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../domain/ports/trip_port.dart';\r\nimport '../../domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\nimport '../../domain/models/shared/city_model.dart';\r\nimport '../../domain/services/trip_service.dart';\r\nimport '../../domain/use_cases/create_trip_use_case.dart';\r\n\r\nclass TripAdapter implements TripPort {\r\n  final SupabaseClient _supabase;\r\n  final TripService _tripService;\r\n\r\n  TripAdapter(SupabaseClient supabase) :\r\n        _supabase = supabase,\r\n        _tripService = TripService(supabase);\r\n\r\n  @override\r\n  Future<Trip> createTrip(CreateTripParams params, City departureCity) async {\r\n    try {\r\n      return await _tripService.saveTrip(\r\n        userId: params.userId,\r\n        title: params.title,\r\n        startDate: params.startDate,\r\n        endDate: params.endDate,\r\n        travelGroup: params.travelGroup,\r\n        activityHours: params.activityHours,\r\n        departureCity: departureCity,\r\n        travelStyle: params.travelStyle,\r\n        preferredMoment: params.preferredMoment,\r\n        dailyBudget: params.dailyBudget,\r\n      );\r\n    } on TripException {\r\n      rethrow;\r\n    } catch (e) {\r\n      throw TripCreationException('chec de la cration du voyage: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<Trip> getTrip(String tripId) async {\r\n    try {\r\n      print(' Tentative de rcupration du voyage: $tripId');\r\n\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .select('''\r\n          *,\r\n          cities!trips_departure_city_id_fkey (*)\r\n        ''')\r\n          .eq('id', tripId)\r\n          .single();\r\n\r\n      print(' Rponse Supabase: $response');\r\n\r\n      if (response == null) {\r\n        print(' Aucun voyage trouv');\r\n        throw TripNotFoundException('Voyage non trouv avec l\\'ID: $tripId');\r\n      }\r\n\r\n      // Renommer la cl pour correspondre  notre modle\r\n      if (response['cities'] != null) {\r\n        response['departure_city'] = response['cities'];\r\n        response.remove('cities');\r\n      }\r\n\r\n      try {\r\n        final trip = Trip.fromJson(response);\r\n        print(' Voyage trouv et pars: ${trip.title}');\r\n        return trip;\r\n      } catch (e) {\r\n        print(' Erreur lors du parsing du voyage: $e');\r\n        throw TripNotFoundException('Erreur lors du parsing du voyage: $e');\r\n      }\r\n    }\r\n    catch (e) {\r\n      print(' Erreur dans getTrip: $e');\r\n      throw TripNotFoundException('Erreur lors de la rcupration du voyage: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<Trip>> getTripsForUser(String userId) async {\r\n    try {\r\n      return await _tripService.getTripsForUser(userId);\r\n    } catch (e) {\r\n      throw DataException('User trips fetch failed: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2933,
        "last_modified": "2025-04-16T13:25:26.1657116",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\geometry_constants.dart",
      "content": "// lib/core/common/constants/geometry_constants.dart\r\n\r\nclass GeometryConstants {\r\n  // Distances\r\n  static const double defaultToleranceMeters = 100.0;\r\n  static const double maxDetourDistanceKm = 5.0;\r\n\r\n  // Facteurs de conversion pour le calcul du malus\r\n  static const double relaxedTravelFactor = 2.0;  // Plus de temps allou\r\n  static const double balancedTravelFactor = 1.75;\r\n  static const double activeTravelFactor = 1.5;  // Moins de temps allou\r\n\r\n  // Vitesse moyenne estime (en m/s)\r\n  static const double averageSpeedMetersPerSecond = 13.89; // ~50km/h\r\n\r\n  // Seuils pour les calculs\r\n  static const int minimumMalusMinutes = 5;\r\n  static const int maximumMalusMinutes = 120;\r\n}",
      "info": {
        "size": 701,
        "last_modified": "2025-04-16T13:25:26.1827906",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\location_constants.dart",
      "content": "// lib/core/common/constants/location_constants.dart\r\n\r\nclass LocationConstants {\r\n  // Distance maximale par dfaut pour la recherche d'activits (en km)\r\n  static const double defaultSearchRadius = 150.0;\r\n\r\n  // Limites min/max que l'utilisateur peut choisir\r\n  static const double minSearchRadius = 10.0;\r\n  static const double maxSearchRadius = 300.0;\r\n\r\n  // Rayon de recherche pour l'API Places (en mtres)\r\n  static const int defaultPlacesSearchRadiusMeters = 50000;\r\n\r\n  // Dlai de debounce pour limiter les appels API (en millisecondes)\r\n  static const int searchDebounceTime = 300;\r\n\r\n  // Prcision minimale requise pour la golocalisation (en mtres)\r\n  static const double minLocationAccuracy = 100.0;\r\n\r\n  // Taille maximale du cache (nombre d'entres)\r\n  static const int maxCacheEntries = 100;\r\n\r\n  // Coordonnes des dpartements cibls (centre, rayon en mtres)\r\n  static const Map<String, Map<String, dynamic>> targetDepartments = {\r\n    'Dordogne': {\r\n      'center': {'lat': 45.1909, 'lng': 0.7214},\r\n      'radius': 80000,\r\n    },\r\n    'Lot': {\r\n      'center': {'lat': 44.6239, 'lng': 1.6094},\r\n      'radius': 50000,\r\n    },\r\n    'Corrze': {\r\n      'center': {'lat': 45.3394, 'lng': 1.8655},\r\n      'radius': 50000,\r\n    },\r\n  };\r\n}\r\n\r\n/// Reprsente un biais de localisation pour centrer les recherches\r\nclass LocationBias {\r\n  final String label;\r\n  final double latitude;\r\n  final double longitude;\r\n  final int radius;\r\n\r\n  const LocationBias({\r\n    required this.label,\r\n    required this.latitude,\r\n    required this.longitude,\r\n    required this.radius,\r\n  });\r\n\r\n  @override\r\n  String toString() => '$label ($latitude, $longitude)';\r\n\r\n  /// Convertit en format utilisable par l'API Google Places (circle:radius@lat,lng)\r\n  String toGoogleCircleBias() => 'circle:$radius@$latitude,$longitude';\r\n}\r\n",
      "info": {
        "size": 1847,
        "last_modified": "2025-04-16T13:25:26.1887908",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\subcategory_icons.dart",
      "content": "// lib/core/common/constants/subcategory_icons.dart\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport 'package:flutter/material.dart';\r\n\r\nclass SubcategoryIcons {\r\n  static final Map<String, IconData> icons = {\r\n    'moon-star': LucideIcons.moonStar,\r\n    'bird': LucideIcons.bird,\r\n    'bike': LucideIcons.bike,\r\n    'wine': LucideIcons.wine,\r\n    'utensils-crossed': LucideIcons.utensilsCrossed,\r\n    'sparkles': LucideIcons.sparkles,\r\n    'palette': LucideIcons.palette,\r\n    'spa': LucideIcons.flower2,\r\n    'droplet': LucideIcons.droplet,\r\n    'home': LucideIcons.home,\r\n    'cave': LucideIcons.warehouse,\r\n    'castle': LucideIcons.castle,\r\n    'plate': LucideIcons.utensils,\r\n    'party-popper': LucideIcons.partyPopper,\r\n    'mountain': LucideIcons.mountain,\r\n    'map': LucideIcons.map,\r\n    // 'horse': LucideIcons.horseIcon,\r\n    'anchor': LucideIcons.anchor,\r\n    'roller-coaster': LucideIcons.rollerCoaster,\r\n    'plane': LucideIcons.plane,\r\n    // 'meditation': LucideIcons.yoga,\r\n    'star': LucideIcons.star,\r\n    'key': LucideIcons.key,\r\n    'shopping-bag': LucideIcons.shoppingBag,\r\n    'landmark': LucideIcons.landmark,\r\n    'hammer': LucideIcons.hammer,\r\n    'compass': LucideIcons.compass,\r\n  };\r\n\r\n  static IconData getIcon(String? iconName) {\r\n    return icons[iconName] ?? LucideIcons.activity;\r\n  }\r\n}",
      "info": {
        "size": 1334,
        "last_modified": "2025-04-16T13:25:26.1953039",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\constants\\trip_constants.dart",
      "content": "// core/common/constants/trip_constants.dart\r\n\r\n\r\nclass TripConstants {\r\n  static const Map<String, int> maxTravelTimes = {\r\n    'around_me': 60,      // 1h\r\n    'small_getaway': 105, // 1h45\r\n    'exploration_day': 150, // 2h30\r\n    'big_adventure': 300,  // 5h\r\n  };\r\n\r\n  static const Map<String, int> minTravelTimes = {\r\n    'exploration_day': 90,  // 1h30\r\n    'big_adventure': 120,   // 2h\r\n  };\r\n\r\n  // Temps de repas standards\r\n  static const int mealDuration = 90; // 1h30 par repas\r\n\r\n  // Crneaux de repas\r\n  static const Map<String, (int, int)> mealTimeSlots = {\r\n    'lunch': (12, 13),  // 12h-13h\r\n    'dinner': (19, 20), // 19h-20h\r\n  };\r\n\r\n  // Ajouter dans la classe TripConstants\r\n  static const Map<String, int> mealDurationByStyle = {\r\n    'relax': 120,     // 2h par repas\r\n    'balanced': 90,   // 1h30 (standard)\r\n    'active': 60,     // 1h par repas\r\n  };\r\n\r\n}",
      "info": {
        "size": 886,
        "last_modified": "2025-04-16T13:25:26.2023369",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\enums\\trip_enums.dart",
      "content": "// lib\\core\\common\\enums\\trip_enums.dart\r\n\r\nenum GroupMemberType {\r\n  adult,\r\n  senior,\r\n  teenager,\r\n  child,\r\n}\r\n\r\nextension GroupMemberTypeExtension on GroupMemberType {\r\n  static GroupMemberType? fromJson(dynamic value) {\r\n    if (value == null) return null;\r\n    return GroupMemberType.values.firstWhere(\r\n          (e) => e.toString().split('.').last == value.toString().toLowerCase(),\r\n      orElse: () => GroupMemberType.adult,\r\n    );\r\n  }\r\n\r\n  String get value => toString().split('.').last;\r\n}\r\n\r\nenum PreferredMoment {\r\n  morning,\r\n  afternoon,\r\n  all_day,\r\n  evening,\r\n}\r\n\r\nextension PreferredMomentExtension on PreferredMoment {\r\n  static PreferredMoment? fromJson(dynamic value) {\r\n    if (value == null) return null;\r\n    switch (value.toString().toLowerCase()) {\r\n      case 'morning':\r\n        return PreferredMoment.morning;\r\n      case 'afternoon':\r\n        return PreferredMoment.afternoon;\r\n      case 'all_day':\r\n        return PreferredMoment.all_day;\r\n      case 'evening':\r\n        return PreferredMoment.evening;\r\n      default:\r\n        throw Exception('Invalid PreferredMoment value: $value');\r\n    }\r\n  }\r\n\r\n  String get value {\r\n    return this.toString().split('.').last;\r\n  }\r\n}\r\n\r\nenum TravelStyle {\r\n  relax,\r\n  balanced,\r\n  active,\r\n}\r\n\r\nextension TravelStyleExtension on TravelStyle {\r\n  static TravelStyle? fromJson(dynamic value) {\r\n    if (value == null) return null;\r\n    switch (value.toString().toLowerCase()) {\r\n      case 'relax':\r\n        return TravelStyle.relax;\r\n      case 'balanced':\r\n        return TravelStyle.balanced;\r\n      case 'active':\r\n        return TravelStyle.active;\r\n      default:\r\n        throw Exception('Invalid TravelStyle value: $value');\r\n    }\r\n  }\r\n\r\n  String get value {\r\n    return toString().split('.').last;\r\n  }\r\n\r\n  String get displayName {\r\n    return toString().split('.').last;\r\n  }\r\n\r\n  int get maxActivities {\r\n    switch (this) {\r\n      case TravelStyle.relax:\r\n        return 4;\r\n      case TravelStyle.balanced:\r\n        return 5;\r\n      case TravelStyle.active:\r\n        return 6;\r\n    }\r\n  }\r\n\r\n  int getDurationMinutes(int minDuration, int maxDuration) {\r\n    switch (this) {\r\n      case TravelStyle.relax:\r\n        return maxDuration;\r\n      case TravelStyle.active:\r\n        return minDuration;\r\n      case TravelStyle.balanced:\r\n        return (minDuration + maxDuration) ~/ 2;\r\n      default:\r\n        return minDuration; // Par scurit, mme si tous les cas sont couverts\r\n    }\r\n  }\r\n}\r\n\r\nenum ExplorationType {\r\n  around_me,\r\n  small_getaway,\r\n  exploration_day,\r\n  big_adventure\r\n}\r\n\r\nextension ExplorationTypeExtension on ExplorationType {\r\n\r\n  double get maxDistance {\r\n    switch (this) {\r\n      case ExplorationType.around_me:\r\n        return 35.0;\r\n      case ExplorationType.small_getaway:\r\n        return 56.0;\r\n      case ExplorationType.exploration_day:\r\n        return 90.0;\r\n      case ExplorationType.big_adventure:\r\n        return 120.0;\r\n    }\r\n  }\r\n\r\n  static ExplorationType? fromJson(String? json) {\r\n    if (json == null) return null;\r\n    return ExplorationType.values.firstWhere(\r\n          (e) => e.toString().split('.').last == json,\r\n      orElse: () => ExplorationType.around_me,\r\n    );\r\n  }\r\n\r\n  String get value => toString().split('.').last;\r\n\r\n  // Ajout des limites de temps en minutes\r\n  (int, int) get timeLimits {\r\n    switch (this) {\r\n      case ExplorationType.around_me:\r\n        return (0, 60);  // max 1h\r\n      case ExplorationType.small_getaway:\r\n        return (0, 105);  // max 1h45\r\n      case ExplorationType.exploration_day:\r\n        return (90, 150);  // 1h30 - 2h30\r\n      case ExplorationType.big_adventure:\r\n        return (120, 300);  // 2h - 5h\r\n    }\r\n  }\r\n\r\n  static (int, int) getCombinedTimeLimits(List<ExplorationType> types) {\r\n    int minTime = 300;  // Valeur max possible\r\n    int maxTime = 0;    // Valeur min possible\r\n\r\n    for (var type in types) {\r\n      final (typeMin, typeMax) = type.timeLimits;\r\n      if (typeMin < minTime) minTime = typeMin;\r\n      if (typeMax > maxTime) maxTime = typeMax;\r\n    }\r\n\r\n    return (minTime, maxTime);\r\n  }\r\n\r\n  bool isValidDuration(int durationMinutes) {\r\n    final (minMinutes, maxMinutes) = timeLimits;\r\n    return durationMinutes >= minMinutes && durationMinutes <= maxMinutes;\r\n  }\r\n\r\n  int getMaxActivitiesByTime(int timeAvailable) {\r\n    if (timeAvailable < 120) return 5;        // < 2h\r\n    if (timeAvailable < 240) return 7;        // 2-4h\r\n    if (timeAvailable < 360) return 8;        // 4-6h\r\n    if (timeAvailable < 480) return 9;        // 6-8h\r\n    return 10;                                // > 8h\r\n  }\r\n}\r\n\r\nenum DailyTripType {\r\n  half_day,\r\n  full_day\r\n}\r\n",
      "info": {
        "size": 4680,
        "last_modified": "2025-04-16T13:25:26.2139049",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\calculation_exception.dart",
      "content": "// lib/core/common/exceptions/calculation_exception.dart\r\n\r\nclass CalculationException implements Exception {\r\n  final String message;\r\n  CalculationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'CalculationException: $message';\r\n}",
      "info": {
        "size": 249,
        "last_modified": "2025-04-16T13:25:26.2260226",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\domain_exception.dart",
      "content": "// lib\\core\\common\\exceptions\\domain_exception.dart",
      "info": {
        "size": 51,
        "last_modified": "2025-04-16T13:25:26.2320717",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\empty_trip_generation_exception.dart",
      "content": "// lib/core/common/exceptions/empty_trip_generation_exception.dart\r\n\r\nclass EmptyTripGenerationException implements Exception {\r\n  final String message;\r\n\r\n  EmptyTripGenerationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'EmptyTripGenerationException: $message';\r\n}",
      "info": {
        "size": 285,
        "last_modified": "2025-04-16T13:25:26.2380712",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\exceptions.dart",
      "content": "// core/common/exceptions/exceptions.dart\r\n\r\nclass DomainException implements Exception {\r\n  final String message;\r\n  DomainException(this.message);\r\n\r\n  @override\r\n  String toString() => message;\r\n}\r\n\r\nclass DataException implements Exception {\r\n  final String message;\r\n  DataException(this.message);\r\n}\r\n\r\nclass ProcessingException implements Exception {\r\n  final String message;\r\n  ProcessingException(this.message);\r\n}",
      "info": {
        "size": 423,
        "last_modified": "2025-04-16T13:25:26.245109",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\geometry_calculation_exception.dart",
      "content": "// lib/core/common/exceptions/geometry_calculation_exception.dart\r\nclass GeometryCalculationException implements Exception {\r\n  final String message;\r\n\r\n  GeometryCalculationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'GeometryCalculationException: $message';\r\n}",
      "info": {
        "size": 282,
        "last_modified": "2025-04-16T13:25:26.2511463",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\google_api_exception.dart",
      "content": "// lib/core/common/exceptions/google_api_exception.dart\r\n\r\nclass GoogleAPIException implements Exception {\r\n  final String message;\r\n\r\n  GoogleAPIException(this.message);\r\n\r\n  @override\r\n  String toString() => 'GoogleAPIException: $message';\r\n}",
      "info": {
        "size": 244,
        "last_modified": "2025-04-16T13:25:26.2576625",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\location_exceptions.dart",
      "content": "// lib/core/common/exceptions/location_exceptions.dart\r\n\r\n/// Exception de base pour tous les problmes lis  la localisation\r\nclass LocationException implements Exception {\r\n  final String message;\r\n\r\n  LocationException(this.message);\r\n\r\n  @override\r\n  String toString() => 'LocationException: $message';\r\n}\r\n\r\n/// Exception spcifique pour les problmes de permission de localisation\r\nclass LocationPermissionException extends LocationException {\r\n  LocationPermissionException(String message) : super(message);\r\n}\r\n\r\n/// Exception spcifique pour les problmes de services de localisation dsactivs\r\nclass LocationServicesDisabledException extends LocationException {\r\n  LocationServicesDisabledException(String message) : super(message);\r\n}\r\n\r\n/// Exception spcifique pour les problmes d'API Google Places\r\nclass PlacesApiException extends LocationException {\r\n  final String? errorCode;\r\n\r\n  PlacesApiException(String message, {this.errorCode}) : super(message);\r\n\r\n  @override\r\n  String toString() => 'PlacesApiException: $message (code: $errorCode)';\r\n}\r\n\r\n/// Exception spcifique pour les problmes de cache de localisation\r\nclass LocationCacheException extends LocationException {\r\n  LocationCacheException(String message) : super(message);\r\n}",
      "info": {
        "size": 1271,
        "last_modified": "2025-04-16T13:25:26.2647133",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\route_optimization_exceptions.dart",
      "content": "// core/common/exceptions/route_optimization_exceptions.dart\r\n\r\nabstract class RouteOptimizationException implements Exception {\r\n  final String message;\r\n  RouteOptimizationException(this.message);\r\n}\r\n\r\nclass RouteNotFoundException extends RouteOptimizationException {\r\n  RouteNotFoundException(String message) : super(message);\r\n}\r\n\r\nclass TravelTimeCalculationException extends RouteOptimizationException {\r\n  TravelTimeCalculationException(String message) : super(message);\r\n}\r\n\r\nclass DetourEvaluationException extends RouteOptimizationException {\r\n  DetourEvaluationException(String message) : super(message);\r\n}\r\n\r\nclass GoogleAPIException extends RouteOptimizationException {\r\n  final int? statusCode;\r\n  final String? errorCode;\r\n\r\n  GoogleAPIException(String message, {this.statusCode, this.errorCode}) : super(message);\r\n}\r\n\r\nclass OptimizationTimeoutException extends RouteOptimizationException {\r\n  OptimizationTimeoutException(String message) : super(message);\r\n}",
      "info": {
        "size": 978,
        "last_modified": "2025-04-16T13:25:26.2712318",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\scoring_exceptions.dart",
      "content": "// core/common/exceptions/scoring_exceptions.dart\r\n\r\nabstract class ScoringException implements Exception {\r\n  final String message;\r\n  ScoringException(this.message);\r\n}\r\n\r\nclass PreferencesNotFoundException extends ScoringException {\r\n  PreferencesNotFoundException(String message) : super(message);\r\n}\r\n\r\nclass ScoreCalculationException extends ScoringException {\r\n  ScoreCalculationException(String message) : super(message);\r\n}\r\n\r\nclass CacheOperationException extends ScoringException {\r\n  CacheOperationException(String message) : super(message);\r\n}",
      "info": {
        "size": 556,
        "last_modified": "2025-04-16T13:25:26.2782924",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\exceptions\\trip_exception.dart",
      "content": "// lib/core/common/exceptions/trip_exceptions.dart\r\n\r\n/// Exception de base pour les erreurs lies aux voyages\r\nabstract class TripException implements Exception {\r\n  final String message;\r\n  TripException(this.message);\r\n}\r\n\r\n/// Exception leve quand la ville de dpart est invalide\r\nclass InvalidDepartureCityException extends TripException {\r\n  InvalidDepartureCityException(String message) : super(message);\r\n}\r\n\r\n/// Exception leve quand les dates du voyage sont invalides\r\nclass InvalidTripDatesException extends TripException {\r\n  InvalidTripDatesException(String message) : super(message);\r\n}\r\n\r\n/// Exception leve quand la cration du voyage choue\r\nclass TripCreationException extends TripException {\r\n  TripCreationException(String message) : super(message);\r\n}\r\n\r\n/// Exception leve quand la rcupration du voyage choue\r\nclass TripNotFoundException extends TripException {\r\n  TripNotFoundException(String message) : super(message);\r\n}\r\n\r\n/// Exception leve quand le groupe de voyage est invalide\r\nclass InvalidTravelGroupException extends TripException {\r\n  InvalidTravelGroupException(String message) : super(message);\r\n}",
      "info": {
        "size": 1153,
        "last_modified": "2025-04-16T13:25:26.2853486",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\activity_mapper.dart",
      "content": "// lib/core/common/utils/activity_mapper.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../constants/subcategory_icons.dart';\r\nimport '../../../features/shared_ui/presentation/widgets/cards/activity_card.dart';\r\n\r\nclass ActivityMapper {\r\n  static const double defaultUserLat = 44.8333;\r\n  static const double defaultUserLng = 0.7333;\r\n\r\n  static List<ActivityCard> mapToActivityCards(List<dynamic> activities) {\r\n    return activities.map((activity) {\r\n      return ActivityCard(\r\n        imageUrl: activity.mainImageUrl ?? '',\r\n        title: activity.base.name ?? '',\r\n        city: activity.base.city ?? '',\r\n        category: activity.subcategoryName ?? 'Autre',\r\n        categoryIcon: SubcategoryIcons.getIcon(activity.subcategoryIcon),\r\n        distance: activity.distance ?? 0.0,\r\n        activityId: activity.base.id,\r\n        activityLat: activity.base.latitude,\r\n        activityLng: activity.base.longitude,\r\n        userLat: defaultUserLat,\r\n        userLng: defaultUserLng,\r\n      );\r\n    }).toList();\r\n  }\r\n}",
      "info": {
        "size": 1032,
        "last_modified": "2025-04-16T13:25:26.2983904",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\date_formatter.dart",
      "content": "// lib\\core\\common\\utils\\date_formatter.dart\r\n\r\nclass DateFormatter {\r\n  static String formatTripDates(DateTime startDate, DateTime endDate) {\r\n    // Noms des mois en franais\r\n    const months = [\r\n      'jan.', 'fv.', 'mars', 'avr.', 'mai', 'juin',\r\n      'juil.', 'aot', 'sept.', 'oct.', 'nov.', 'dc.'\r\n    ];\r\n\r\n    // Si mme mois et anne\r\n    if (startDate.month == endDate.month && startDate.year == endDate.year) {\r\n      return '${startDate.day} - ${endDate.day} ${months[startDate.month - 1]}';\r\n    }\r\n\r\n    // Si mme anne\r\n    if (startDate.year == endDate.year) {\r\n      return '${startDate.day} ${months[startDate.month - 1]} - ${endDate.day} ${months[endDate.month - 1]}';\r\n    }\r\n\r\n    // Diffrentes annes\r\n    return '${startDate.day} ${months[startDate.month - 1]} ${startDate.year} - ${endDate.day} ${months[endDate.month - 1]} ${endDate.year}';\r\n  }\r\n\r\n  static String formatShortDate(DateTime date) {\r\n    const months = [\r\n      'jan.', 'fv.', 'mars', 'avr.', 'mai', 'juin',\r\n      'juil.', 'aot', 'sept.', 'oct.', 'nov.', 'dc.'\r\n    ];\r\n    return '${date.day} ${months[date.month - 1]}';\r\n  }\r\n}",
      "info": {
        "size": 1144,
        "last_modified": "2025-04-16T13:25:26.3049075",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\debouncer.dart",
      "content": "// lib/core/common/utils/debouncer.dart\r\n\r\nimport 'dart:async';\r\nimport 'package:flutter/foundation.dart';\r\n\r\n/// Utilitaire pour limiter les appels frquents  une fonction\r\nclass Debouncer {\r\n  final int milliseconds;\r\n  Timer? _timer;\r\n\r\n  Debouncer({this.milliseconds = 300});\r\n\r\n  void run(VoidCallback action) {\r\n    _timer?.cancel();\r\n    _timer = Timer(Duration(milliseconds: milliseconds), action);\r\n  }\r\n\r\n  void cancel() {\r\n    _timer?.cancel();\r\n  }\r\n\r\n  bool get isActive => _timer?.isActive ?? false;\r\n}",
      "info": {
        "size": 519,
        "last_modified": "2025-04-16T13:25:26.3119405",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\geohash.dart",
      "content": "// lib\\core\\common\\utils\\geohash.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:maps_toolkit/maps_toolkit.dart' as maps_toolkit;\r\nimport 'package:polyline_codec/polyline_codec.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\n\r\nclass Geohash {\r\n  static const List<String> _base32 = [\r\n    '0','1','2','3','4','5','6','7','8','9',\r\n    'b','c','d','e','f','g','h','j','k','m',\r\n    'n','p','q','r','s','t','u','v','w','x',\r\n    'y','z'\r\n  ];\r\n\r\n  /// Encode une position gographique en geohash\r\n  /// @param lat - Latitude\r\n  /// @param lon - Longitude\r\n  /// @param precision - Prcision du geohash (1-12)\r\n  static String encode(double lat, double lon, {int precision = 5}) {\r\n    // Utilisation de la bibliothque dart_geohash pour assurer la cohrence\r\n    // Note: la bibliothque attend (longitude, latitude) dans cet ordre\r\n    final geoHasher = GeoHasher();\r\n    return geoHasher.encode(lon, lat, precision: precision);\r\n  }\r\n\r\n  /// Version originale conserve pour rfrence (dcommentez si ncessaire)\r\n  /*\r\n  static String encodeOriginal(double lat, double lon, {int precision = 5}) {\r\n    if (lat < -90.0 || lat > 90.0) {\r\n      throw ArgumentError('Latitude must be between -90 and 90');\r\n    }\r\n    if (lon < -180.0 || lon > 180.0) {\r\n      throw ArgumentError('Longitude must be between -180 and 180');\r\n    }\r\n    if (precision < 1 || precision > 12) {\r\n      throw ArgumentError('Precision must be between 1 and 12');\r\n    }\r\n\r\n    var latMin = -90.0;\r\n    var latMax = 90.0;\r\n    var lonMin = -180.0;\r\n    var lonMax = 180.0;\r\n\r\n    var bits = 0;\r\n    var bitsTotal = 0;\r\n    var hashValue = '';\r\n\r\n    while (hashValue.length < precision) {\r\n      if (bitsTotal % 2 == 0) {\r\n        var mid = (lonMin + lonMax) / 2;\r\n        if (lon >= mid) {\r\n          bits = (bits << 1) + 1;\r\n          lonMin = mid;\r\n        } else {\r\n          bits <<= 1;\r\n          lonMax = mid;\r\n        }\r\n      } else {\r\n        var mid = (latMin + latMax) / 2;\r\n        if (lat >= mid) {\r\n          bits = (bits << 1) + 1;\r\n          latMin = mid;\r\n        } else {\r\n          bits <<= 1;\r\n          latMax = mid;\r\n        }\r\n      }\r\n\r\n      bitsTotal++;\r\n      if (bitsTotal == 5) {\r\n        hashValue += _base32[bits];\r\n        bits = 0;\r\n        bitsTotal = 0;\r\n      }\r\n    }\r\n\r\n    return hashValue;\r\n  }\r\n  */\r\n\r\n  /// Convertit une polyline en liste de geohash5 traverss\r\n  static List<String> getGeohashesFromPolyline(String encodedPolyline) {\r\n    try {\r\n      print(' Dcodage de la polyline');\r\n\r\n      // Dcoder la polyline en liste de points avec une prcision de 5\r\n      final decodedPoints = PolylineCodec.decode(encodedPolyline, precision: 5);\r\n      final points = decodedPoints.map((point) => LatLng(point[0].toDouble(), point[1].toDouble())).toList();\r\n\r\n      print(' ${points.length} points extraits de la polyline');\r\n\r\n      // Convertir chaque point en geohash5 et liminer les doublons\r\n      final geohashes = <String>{};\r\n      final geoHasher = GeoHasher();\r\n      for (final point in points) {\r\n        final geohash = geoHasher.encode(point.longitude, point.latitude, precision: 5);\r\n        geohashes.add(geohash);\r\n      }\r\n\r\n      print(' ${geohashes.length} geohash5 uniques trouvs');\r\n      return geohashes.toList();\r\n    } catch (e) {\r\n      print(' Erreur lors de la conversion polyline  geohash: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3461,
        "last_modified": "2025-04-16T13:25:26.3179398",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\geo_utils.dart",
      "content": "// lib/core/common/utils/geo_utils.dart\r\n\r\nimport 'package:maps_toolkit/maps_toolkit.dart' as maps_toolkit;\r\nimport 'geohash.dart';\r\n\r\nclass GeoUtils {\r\n  /// Calcule le geohash d'une position\r\n  static String calculateGeohash(double latitude, double longitude, {int precision = 4}) {\r\n    return Geohash.encode(latitude, longitude, precision: precision);\r\n  }\r\n\r\n  /// Calcule la distance entre deux points en kilomtres\r\n  static double calculateDistance(\r\n      double startLat,\r\n      double startLng,\r\n      double endLat,\r\n      double endLng,\r\n      ) {\r\n    final start = maps_toolkit.LatLng(startLat, startLng);\r\n    final end = maps_toolkit.LatLng(endLat, endLng);\r\n\r\n    // SphericalUtil.computeDistanceBetween retourne la distance en mtres\r\n    return maps_toolkit.SphericalUtil.computeDistanceBetween(start, end) / 1000;\r\n  }\r\n}",
      "info": {
        "size": 844,
        "last_modified": "2025-04-16T13:25:26.3245397",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\location_formatter.dart",
      "content": "// lib/core/common/utils/location_formatter.dart\r\n\r\nimport '../../domain/models/location/place_details.dart';\r\n\r\n/// Classe utilitaire pour le formatage des adresses et lieux\r\nclass LocationFormatter {\r\n  /// Formate une adresse complte pour l'affichage\r\n  static String formatAddress(PlaceDetails details) {\r\n    final List<String> parts = [];\r\n\r\n    if (details.name.isNotEmpty) {\r\n      parts.add(details.name);\r\n    }\r\n\r\n    if (details.locality != null && details.locality!.isNotEmpty) {\r\n      parts.add(details.locality!);\r\n    }\r\n\r\n    if (details.administrativeArea != null && details.administrativeArea!.isNotEmpty) {\r\n      parts.add(details.administrativeArea!);\r\n    }\r\n\r\n    return parts.join(', ');\r\n  }\r\n\r\n  /// Formate une distance en mtres pour l'affichage\r\n  static String formatDistance(double distanceInMeters) {\r\n    if (distanceInMeters < 1000) {\r\n      return '${distanceInMeters.round()} m';\r\n    } else {\r\n      final double km = distanceInMeters / 1000;\r\n      return '${km.toStringAsFixed(1)} km';\r\n    }\r\n  }\r\n\r\n  /// Extrait le nom principal d'un lieu (gnralement la ville ou commune)\r\n  static String extractMainName(PlaceDetails details) {\r\n    return details.locality ?? details.name;\r\n  }\r\n}",
      "info": {
        "size": 1233,
        "last_modified": "2025-04-16T13:25:26.3310441",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\common\\utils\\maps_toolkit_utils.dart",
      "content": "// lib/core/common/utils/maps_toolkit_utils.dart\r\n\r\nimport 'package:maps_toolkit/maps_toolkit.dart' as mtk;\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../exceptions/geometry_calculation_exception.dart';\r\nimport '../constants/geometry_constants.dart';\r\n\r\nclass MapsToolkitUtils {\r\n  static double calculateHaversineDistance(LatLng start, LatLng end) {\r\n    try {\r\n      return mtk.SphericalUtil.computeDistanceBetween(\r\n          mtk.LatLng(start.latitude, start.longitude),\r\n          mtk.LatLng(end.latitude, end.longitude)\r\n      ).toDouble();\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Error calculating haversine distance: $e');\r\n    }\r\n  }\r\n\r\n  static bool isLocationOnPath(\r\n      LatLng point,\r\n      List<LatLng> pathPoints,\r\n      {double? toleranceMeters}\r\n      ) {\r\n    try {\r\n      return mtk.PolygonUtil.isLocationOnPath(\r\n          mtk.LatLng(point.latitude, point.longitude),\r\n          pathPoints.map((p) => mtk.LatLng(p.latitude, p.longitude)).toList(),\r\n          true  // On met simplement true car le paramtre est obligatoire mais son utilisation n'est pas claire dans maps_toolkit\r\n      );\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Error checking location on path: $e');\r\n    }\r\n  }\r\n\r\n  static int calculateMalusMinutes(\r\n      double distanceMeters,\r\n      String travelStyle,\r\n      ) {\r\n    try {\r\n      final factor = switch(travelStyle) {\r\n        'relax' => GeometryConstants.relaxedTravelFactor,\r\n        'active' => GeometryConstants.activeTravelFactor,\r\n        _ => GeometryConstants.balancedTravelFactor\r\n      };\r\n\r\n      final estimatedMinutes = (distanceMeters * factor) /\r\n          (GeometryConstants.averageSpeedMetersPerSecond * 60);\r\n\r\n      return estimatedMinutes.clamp(\r\n          GeometryConstants.minimumMalusMinutes.toDouble(),\r\n          GeometryConstants.maximumMalusMinutes.toDouble()\r\n      ).round();\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Error calculating malus minutes: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2041,
        "last_modified": "2025-04-16T13:25:26.3370458",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\activity_filter.dart",
      "content": "// lib\\core\\domain\\filters\\activity_filter.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nabstract class ActivityFilter {\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities);\r\n  String? get exclusionReason;\r\n}",
      "info": {
        "size": 282,
        "last_modified": "2025-04-16T13:25:26.3551255",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\filter_chain.dart",
      "content": "// core/domain/filters/filter_chain.dart\r\n\r\nimport 'activity_filter.dart';\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nclass FilterChain {\r\n  final List<ActivityFilter> _filters = [];\r\n\r\n  void addFilter(ActivityFilter filter) => _filters.add(filter);\r\n\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities) async {\r\n    var filtered = activities;\r\n    for (var filter in _filters) {\r\n      filtered = await filter.apply(filtered);\r\n    }\r\n    return filtered;\r\n  }\r\n}",
      "info": {
        "size": 535,
        "last_modified": "2025-04-16T13:25:26.3611586",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\time_filter.dart",
      "content": "// lib\\core\\domain\\filters\\time_filter.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../../domain/ports/activity_hours_port.dart';\r\nimport '../../domain/services/travel_time_service.dart';\r\nimport 'activity_filter.dart';\r\n\r\nclass TimeFilter implements ActivityFilter {\r\n  final ActivityHoursPort _hoursService;\r\n  final TravelTimeService _travelTimeService;\r\n  final DateTime tripStartDate;\r\n  final DateTime tripEndDate;\r\n  final Map<String, Map<String, String?>> dailyHours;\r\n  final String departureGeohash5;\r\n\r\n  TimeFilter({\r\n    required this.tripStartDate,\r\n    required this.tripEndDate,\r\n    required this.dailyHours,\r\n    required ActivityHoursPort hoursService,\r\n    required TravelTimeService travelTimeService,\r\n    required this.departureGeohash5,\r\n  }) : _hoursService = hoursService,\r\n        _travelTimeService = travelTimeService;\r\n\r\n  @override\r\n  String? get exclusionReason => null;\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities) async {\r\n    print(' Application du TimeFilter');\r\n    print('Priode du voyage: ${tripStartDate.toString()} - ${tripEndDate.toString()}');\r\n    print('Horaires journaliers: $dailyHours');\r\n\r\n    final filteredActivities = <ActivityForProcessing>[];\r\n\r\n    for (var activity in activities) {\r\n      activity.exclusionReason = null;\r\n      print('\\n Analyse de l\\'activit: ${activity.name}');\r\n\r\n      final openingDays = await _hoursService.getActivityHours(\r\n        activity.id,\r\n        tripStartDate,\r\n        tripEndDate,\r\n      );\r\n\r\n      if (openingDays == null || !openingDays.hasOpenDays) {\r\n        activity.exclusionReason = \"Activit ferme pendant cette priode\";\r\n        print(' ${activity.name}: Ferme pendant la priode');\r\n        continue;\r\n      }\r\n\r\n      // Vrifier la compatibilit pour chaque jour du voyage\r\n      bool hasCompatibleDay = false;\r\n      for (var entry in dailyHours.entries) {\r\n        final date = entry.key;\r\n        final hours = entry.value;\r\n\r\n        // Si l'utilisateur n'a pas prvu d'activits ce jour-l\r\n        if (hours['start'] == null || hours['end'] == null) {\r\n          print(' $date: Pas d\\'activits prvues');\r\n          continue;\r\n        }\r\n\r\n        // Vrifier si l'activit est ouverte ce jour-l\r\n        final activityHours = openingDays.availableDays[date];\r\n        if (activityHours == null) {\r\n          print(' $date: Activit ferme');\r\n          continue;\r\n        }\r\n\r\n        // Calculer d'abord le temps disponible sans le trajet\r\n        final activityOpenMinutes = _timeToMinutes(activityHours['opens_at']!);\r\n        final activityCloseMinutes = _timeToMinutes(activityHours['closes_at']!);\r\n        final tripStartMinutes = _timeToMinutes(hours['start']!);\r\n        final tripEndMinutes = _timeToMinutes(hours['end']!);\r\n\r\n        // Vrifier d'abord s'il y a un chevauchement basique\r\n        if (activityCloseMinutes <= tripStartMinutes || activityOpenMinutes >= tripEndMinutes) {\r\n          print(' $date: Pas de chevauchement des horaires');\r\n          continue;\r\n        }\r\n\r\n        // Calculer le temps disponible\r\n        final startTime = activityOpenMinutes > tripStartMinutes ? activityOpenMinutes : tripStartMinutes;\r\n        final endTime = activityCloseMinutes < tripEndMinutes ? activityCloseMinutes : tripEndMinutes;\r\n        final availableTime = endTime - startTime;\r\n\r\n        // Si le temps est serr (moins d'une heure de marge), calculer le temps de trajet\r\n        if (availableTime <= activity.minDurationMinutes + 60) {\r\n          print(' Temps serr, vrification du temps de trajet');\r\n          final travelTime = await _travelTimeService.calculateTravelTime(\r\n            departureGeohash5,\r\n            activity.geohash5 ?? '',\r\n          );\r\n          final totalTimeNeeded = activity.minDurationMinutes + travelTime;\r\n\r\n          if (availableTime < totalTimeNeeded) {\r\n            print(' $date: Temps insuffisant avec trajet (disponible: $availableTime, ncessaire: $totalTimeNeeded)');\r\n            continue;\r\n          }\r\n        }\r\n\r\n        hasCompatibleDay = true;\r\n        print(' $date: Horaires compatibles');\r\n        break; // On peut arrter ds qu'on trouve un jour compatible\r\n      }\r\n\r\n      if (!hasCompatibleDay) {\r\n        activity.exclusionReason = \"Horaires incompatibles avec le planning du voyage\";\r\n        print(' ${activity.name}: Aucun jour compatible trouv');\r\n        continue;\r\n      }\r\n\r\n      print(' ${activity.name}: Compatible avec au moins un jour du sjour');\r\n      filteredActivities.add(activity);\r\n    }\r\n\r\n    return filteredActivities;\r\n  }\r\n\r\n  int _timeToMinutes(String time) {\r\n    final parts = time.split(':');\r\n    return int.parse(parts[0]) * 60 + int.parse(parts[1]);\r\n  }\r\n}",
      "info": {
        "size": 4864,
        "last_modified": "2025-04-16T13:25:26.3686755",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\filters\\travel_group_filter.dart",
      "content": "// lib\\core\\domain\\filters\\travel_group_filter.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport 'activity_filter.dart';\r\n\r\nclass TravelGroupFilter implements ActivityFilter {\r\n  final TravelGroup travelGroup;\r\n\r\n  TravelGroupFilter(this.travelGroup);\r\n\r\n  @override\r\n  String? get exclusionReason => null; // Plus utilis ici car gr directement sur l'activit\r\n\r\n  @override\r\n  Future<List<ActivityForProcessing>> apply(List<ActivityForProcessing> activities) async {\r\n    print(' Application du TravelGroupFilter');\r\n    print(' Contraintes du voyage:');\r\n    print('- Enfants: ${travelGroup.members.children}');\r\n    print('- PMR: ${travelGroup.members.pmr}');\r\n    print('- Seniors: ${travelGroup.members.seniors}');\r\n\r\n    return activities.where((activity) {\r\n      print('\\n Analyse de l\\'activit: ${activity.name}');\r\n      activity.exclusionReason = null;\r\n\r\n      // Log des donnes initiales\r\n      print('Donnes activit:');\r\n      print('- kid_friendly: ${activity.kidFriendly}');\r\n      print('- wheelchairAccessible: ${activity.wheelchairAccessible}');\r\n      print('- intensityLevel: ${activity.intensityLevel}');\r\n\r\n      // Filtre pour enfants\r\n      if (travelGroup.members.children.isNotEmpty) {\r\n        print(' Vrification enfants');\r\n        if (activity.kidFriendly == false) {\r\n          print(' Non adapt aux enfants');\r\n          activity.exclusionReason = 'Non adapt aux enfants';\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Filtre pour PMR\r\n      if (travelGroup.members.pmr) {\r\n        print(' Vrification PMR');\r\n        if (activity.wheelchairAccessible == 'none') {\r\n          print(' Non accessible PMR');\r\n          activity.exclusionReason = 'Non accessible PMR';\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Filtre pour seniors\r\n      if (travelGroup.members.seniors) {\r\n        print(' Vrification seniors');\r\n        if (activity.intensityLevel > 2) {\r\n          print(' Intensit trop leve pour seniors');\r\n          activity.exclusionReason = 'Intensit trop leve pour seniors';\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }).toList();\r\n  }\r\n}",
      "info": {
        "size": 2299,
        "last_modified": "2025-04-16T13:25:26.3742753",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_base.dart",
      "content": "// lib/core/domain/models/activity/base/activity_base.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'activity_base.freezed.dart';\r\npart 'activity_base.g.dart';\r\n\r\n@freezed\r\nclass ActivityBase with _$ActivityBase {\r\n  const factory ActivityBase({\r\n    required String id,\r\n    required String name,\r\n    required String? description,\r\n    required double latitude,\r\n    required double longitude,\r\n    required String categoryId,\r\n    String? subcategoryId,\r\n    String? city,\r\n    String? imageUrl,\r\n    @Default(false) bool isWow,\r\n    double? basePrice,\r\n    @Default(0.0) double ratingAvg,\r\n    @Default(0) int ratingCount,\r\n    @Default(false) bool kidFriendly,\r\n    String? wheelchairAccessible,\r\n    @Default(false) bool bookingRequired,\r\n  }) = _ActivityBase;\r\n\r\n  factory ActivityBase.fromJson(Map<String, dynamic> json) => _$ActivityBaseFromJson(json);\r\n\r\n  // Factory depuis activity_model.dart\r\n  factory ActivityBase.fromActivityModel(dynamic activity) {\r\n    return ActivityBase(\r\n      id: activity.id,\r\n      name: activity.name,\r\n      description: activity.description,\r\n      latitude: activity.latitude,\r\n      longitude: activity.longitude,\r\n      categoryId: activity.categoryId,\r\n      subcategoryId: activity.subcategoryId,\r\n      isWow: activity.isWow,\r\n      basePrice: activity.basePrice,\r\n      ratingAvg: double.tryParse(activity.ratingAvg.toString()) ?? 0.0,\r\n      ratingCount: activity.ratingCount,\r\n      kidFriendly: activity.kidFriendly ?? false,\r\n      wheelchairAccessible: activity.wheelchairAccessible,\r\n      bookingRequired: activity.bookingRequired ?? false,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1646,
        "last_modified": "2025-04-16T13:25:26.3863119",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_base.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_base.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nActivityBase _$ActivityBaseFromJson(Map<String, dynamic> json) {\n  return _ActivityBase.fromJson(json);\n}\n\n/// @nodoc\nmixin _$ActivityBase {\n  String get id => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  String? get description => throw _privateConstructorUsedError;\n  double get latitude => throw _privateConstructorUsedError;\n  double get longitude => throw _privateConstructorUsedError;\n  String get categoryId => throw _privateConstructorUsedError;\n  String? get subcategoryId => throw _privateConstructorUsedError;\n  String? get city => throw _privateConstructorUsedError;\n  String? get imageUrl => throw _privateConstructorUsedError;\n  bool get isWow => throw _privateConstructorUsedError;\n  double? get basePrice => throw _privateConstructorUsedError;\n  double get ratingAvg => throw _privateConstructorUsedError;\n  int get ratingCount => throw _privateConstructorUsedError;\n  bool get kidFriendly => throw _privateConstructorUsedError;\n  String? get wheelchairAccessible => throw _privateConstructorUsedError;\n  bool get bookingRequired => throw _privateConstructorUsedError;\n\n  /// Serializes this ActivityBase to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $ActivityBaseCopyWith<ActivityBase> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityBaseCopyWith<$Res> {\n  factory $ActivityBaseCopyWith(\n          ActivityBase value, $Res Function(ActivityBase) then) =\n      _$ActivityBaseCopyWithImpl<$Res, ActivityBase>;\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? subcategoryId,\n      String? city,\n      String? imageUrl,\n      bool isWow,\n      double? basePrice,\n      double ratingAvg,\n      int ratingCount,\n      bool kidFriendly,\n      String? wheelchairAccessible,\n      bool bookingRequired});\n}\n\n/// @nodoc\nclass _$ActivityBaseCopyWithImpl<$Res, $Val extends ActivityBase>\n    implements $ActivityBaseCopyWith<$Res> {\n  _$ActivityBaseCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? subcategoryId = freezed,\n    Object? city = freezed,\n    Object? imageUrl = freezed,\n    Object? isWow = null,\n    Object? basePrice = freezed,\n    Object? ratingAvg = null,\n    Object? ratingCount = null,\n    Object? kidFriendly = null,\n    Object? wheelchairAccessible = freezed,\n    Object? bookingRequired = null,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      imageUrl: freezed == imageUrl\n          ? _value.imageUrl\n          : imageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isWow: null == isWow\n          ? _value.isWow\n          : isWow // ignore: cast_nullable_to_non_nullable\n              as bool,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      ratingAvg: null == ratingAvg\n          ? _value.ratingAvg\n          : ratingAvg // ignore: cast_nullable_to_non_nullable\n              as double,\n      ratingCount: null == ratingCount\n          ? _value.ratingCount\n          : ratingCount // ignore: cast_nullable_to_non_nullable\n              as int,\n      kidFriendly: null == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: null == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$ActivityBaseImplCopyWith<$Res>\n    implements $ActivityBaseCopyWith<$Res> {\n  factory _$$ActivityBaseImplCopyWith(\n          _$ActivityBaseImpl value, $Res Function(_$ActivityBaseImpl) then) =\n      __$$ActivityBaseImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? subcategoryId,\n      String? city,\n      String? imageUrl,\n      bool isWow,\n      double? basePrice,\n      double ratingAvg,\n      int ratingCount,\n      bool kidFriendly,\n      String? wheelchairAccessible,\n      bool bookingRequired});\n}\n\n/// @nodoc\nclass __$$ActivityBaseImplCopyWithImpl<$Res>\n    extends _$ActivityBaseCopyWithImpl<$Res, _$ActivityBaseImpl>\n    implements _$$ActivityBaseImplCopyWith<$Res> {\n  __$$ActivityBaseImplCopyWithImpl(\n      _$ActivityBaseImpl _value, $Res Function(_$ActivityBaseImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? subcategoryId = freezed,\n    Object? city = freezed,\n    Object? imageUrl = freezed,\n    Object? isWow = null,\n    Object? basePrice = freezed,\n    Object? ratingAvg = null,\n    Object? ratingCount = null,\n    Object? kidFriendly = null,\n    Object? wheelchairAccessible = freezed,\n    Object? bookingRequired = null,\n  }) {\n    return _then(_$ActivityBaseImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      imageUrl: freezed == imageUrl\n          ? _value.imageUrl\n          : imageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isWow: null == isWow\n          ? _value.isWow\n          : isWow // ignore: cast_nullable_to_non_nullable\n              as bool,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      ratingAvg: null == ratingAvg\n          ? _value.ratingAvg\n          : ratingAvg // ignore: cast_nullable_to_non_nullable\n              as double,\n      ratingCount: null == ratingCount\n          ? _value.ratingCount\n          : ratingCount // ignore: cast_nullable_to_non_nullable\n              as int,\n      kidFriendly: null == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: null == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$ActivityBaseImpl implements _ActivityBase {\n  const _$ActivityBaseImpl(\n      {required this.id,\n      required this.name,\n      required this.description,\n      required this.latitude,\n      required this.longitude,\n      required this.categoryId,\n      this.subcategoryId,\n      this.city,\n      this.imageUrl,\n      this.isWow = false,\n      this.basePrice,\n      this.ratingAvg = 0.0,\n      this.ratingCount = 0,\n      this.kidFriendly = false,\n      this.wheelchairAccessible,\n      this.bookingRequired = false});\n\n  factory _$ActivityBaseImpl.fromJson(Map<String, dynamic> json) =>\n      _$$ActivityBaseImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String name;\n  @override\n  final String? description;\n  @override\n  final double latitude;\n  @override\n  final double longitude;\n  @override\n  final String categoryId;\n  @override\n  final String? subcategoryId;\n  @override\n  final String? city;\n  @override\n  final String? imageUrl;\n  @override\n  @JsonKey()\n  final bool isWow;\n  @override\n  final double? basePrice;\n  @override\n  @JsonKey()\n  final double ratingAvg;\n  @override\n  @JsonKey()\n  final int ratingCount;\n  @override\n  @JsonKey()\n  final bool kidFriendly;\n  @override\n  final String? wheelchairAccessible;\n  @override\n  @JsonKey()\n  final bool bookingRequired;\n\n  @override\n  String toString() {\n    return 'ActivityBase(id: $id, name: $name, description: $description, latitude: $latitude, longitude: $longitude, categoryId: $categoryId, subcategoryId: $subcategoryId, city: $city, imageUrl: $imageUrl, isWow: $isWow, basePrice: $basePrice, ratingAvg: $ratingAvg, ratingCount: $ratingCount, kidFriendly: $kidFriendly, wheelchairAccessible: $wheelchairAccessible, bookingRequired: $bookingRequired)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ActivityBaseImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.description, description) ||\n                other.description == description) &&\n            (identical(other.latitude, latitude) ||\n                other.latitude == latitude) &&\n            (identical(other.longitude, longitude) ||\n                other.longitude == longitude) &&\n            (identical(other.categoryId, categoryId) ||\n                other.categoryId == categoryId) &&\n            (identical(other.subcategoryId, subcategoryId) ||\n                other.subcategoryId == subcategoryId) &&\n            (identical(other.city, city) || other.city == city) &&\n            (identical(other.imageUrl, imageUrl) ||\n                other.imageUrl == imageUrl) &&\n            (identical(other.isWow, isWow) || other.isWow == isWow) &&\n            (identical(other.basePrice, basePrice) ||\n                other.basePrice == basePrice) &&\n            (identical(other.ratingAvg, ratingAvg) ||\n                other.ratingAvg == ratingAvg) &&\n            (identical(other.ratingCount, ratingCount) ||\n                other.ratingCount == ratingCount) &&\n            (identical(other.kidFriendly, kidFriendly) ||\n                other.kidFriendly == kidFriendly) &&\n            (identical(other.wheelchairAccessible, wheelchairAccessible) ||\n                other.wheelchairAccessible == wheelchairAccessible) &&\n            (identical(other.bookingRequired, bookingRequired) ||\n                other.bookingRequired == bookingRequired));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType,\n      id,\n      name,\n      description,\n      latitude,\n      longitude,\n      categoryId,\n      subcategoryId,\n      city,\n      imageUrl,\n      isWow,\n      basePrice,\n      ratingAvg,\n      ratingCount,\n      kidFriendly,\n      wheelchairAccessible,\n      bookingRequired);\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ActivityBaseImplCopyWith<_$ActivityBaseImpl> get copyWith =>\n      __$$ActivityBaseImplCopyWithImpl<_$ActivityBaseImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$ActivityBaseImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _ActivityBase implements ActivityBase {\n  const factory _ActivityBase(\n      {required final String id,\n      required final String name,\n      required final String? description,\n      required final double latitude,\n      required final double longitude,\n      required final String categoryId,\n      final String? subcategoryId,\n      final String? city,\n      final String? imageUrl,\n      final bool isWow,\n      final double? basePrice,\n      final double ratingAvg,\n      final int ratingCount,\n      final bool kidFriendly,\n      final String? wheelchairAccessible,\n      final bool bookingRequired}) = _$ActivityBaseImpl;\n\n  factory _ActivityBase.fromJson(Map<String, dynamic> json) =\n      _$ActivityBaseImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get name;\n  @override\n  String? get description;\n  @override\n  double get latitude;\n  @override\n  double get longitude;\n  @override\n  String get categoryId;\n  @override\n  String? get subcategoryId;\n  @override\n  String? get city;\n  @override\n  String? get imageUrl;\n  @override\n  bool get isWow;\n  @override\n  double? get basePrice;\n  @override\n  double get ratingAvg;\n  @override\n  int get ratingCount;\n  @override\n  bool get kidFriendly;\n  @override\n  String? get wheelchairAccessible;\n  @override\n  bool get bookingRequired;\n\n  /// Create a copy of ActivityBase\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ActivityBaseImplCopyWith<_$ActivityBaseImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 16922,
        "last_modified": "2025-04-16T13:25:26.3933505",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_base.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'activity_base.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$ActivityBaseImpl _$$ActivityBaseImplFromJson(Map<String, dynamic> json) =>\n    _$ActivityBaseImpl(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      description: json['description'] as String?,\n      latitude: (json['latitude'] as num).toDouble(),\n      longitude: (json['longitude'] as num).toDouble(),\n      categoryId: json['categoryId'] as String,\n      subcategoryId: json['subcategoryId'] as String?,\n      city: json['city'] as String?,\n      imageUrl: json['imageUrl'] as String?,\n      isWow: json['isWow'] as bool? ?? false,\n      basePrice: (json['basePrice'] as num?)?.toDouble(),\n      ratingAvg: (json['ratingAvg'] as num?)?.toDouble() ?? 0.0,\n      ratingCount: (json['ratingCount'] as num?)?.toInt() ?? 0,\n      kidFriendly: json['kidFriendly'] as bool? ?? false,\n      wheelchairAccessible: json['wheelchairAccessible'] as String?,\n      bookingRequired: json['bookingRequired'] as bool? ?? false,\n    );\n\nMap<String, dynamic> _$$ActivityBaseImplToJson(_$ActivityBaseImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'name': instance.name,\n      'description': instance.description,\n      'latitude': instance.latitude,\n      'longitude': instance.longitude,\n      'categoryId': instance.categoryId,\n      'subcategoryId': instance.subcategoryId,\n      'city': instance.city,\n      'imageUrl': instance.imageUrl,\n      'isWow': instance.isWow,\n      'basePrice': instance.basePrice,\n      'ratingAvg': instance.ratingAvg,\n      'ratingCount': instance.ratingCount,\n      'kidFriendly': instance.kidFriendly,\n      'wheelchairAccessible': instance.wheelchairAccessible,\n      'bookingRequired': instance.bookingRequired,\n    };\n",
      "info": {
        "size": 1952,
        "last_modified": "2025-04-16T13:25:26.4003507",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\base\\activity_interface.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.4074492",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\searchable_activity.dart",
      "content": "// lib/core/domain/models/activity/search/searchable_activity.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../base/activity_base.dart';\r\n\r\npart 'searchable_activity.freezed.dart';\r\npart 'searchable_activity.g.dart';\r\n\r\n@freezed\r\nclass SearchableActivity with _$SearchableActivity {\r\n  const factory SearchableActivity({\r\n    required ActivityBase base,\r\n    String? categoryName,\r\n    String? subcategoryName,\r\n    String? subcategoryIcon,\r\n    String? geohash4,\r\n    String? geohash5,\r\n    double? approxDistanceKm,\r\n    double? distance,\r\n    String? city,\r\n    String? mainImageUrl,\r\n    List<String>? momentPreferences,\r\n    List<String>? weatherPreferences,\r\n  }) = _SearchableActivity;\r\n\r\n  factory SearchableActivity.fromJson(Map<String, dynamic> json) =>\r\n      _$SearchableActivityFromJson(json);\r\n\r\n  factory SearchableActivity.fromSupabase(\r\n      Map<String, dynamic> json, {\r\n        double? distanceFromSearch,\r\n      }) {\r\n    final categories = json['categories'] as Map<String, dynamic>?;\r\n    final subcategories = json['activity_subcategories'] as Map<String, dynamic>?;\r\n    final imagesData = json['activities_images'] as List?;\r\n    final mainImageUrl = imagesData?.firstWhere(\r\n          (img) => img['is_main'] == true,\r\n      orElse: () => imagesData.firstOrNull,\r\n    )?['mobile_url'];\r\n\r\n    return SearchableActivity(\r\n      base: ActivityBase(\r\n        id: json['id'],\r\n        name: json['name'],\r\n        city: json['city'],\r\n        description: json['description'],\r\n        latitude: json['latitude']?.toDouble() ?? 0.0,\r\n        longitude: json['longitude']?.toDouble() ?? 0.0,\r\n        categoryId: json['category_id'] ?? '',\r\n        subcategoryId: json['subcategory_id'],\r\n        isWow: json['is_wow'] ?? false,\r\n        basePrice: json['base_price']?.toDouble(),\r\n        ratingAvg: json['rating_avg']?.toDouble() ?? 0.0,\r\n        ratingCount: json['rating_count'] ?? 0,\r\n        kidFriendly: json['kid_friendly'] ?? false,\r\n        wheelchairAccessible: json['wheelchair_accessible'],\r\n        bookingRequired: json['booking_required'] ?? false,\r\n      ),\r\n      categoryName: categories?['name'],\r\n      subcategoryName: subcategories?['name'],\r\n      subcategoryIcon: subcategories?['icon'],\r\n      geohash4: json['geohash_4'],\r\n      geohash5: json['geohash_5'],\r\n      approxDistanceKm: (json['approx_distance_km'] as num?)?.toDouble(),\r\n      distance: distanceFromSearch,\r\n      city: json['address']?.toString().split(',').last.trim(),\r\n      mainImageUrl: mainImageUrl,\r\n      momentPreferences: (json['moment_preferences'] as List<dynamic>?)?.cast<String>(),\r\n      weatherPreferences: (json['weather_preferences'] as List<dynamic>?)?.cast<String>(),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2748,
        "last_modified": "2025-04-16T13:25:26.4199672",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\searchable_activity.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'searchable_activity.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nSearchableActivity _$SearchableActivityFromJson(Map<String, dynamic> json) {\n  return _SearchableActivity.fromJson(json);\n}\n\n/// @nodoc\nmixin _$SearchableActivity {\n  ActivityBase get base => throw _privateConstructorUsedError;\n  String? get categoryName => throw _privateConstructorUsedError;\n  String? get subcategoryName => throw _privateConstructorUsedError;\n  String? get subcategoryIcon => throw _privateConstructorUsedError;\n  String? get geohash4 => throw _privateConstructorUsedError;\n  String? get geohash5 => throw _privateConstructorUsedError;\n  double? get approxDistanceKm => throw _privateConstructorUsedError;\n  double? get distance => throw _privateConstructorUsedError;\n  String? get city => throw _privateConstructorUsedError;\n  String? get mainImageUrl => throw _privateConstructorUsedError;\n  List<String>? get momentPreferences => throw _privateConstructorUsedError;\n  List<String>? get weatherPreferences => throw _privateConstructorUsedError;\n\n  /// Serializes this SearchableActivity to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $SearchableActivityCopyWith<SearchableActivity> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $SearchableActivityCopyWith<$Res> {\n  factory $SearchableActivityCopyWith(\n          SearchableActivity value, $Res Function(SearchableActivity) then) =\n      _$SearchableActivityCopyWithImpl<$Res, SearchableActivity>;\n  @useResult\n  $Res call(\n      {ActivityBase base,\n      String? categoryName,\n      String? subcategoryName,\n      String? subcategoryIcon,\n      String? geohash4,\n      String? geohash5,\n      double? approxDistanceKm,\n      double? distance,\n      String? city,\n      String? mainImageUrl,\n      List<String>? momentPreferences,\n      List<String>? weatherPreferences});\n\n  $ActivityBaseCopyWith<$Res> get base;\n}\n\n/// @nodoc\nclass _$SearchableActivityCopyWithImpl<$Res, $Val extends SearchableActivity>\n    implements $SearchableActivityCopyWith<$Res> {\n  _$SearchableActivityCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? base = null,\n    Object? categoryName = freezed,\n    Object? subcategoryName = freezed,\n    Object? subcategoryIcon = freezed,\n    Object? geohash4 = freezed,\n    Object? geohash5 = freezed,\n    Object? approxDistanceKm = freezed,\n    Object? distance = freezed,\n    Object? city = freezed,\n    Object? mainImageUrl = freezed,\n    Object? momentPreferences = freezed,\n    Object? weatherPreferences = freezed,\n  }) {\n    return _then(_value.copyWith(\n      base: null == base\n          ? _value.base\n          : base // ignore: cast_nullable_to_non_nullable\n              as ActivityBase,\n      categoryName: freezed == categoryName\n          ? _value.categoryName\n          : categoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryName: freezed == subcategoryName\n          ? _value.subcategoryName\n          : subcategoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryIcon: freezed == subcategoryIcon\n          ? _value.subcategoryIcon\n          : subcategoryIcon // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash4: freezed == geohash4\n          ? _value.geohash4\n          : geohash4 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash5: freezed == geohash5\n          ? _value.geohash5\n          : geohash5 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      approxDistanceKm: freezed == approxDistanceKm\n          ? _value.approxDistanceKm\n          : approxDistanceKm // ignore: cast_nullable_to_non_nullable\n              as double?,\n      distance: freezed == distance\n          ? _value.distance\n          : distance // ignore: cast_nullable_to_non_nullable\n              as double?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mainImageUrl: freezed == mainImageUrl\n          ? _value.mainImageUrl\n          : mainImageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      momentPreferences: freezed == momentPreferences\n          ? _value.momentPreferences\n          : momentPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n      weatherPreferences: freezed == weatherPreferences\n          ? _value.weatherPreferences\n          : weatherPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n    ) as $Val);\n  }\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $ActivityBaseCopyWith<$Res> get base {\n    return $ActivityBaseCopyWith<$Res>(_value.base, (value) {\n      return _then(_value.copyWith(base: value) as $Val);\n    });\n  }\n}\n\n/// @nodoc\nabstract class _$$SearchableActivityImplCopyWith<$Res>\n    implements $SearchableActivityCopyWith<$Res> {\n  factory _$$SearchableActivityImplCopyWith(_$SearchableActivityImpl value,\n          $Res Function(_$SearchableActivityImpl) then) =\n      __$$SearchableActivityImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {ActivityBase base,\n      String? categoryName,\n      String? subcategoryName,\n      String? subcategoryIcon,\n      String? geohash4,\n      String? geohash5,\n      double? approxDistanceKm,\n      double? distance,\n      String? city,\n      String? mainImageUrl,\n      List<String>? momentPreferences,\n      List<String>? weatherPreferences});\n\n  @override\n  $ActivityBaseCopyWith<$Res> get base;\n}\n\n/// @nodoc\nclass __$$SearchableActivityImplCopyWithImpl<$Res>\n    extends _$SearchableActivityCopyWithImpl<$Res, _$SearchableActivityImpl>\n    implements _$$SearchableActivityImplCopyWith<$Res> {\n  __$$SearchableActivityImplCopyWithImpl(_$SearchableActivityImpl _value,\n      $Res Function(_$SearchableActivityImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? base = null,\n    Object? categoryName = freezed,\n    Object? subcategoryName = freezed,\n    Object? subcategoryIcon = freezed,\n    Object? geohash4 = freezed,\n    Object? geohash5 = freezed,\n    Object? approxDistanceKm = freezed,\n    Object? distance = freezed,\n    Object? city = freezed,\n    Object? mainImageUrl = freezed,\n    Object? momentPreferences = freezed,\n    Object? weatherPreferences = freezed,\n  }) {\n    return _then(_$SearchableActivityImpl(\n      base: null == base\n          ? _value.base\n          : base // ignore: cast_nullable_to_non_nullable\n              as ActivityBase,\n      categoryName: freezed == categoryName\n          ? _value.categoryName\n          : categoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryName: freezed == subcategoryName\n          ? _value.subcategoryName\n          : subcategoryName // ignore: cast_nullable_to_non_nullable\n              as String?,\n      subcategoryIcon: freezed == subcategoryIcon\n          ? _value.subcategoryIcon\n          : subcategoryIcon // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash4: freezed == geohash4\n          ? _value.geohash4\n          : geohash4 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      geohash5: freezed == geohash5\n          ? _value.geohash5\n          : geohash5 // ignore: cast_nullable_to_non_nullable\n              as String?,\n      approxDistanceKm: freezed == approxDistanceKm\n          ? _value.approxDistanceKm\n          : approxDistanceKm // ignore: cast_nullable_to_non_nullable\n              as double?,\n      distance: freezed == distance\n          ? _value.distance\n          : distance // ignore: cast_nullable_to_non_nullable\n              as double?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mainImageUrl: freezed == mainImageUrl\n          ? _value.mainImageUrl\n          : mainImageUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      momentPreferences: freezed == momentPreferences\n          ? _value._momentPreferences\n          : momentPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n      weatherPreferences: freezed == weatherPreferences\n          ? _value._weatherPreferences\n          : weatherPreferences // ignore: cast_nullable_to_non_nullable\n              as List<String>?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$SearchableActivityImpl implements _SearchableActivity {\n  const _$SearchableActivityImpl(\n      {required this.base,\n      this.categoryName,\n      this.subcategoryName,\n      this.subcategoryIcon,\n      this.geohash4,\n      this.geohash5,\n      this.approxDistanceKm,\n      this.distance,\n      this.city,\n      this.mainImageUrl,\n      final List<String>? momentPreferences,\n      final List<String>? weatherPreferences})\n      : _momentPreferences = momentPreferences,\n        _weatherPreferences = weatherPreferences;\n\n  factory _$SearchableActivityImpl.fromJson(Map<String, dynamic> json) =>\n      _$$SearchableActivityImplFromJson(json);\n\n  @override\n  final ActivityBase base;\n  @override\n  final String? categoryName;\n  @override\n  final String? subcategoryName;\n  @override\n  final String? subcategoryIcon;\n  @override\n  final String? geohash4;\n  @override\n  final String? geohash5;\n  @override\n  final double? approxDistanceKm;\n  @override\n  final double? distance;\n  @override\n  final String? city;\n  @override\n  final String? mainImageUrl;\n  final List<String>? _momentPreferences;\n  @override\n  List<String>? get momentPreferences {\n    final value = _momentPreferences;\n    if (value == null) return null;\n    if (_momentPreferences is EqualUnmodifiableListView)\n      return _momentPreferences;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(value);\n  }\n\n  final List<String>? _weatherPreferences;\n  @override\n  List<String>? get weatherPreferences {\n    final value = _weatherPreferences;\n    if (value == null) return null;\n    if (_weatherPreferences is EqualUnmodifiableListView)\n      return _weatherPreferences;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(value);\n  }\n\n  @override\n  String toString() {\n    return 'SearchableActivity(base: $base, categoryName: $categoryName, subcategoryName: $subcategoryName, subcategoryIcon: $subcategoryIcon, geohash4: $geohash4, geohash5: $geohash5, approxDistanceKm: $approxDistanceKm, distance: $distance, city: $city, mainImageUrl: $mainImageUrl, momentPreferences: $momentPreferences, weatherPreferences: $weatherPreferences)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SearchableActivityImpl &&\n            (identical(other.base, base) || other.base == base) &&\n            (identical(other.categoryName, categoryName) ||\n                other.categoryName == categoryName) &&\n            (identical(other.subcategoryName, subcategoryName) ||\n                other.subcategoryName == subcategoryName) &&\n            (identical(other.subcategoryIcon, subcategoryIcon) ||\n                other.subcategoryIcon == subcategoryIcon) &&\n            (identical(other.geohash4, geohash4) ||\n                other.geohash4 == geohash4) &&\n            (identical(other.geohash5, geohash5) ||\n                other.geohash5 == geohash5) &&\n            (identical(other.approxDistanceKm, approxDistanceKm) ||\n                other.approxDistanceKm == approxDistanceKm) &&\n            (identical(other.distance, distance) ||\n                other.distance == distance) &&\n            (identical(other.city, city) || other.city == city) &&\n            (identical(other.mainImageUrl, mainImageUrl) ||\n                other.mainImageUrl == mainImageUrl) &&\n            const DeepCollectionEquality()\n                .equals(other._momentPreferences, _momentPreferences) &&\n            const DeepCollectionEquality()\n                .equals(other._weatherPreferences, _weatherPreferences));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType,\n      base,\n      categoryName,\n      subcategoryName,\n      subcategoryIcon,\n      geohash4,\n      geohash5,\n      approxDistanceKm,\n      distance,\n      city,\n      mainImageUrl,\n      const DeepCollectionEquality().hash(_momentPreferences),\n      const DeepCollectionEquality().hash(_weatherPreferences));\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SearchableActivityImplCopyWith<_$SearchableActivityImpl> get copyWith =>\n      __$$SearchableActivityImplCopyWithImpl<_$SearchableActivityImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$SearchableActivityImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _SearchableActivity implements SearchableActivity {\n  const factory _SearchableActivity(\n      {required final ActivityBase base,\n      final String? categoryName,\n      final String? subcategoryName,\n      final String? subcategoryIcon,\n      final String? geohash4,\n      final String? geohash5,\n      final double? approxDistanceKm,\n      final double? distance,\n      final String? city,\n      final String? mainImageUrl,\n      final List<String>? momentPreferences,\n      final List<String>? weatherPreferences}) = _$SearchableActivityImpl;\n\n  factory _SearchableActivity.fromJson(Map<String, dynamic> json) =\n      _$SearchableActivityImpl.fromJson;\n\n  @override\n  ActivityBase get base;\n  @override\n  String? get categoryName;\n  @override\n  String? get subcategoryName;\n  @override\n  String? get subcategoryIcon;\n  @override\n  String? get geohash4;\n  @override\n  String? get geohash5;\n  @override\n  double? get approxDistanceKm;\n  @override\n  double? get distance;\n  @override\n  String? get city;\n  @override\n  String? get mainImageUrl;\n  @override\n  List<String>? get momentPreferences;\n  @override\n  List<String>? get weatherPreferences;\n\n  /// Create a copy of SearchableActivity\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SearchableActivityImplCopyWith<_$SearchableActivityImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 16211,
        "last_modified": "2025-04-16T13:25:26.4271204",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\searchable_activity.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'searchable_activity.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$SearchableActivityImpl _$$SearchableActivityImplFromJson(\n        Map<String, dynamic> json) =>\n    _$SearchableActivityImpl(\n      base: ActivityBase.fromJson(json['base'] as Map<String, dynamic>),\n      categoryName: json['categoryName'] as String?,\n      subcategoryName: json['subcategoryName'] as String?,\n      subcategoryIcon: json['subcategoryIcon'] as String?,\n      geohash4: json['geohash4'] as String?,\n      geohash5: json['geohash5'] as String?,\n      approxDistanceKm: (json['approxDistanceKm'] as num?)?.toDouble(),\n      distance: (json['distance'] as num?)?.toDouble(),\n      city: json['city'] as String?,\n      mainImageUrl: json['mainImageUrl'] as String?,\n      momentPreferences: (json['momentPreferences'] as List<dynamic>?)\n          ?.map((e) => e as String)\n          .toList(),\n      weatherPreferences: (json['weatherPreferences'] as List<dynamic>?)\n          ?.map((e) => e as String)\n          .toList(),\n    );\n\nMap<String, dynamic> _$$SearchableActivityImplToJson(\n        _$SearchableActivityImpl instance) =>\n    <String, dynamic>{\n      'base': instance.base,\n      'categoryName': instance.categoryName,\n      'subcategoryName': instance.subcategoryName,\n      'subcategoryIcon': instance.subcategoryIcon,\n      'geohash4': instance.geohash4,\n      'geohash5': instance.geohash5,\n      'approxDistanceKm': instance.approxDistanceKm,\n      'distance': instance.distance,\n      'city': instance.city,\n      'mainImageUrl': instance.mainImageUrl,\n      'momentPreferences': instance.momentPreferences,\n      'weatherPreferences': instance.weatherPreferences,\n    };\n",
      "info": {
        "size": 1868,
        "last_modified": "2025-04-16T13:25:26.4331639",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\search\\search_result.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.4411855",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\activity\\trip\\trip_activity.dart",
      "content": "",
      "info": {
        "size": 0,
        "last_modified": "2025-04-16T13:25:26.4524634",
        "mime_type": "application/octet-stream",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\common_models.dart",
      "content": "// lib\\core\\domain\\models\\common_models.dart\r\n\r\nimport '../../common/enums/trip_enums.dart';\r\n\r\nclass GeoPoint {\r\n  final double latitude;\r\n  final double longitude;\r\n\r\n  GeoPoint({\r\n    required this.latitude,\r\n    required this.longitude,\r\n  });\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'latitude': latitude,\r\n    'longitude': longitude,\r\n  };\r\n}\r\n\r\nclass GroupMember {\r\n  final GroupMemberType type;\r\n  final bool hasMobilityIssues;\r\n\r\n  GroupMember({\r\n    required this.type,\r\n    this.hasMobilityIssues = false,\r\n  });\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'type': type.toString(),\r\n    'hasMobilityIssues': hasMobilityIssues,\r\n  };\r\n}",
      "info": {
        "size": 651,
        "last_modified": "2025-04-16T13:25:26.4689854",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\app_remote_config.dart",
      "content": "// lib/core/domain/models/config/app_remote_config.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'app_remote_config.freezed.dart';\r\npart 'app_remote_config.g.dart';\r\n\r\n@freezed\r\nclass AppRemoteConfig with _$AppRemoteConfig {\r\n  const factory AppRemoteConfig({\r\n    required String key,\r\n    required dynamic value,\r\n    String? minAppVersion,\r\n  }) = _AppRemoteConfig;\r\n\r\n  factory AppRemoteConfig.fromJson(Map<String, dynamic> json) =>\r\n      _$AppRemoteConfigFromJson(json);\r\n}",
      "info": {
        "size": 510,
        "last_modified": "2025-04-16T13:25:26.4750017",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\app_remote_config.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'app_remote_config.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nAppRemoteConfig _$AppRemoteConfigFromJson(Map<String, dynamic> json) {\n  return _AppRemoteConfig.fromJson(json);\n}\n\n/// @nodoc\nmixin _$AppRemoteConfig {\n  String get key => throw _privateConstructorUsedError;\n  dynamic get value => throw _privateConstructorUsedError;\n  String? get minAppVersion => throw _privateConstructorUsedError;\n\n  /// Serializes this AppRemoteConfig to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $AppRemoteConfigCopyWith<AppRemoteConfig> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $AppRemoteConfigCopyWith<$Res> {\n  factory $AppRemoteConfigCopyWith(\n          AppRemoteConfig value, $Res Function(AppRemoteConfig) then) =\n      _$AppRemoteConfigCopyWithImpl<$Res, AppRemoteConfig>;\n  @useResult\n  $Res call({String key, dynamic value, String? minAppVersion});\n}\n\n/// @nodoc\nclass _$AppRemoteConfigCopyWithImpl<$Res, $Val extends AppRemoteConfig>\n    implements $AppRemoteConfigCopyWith<$Res> {\n  _$AppRemoteConfigCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? key = null,\n    Object? value = freezed,\n    Object? minAppVersion = freezed,\n  }) {\n    return _then(_value.copyWith(\n      key: null == key\n          ? _value.key\n          : key // ignore: cast_nullable_to_non_nullable\n              as String,\n      value: freezed == value\n          ? _value.value\n          : value // ignore: cast_nullable_to_non_nullable\n              as dynamic,\n      minAppVersion: freezed == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$AppRemoteConfigImplCopyWith<$Res>\n    implements $AppRemoteConfigCopyWith<$Res> {\n  factory _$$AppRemoteConfigImplCopyWith(_$AppRemoteConfigImpl value,\n          $Res Function(_$AppRemoteConfigImpl) then) =\n      __$$AppRemoteConfigImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call({String key, dynamic value, String? minAppVersion});\n}\n\n/// @nodoc\nclass __$$AppRemoteConfigImplCopyWithImpl<$Res>\n    extends _$AppRemoteConfigCopyWithImpl<$Res, _$AppRemoteConfigImpl>\n    implements _$$AppRemoteConfigImplCopyWith<$Res> {\n  __$$AppRemoteConfigImplCopyWithImpl(\n      _$AppRemoteConfigImpl _value, $Res Function(_$AppRemoteConfigImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? key = null,\n    Object? value = freezed,\n    Object? minAppVersion = freezed,\n  }) {\n    return _then(_$AppRemoteConfigImpl(\n      key: null == key\n          ? _value.key\n          : key // ignore: cast_nullable_to_non_nullable\n              as String,\n      value: freezed == value\n          ? _value.value\n          : value // ignore: cast_nullable_to_non_nullable\n              as dynamic,\n      minAppVersion: freezed == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$AppRemoteConfigImpl implements _AppRemoteConfig {\n  const _$AppRemoteConfigImpl(\n      {required this.key, required this.value, this.minAppVersion});\n\n  factory _$AppRemoteConfigImpl.fromJson(Map<String, dynamic> json) =>\n      _$$AppRemoteConfigImplFromJson(json);\n\n  @override\n  final String key;\n  @override\n  final dynamic value;\n  @override\n  final String? minAppVersion;\n\n  @override\n  String toString() {\n    return 'AppRemoteConfig(key: $key, value: $value, minAppVersion: $minAppVersion)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$AppRemoteConfigImpl &&\n            (identical(other.key, key) || other.key == key) &&\n            const DeepCollectionEquality().equals(other.value, value) &&\n            (identical(other.minAppVersion, minAppVersion) ||\n                other.minAppVersion == minAppVersion));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, key,\n      const DeepCollectionEquality().hash(value), minAppVersion);\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$AppRemoteConfigImplCopyWith<_$AppRemoteConfigImpl> get copyWith =>\n      __$$AppRemoteConfigImplCopyWithImpl<_$AppRemoteConfigImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$AppRemoteConfigImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _AppRemoteConfig implements AppRemoteConfig {\n  const factory _AppRemoteConfig(\n      {required final String key,\n      required final dynamic value,\n      final String? minAppVersion}) = _$AppRemoteConfigImpl;\n\n  factory _AppRemoteConfig.fromJson(Map<String, dynamic> json) =\n      _$AppRemoteConfigImpl.fromJson;\n\n  @override\n  String get key;\n  @override\n  dynamic get value;\n  @override\n  String? get minAppVersion;\n\n  /// Create a copy of AppRemoteConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$AppRemoteConfigImplCopyWith<_$AppRemoteConfigImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 7004,
        "last_modified": "2025-04-16T13:25:26.4813668",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\app_remote_config.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'app_remote_config.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$AppRemoteConfigImpl _$$AppRemoteConfigImplFromJson(\n        Map<String, dynamic> json) =>\n    _$AppRemoteConfigImpl(\n      key: json['key'] as String,\n      value: json['value'],\n      minAppVersion: json['minAppVersion'] as String?,\n    );\n\nMap<String, dynamic> _$$AppRemoteConfigImplToJson(\n        _$AppRemoteConfigImpl instance) =>\n    <String, dynamic>{\n      'key': instance.key,\n      'value': instance.value,\n      'minAppVersion': instance.minAppVersion,\n    };\n",
      "info": {
        "size": 737,
        "last_modified": "2025-04-16T13:25:26.4873663",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\home_section_config.dart",
      "content": "// lib/core/domain/models/config/home_section_config.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'home_section_config.freezed.dart';\r\npart 'home_section_config.g.dart';\r\n\r\n@freezed\r\nclass HomeSectionConfig with _$HomeSectionConfig {\r\n  const factory HomeSectionConfig({\r\n    required String id,\r\n    required String title,\r\n    required String queryFilter,\r\n    String? iconUrl,\r\n    required int priority,\r\n    required String minAppVersion,\r\n  }) = _HomeSectionConfig;\r\n\r\n  factory HomeSectionConfig.fromJson(Map<String, dynamic> json) =>\r\n      _$HomeSectionConfigFromJson(json);\r\n}\r\n\r\n\r\n\r\n",
      "info": {
        "size": 626,
        "last_modified": "2025-04-16T13:25:26.4938776",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\home_section_config.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'home_section_config.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nHomeSectionConfig _$HomeSectionConfigFromJson(Map<String, dynamic> json) {\n  return _HomeSectionConfig.fromJson(json);\n}\n\n/// @nodoc\nmixin _$HomeSectionConfig {\n  String get id => throw _privateConstructorUsedError;\n  String get title => throw _privateConstructorUsedError;\n  String get queryFilter => throw _privateConstructorUsedError;\n  String? get iconUrl => throw _privateConstructorUsedError;\n  int get priority => throw _privateConstructorUsedError;\n  String get minAppVersion => throw _privateConstructorUsedError;\n\n  /// Serializes this HomeSectionConfig to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $HomeSectionConfigCopyWith<HomeSectionConfig> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $HomeSectionConfigCopyWith<$Res> {\n  factory $HomeSectionConfigCopyWith(\n          HomeSectionConfig value, $Res Function(HomeSectionConfig) then) =\n      _$HomeSectionConfigCopyWithImpl<$Res, HomeSectionConfig>;\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? iconUrl,\n      int priority,\n      String minAppVersion});\n}\n\n/// @nodoc\nclass _$HomeSectionConfigCopyWithImpl<$Res, $Val extends HomeSectionConfig>\n    implements $HomeSectionConfigCopyWith<$Res> {\n  _$HomeSectionConfigCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? iconUrl = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      iconUrl: freezed == iconUrl\n          ? _value.iconUrl\n          : iconUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$HomeSectionConfigImplCopyWith<$Res>\n    implements $HomeSectionConfigCopyWith<$Res> {\n  factory _$$HomeSectionConfigImplCopyWith(_$HomeSectionConfigImpl value,\n          $Res Function(_$HomeSectionConfigImpl) then) =\n      __$$HomeSectionConfigImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? iconUrl,\n      int priority,\n      String minAppVersion});\n}\n\n/// @nodoc\nclass __$$HomeSectionConfigImplCopyWithImpl<$Res>\n    extends _$HomeSectionConfigCopyWithImpl<$Res, _$HomeSectionConfigImpl>\n    implements _$$HomeSectionConfigImplCopyWith<$Res> {\n  __$$HomeSectionConfigImplCopyWithImpl(_$HomeSectionConfigImpl _value,\n      $Res Function(_$HomeSectionConfigImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? iconUrl = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n  }) {\n    return _then(_$HomeSectionConfigImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      iconUrl: freezed == iconUrl\n          ? _value.iconUrl\n          : iconUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$HomeSectionConfigImpl implements _HomeSectionConfig {\n  const _$HomeSectionConfigImpl(\n      {required this.id,\n      required this.title,\n      required this.queryFilter,\n      this.iconUrl,\n      required this.priority,\n      required this.minAppVersion});\n\n  factory _$HomeSectionConfigImpl.fromJson(Map<String, dynamic> json) =>\n      _$$HomeSectionConfigImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String title;\n  @override\n  final String queryFilter;\n  @override\n  final String? iconUrl;\n  @override\n  final int priority;\n  @override\n  final String minAppVersion;\n\n  @override\n  String toString() {\n    return 'HomeSectionConfig(id: $id, title: $title, queryFilter: $queryFilter, iconUrl: $iconUrl, priority: $priority, minAppVersion: $minAppVersion)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$HomeSectionConfigImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.title, title) || other.title == title) &&\n            (identical(other.queryFilter, queryFilter) ||\n                other.queryFilter == queryFilter) &&\n            (identical(other.iconUrl, iconUrl) || other.iconUrl == iconUrl) &&\n            (identical(other.priority, priority) ||\n                other.priority == priority) &&\n            (identical(other.minAppVersion, minAppVersion) ||\n                other.minAppVersion == minAppVersion));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, id, title, queryFilter, iconUrl, priority, minAppVersion);\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$HomeSectionConfigImplCopyWith<_$HomeSectionConfigImpl> get copyWith =>\n      __$$HomeSectionConfigImplCopyWithImpl<_$HomeSectionConfigImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$HomeSectionConfigImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _HomeSectionConfig implements HomeSectionConfig {\n  const factory _HomeSectionConfig(\n      {required final String id,\n      required final String title,\n      required final String queryFilter,\n      final String? iconUrl,\n      required final int priority,\n      required final String minAppVersion}) = _$HomeSectionConfigImpl;\n\n  factory _HomeSectionConfig.fromJson(Map<String, dynamic> json) =\n      _$HomeSectionConfigImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get title;\n  @override\n  String get queryFilter;\n  @override\n  String? get iconUrl;\n  @override\n  int get priority;\n  @override\n  String get minAppVersion;\n\n  /// Create a copy of HomeSectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$HomeSectionConfigImplCopyWith<_$HomeSectionConfigImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 9286,
        "last_modified": "2025-04-16T13:25:26.4998818",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\home_section_config.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'home_section_config.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$HomeSectionConfigImpl _$$HomeSectionConfigImplFromJson(\n        Map<String, dynamic> json) =>\n    _$HomeSectionConfigImpl(\n      id: json['id'] as String,\n      title: json['title'] as String,\n      queryFilter: json['queryFilter'] as String,\n      iconUrl: json['iconUrl'] as String?,\n      priority: (json['priority'] as num).toInt(),\n      minAppVersion: json['minAppVersion'] as String,\n    );\n\nMap<String, dynamic> _$$HomeSectionConfigImplToJson(\n        _$HomeSectionConfigImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'title': instance.title,\n      'queryFilter': instance.queryFilter,\n      'iconUrl': instance.iconUrl,\n      'priority': instance.priority,\n      'minAppVersion': instance.minAppVersion,\n    };\n",
      "info": {
        "size": 1013,
        "last_modified": "2025-04-16T13:25:26.5064233",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\subcategory_section_config.dart",
      "content": "// lib/core/domain/models/config/subcategory_section_config.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'subcategory_section_config.freezed.dart';\r\npart 'subcategory_section_config.g.dart';\r\n\r\n@freezed\r\nclass SubcategorySectionConfig with _$SubcategorySectionConfig {\r\n  const factory SubcategorySectionConfig({\r\n    required String id,\r\n    required String title,\r\n    required String queryFilter,\r\n    String? subcategoryId,  // Nullable car peut tre null pour config par dfaut\r\n    required int priority,\r\n    required String minAppVersion,\r\n    @Default(false) bool isDefault,  // Nouveau champ avec valeur par dfaut\r\n  }) = _SubcategorySectionConfig;\r\n\r\n  factory SubcategorySectionConfig.fromJson(Map<String, dynamic> json) =>\r\n      _$SubcategorySectionConfigFromJson(json);\r\n}",
      "info": {
        "size": 823,
        "last_modified": "2025-04-16T13:25:26.5129588",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\subcategory_section_config.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'subcategory_section_config.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nSubcategorySectionConfig _$SubcategorySectionConfigFromJson(\n    Map<String, dynamic> json) {\n  return _SubcategorySectionConfig.fromJson(json);\n}\n\n/// @nodoc\nmixin _$SubcategorySectionConfig {\n  String get id => throw _privateConstructorUsedError;\n  String get title => throw _privateConstructorUsedError;\n  String get queryFilter => throw _privateConstructorUsedError;\n  String? get subcategoryId =>\n      throw _privateConstructorUsedError; // Nullable car peut tre null pour config par dfaut\n  int get priority => throw _privateConstructorUsedError;\n  String get minAppVersion => throw _privateConstructorUsedError;\n  bool get isDefault => throw _privateConstructorUsedError;\n\n  /// Serializes this SubcategorySectionConfig to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $SubcategorySectionConfigCopyWith<SubcategorySectionConfig> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $SubcategorySectionConfigCopyWith<$Res> {\n  factory $SubcategorySectionConfigCopyWith(SubcategorySectionConfig value,\n          $Res Function(SubcategorySectionConfig) then) =\n      _$SubcategorySectionConfigCopyWithImpl<$Res, SubcategorySectionConfig>;\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? subcategoryId,\n      int priority,\n      String minAppVersion,\n      bool isDefault});\n}\n\n/// @nodoc\nclass _$SubcategorySectionConfigCopyWithImpl<$Res,\n        $Val extends SubcategorySectionConfig>\n    implements $SubcategorySectionConfigCopyWith<$Res> {\n  _$SubcategorySectionConfigCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? subcategoryId = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n    Object? isDefault = null,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n      isDefault: null == isDefault\n          ? _value.isDefault\n          : isDefault // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$SubcategorySectionConfigImplCopyWith<$Res>\n    implements $SubcategorySectionConfigCopyWith<$Res> {\n  factory _$$SubcategorySectionConfigImplCopyWith(\n          _$SubcategorySectionConfigImpl value,\n          $Res Function(_$SubcategorySectionConfigImpl) then) =\n      __$$SubcategorySectionConfigImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String title,\n      String queryFilter,\n      String? subcategoryId,\n      int priority,\n      String minAppVersion,\n      bool isDefault});\n}\n\n/// @nodoc\nclass __$$SubcategorySectionConfigImplCopyWithImpl<$Res>\n    extends _$SubcategorySectionConfigCopyWithImpl<$Res,\n        _$SubcategorySectionConfigImpl>\n    implements _$$SubcategorySectionConfigImplCopyWith<$Res> {\n  __$$SubcategorySectionConfigImplCopyWithImpl(\n      _$SubcategorySectionConfigImpl _value,\n      $Res Function(_$SubcategorySectionConfigImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? title = null,\n    Object? queryFilter = null,\n    Object? subcategoryId = freezed,\n    Object? priority = null,\n    Object? minAppVersion = null,\n    Object? isDefault = null,\n  }) {\n    return _then(_$SubcategorySectionConfigImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      title: null == title\n          ? _value.title\n          : title // ignore: cast_nullable_to_non_nullable\n              as String,\n      queryFilter: null == queryFilter\n          ? _value.queryFilter\n          : queryFilter // ignore: cast_nullable_to_non_nullable\n              as String,\n      subcategoryId: freezed == subcategoryId\n          ? _value.subcategoryId\n          : subcategoryId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      priority: null == priority\n          ? _value.priority\n          : priority // ignore: cast_nullable_to_non_nullable\n              as int,\n      minAppVersion: null == minAppVersion\n          ? _value.minAppVersion\n          : minAppVersion // ignore: cast_nullable_to_non_nullable\n              as String,\n      isDefault: null == isDefault\n          ? _value.isDefault\n          : isDefault // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$SubcategorySectionConfigImpl implements _SubcategorySectionConfig {\n  const _$SubcategorySectionConfigImpl(\n      {required this.id,\n      required this.title,\n      required this.queryFilter,\n      this.subcategoryId,\n      required this.priority,\n      required this.minAppVersion,\n      this.isDefault = false});\n\n  factory _$SubcategorySectionConfigImpl.fromJson(Map<String, dynamic> json) =>\n      _$$SubcategorySectionConfigImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String title;\n  @override\n  final String queryFilter;\n  @override\n  final String? subcategoryId;\n// Nullable car peut tre null pour config par dfaut\n  @override\n  final int priority;\n  @override\n  final String minAppVersion;\n  @override\n  @JsonKey()\n  final bool isDefault;\n\n  @override\n  String toString() {\n    return 'SubcategorySectionConfig(id: $id, title: $title, queryFilter: $queryFilter, subcategoryId: $subcategoryId, priority: $priority, minAppVersion: $minAppVersion, isDefault: $isDefault)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SubcategorySectionConfigImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.title, title) || other.title == title) &&\n            (identical(other.queryFilter, queryFilter) ||\n                other.queryFilter == queryFilter) &&\n            (identical(other.subcategoryId, subcategoryId) ||\n                other.subcategoryId == subcategoryId) &&\n            (identical(other.priority, priority) ||\n                other.priority == priority) &&\n            (identical(other.minAppVersion, minAppVersion) ||\n                other.minAppVersion == minAppVersion) &&\n            (identical(other.isDefault, isDefault) ||\n                other.isDefault == isDefault));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, id, title, queryFilter,\n      subcategoryId, priority, minAppVersion, isDefault);\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SubcategorySectionConfigImplCopyWith<_$SubcategorySectionConfigImpl>\n      get copyWith => __$$SubcategorySectionConfigImplCopyWithImpl<\n          _$SubcategorySectionConfigImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$SubcategorySectionConfigImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _SubcategorySectionConfig implements SubcategorySectionConfig {\n  const factory _SubcategorySectionConfig(\n      {required final String id,\n      required final String title,\n      required final String queryFilter,\n      final String? subcategoryId,\n      required final int priority,\n      required final String minAppVersion,\n      final bool isDefault}) = _$SubcategorySectionConfigImpl;\n\n  factory _SubcategorySectionConfig.fromJson(Map<String, dynamic> json) =\n      _$SubcategorySectionConfigImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get title;\n  @override\n  String get queryFilter;\n  @override\n  String?\n      get subcategoryId; // Nullable car peut tre null pour config par dfaut\n  @override\n  int get priority;\n  @override\n  String get minAppVersion;\n  @override\n  bool get isDefault;\n\n  /// Create a copy of SubcategorySectionConfig\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SubcategorySectionConfigImplCopyWith<_$SubcategorySectionConfigImpl>\n      get copyWith => throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 10804,
        "last_modified": "2025-04-16T13:25:26.5199506",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\config\\subcategory_section_config.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'subcategory_section_config.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$SubcategorySectionConfigImpl _$$SubcategorySectionConfigImplFromJson(\n        Map<String, dynamic> json) =>\n    _$SubcategorySectionConfigImpl(\n      id: json['id'] as String,\n      title: json['title'] as String,\n      queryFilter: json['queryFilter'] as String,\n      subcategoryId: json['subcategoryId'] as String?,\n      priority: (json['priority'] as num).toInt(),\n      minAppVersion: json['minAppVersion'] as String,\n      isDefault: json['isDefault'] as bool? ?? false,\n    );\n\nMap<String, dynamic> _$$SubcategorySectionConfigImplToJson(\n        _$SubcategorySectionConfigImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'title': instance.title,\n      'queryFilter': instance.queryFilter,\n      'subcategoryId': instance.subcategoryId,\n      'priority': instance.priority,\n      'minAppVersion': instance.minAppVersion,\n      'isDefault': instance.isDefault,\n    };\n",
      "info": {
        "size": 1172,
        "last_modified": "2025-04-16T13:25:26.5260721",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_details.dart",
      "content": "// lib/core/domain/models/location/place_details.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport 'user_location.dart';\r\n\r\npart 'place_details.freezed.dart';\r\npart 'place_details.g.dart';\r\n\r\n@freezed\r\nclass PlaceDetails with _$PlaceDetails {\r\n  const factory PlaceDetails({\r\n    required String placeId,\r\n    required String formattedAddress,\r\n    required String name,\r\n    required UserLocation location,\r\n    String? country,\r\n    String? administrativeArea,\r\n    String? locality,\r\n    String? postalCode,\r\n    DateTime? lastUpdated,\r\n  }) = _PlaceDetails;\r\n\r\n  factory PlaceDetails.fromJson(Map<String, dynamic> json) =>\r\n      _$PlaceDetailsFromJson(json);\r\n}",
      "info": {
        "size": 693,
        "last_modified": "2025-04-16T13:25:26.5397168",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_details.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_details.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nPlaceDetails _$PlaceDetailsFromJson(Map<String, dynamic> json) {\n  return _PlaceDetails.fromJson(json);\n}\n\n/// @nodoc\nmixin _$PlaceDetails {\n  String get placeId => throw _privateConstructorUsedError;\n  String get formattedAddress => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  UserLocation get location => throw _privateConstructorUsedError;\n  String? get country => throw _privateConstructorUsedError;\n  String? get administrativeArea => throw _privateConstructorUsedError;\n  String? get locality => throw _privateConstructorUsedError;\n  String? get postalCode => throw _privateConstructorUsedError;\n  DateTime? get lastUpdated => throw _privateConstructorUsedError;\n\n  /// Serializes this PlaceDetails to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $PlaceDetailsCopyWith<PlaceDetails> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceDetailsCopyWith<$Res> {\n  factory $PlaceDetailsCopyWith(\n          PlaceDetails value, $Res Function(PlaceDetails) then) =\n      _$PlaceDetailsCopyWithImpl<$Res, PlaceDetails>;\n  @useResult\n  $Res call(\n      {String placeId,\n      String formattedAddress,\n      String name,\n      UserLocation location,\n      String? country,\n      String? administrativeArea,\n      String? locality,\n      String? postalCode,\n      DateTime? lastUpdated});\n\n  $UserLocationCopyWith<$Res> get location;\n}\n\n/// @nodoc\nclass _$PlaceDetailsCopyWithImpl<$Res, $Val extends PlaceDetails>\n    implements $PlaceDetailsCopyWith<$Res> {\n  _$PlaceDetailsCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? formattedAddress = null,\n    Object? name = null,\n    Object? location = null,\n    Object? country = freezed,\n    Object? administrativeArea = freezed,\n    Object? locality = freezed,\n    Object? postalCode = freezed,\n    Object? lastUpdated = freezed,\n  }) {\n    return _then(_value.copyWith(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      formattedAddress: null == formattedAddress\n          ? _value.formattedAddress\n          : formattedAddress // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      location: null == location\n          ? _value.location\n          : location // ignore: cast_nullable_to_non_nullable\n              as UserLocation,\n      country: freezed == country\n          ? _value.country\n          : country // ignore: cast_nullable_to_non_nullable\n              as String?,\n      administrativeArea: freezed == administrativeArea\n          ? _value.administrativeArea\n          : administrativeArea // ignore: cast_nullable_to_non_nullable\n              as String?,\n      locality: freezed == locality\n          ? _value.locality\n          : locality // ignore: cast_nullable_to_non_nullable\n              as String?,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      lastUpdated: freezed == lastUpdated\n          ? _value.lastUpdated\n          : lastUpdated // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ) as $Val);\n  }\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $UserLocationCopyWith<$Res> get location {\n    return $UserLocationCopyWith<$Res>(_value.location, (value) {\n      return _then(_value.copyWith(location: value) as $Val);\n    });\n  }\n}\n\n/// @nodoc\nabstract class _$$PlaceDetailsImplCopyWith<$Res>\n    implements $PlaceDetailsCopyWith<$Res> {\n  factory _$$PlaceDetailsImplCopyWith(\n          _$PlaceDetailsImpl value, $Res Function(_$PlaceDetailsImpl) then) =\n      __$$PlaceDetailsImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String placeId,\n      String formattedAddress,\n      String name,\n      UserLocation location,\n      String? country,\n      String? administrativeArea,\n      String? locality,\n      String? postalCode,\n      DateTime? lastUpdated});\n\n  @override\n  $UserLocationCopyWith<$Res> get location;\n}\n\n/// @nodoc\nclass __$$PlaceDetailsImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsCopyWithImpl<$Res, _$PlaceDetailsImpl>\n    implements _$$PlaceDetailsImplCopyWith<$Res> {\n  __$$PlaceDetailsImplCopyWithImpl(\n      _$PlaceDetailsImpl _value, $Res Function(_$PlaceDetailsImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? formattedAddress = null,\n    Object? name = null,\n    Object? location = null,\n    Object? country = freezed,\n    Object? administrativeArea = freezed,\n    Object? locality = freezed,\n    Object? postalCode = freezed,\n    Object? lastUpdated = freezed,\n  }) {\n    return _then(_$PlaceDetailsImpl(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      formattedAddress: null == formattedAddress\n          ? _value.formattedAddress\n          : formattedAddress // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      location: null == location\n          ? _value.location\n          : location // ignore: cast_nullable_to_non_nullable\n              as UserLocation,\n      country: freezed == country\n          ? _value.country\n          : country // ignore: cast_nullable_to_non_nullable\n              as String?,\n      administrativeArea: freezed == administrativeArea\n          ? _value.administrativeArea\n          : administrativeArea // ignore: cast_nullable_to_non_nullable\n              as String?,\n      locality: freezed == locality\n          ? _value.locality\n          : locality // ignore: cast_nullable_to_non_nullable\n              as String?,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      lastUpdated: freezed == lastUpdated\n          ? _value.lastUpdated\n          : lastUpdated // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$PlaceDetailsImpl implements _PlaceDetails {\n  const _$PlaceDetailsImpl(\n      {required this.placeId,\n      required this.formattedAddress,\n      required this.name,\n      required this.location,\n      this.country,\n      this.administrativeArea,\n      this.locality,\n      this.postalCode,\n      this.lastUpdated});\n\n  factory _$PlaceDetailsImpl.fromJson(Map<String, dynamic> json) =>\n      _$$PlaceDetailsImplFromJson(json);\n\n  @override\n  final String placeId;\n  @override\n  final String formattedAddress;\n  @override\n  final String name;\n  @override\n  final UserLocation location;\n  @override\n  final String? country;\n  @override\n  final String? administrativeArea;\n  @override\n  final String? locality;\n  @override\n  final String? postalCode;\n  @override\n  final DateTime? lastUpdated;\n\n  @override\n  String toString() {\n    return 'PlaceDetails(placeId: $placeId, formattedAddress: $formattedAddress, name: $name, location: $location, country: $country, administrativeArea: $administrativeArea, locality: $locality, postalCode: $postalCode, lastUpdated: $lastUpdated)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$PlaceDetailsImpl &&\n            (identical(other.placeId, placeId) || other.placeId == placeId) &&\n            (identical(other.formattedAddress, formattedAddress) ||\n                other.formattedAddress == formattedAddress) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.location, location) ||\n                other.location == location) &&\n            (identical(other.country, country) || other.country == country) &&\n            (identical(other.administrativeArea, administrativeArea) ||\n                other.administrativeArea == administrativeArea) &&\n            (identical(other.locality, locality) ||\n                other.locality == locality) &&\n            (identical(other.postalCode, postalCode) ||\n                other.postalCode == postalCode) &&\n            (identical(other.lastUpdated, lastUpdated) ||\n                other.lastUpdated == lastUpdated));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, placeId, formattedAddress, name,\n      location, country, administrativeArea, locality, postalCode, lastUpdated);\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$PlaceDetailsImplCopyWith<_$PlaceDetailsImpl> get copyWith =>\n      __$$PlaceDetailsImplCopyWithImpl<_$PlaceDetailsImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$PlaceDetailsImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _PlaceDetails implements PlaceDetails {\n  const factory _PlaceDetails(\n      {required final String placeId,\n      required final String formattedAddress,\n      required final String name,\n      required final UserLocation location,\n      final String? country,\n      final String? administrativeArea,\n      final String? locality,\n      final String? postalCode,\n      final DateTime? lastUpdated}) = _$PlaceDetailsImpl;\n\n  factory _PlaceDetails.fromJson(Map<String, dynamic> json) =\n      _$PlaceDetailsImpl.fromJson;\n\n  @override\n  String get placeId;\n  @override\n  String get formattedAddress;\n  @override\n  String get name;\n  @override\n  UserLocation get location;\n  @override\n  String? get country;\n  @override\n  String? get administrativeArea;\n  @override\n  String? get locality;\n  @override\n  String? get postalCode;\n  @override\n  DateTime? get lastUpdated;\n\n  /// Create a copy of PlaceDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$PlaceDetailsImplCopyWith<_$PlaceDetailsImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 12172,
        "last_modified": "2025-04-16T13:25:26.5462389",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_details.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'place_details.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$PlaceDetailsImpl _$$PlaceDetailsImplFromJson(Map<String, dynamic> json) =>\n    _$PlaceDetailsImpl(\n      placeId: json['placeId'] as String,\n      formattedAddress: json['formattedAddress'] as String,\n      name: json['name'] as String,\n      location: UserLocation.fromJson(json['location'] as Map<String, dynamic>),\n      country: json['country'] as String?,\n      administrativeArea: json['administrativeArea'] as String?,\n      locality: json['locality'] as String?,\n      postalCode: json['postalCode'] as String?,\n      lastUpdated: json['lastUpdated'] == null\n          ? null\n          : DateTime.parse(json['lastUpdated'] as String),\n    );\n\nMap<String, dynamic> _$$PlaceDetailsImplToJson(_$PlaceDetailsImpl instance) =>\n    <String, dynamic>{\n      'placeId': instance.placeId,\n      'formattedAddress': instance.formattedAddress,\n      'name': instance.name,\n      'location': instance.location,\n      'country': instance.country,\n      'administrativeArea': instance.administrativeArea,\n      'locality': instance.locality,\n      'postalCode': instance.postalCode,\n      'lastUpdated': instance.lastUpdated?.toIso8601String(),\n    };\n",
      "info": {
        "size": 1408,
        "last_modified": "2025-04-16T13:25:26.5522903",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_suggestion.dart",
      "content": "// lib/core/domain/models/location/place_suggestion.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'place_suggestion.freezed.dart';\r\npart 'place_suggestion.g.dart';\r\n\r\n@freezed\r\nclass PlaceSuggestion with _$PlaceSuggestion {\r\n  const factory PlaceSuggestion({\r\n    required String placeId,\r\n    required String primaryText,\r\n    String? secondaryText,\r\n    @Default(false) bool isFromCache,\r\n  }) = _PlaceSuggestion;\r\n\r\n  factory PlaceSuggestion.fromJson(Map<String, dynamic> json) =>\r\n      _$PlaceSuggestionFromJson(json);\r\n}",
      "info": {
        "size": 557,
        "last_modified": "2025-04-16T13:25:26.5603338",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_suggestion.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_suggestion.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nPlaceSuggestion _$PlaceSuggestionFromJson(Map<String, dynamic> json) {\n  return _PlaceSuggestion.fromJson(json);\n}\n\n/// @nodoc\nmixin _$PlaceSuggestion {\n  String get placeId => throw _privateConstructorUsedError;\n  String get primaryText => throw _privateConstructorUsedError;\n  String? get secondaryText => throw _privateConstructorUsedError;\n  bool get isFromCache => throw _privateConstructorUsedError;\n\n  /// Serializes this PlaceSuggestion to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $PlaceSuggestionCopyWith<PlaceSuggestion> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceSuggestionCopyWith<$Res> {\n  factory $PlaceSuggestionCopyWith(\n          PlaceSuggestion value, $Res Function(PlaceSuggestion) then) =\n      _$PlaceSuggestionCopyWithImpl<$Res, PlaceSuggestion>;\n  @useResult\n  $Res call(\n      {String placeId,\n      String primaryText,\n      String? secondaryText,\n      bool isFromCache});\n}\n\n/// @nodoc\nclass _$PlaceSuggestionCopyWithImpl<$Res, $Val extends PlaceSuggestion>\n    implements $PlaceSuggestionCopyWith<$Res> {\n  _$PlaceSuggestionCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? primaryText = null,\n    Object? secondaryText = freezed,\n    Object? isFromCache = null,\n  }) {\n    return _then(_value.copyWith(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      primaryText: null == primaryText\n          ? _value.primaryText\n          : primaryText // ignore: cast_nullable_to_non_nullable\n              as String,\n      secondaryText: freezed == secondaryText\n          ? _value.secondaryText\n          : secondaryText // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isFromCache: null == isFromCache\n          ? _value.isFromCache\n          : isFromCache // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$PlaceSuggestionImplCopyWith<$Res>\n    implements $PlaceSuggestionCopyWith<$Res> {\n  factory _$$PlaceSuggestionImplCopyWith(_$PlaceSuggestionImpl value,\n          $Res Function(_$PlaceSuggestionImpl) then) =\n      __$$PlaceSuggestionImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String placeId,\n      String primaryText,\n      String? secondaryText,\n      bool isFromCache});\n}\n\n/// @nodoc\nclass __$$PlaceSuggestionImplCopyWithImpl<$Res>\n    extends _$PlaceSuggestionCopyWithImpl<$Res, _$PlaceSuggestionImpl>\n    implements _$$PlaceSuggestionImplCopyWith<$Res> {\n  __$$PlaceSuggestionImplCopyWithImpl(\n      _$PlaceSuggestionImpl _value, $Res Function(_$PlaceSuggestionImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? placeId = null,\n    Object? primaryText = null,\n    Object? secondaryText = freezed,\n    Object? isFromCache = null,\n  }) {\n    return _then(_$PlaceSuggestionImpl(\n      placeId: null == placeId\n          ? _value.placeId\n          : placeId // ignore: cast_nullable_to_non_nullable\n              as String,\n      primaryText: null == primaryText\n          ? _value.primaryText\n          : primaryText // ignore: cast_nullable_to_non_nullable\n              as String,\n      secondaryText: freezed == secondaryText\n          ? _value.secondaryText\n          : secondaryText // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isFromCache: null == isFromCache\n          ? _value.isFromCache\n          : isFromCache // ignore: cast_nullable_to_non_nullable\n              as bool,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$PlaceSuggestionImpl implements _PlaceSuggestion {\n  const _$PlaceSuggestionImpl(\n      {required this.placeId,\n      required this.primaryText,\n      this.secondaryText,\n      this.isFromCache = false});\n\n  factory _$PlaceSuggestionImpl.fromJson(Map<String, dynamic> json) =>\n      _$$PlaceSuggestionImplFromJson(json);\n\n  @override\n  final String placeId;\n  @override\n  final String primaryText;\n  @override\n  final String? secondaryText;\n  @override\n  @JsonKey()\n  final bool isFromCache;\n\n  @override\n  String toString() {\n    return 'PlaceSuggestion(placeId: $placeId, primaryText: $primaryText, secondaryText: $secondaryText, isFromCache: $isFromCache)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$PlaceSuggestionImpl &&\n            (identical(other.placeId, placeId) || other.placeId == placeId) &&\n            (identical(other.primaryText, primaryText) ||\n                other.primaryText == primaryText) &&\n            (identical(other.secondaryText, secondaryText) ||\n                other.secondaryText == secondaryText) &&\n            (identical(other.isFromCache, isFromCache) ||\n                other.isFromCache == isFromCache));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, placeId, primaryText, secondaryText, isFromCache);\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$PlaceSuggestionImplCopyWith<_$PlaceSuggestionImpl> get copyWith =>\n      __$$PlaceSuggestionImplCopyWithImpl<_$PlaceSuggestionImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$PlaceSuggestionImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _PlaceSuggestion implements PlaceSuggestion {\n  const factory _PlaceSuggestion(\n      {required final String placeId,\n      required final String primaryText,\n      final String? secondaryText,\n      final bool isFromCache}) = _$PlaceSuggestionImpl;\n\n  factory _PlaceSuggestion.fromJson(Map<String, dynamic> json) =\n      _$PlaceSuggestionImpl.fromJson;\n\n  @override\n  String get placeId;\n  @override\n  String get primaryText;\n  @override\n  String? get secondaryText;\n  @override\n  bool get isFromCache;\n\n  /// Create a copy of PlaceSuggestion\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$PlaceSuggestionImplCopyWith<_$PlaceSuggestionImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 8041,
        "last_modified": "2025-04-16T13:25:26.5659497",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\place_suggestion.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'place_suggestion.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$PlaceSuggestionImpl _$$PlaceSuggestionImplFromJson(\n        Map<String, dynamic> json) =>\n    _$PlaceSuggestionImpl(\n      placeId: json['placeId'] as String,\n      primaryText: json['primaryText'] as String,\n      secondaryText: json['secondaryText'] as String?,\n      isFromCache: json['isFromCache'] as bool? ?? false,\n    );\n\nMap<String, dynamic> _$$PlaceSuggestionImplToJson(\n        _$PlaceSuggestionImpl instance) =>\n    <String, dynamic>{\n      'placeId': instance.placeId,\n      'primaryText': instance.primaryText,\n      'secondaryText': instance.secondaryText,\n      'isFromCache': instance.isFromCache,\n    };\n",
      "info": {
        "size": 887,
        "last_modified": "2025-04-16T13:25:26.5732041",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\user_location.dart",
      "content": "// lib/core/domain/models/location/user_location.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'user_location.freezed.dart';\r\npart 'user_location.g.dart';\r\n\r\n@freezed\r\nclass UserLocation with _$UserLocation {\r\n  const factory UserLocation({\r\n    required double latitude,\r\n    required double longitude,\r\n    double? accuracy,\r\n    @Default(false) bool isFromGps,\r\n    DateTime? timestamp,\r\n  }) = _UserLocation;\r\n\r\n  factory UserLocation.fromJson(Map<String, dynamic> json) =>\r\n      _$UserLocationFromJson(json);\r\n}",
      "info": {
        "size": 548,
        "last_modified": "2025-04-16T13:25:26.5792556",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\user_location.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'user_location.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nUserLocation _$UserLocationFromJson(Map<String, dynamic> json) {\n  return _UserLocation.fromJson(json);\n}\n\n/// @nodoc\nmixin _$UserLocation {\n  double get latitude => throw _privateConstructorUsedError;\n  double get longitude => throw _privateConstructorUsedError;\n  double? get accuracy => throw _privateConstructorUsedError;\n  bool get isFromGps => throw _privateConstructorUsedError;\n  DateTime? get timestamp => throw _privateConstructorUsedError;\n\n  /// Serializes this UserLocation to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $UserLocationCopyWith<UserLocation> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $UserLocationCopyWith<$Res> {\n  factory $UserLocationCopyWith(\n          UserLocation value, $Res Function(UserLocation) then) =\n      _$UserLocationCopyWithImpl<$Res, UserLocation>;\n  @useResult\n  $Res call(\n      {double latitude,\n      double longitude,\n      double? accuracy,\n      bool isFromGps,\n      DateTime? timestamp});\n}\n\n/// @nodoc\nclass _$UserLocationCopyWithImpl<$Res, $Val extends UserLocation>\n    implements $UserLocationCopyWith<$Res> {\n  _$UserLocationCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? accuracy = freezed,\n    Object? isFromGps = null,\n    Object? timestamp = freezed,\n  }) {\n    return _then(_value.copyWith(\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      accuracy: freezed == accuracy\n          ? _value.accuracy\n          : accuracy // ignore: cast_nullable_to_non_nullable\n              as double?,\n      isFromGps: null == isFromGps\n          ? _value.isFromGps\n          : isFromGps // ignore: cast_nullable_to_non_nullable\n              as bool,\n      timestamp: freezed == timestamp\n          ? _value.timestamp\n          : timestamp // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$UserLocationImplCopyWith<$Res>\n    implements $UserLocationCopyWith<$Res> {\n  factory _$$UserLocationImplCopyWith(\n          _$UserLocationImpl value, $Res Function(_$UserLocationImpl) then) =\n      __$$UserLocationImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {double latitude,\n      double longitude,\n      double? accuracy,\n      bool isFromGps,\n      DateTime? timestamp});\n}\n\n/// @nodoc\nclass __$$UserLocationImplCopyWithImpl<$Res>\n    extends _$UserLocationCopyWithImpl<$Res, _$UserLocationImpl>\n    implements _$$UserLocationImplCopyWith<$Res> {\n  __$$UserLocationImplCopyWithImpl(\n      _$UserLocationImpl _value, $Res Function(_$UserLocationImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? accuracy = freezed,\n    Object? isFromGps = null,\n    Object? timestamp = freezed,\n  }) {\n    return _then(_$UserLocationImpl(\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      accuracy: freezed == accuracy\n          ? _value.accuracy\n          : accuracy // ignore: cast_nullable_to_non_nullable\n              as double?,\n      isFromGps: null == isFromGps\n          ? _value.isFromGps\n          : isFromGps // ignore: cast_nullable_to_non_nullable\n              as bool,\n      timestamp: freezed == timestamp\n          ? _value.timestamp\n          : timestamp // ignore: cast_nullable_to_non_nullable\n              as DateTime?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$UserLocationImpl implements _UserLocation {\n  const _$UserLocationImpl(\n      {required this.latitude,\n      required this.longitude,\n      this.accuracy,\n      this.isFromGps = false,\n      this.timestamp});\n\n  factory _$UserLocationImpl.fromJson(Map<String, dynamic> json) =>\n      _$$UserLocationImplFromJson(json);\n\n  @override\n  final double latitude;\n  @override\n  final double longitude;\n  @override\n  final double? accuracy;\n  @override\n  @JsonKey()\n  final bool isFromGps;\n  @override\n  final DateTime? timestamp;\n\n  @override\n  String toString() {\n    return 'UserLocation(latitude: $latitude, longitude: $longitude, accuracy: $accuracy, isFromGps: $isFromGps, timestamp: $timestamp)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$UserLocationImpl &&\n            (identical(other.latitude, latitude) ||\n                other.latitude == latitude) &&\n            (identical(other.longitude, longitude) ||\n                other.longitude == longitude) &&\n            (identical(other.accuracy, accuracy) ||\n                other.accuracy == accuracy) &&\n            (identical(other.isFromGps, isFromGps) ||\n                other.isFromGps == isFromGps) &&\n            (identical(other.timestamp, timestamp) ||\n                other.timestamp == timestamp));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, latitude, longitude, accuracy, isFromGps, timestamp);\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$UserLocationImplCopyWith<_$UserLocationImpl> get copyWith =>\n      __$$UserLocationImplCopyWithImpl<_$UserLocationImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$UserLocationImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _UserLocation implements UserLocation {\n  const factory _UserLocation(\n      {required final double latitude,\n      required final double longitude,\n      final double? accuracy,\n      final bool isFromGps,\n      final DateTime? timestamp}) = _$UserLocationImpl;\n\n  factory _UserLocation.fromJson(Map<String, dynamic> json) =\n      _$UserLocationImpl.fromJson;\n\n  @override\n  double get latitude;\n  @override\n  double get longitude;\n  @override\n  double? get accuracy;\n  @override\n  bool get isFromGps;\n  @override\n  DateTime? get timestamp;\n\n  /// Create a copy of UserLocation\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$UserLocationImplCopyWith<_$UserLocationImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 8457,
        "last_modified": "2025-04-16T13:25:26.5863596",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\location\\user_location.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'user_location.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$UserLocationImpl _$$UserLocationImplFromJson(Map<String, dynamic> json) =>\n    _$UserLocationImpl(\n      latitude: (json['latitude'] as num).toDouble(),\n      longitude: (json['longitude'] as num).toDouble(),\n      accuracy: (json['accuracy'] as num?)?.toDouble(),\n      isFromGps: json['isFromGps'] as bool? ?? false,\n      timestamp: json['timestamp'] == null\n          ? null\n          : DateTime.parse(json['timestamp'] as String),\n    );\n\nMap<String, dynamic> _$$UserLocationImplToJson(_$UserLocationImpl instance) =>\n    <String, dynamic>{\n      'latitude': instance.latitude,\n      'longitude': instance.longitude,\n      'accuracy': instance.accuracy,\n      'isFromGps': instance.isFromGps,\n      'timestamp': instance.timestamp?.toIso8601String(),\n    };\n",
      "info": {
        "size": 1025,
        "last_modified": "2025-04-16T13:25:26.5928727",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\opening_days.dart",
      "content": "// core/domain/models/opening_days.dart\r\n\r\nclass OpeningDays {\r\n  final Map<String, Map<String, String>> availableDays;\r\n  final Map<String, String>? allDaysHours;  // Nouveau champ pour \"all\"\r\n\r\n  OpeningDays({\r\n    required this.availableDays,\r\n    this.allDaysHours,\r\n  });\r\n\r\n  factory OpeningDays.fromActivityHours(Map<String, dynamic> json) {\r\n    // Si nous avons des horaires pour tous les jours\r\n    if (json['day_of_week']['all'] != null) {\r\n      return OpeningDays(\r\n        availableDays: {},\r\n        allDaysHours: Map<String, String>.from(json['day_of_week']['all']),\r\n      );\r\n    }\r\n\r\n    // Sinon, on traite les jours spcifiques\r\n    return OpeningDays(\r\n      availableDays: {}, //  remplir avec les jours spcifiques si ncessaire\r\n      allDaysHours: null,\r\n    );\r\n  }\r\n\r\n  bool get hasOpenDays => allDaysHours != null || availableDays.isNotEmpty;\r\n\r\n  Map<String, String>? getHoursForDay(String date) {\r\n    return allDaysHours ?? availableDays[date];\r\n  }\r\n}",
      "info": {
        "size": 989,
        "last_modified": "2025-04-16T13:25:26.6052047",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\scored_activity.dart",
      "content": "// lib/core/domain/models/scored_activity.dart\r\n\r\nclass ScoredActivity {\r\n  final String id;\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperwow;\r\n  final Map<String, dynamic> activityData;  // Donnes brutes de l'activit\r\n\r\n  const ScoredActivity({\r\n    required this.id,\r\n    required this.totalScore,\r\n    required this.subcategoryScore,\r\n    required this.isSuperwow,\r\n    required this.activityData,\r\n  });\r\n\r\n  /// Cre une instance depuis les donnes JSON de Supabase\r\n  factory ScoredActivity.fromJson(Map<String, dynamic> json) {\r\n    return ScoredActivity(\r\n      id: json['id'],\r\n      totalScore: json['total_score']?.toDouble() ?? 0.0,\r\n      subcategoryScore: json['subcategory_score']?.toDouble() ?? 0.0,\r\n      isSuperwow: json['is_superwow'] ?? false,\r\n      activityData: json,\r\n    );\r\n  }\r\n\r\n  /// Convertit l'instance en Map pour Supabase\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_superwow': isSuperwow,\r\n      ...activityData,  // Inclut toutes les donnes de l'activit\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 1165,
        "last_modified": "2025-04-16T13:25:26.611339",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_details_model.dart",
      "content": "// core/domain/models/shared/activity_details_model.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../activity/base/activity_base.dart';\r\nimport 'activity_image_model.dart';\r\n\r\npart 'activity_details_model.freezed.dart';\r\npart 'activity_details_model.g.dart';\r\n\r\n@freezed\r\nclass ActivityDetails with _$ActivityDetails {\r\n  const factory ActivityDetails({\r\n    required String id,\r\n    required String name,\r\n    String? description,\r\n    required double latitude,\r\n    required double longitude,\r\n    required String categoryId,\r\n    String? postalCode,\r\n    String? address,\r\n    String? city,\r\n    String? googlePlaceId,\r\n    Map<String, dynamic>? currentOpeningHours,\r\n    String? contactPhone,\r\n    String? contactEmail,\r\n    String? contactWebsite,\r\n    bool? bookingRequired,\r\n    bool? kidFriendly,\r\n    String? wheelchairAccessible,\r\n    int? minDurationMinutes,\r\n    int? maxDurationMinutes,\r\n    int? priceLevel,\r\n    double? basePrice,\r\n    List<ActivityImage>? images,\r\n  }) = _ActivityDetails;\r\n\r\n  factory ActivityDetails.fromJson(Map<String, dynamic> json) =>\r\n      _$ActivityDetailsFromJson(json);\r\n\r\n  factory ActivityDetails.fromActivityBase(ActivityBase base) {\r\n    return ActivityDetails(\r\n      id: base.id,\r\n      name: base.name,\r\n      description: base.description,\r\n      latitude: base.latitude,\r\n      longitude: base.longitude,\r\n      categoryId: base.categoryId,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1441,
        "last_modified": "2025-04-16T13:25:26.6183424",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_details_model.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_details_model.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nActivityDetails _$ActivityDetailsFromJson(Map<String, dynamic> json) {\n  return _ActivityDetails.fromJson(json);\n}\n\n/// @nodoc\nmixin _$ActivityDetails {\n  String get id => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  String? get description => throw _privateConstructorUsedError;\n  double get latitude => throw _privateConstructorUsedError;\n  double get longitude => throw _privateConstructorUsedError;\n  String get categoryId => throw _privateConstructorUsedError;\n  String? get postalCode => throw _privateConstructorUsedError;\n  String? get address => throw _privateConstructorUsedError;\n  String? get city => throw _privateConstructorUsedError;\n  String? get googlePlaceId => throw _privateConstructorUsedError;\n  Map<String, dynamic>? get currentOpeningHours =>\n      throw _privateConstructorUsedError;\n  String? get contactPhone => throw _privateConstructorUsedError;\n  String? get contactEmail => throw _privateConstructorUsedError;\n  String? get contactWebsite => throw _privateConstructorUsedError;\n  bool? get bookingRequired => throw _privateConstructorUsedError;\n  bool? get kidFriendly => throw _privateConstructorUsedError;\n  String? get wheelchairAccessible => throw _privateConstructorUsedError;\n  int? get minDurationMinutes => throw _privateConstructorUsedError;\n  int? get maxDurationMinutes => throw _privateConstructorUsedError;\n  int? get priceLevel => throw _privateConstructorUsedError;\n  double? get basePrice => throw _privateConstructorUsedError;\n  List<ActivityImage>? get images => throw _privateConstructorUsedError;\n\n  /// Serializes this ActivityDetails to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $ActivityDetailsCopyWith<ActivityDetails> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityDetailsCopyWith<$Res> {\n  factory $ActivityDetailsCopyWith(\n          ActivityDetails value, $Res Function(ActivityDetails) then) =\n      _$ActivityDetailsCopyWithImpl<$Res, ActivityDetails>;\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? postalCode,\n      String? address,\n      String? city,\n      String? googlePlaceId,\n      Map<String, dynamic>? currentOpeningHours,\n      String? contactPhone,\n      String? contactEmail,\n      String? contactWebsite,\n      bool? bookingRequired,\n      bool? kidFriendly,\n      String? wheelchairAccessible,\n      int? minDurationMinutes,\n      int? maxDurationMinutes,\n      int? priceLevel,\n      double? basePrice,\n      List<ActivityImage>? images});\n}\n\n/// @nodoc\nclass _$ActivityDetailsCopyWithImpl<$Res, $Val extends ActivityDetails>\n    implements $ActivityDetailsCopyWith<$Res> {\n  _$ActivityDetailsCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? postalCode = freezed,\n    Object? address = freezed,\n    Object? city = freezed,\n    Object? googlePlaceId = freezed,\n    Object? currentOpeningHours = freezed,\n    Object? contactPhone = freezed,\n    Object? contactEmail = freezed,\n    Object? contactWebsite = freezed,\n    Object? bookingRequired = freezed,\n    Object? kidFriendly = freezed,\n    Object? wheelchairAccessible = freezed,\n    Object? minDurationMinutes = freezed,\n    Object? maxDurationMinutes = freezed,\n    Object? priceLevel = freezed,\n    Object? basePrice = freezed,\n    Object? images = freezed,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      address: freezed == address\n          ? _value.address\n          : address // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      googlePlaceId: freezed == googlePlaceId\n          ? _value.googlePlaceId\n          : googlePlaceId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      currentOpeningHours: freezed == currentOpeningHours\n          ? _value.currentOpeningHours\n          : currentOpeningHours // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>?,\n      contactPhone: freezed == contactPhone\n          ? _value.contactPhone\n          : contactPhone // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactEmail: freezed == contactEmail\n          ? _value.contactEmail\n          : contactEmail // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactWebsite: freezed == contactWebsite\n          ? _value.contactWebsite\n          : contactWebsite // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: freezed == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      kidFriendly: freezed == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      minDurationMinutes: freezed == minDurationMinutes\n          ? _value.minDurationMinutes\n          : minDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      maxDurationMinutes: freezed == maxDurationMinutes\n          ? _value.maxDurationMinutes\n          : maxDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      priceLevel: freezed == priceLevel\n          ? _value.priceLevel\n          : priceLevel // ignore: cast_nullable_to_non_nullable\n              as int?,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      images: freezed == images\n          ? _value.images\n          : images // ignore: cast_nullable_to_non_nullable\n              as List<ActivityImage>?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$ActivityDetailsImplCopyWith<$Res>\n    implements $ActivityDetailsCopyWith<$Res> {\n  factory _$$ActivityDetailsImplCopyWith(_$ActivityDetailsImpl value,\n          $Res Function(_$ActivityDetailsImpl) then) =\n      __$$ActivityDetailsImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String? description,\n      double latitude,\n      double longitude,\n      String categoryId,\n      String? postalCode,\n      String? address,\n      String? city,\n      String? googlePlaceId,\n      Map<String, dynamic>? currentOpeningHours,\n      String? contactPhone,\n      String? contactEmail,\n      String? contactWebsite,\n      bool? bookingRequired,\n      bool? kidFriendly,\n      String? wheelchairAccessible,\n      int? minDurationMinutes,\n      int? maxDurationMinutes,\n      int? priceLevel,\n      double? basePrice,\n      List<ActivityImage>? images});\n}\n\n/// @nodoc\nclass __$$ActivityDetailsImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsCopyWithImpl<$Res, _$ActivityDetailsImpl>\n    implements _$$ActivityDetailsImplCopyWith<$Res> {\n  __$$ActivityDetailsImplCopyWithImpl(\n      _$ActivityDetailsImpl _value, $Res Function(_$ActivityDetailsImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? description = freezed,\n    Object? latitude = null,\n    Object? longitude = null,\n    Object? categoryId = null,\n    Object? postalCode = freezed,\n    Object? address = freezed,\n    Object? city = freezed,\n    Object? googlePlaceId = freezed,\n    Object? currentOpeningHours = freezed,\n    Object? contactPhone = freezed,\n    Object? contactEmail = freezed,\n    Object? contactWebsite = freezed,\n    Object? bookingRequired = freezed,\n    Object? kidFriendly = freezed,\n    Object? wheelchairAccessible = freezed,\n    Object? minDurationMinutes = freezed,\n    Object? maxDurationMinutes = freezed,\n    Object? priceLevel = freezed,\n    Object? basePrice = freezed,\n    Object? images = freezed,\n  }) {\n    return _then(_$ActivityDetailsImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      latitude: null == latitude\n          ? _value.latitude\n          : latitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      longitude: null == longitude\n          ? _value.longitude\n          : longitude // ignore: cast_nullable_to_non_nullable\n              as double,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      postalCode: freezed == postalCode\n          ? _value.postalCode\n          : postalCode // ignore: cast_nullable_to_non_nullable\n              as String?,\n      address: freezed == address\n          ? _value.address\n          : address // ignore: cast_nullable_to_non_nullable\n              as String?,\n      city: freezed == city\n          ? _value.city\n          : city // ignore: cast_nullable_to_non_nullable\n              as String?,\n      googlePlaceId: freezed == googlePlaceId\n          ? _value.googlePlaceId\n          : googlePlaceId // ignore: cast_nullable_to_non_nullable\n              as String?,\n      currentOpeningHours: freezed == currentOpeningHours\n          ? _value._currentOpeningHours\n          : currentOpeningHours // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>?,\n      contactPhone: freezed == contactPhone\n          ? _value.contactPhone\n          : contactPhone // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactEmail: freezed == contactEmail\n          ? _value.contactEmail\n          : contactEmail // ignore: cast_nullable_to_non_nullable\n              as String?,\n      contactWebsite: freezed == contactWebsite\n          ? _value.contactWebsite\n          : contactWebsite // ignore: cast_nullable_to_non_nullable\n              as String?,\n      bookingRequired: freezed == bookingRequired\n          ? _value.bookingRequired\n          : bookingRequired // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      kidFriendly: freezed == kidFriendly\n          ? _value.kidFriendly\n          : kidFriendly // ignore: cast_nullable_to_non_nullable\n              as bool?,\n      wheelchairAccessible: freezed == wheelchairAccessible\n          ? _value.wheelchairAccessible\n          : wheelchairAccessible // ignore: cast_nullable_to_non_nullable\n              as String?,\n      minDurationMinutes: freezed == minDurationMinutes\n          ? _value.minDurationMinutes\n          : minDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      maxDurationMinutes: freezed == maxDurationMinutes\n          ? _value.maxDurationMinutes\n          : maxDurationMinutes // ignore: cast_nullable_to_non_nullable\n              as int?,\n      priceLevel: freezed == priceLevel\n          ? _value.priceLevel\n          : priceLevel // ignore: cast_nullable_to_non_nullable\n              as int?,\n      basePrice: freezed == basePrice\n          ? _value.basePrice\n          : basePrice // ignore: cast_nullable_to_non_nullable\n              as double?,\n      images: freezed == images\n          ? _value._images\n          : images // ignore: cast_nullable_to_non_nullable\n              as List<ActivityImage>?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$ActivityDetailsImpl implements _ActivityDetails {\n  const _$ActivityDetailsImpl(\n      {required this.id,\n      required this.name,\n      this.description,\n      required this.latitude,\n      required this.longitude,\n      required this.categoryId,\n      this.postalCode,\n      this.address,\n      this.city,\n      this.googlePlaceId,\n      final Map<String, dynamic>? currentOpeningHours,\n      this.contactPhone,\n      this.contactEmail,\n      this.contactWebsite,\n      this.bookingRequired,\n      this.kidFriendly,\n      this.wheelchairAccessible,\n      this.minDurationMinutes,\n      this.maxDurationMinutes,\n      this.priceLevel,\n      this.basePrice,\n      final List<ActivityImage>? images})\n      : _currentOpeningHours = currentOpeningHours,\n        _images = images;\n\n  factory _$ActivityDetailsImpl.fromJson(Map<String, dynamic> json) =>\n      _$$ActivityDetailsImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String name;\n  @override\n  final String? description;\n  @override\n  final double latitude;\n  @override\n  final double longitude;\n  @override\n  final String categoryId;\n  @override\n  final String? postalCode;\n  @override\n  final String? address;\n  @override\n  final String? city;\n  @override\n  final String? googlePlaceId;\n  final Map<String, dynamic>? _currentOpeningHours;\n  @override\n  Map<String, dynamic>? get currentOpeningHours {\n    final value = _currentOpeningHours;\n    if (value == null) return null;\n    if (_currentOpeningHours is EqualUnmodifiableMapView)\n      return _currentOpeningHours;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(value);\n  }\n\n  @override\n  final String? contactPhone;\n  @override\n  final String? contactEmail;\n  @override\n  final String? contactWebsite;\n  @override\n  final bool? bookingRequired;\n  @override\n  final bool? kidFriendly;\n  @override\n  final String? wheelchairAccessible;\n  @override\n  final int? minDurationMinutes;\n  @override\n  final int? maxDurationMinutes;\n  @override\n  final int? priceLevel;\n  @override\n  final double? basePrice;\n  final List<ActivityImage>? _images;\n  @override\n  List<ActivityImage>? get images {\n    final value = _images;\n    if (value == null) return null;\n    if (_images is EqualUnmodifiableListView) return _images;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(value);\n  }\n\n  @override\n  String toString() {\n    return 'ActivityDetails(id: $id, name: $name, description: $description, latitude: $latitude, longitude: $longitude, categoryId: $categoryId, postalCode: $postalCode, address: $address, city: $city, googlePlaceId: $googlePlaceId, currentOpeningHours: $currentOpeningHours, contactPhone: $contactPhone, contactEmail: $contactEmail, contactWebsite: $contactWebsite, bookingRequired: $bookingRequired, kidFriendly: $kidFriendly, wheelchairAccessible: $wheelchairAccessible, minDurationMinutes: $minDurationMinutes, maxDurationMinutes: $maxDurationMinutes, priceLevel: $priceLevel, basePrice: $basePrice, images: $images)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ActivityDetailsImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.description, description) ||\n                other.description == description) &&\n            (identical(other.latitude, latitude) ||\n                other.latitude == latitude) &&\n            (identical(other.longitude, longitude) ||\n                other.longitude == longitude) &&\n            (identical(other.categoryId, categoryId) ||\n                other.categoryId == categoryId) &&\n            (identical(other.postalCode, postalCode) ||\n                other.postalCode == postalCode) &&\n            (identical(other.address, address) || other.address == address) &&\n            (identical(other.city, city) || other.city == city) &&\n            (identical(other.googlePlaceId, googlePlaceId) ||\n                other.googlePlaceId == googlePlaceId) &&\n            const DeepCollectionEquality()\n                .equals(other._currentOpeningHours, _currentOpeningHours) &&\n            (identical(other.contactPhone, contactPhone) ||\n                other.contactPhone == contactPhone) &&\n            (identical(other.contactEmail, contactEmail) ||\n                other.contactEmail == contactEmail) &&\n            (identical(other.contactWebsite, contactWebsite) ||\n                other.contactWebsite == contactWebsite) &&\n            (identical(other.bookingRequired, bookingRequired) ||\n                other.bookingRequired == bookingRequired) &&\n            (identical(other.kidFriendly, kidFriendly) ||\n                other.kidFriendly == kidFriendly) &&\n            (identical(other.wheelchairAccessible, wheelchairAccessible) ||\n                other.wheelchairAccessible == wheelchairAccessible) &&\n            (identical(other.minDurationMinutes, minDurationMinutes) ||\n                other.minDurationMinutes == minDurationMinutes) &&\n            (identical(other.maxDurationMinutes, maxDurationMinutes) ||\n                other.maxDurationMinutes == maxDurationMinutes) &&\n            (identical(other.priceLevel, priceLevel) ||\n                other.priceLevel == priceLevel) &&\n            (identical(other.basePrice, basePrice) ||\n                other.basePrice == basePrice) &&\n            const DeepCollectionEquality().equals(other._images, _images));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hashAll([\n        runtimeType,\n        id,\n        name,\n        description,\n        latitude,\n        longitude,\n        categoryId,\n        postalCode,\n        address,\n        city,\n        googlePlaceId,\n        const DeepCollectionEquality().hash(_currentOpeningHours),\n        contactPhone,\n        contactEmail,\n        contactWebsite,\n        bookingRequired,\n        kidFriendly,\n        wheelchairAccessible,\n        minDurationMinutes,\n        maxDurationMinutes,\n        priceLevel,\n        basePrice,\n        const DeepCollectionEquality().hash(_images)\n      ]);\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ActivityDetailsImplCopyWith<_$ActivityDetailsImpl> get copyWith =>\n      __$$ActivityDetailsImplCopyWithImpl<_$ActivityDetailsImpl>(\n          this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$ActivityDetailsImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _ActivityDetails implements ActivityDetails {\n  const factory _ActivityDetails(\n      {required final String id,\n      required final String name,\n      final String? description,\n      required final double latitude,\n      required final double longitude,\n      required final String categoryId,\n      final String? postalCode,\n      final String? address,\n      final String? city,\n      final String? googlePlaceId,\n      final Map<String, dynamic>? currentOpeningHours,\n      final String? contactPhone,\n      final String? contactEmail,\n      final String? contactWebsite,\n      final bool? bookingRequired,\n      final bool? kidFriendly,\n      final String? wheelchairAccessible,\n      final int? minDurationMinutes,\n      final int? maxDurationMinutes,\n      final int? priceLevel,\n      final double? basePrice,\n      final List<ActivityImage>? images}) = _$ActivityDetailsImpl;\n\n  factory _ActivityDetails.fromJson(Map<String, dynamic> json) =\n      _$ActivityDetailsImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get name;\n  @override\n  String? get description;\n  @override\n  double get latitude;\n  @override\n  double get longitude;\n  @override\n  String get categoryId;\n  @override\n  String? get postalCode;\n  @override\n  String? get address;\n  @override\n  String? get city;\n  @override\n  String? get googlePlaceId;\n  @override\n  Map<String, dynamic>? get currentOpeningHours;\n  @override\n  String? get contactPhone;\n  @override\n  String? get contactEmail;\n  @override\n  String? get contactWebsite;\n  @override\n  bool? get bookingRequired;\n  @override\n  bool? get kidFriendly;\n  @override\n  String? get wheelchairAccessible;\n  @override\n  int? get minDurationMinutes;\n  @override\n  int? get maxDurationMinutes;\n  @override\n  int? get priceLevel;\n  @override\n  double? get basePrice;\n  @override\n  List<ActivityImage>? get images;\n\n  /// Create a copy of ActivityDetails\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ActivityDetailsImplCopyWith<_$ActivityDetailsImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 23571,
        "last_modified": "2025-04-16T13:25:26.6259152",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_details_model.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'activity_details_model.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$ActivityDetailsImpl _$$ActivityDetailsImplFromJson(\n        Map<String, dynamic> json) =>\n    _$ActivityDetailsImpl(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      description: json['description'] as String?,\n      latitude: (json['latitude'] as num).toDouble(),\n      longitude: (json['longitude'] as num).toDouble(),\n      categoryId: json['categoryId'] as String,\n      postalCode: json['postalCode'] as String?,\n      address: json['address'] as String?,\n      city: json['city'] as String?,\n      googlePlaceId: json['googlePlaceId'] as String?,\n      currentOpeningHours: json['currentOpeningHours'] as Map<String, dynamic>?,\n      contactPhone: json['contactPhone'] as String?,\n      contactEmail: json['contactEmail'] as String?,\n      contactWebsite: json['contactWebsite'] as String?,\n      bookingRequired: json['bookingRequired'] as bool?,\n      kidFriendly: json['kidFriendly'] as bool?,\n      wheelchairAccessible: json['wheelchairAccessible'] as String?,\n      minDurationMinutes: (json['minDurationMinutes'] as num?)?.toInt(),\n      maxDurationMinutes: (json['maxDurationMinutes'] as num?)?.toInt(),\n      priceLevel: (json['priceLevel'] as num?)?.toInt(),\n      basePrice: (json['basePrice'] as num?)?.toDouble(),\n      images: (json['images'] as List<dynamic>?)\n          ?.map((e) => ActivityImage.fromJson(e as Map<String, dynamic>))\n          .toList(),\n    );\n\nMap<String, dynamic> _$$ActivityDetailsImplToJson(\n        _$ActivityDetailsImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'name': instance.name,\n      'description': instance.description,\n      'latitude': instance.latitude,\n      'longitude': instance.longitude,\n      'categoryId': instance.categoryId,\n      'postalCode': instance.postalCode,\n      'address': instance.address,\n      'city': instance.city,\n      'googlePlaceId': instance.googlePlaceId,\n      'currentOpeningHours': instance.currentOpeningHours,\n      'contactPhone': instance.contactPhone,\n      'contactEmail': instance.contactEmail,\n      'contactWebsite': instance.contactWebsite,\n      'bookingRequired': instance.bookingRequired,\n      'kidFriendly': instance.kidFriendly,\n      'wheelchairAccessible': instance.wheelchairAccessible,\n      'minDurationMinutes': instance.minDurationMinutes,\n      'maxDurationMinutes': instance.maxDurationMinutes,\n      'priceLevel': instance.priceLevel,\n      'basePrice': instance.basePrice,\n      'images': instance.images,\n    };\n",
      "info": {
        "size": 2751,
        "last_modified": "2025-04-16T13:25:26.6322028",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_image_model.dart",
      "content": "// core/domain/models/shared/activity_image_model.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'activity_image_model.freezed.dart';\r\npart 'activity_image_model.g.dart';\r\n\r\n@freezed\r\nclass ActivityImage with _$ActivityImage {\r\n  const factory ActivityImage({\r\n    String? id,\r\n    String? mobileUrl,\r\n    bool? isMain,\r\n  }) = _ActivityImage;\r\n\r\n  factory ActivityImage.fromJson(Map<String, dynamic> json) =>\r\n      _$ActivityImageFromJson(json);\r\n}",
      "info": {
        "size": 480,
        "last_modified": "2025-04-16T13:25:26.6382038",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_image_model.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_image_model.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nActivityImage _$ActivityImageFromJson(Map<String, dynamic> json) {\n  return _ActivityImage.fromJson(json);\n}\n\n/// @nodoc\nmixin _$ActivityImage {\n  String? get id => throw _privateConstructorUsedError;\n  String? get mobileUrl => throw _privateConstructorUsedError;\n  bool? get isMain => throw _privateConstructorUsedError;\n\n  /// Serializes this ActivityImage to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $ActivityImageCopyWith<ActivityImage> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityImageCopyWith<$Res> {\n  factory $ActivityImageCopyWith(\n          ActivityImage value, $Res Function(ActivityImage) then) =\n      _$ActivityImageCopyWithImpl<$Res, ActivityImage>;\n  @useResult\n  $Res call({String? id, String? mobileUrl, bool? isMain});\n}\n\n/// @nodoc\nclass _$ActivityImageCopyWithImpl<$Res, $Val extends ActivityImage>\n    implements $ActivityImageCopyWith<$Res> {\n  _$ActivityImageCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = freezed,\n    Object? mobileUrl = freezed,\n    Object? isMain = freezed,\n  }) {\n    return _then(_value.copyWith(\n      id: freezed == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mobileUrl: freezed == mobileUrl\n          ? _value.mobileUrl\n          : mobileUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isMain: freezed == isMain\n          ? _value.isMain\n          : isMain // ignore: cast_nullable_to_non_nullable\n              as bool?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$ActivityImageImplCopyWith<$Res>\n    implements $ActivityImageCopyWith<$Res> {\n  factory _$$ActivityImageImplCopyWith(\n          _$ActivityImageImpl value, $Res Function(_$ActivityImageImpl) then) =\n      __$$ActivityImageImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call({String? id, String? mobileUrl, bool? isMain});\n}\n\n/// @nodoc\nclass __$$ActivityImageImplCopyWithImpl<$Res>\n    extends _$ActivityImageCopyWithImpl<$Res, _$ActivityImageImpl>\n    implements _$$ActivityImageImplCopyWith<$Res> {\n  __$$ActivityImageImplCopyWithImpl(\n      _$ActivityImageImpl _value, $Res Function(_$ActivityImageImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = freezed,\n    Object? mobileUrl = freezed,\n    Object? isMain = freezed,\n  }) {\n    return _then(_$ActivityImageImpl(\n      id: freezed == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String?,\n      mobileUrl: freezed == mobileUrl\n          ? _value.mobileUrl\n          : mobileUrl // ignore: cast_nullable_to_non_nullable\n              as String?,\n      isMain: freezed == isMain\n          ? _value.isMain\n          : isMain // ignore: cast_nullable_to_non_nullable\n              as bool?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$ActivityImageImpl implements _ActivityImage {\n  const _$ActivityImageImpl({this.id, this.mobileUrl, this.isMain});\n\n  factory _$ActivityImageImpl.fromJson(Map<String, dynamic> json) =>\n      _$$ActivityImageImplFromJson(json);\n\n  @override\n  final String? id;\n  @override\n  final String? mobileUrl;\n  @override\n  final bool? isMain;\n\n  @override\n  String toString() {\n    return 'ActivityImage(id: $id, mobileUrl: $mobileUrl, isMain: $isMain)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ActivityImageImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.mobileUrl, mobileUrl) ||\n                other.mobileUrl == mobileUrl) &&\n            (identical(other.isMain, isMain) || other.isMain == isMain));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode => Object.hash(runtimeType, id, mobileUrl, isMain);\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ActivityImageImplCopyWith<_$ActivityImageImpl> get copyWith =>\n      __$$ActivityImageImplCopyWithImpl<_$ActivityImageImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$ActivityImageImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _ActivityImage implements ActivityImage {\n  const factory _ActivityImage(\n      {final String? id,\n      final String? mobileUrl,\n      final bool? isMain}) = _$ActivityImageImpl;\n\n  factory _ActivityImage.fromJson(Map<String, dynamic> json) =\n      _$ActivityImageImpl.fromJson;\n\n  @override\n  String? get id;\n  @override\n  String? get mobileUrl;\n  @override\n  bool? get isMain;\n\n  /// Create a copy of ActivityImage\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ActivityImageImplCopyWith<_$ActivityImageImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 6705,
        "last_modified": "2025-04-16T13:25:26.6452314",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\activity_image_model.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'activity_image_model.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$ActivityImageImpl _$$ActivityImageImplFromJson(Map<String, dynamic> json) =>\n    _$ActivityImageImpl(\n      id: json['id'] as String?,\n      mobileUrl: json['mobileUrl'] as String?,\n      isMain: json['isMain'] as bool?,\n    );\n\nMap<String, dynamic> _$$ActivityImageImplToJson(_$ActivityImageImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'mobileUrl': instance.mobileUrl,\n      'isMain': instance.isMain,\n    };\n",
      "info": {
        "size": 706,
        "last_modified": "2025-04-16T13:25:26.6514762",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\city_model.dart",
      "content": "// lib/core/domain/models/shared/city_model.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\n\r\n\r\nclass City extends Equatable{\r\n  final String id;\r\n  final String cityName;\r\n  final double lat;\r\n  final double lon;\r\n  final String geohash5;\r\n  final String? placeId;\r\n  final String? zoneCode;\r\n  final DateTime createdAt;\r\n  final DateTime updatedAt;\r\n\r\n  const City({  // Ajout du const pour optimisation\r\n    required this.id,\r\n    required this.cityName,\r\n    required this.lat,\r\n    required this.lon,\r\n    required this.geohash5,\r\n    this.zoneCode,\r\n    this.placeId,\r\n    required this.createdAt,\r\n    required this.updatedAt,\r\n  });\r\n\r\n  // Factory constructor pour crer une instance  partir d'un JSON\r\n  factory City.fromJson(Map<String, dynamic> json) {\r\n    return City(\r\n      id: json['id']?.toString() ?? '',  // Assurons-nous d'avoir une String\r\n      cityName: json['city_name']?.toString() ?? '',\r\n      lat: (json['lat'] as num?)?.toDouble() ?? 0.0,\r\n      lon: (json['lon'] as num?)?.toDouble() ?? 0.0,\r\n      geohash5: json['geohash_5']?.toString() ?? '',\r\n      zoneCode: json['zone_code']?.toString(),\r\n      placeId: json['place_id']?.toString(),\r\n      createdAt: json['created_at'] != null\r\n          ? DateTime.parse(json['created_at'].toString())\r\n          : DateTime.now(),\r\n      updatedAt: json['updated_at'] != null\r\n          ? DateTime.parse(json['updated_at'].toString())\r\n          : DateTime.now(),\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'city_name': cityName,\r\n      'lat': lat,\r\n      'lon': lon,\r\n      'geohash_5': geohash5,\r\n      'zone_code': zoneCode,\r\n      'place_id': placeId,\r\n      'created_at': createdAt.toIso8601String(),\r\n      'updated_at': updatedAt.toIso8601String(),\r\n    };\r\n  }\r\n\r\n  // Ajout d'une mthode pour la copie avec modifications\r\n  City copyWith({\r\n    String? id,\r\n    String? cityName,\r\n    double? lat,\r\n    double? lon,\r\n    String? geohash5,\r\n    String? zoneCode,\r\n    String? placeId,\r\n    DateTime? createdAt,\r\n    DateTime? updatedAt,\r\n  }) {\r\n    return City(\r\n      id: id ?? this.id,\r\n      cityName: cityName ?? this.cityName,\r\n      lat: lat ?? this.lat,\r\n      lon: lon ?? this.lon,\r\n      geohash5: geohash5 ?? this.geohash5,\r\n      zoneCode: zoneCode ?? this.zoneCode,\r\n      placeId: placeId ?? this.placeId,\r\n      createdAt: createdAt ?? this.createdAt,\r\n      updatedAt: updatedAt ?? this.updatedAt,\r\n    );\r\n  }\r\n\r\n  @override\r\n  String toString() => 'City(id: $id, cityName: $cityName, geohash5: $geohash5, zoneCode: $zoneCode)';\r\n\r\n  @override\r\n  List<Object?> get props => [id, cityName, lat, lon, geohash5, zoneCode, createdAt, updatedAt];\r\n}",
      "info": {
        "size": 2695,
        "last_modified": "2025-04-16T13:25:26.6585215",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\subcategory_model.dart",
      "content": "// lib/core/domain/models/shared/subcategory_model.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'subcategory_model.freezed.dart';\r\npart 'subcategory_model.g.dart';\r\n\r\n@freezed\r\nclass Subcategory with _$Subcategory {\r\n  const factory Subcategory({\r\n    required String id,\r\n    required String name,\r\n    required String categoryId,\r\n    String? description,\r\n    String? icon,\r\n  }) = _Subcategory;\r\n\r\n  factory Subcategory.fromJson(Map<String, dynamic> json) =>\r\n      _$SubcategoryFromJson(json);\r\n}",
      "info": {
        "size": 533,
        "last_modified": "2025-04-16T13:25:26.6655501",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\subcategory_model.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'subcategory_model.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\nSubcategory _$SubcategoryFromJson(Map<String, dynamic> json) {\n  return _Subcategory.fromJson(json);\n}\n\n/// @nodoc\nmixin _$Subcategory {\n  String get id => throw _privateConstructorUsedError;\n  String get name => throw _privateConstructorUsedError;\n  String get categoryId => throw _privateConstructorUsedError;\n  String? get description => throw _privateConstructorUsedError;\n  String? get icon => throw _privateConstructorUsedError;\n\n  /// Serializes this Subcategory to a JSON map.\n  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $SubcategoryCopyWith<Subcategory> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $SubcategoryCopyWith<$Res> {\n  factory $SubcategoryCopyWith(\n          Subcategory value, $Res Function(Subcategory) then) =\n      _$SubcategoryCopyWithImpl<$Res, Subcategory>;\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String categoryId,\n      String? description,\n      String? icon});\n}\n\n/// @nodoc\nclass _$SubcategoryCopyWithImpl<$Res, $Val extends Subcategory>\n    implements $SubcategoryCopyWith<$Res> {\n  _$SubcategoryCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? categoryId = null,\n    Object? description = freezed,\n    Object? icon = freezed,\n  }) {\n    return _then(_value.copyWith(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      icon: freezed == icon\n          ? _value.icon\n          : icon // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$SubcategoryImplCopyWith<$Res>\n    implements $SubcategoryCopyWith<$Res> {\n  factory _$$SubcategoryImplCopyWith(\n          _$SubcategoryImpl value, $Res Function(_$SubcategoryImpl) then) =\n      __$$SubcategoryImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {String id,\n      String name,\n      String categoryId,\n      String? description,\n      String? icon});\n}\n\n/// @nodoc\nclass __$$SubcategoryImplCopyWithImpl<$Res>\n    extends _$SubcategoryCopyWithImpl<$Res, _$SubcategoryImpl>\n    implements _$$SubcategoryImplCopyWith<$Res> {\n  __$$SubcategoryImplCopyWithImpl(\n      _$SubcategoryImpl _value, $Res Function(_$SubcategoryImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? id = null,\n    Object? name = null,\n    Object? categoryId = null,\n    Object? description = freezed,\n    Object? icon = freezed,\n  }) {\n    return _then(_$SubcategoryImpl(\n      id: null == id\n          ? _value.id\n          : id // ignore: cast_nullable_to_non_nullable\n              as String,\n      name: null == name\n          ? _value.name\n          : name // ignore: cast_nullable_to_non_nullable\n              as String,\n      categoryId: null == categoryId\n          ? _value.categoryId\n          : categoryId // ignore: cast_nullable_to_non_nullable\n              as String,\n      description: freezed == description\n          ? _value.description\n          : description // ignore: cast_nullable_to_non_nullable\n              as String?,\n      icon: freezed == icon\n          ? _value.icon\n          : icon // ignore: cast_nullable_to_non_nullable\n              as String?,\n    ));\n  }\n}\n\n/// @nodoc\n@JsonSerializable()\nclass _$SubcategoryImpl implements _Subcategory {\n  const _$SubcategoryImpl(\n      {required this.id,\n      required this.name,\n      required this.categoryId,\n      this.description,\n      this.icon});\n\n  factory _$SubcategoryImpl.fromJson(Map<String, dynamic> json) =>\n      _$$SubcategoryImplFromJson(json);\n\n  @override\n  final String id;\n  @override\n  final String name;\n  @override\n  final String categoryId;\n  @override\n  final String? description;\n  @override\n  final String? icon;\n\n  @override\n  String toString() {\n    return 'Subcategory(id: $id, name: $name, categoryId: $categoryId, description: $description, icon: $icon)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SubcategoryImpl &&\n            (identical(other.id, id) || other.id == id) &&\n            (identical(other.name, name) || other.name == name) &&\n            (identical(other.categoryId, categoryId) ||\n                other.categoryId == categoryId) &&\n            (identical(other.description, description) ||\n                other.description == description) &&\n            (identical(other.icon, icon) || other.icon == icon));\n  }\n\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, id, name, categoryId, description, icon);\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SubcategoryImplCopyWith<_$SubcategoryImpl> get copyWith =>\n      __$$SubcategoryImplCopyWithImpl<_$SubcategoryImpl>(this, _$identity);\n\n  @override\n  Map<String, dynamic> toJson() {\n    return _$$SubcategoryImplToJson(\n      this,\n    );\n  }\n}\n\nabstract class _Subcategory implements Subcategory {\n  const factory _Subcategory(\n      {required final String id,\n      required final String name,\n      required final String categoryId,\n      final String? description,\n      final String? icon}) = _$SubcategoryImpl;\n\n  factory _Subcategory.fromJson(Map<String, dynamic> json) =\n      _$SubcategoryImpl.fromJson;\n\n  @override\n  String get id;\n  @override\n  String get name;\n  @override\n  String get categoryId;\n  @override\n  String? get description;\n  @override\n  String? get icon;\n\n  /// Create a copy of Subcategory\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SubcategoryImplCopyWith<_$SubcategoryImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 8065,
        "last_modified": "2025-04-16T13:25:26.6720657",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\shared\\subcategory_model.g.dart",
      "content": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'subcategory_model.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\n_$SubcategoryImpl _$$SubcategoryImplFromJson(Map<String, dynamic> json) =>\n    _$SubcategoryImpl(\n      id: json['id'] as String,\n      name: json['name'] as String,\n      categoryId: json['categoryId'] as String,\n      description: json['description'] as String?,\n      icon: json['icon'] as String?,\n    );\n\nMap<String, dynamic> _$$SubcategoryImplToJson(_$SubcategoryImpl instance) =>\n    <String, dynamic>{\n      'id': instance.id,\n      'name': instance.name,\n      'categoryId': instance.categoryId,\n      'description': instance.description,\n      'icon': instance.icon,\n    };\n",
      "info": {
        "size": 848,
        "last_modified": "2025-04-16T13:25:26.6781519",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\bonus_activities\\potential_bonus_activity.dart",
      "content": "// lib/core/domain/models/bonus_activities/potential_bonus_activity.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport 'value_objects/malus_vol_oiseau.dart';\r\n\r\nclass PotentialBonusActivity extends Equatable {\r\n  final String id;\r\n  final String emptyDailyTripId;\r\n  final String activityId;\r\n  final MalusVolOiseau malusVolOiseau;\r\n  final DateTime tripDate;\r\n  final DateTime createdAt;\r\n  final DateTime updatedAt;\r\n\r\n  const PotentialBonusActivity({\r\n    required this.id,\r\n    required this.emptyDailyTripId,\r\n    required this.activityId,\r\n    required this.malusVolOiseau,\r\n    required this.tripDate,\r\n    required this.createdAt,\r\n    required this.updatedAt,\r\n  });\r\n\r\n  @override\r\n  List<Object> get props => [\r\n    id,\r\n    emptyDailyTripId,\r\n    activityId,\r\n    malusVolOiseau,\r\n    createdAt,\r\n    updatedAt\r\n  ];\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'id': id,\r\n    'empty_daily_trip_id': emptyDailyTripId,\r\n    'activity_id': activityId,\r\n    'malus_vol_oiseau': malusVolOiseau.minutes,\r\n    'trip_date': tripDate.toIso8601String(),\r\n    'created_at': createdAt.toIso8601String(),\r\n    'updated_at': updatedAt.toIso8601String(),\r\n  };\r\n\r\n  factory PotentialBonusActivity.fromJson(Map<String, dynamic> json) {\r\n    return PotentialBonusActivity(\r\n      id: json['id'],\r\n      emptyDailyTripId: json['empty_daily_trip_id'],\r\n      activityId: json['activity_id'],\r\n      malusVolOiseau: MalusVolOiseau.fromInt(json['malus_vol_oiseau']),\r\n      tripDate: DateTime.parse(json['trip_date']),\r\n      createdAt: DateTime.parse(json['created_at']),\r\n      updatedAt: DateTime.parse(json['updated_at']),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1642,
        "last_modified": "2025-04-16T13:25:26.6912315",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\bonus_activities\\value_objects\\malus_vol_oiseau.dart",
      "content": "// lib/core/domain/models/bonus_activities/value_objects/malus_vol_oiseau.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\npart 'malus_vol_oiseau.freezed.dart';\r\n\r\n\r\n@freezed\r\nclass MalusVolOiseau with _$MalusVolOiseau {\r\n  const factory MalusVolOiseau({\r\n    required int minutes,\r\n  }) = _MalusVolOiseau;\r\n\r\n  factory MalusVolOiseau.fromInt(int minutes) {\r\n    if (minutes < 0) {\r\n      throw ArgumentError('Malus minutes cannot be negative');\r\n    }\r\n    return MalusVolOiseau(minutes: minutes);\r\n  }\r\n}",
      "info": {
        "size": 527,
        "last_modified": "2025-04-16T13:25:26.6982164",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\bonus_activities\\value_objects\\malus_vol_oiseau.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'malus_vol_oiseau.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$MalusVolOiseau {\n  int get minutes => throw _privateConstructorUsedError;\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $MalusVolOiseauCopyWith<MalusVolOiseau> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $MalusVolOiseauCopyWith<$Res> {\n  factory $MalusVolOiseauCopyWith(\n          MalusVolOiseau value, $Res Function(MalusVolOiseau) then) =\n      _$MalusVolOiseauCopyWithImpl<$Res, MalusVolOiseau>;\n  @useResult\n  $Res call({int minutes});\n}\n\n/// @nodoc\nclass _$MalusVolOiseauCopyWithImpl<$Res, $Val extends MalusVolOiseau>\n    implements $MalusVolOiseauCopyWith<$Res> {\n  _$MalusVolOiseauCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? minutes = null,\n  }) {\n    return _then(_value.copyWith(\n      minutes: null == minutes\n          ? _value.minutes\n          : minutes // ignore: cast_nullable_to_non_nullable\n              as int,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$MalusVolOiseauImplCopyWith<$Res>\n    implements $MalusVolOiseauCopyWith<$Res> {\n  factory _$$MalusVolOiseauImplCopyWith(_$MalusVolOiseauImpl value,\n          $Res Function(_$MalusVolOiseauImpl) then) =\n      __$$MalusVolOiseauImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call({int minutes});\n}\n\n/// @nodoc\nclass __$$MalusVolOiseauImplCopyWithImpl<$Res>\n    extends _$MalusVolOiseauCopyWithImpl<$Res, _$MalusVolOiseauImpl>\n    implements _$$MalusVolOiseauImplCopyWith<$Res> {\n  __$$MalusVolOiseauImplCopyWithImpl(\n      _$MalusVolOiseauImpl _value, $Res Function(_$MalusVolOiseauImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? minutes = null,\n  }) {\n    return _then(_$MalusVolOiseauImpl(\n      minutes: null == minutes\n          ? _value.minutes\n          : minutes // ignore: cast_nullable_to_non_nullable\n              as int,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$MalusVolOiseauImpl implements _MalusVolOiseau {\n  const _$MalusVolOiseauImpl({required this.minutes});\n\n  @override\n  final int minutes;\n\n  @override\n  String toString() {\n    return 'MalusVolOiseau(minutes: $minutes)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$MalusVolOiseauImpl &&\n            (identical(other.minutes, minutes) || other.minutes == minutes));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, minutes);\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$MalusVolOiseauImplCopyWith<_$MalusVolOiseauImpl> get copyWith =>\n      __$$MalusVolOiseauImplCopyWithImpl<_$MalusVolOiseauImpl>(\n          this, _$identity);\n}\n\nabstract class _MalusVolOiseau implements MalusVolOiseau {\n  const factory _MalusVolOiseau({required final int minutes}) =\n      _$MalusVolOiseauImpl;\n\n  @override\n  int get minutes;\n\n  /// Create a copy of MalusVolOiseau\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$MalusVolOiseauImplCopyWith<_$MalusVolOiseauImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 4847,
        "last_modified": "2025-04-16T13:25:26.7052579",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\empty_daily_trip.dart",
      "content": "// lib/core/domain/empty_trips/empty_daily_trip.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\n\r\nclass EmptyDailyTrip extends Equatable {\r\n  final String id;\r\n  final DailyTripType type;\r\n  final String departureGeohash5;\r\n  final String arrivalGeohash5;\r\n  final String sw1Id;\r\n  final String? sw2Id;\r\n  final List<String> traversedGeohashes;\r\n  final String routePolyline;\r\n  final int totalDuration;\r\n  final int totalDistance;\r\n  final DateTime createdAt;\r\n\r\n  const EmptyDailyTrip({\r\n    required this.id,\r\n    required this.type,\r\n    required this.departureGeohash5,\r\n    required this.arrivalGeohash5,\r\n    required this.sw1Id,\r\n    this.sw2Id,\r\n    required this.traversedGeohashes,\r\n    required this.routePolyline,\r\n    required this.totalDuration,\r\n    required this.totalDistance,\r\n    required this.createdAt,\r\n  });\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id,\r\n    type,\r\n    departureGeohash5,\r\n    arrivalGeohash5,\r\n    sw1Id,\r\n    sw2Id,\r\n    traversedGeohashes,\r\n    routePolyline,\r\n    totalDuration,\r\n    totalDistance,\r\n    createdAt,\r\n  ];\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'id': id,\r\n    'type': type.toString().split('.').last,\r\n    'departure_geohash5': departureGeohash5,\r\n    'arrival_geohash5': arrivalGeohash5,\r\n    'sw1_id': sw1Id,\r\n    'sw2_id': sw2Id,\r\n    'traversed_geohashes': traversedGeohashes,\r\n    'route_polyline': routePolyline,\r\n    'total_duration': totalDuration,\r\n    'total_distance': totalDistance,\r\n    'created_at': createdAt.toIso8601String(),\r\n  };\r\n}",
      "info": {
        "size": 1583,
        "last_modified": "2025-04-16T13:25:26.7232034",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\value_objects\\generation_result.dart",
      "content": "// lib/core/domain/models/empty_trips/value_objects/generation_result.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../empty_daily_trip.dart';\r\n\r\npart 'generation_result.freezed.dart';\r\n\r\n@freezed\r\nclass EmptyTripGenerationResult with _$EmptyTripGenerationResult {\r\n  const factory EmptyTripGenerationResult({\r\n    required List<EmptyDailyTrip> halfDayTrips,\r\n    required List<EmptyDailyTrip> fullDayTrips,\r\n    required String departureGeohash5,\r\n    required List<String> errors,\r\n  }) = _EmptyTripGenerationResult;\r\n}",
      "info": {
        "size": 553,
        "last_modified": "2025-04-16T13:25:26.7302694",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\value_objects\\generation_result.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'generation_result.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$EmptyTripGenerationResult {\n  List<EmptyDailyTrip> get halfDayTrips => throw _privateConstructorUsedError;\n  List<EmptyDailyTrip> get fullDayTrips => throw _privateConstructorUsedError;\n  String get departureGeohash5 => throw _privateConstructorUsedError;\n  List<String> get errors => throw _privateConstructorUsedError;\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  $EmptyTripGenerationResultCopyWith<EmptyTripGenerationResult> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $EmptyTripGenerationResultCopyWith<$Res> {\n  factory $EmptyTripGenerationResultCopyWith(EmptyTripGenerationResult value,\n          $Res Function(EmptyTripGenerationResult) then) =\n      _$EmptyTripGenerationResultCopyWithImpl<$Res, EmptyTripGenerationResult>;\n  @useResult\n  $Res call(\n      {List<EmptyDailyTrip> halfDayTrips,\n      List<EmptyDailyTrip> fullDayTrips,\n      String departureGeohash5,\n      List<String> errors});\n}\n\n/// @nodoc\nclass _$EmptyTripGenerationResultCopyWithImpl<$Res,\n        $Val extends EmptyTripGenerationResult>\n    implements $EmptyTripGenerationResultCopyWith<$Res> {\n  _$EmptyTripGenerationResultCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? halfDayTrips = null,\n    Object? fullDayTrips = null,\n    Object? departureGeohash5 = null,\n    Object? errors = null,\n  }) {\n    return _then(_value.copyWith(\n      halfDayTrips: null == halfDayTrips\n          ? _value.halfDayTrips\n          : halfDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      fullDayTrips: null == fullDayTrips\n          ? _value.fullDayTrips\n          : fullDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      departureGeohash5: null == departureGeohash5\n          ? _value.departureGeohash5\n          : departureGeohash5 // ignore: cast_nullable_to_non_nullable\n              as String,\n      errors: null == errors\n          ? _value.errors\n          : errors // ignore: cast_nullable_to_non_nullable\n              as List<String>,\n    ) as $Val);\n  }\n}\n\n/// @nodoc\nabstract class _$$EmptyTripGenerationResultImplCopyWith<$Res>\n    implements $EmptyTripGenerationResultCopyWith<$Res> {\n  factory _$$EmptyTripGenerationResultImplCopyWith(\n          _$EmptyTripGenerationResultImpl value,\n          $Res Function(_$EmptyTripGenerationResultImpl) then) =\n      __$$EmptyTripGenerationResultImplCopyWithImpl<$Res>;\n  @override\n  @useResult\n  $Res call(\n      {List<EmptyDailyTrip> halfDayTrips,\n      List<EmptyDailyTrip> fullDayTrips,\n      String departureGeohash5,\n      List<String> errors});\n}\n\n/// @nodoc\nclass __$$EmptyTripGenerationResultImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationResultCopyWithImpl<$Res,\n        _$EmptyTripGenerationResultImpl>\n    implements _$$EmptyTripGenerationResultImplCopyWith<$Res> {\n  __$$EmptyTripGenerationResultImplCopyWithImpl(\n      _$EmptyTripGenerationResultImpl _value,\n      $Res Function(_$EmptyTripGenerationResultImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? halfDayTrips = null,\n    Object? fullDayTrips = null,\n    Object? departureGeohash5 = null,\n    Object? errors = null,\n  }) {\n    return _then(_$EmptyTripGenerationResultImpl(\n      halfDayTrips: null == halfDayTrips\n          ? _value._halfDayTrips\n          : halfDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      fullDayTrips: null == fullDayTrips\n          ? _value._fullDayTrips\n          : fullDayTrips // ignore: cast_nullable_to_non_nullable\n              as List<EmptyDailyTrip>,\n      departureGeohash5: null == departureGeohash5\n          ? _value.departureGeohash5\n          : departureGeohash5 // ignore: cast_nullable_to_non_nullable\n              as String,\n      errors: null == errors\n          ? _value._errors\n          : errors // ignore: cast_nullable_to_non_nullable\n              as List<String>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$EmptyTripGenerationResultImpl implements _EmptyTripGenerationResult {\n  const _$EmptyTripGenerationResultImpl(\n      {required final List<EmptyDailyTrip> halfDayTrips,\n      required final List<EmptyDailyTrip> fullDayTrips,\n      required this.departureGeohash5,\n      required final List<String> errors})\n      : _halfDayTrips = halfDayTrips,\n        _fullDayTrips = fullDayTrips,\n        _errors = errors;\n\n  final List<EmptyDailyTrip> _halfDayTrips;\n  @override\n  List<EmptyDailyTrip> get halfDayTrips {\n    if (_halfDayTrips is EqualUnmodifiableListView) return _halfDayTrips;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_halfDayTrips);\n  }\n\n  final List<EmptyDailyTrip> _fullDayTrips;\n  @override\n  List<EmptyDailyTrip> get fullDayTrips {\n    if (_fullDayTrips is EqualUnmodifiableListView) return _fullDayTrips;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_fullDayTrips);\n  }\n\n  @override\n  final String departureGeohash5;\n  final List<String> _errors;\n  @override\n  List<String> get errors {\n    if (_errors is EqualUnmodifiableListView) return _errors;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_errors);\n  }\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationResult(halfDayTrips: $halfDayTrips, fullDayTrips: $fullDayTrips, departureGeohash5: $departureGeohash5, errors: $errors)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$EmptyTripGenerationResultImpl &&\n            const DeepCollectionEquality()\n                .equals(other._halfDayTrips, _halfDayTrips) &&\n            const DeepCollectionEquality()\n                .equals(other._fullDayTrips, _fullDayTrips) &&\n            (identical(other.departureGeohash5, departureGeohash5) ||\n                other.departureGeohash5 == departureGeohash5) &&\n            const DeepCollectionEquality().equals(other._errors, _errors));\n  }\n\n  @override\n  int get hashCode => Object.hash(\n      runtimeType,\n      const DeepCollectionEquality().hash(_halfDayTrips),\n      const DeepCollectionEquality().hash(_fullDayTrips),\n      departureGeohash5,\n      const DeepCollectionEquality().hash(_errors));\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$EmptyTripGenerationResultImplCopyWith<_$EmptyTripGenerationResultImpl>\n      get copyWith => __$$EmptyTripGenerationResultImplCopyWithImpl<\n          _$EmptyTripGenerationResultImpl>(this, _$identity);\n}\n\nabstract class _EmptyTripGenerationResult implements EmptyTripGenerationResult {\n  const factory _EmptyTripGenerationResult(\n      {required final List<EmptyDailyTrip> halfDayTrips,\n      required final List<EmptyDailyTrip> fullDayTrips,\n      required final String departureGeohash5,\n      required final List<String> errors}) = _$EmptyTripGenerationResultImpl;\n\n  @override\n  List<EmptyDailyTrip> get halfDayTrips;\n  @override\n  List<EmptyDailyTrip> get fullDayTrips;\n  @override\n  String get departureGeohash5;\n  @override\n  List<String> get errors;\n\n  /// Create a copy of EmptyTripGenerationResult\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$EmptyTripGenerationResultImplCopyWith<_$EmptyTripGenerationResultImpl>\n      get copyWith => throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 9186,
        "last_modified": "2025-04-16T13:25:26.736305",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\empty_trips\\value_objects\\superwow_pair.dart",
      "content": "// lib/core/domain/empty_trips/value_objects/superwow_pair.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nclass SuperWowPair extends Equatable {\r\n  final String sw1Id;  // Premier SuperWow (le plus proche du dpart)\r\n  final String sw2Id;  // Second SuperWow\r\n  final LatLng sw1Location;\r\n  final LatLng sw2Location;\r\n  final int distanceBetween;  // Distance en mtres entre SW1 et SW2\r\n  final Duration travelTime;  // Temps de trajet entre SW1 et SW2\r\n\r\n  const SuperWowPair({\r\n    required this.sw1Id,\r\n    required this.sw2Id,\r\n    required this.sw1Location,\r\n    required this.sw2Location,\r\n    required this.distanceBetween,\r\n    required this.travelTime,\r\n  });\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    sw1Id,\r\n    sw2Id,\r\n    sw1Location,\r\n    sw2Location,\r\n    distanceBetween,\r\n    travelTime,\r\n  ];\r\n\r\n  double get distanceInKm => distanceBetween / 1000;\r\n}",
      "info": {
        "size": 953,
        "last_modified": "2025-04-16T13:25:26.7433327",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\processing\\activity_processing_model.dart",
      "content": "// core/domain/models/processing/activity_processing_model.dart\r\n\r\nimport '../trip/activity_model.dart';\r\n\r\nclass ActivityForProcessing extends Activity {\r\n  String? exclusionReason;\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperWow;\r\n  final String? superwowValidityPeriod;\r\n  final Map<String, dynamic>? superwowScoreSnapshot;\r\n  final Map<String, dynamic>? superwowCriteriaMet;\r\n\r\n  ActivityForProcessing({\r\n    required super.id,\r\n    required super.name,\r\n    required super.latitude,\r\n    required super.longitude,\r\n    required super.geohash,\r\n    super.geohash5,\r\n    required super.isWow,\r\n    required super.minDurationMinutes,\r\n    required super.maxDurationMinutes,\r\n    required super.momentPreferences,\r\n    required super.intensityLevel,\r\n    required super.categoryId,\r\n    super.subcategoryId,\r\n    super.kidFriendly,\r\n    super.wheelchairAccessible,\r\n    super.metadata,\r\n    required super.ratingAvg,\r\n    required super.ratingCount,\r\n    super.basePrice,\r\n    super.bookingRequired,\r\n    super.weatherPreferences,\r\n    super.activitySubtype,\r\n    super.seasonPrices,\r\n    this.exclusionReason,\r\n    this.totalScore = 0.0,\r\n    this.subcategoryScore = 0.0,\r\n    this.isSuperWow = false,\r\n    this.superwowValidityPeriod,\r\n    this.superwowScoreSnapshot,\r\n    this.superwowCriteriaMet,\r\n  });\r\n\r\n  factory ActivityForProcessing.fromJson(Map<String, dynamic> json) {\r\n    return ActivityForProcessing(\r\n      id: json['id'],\r\n      name: json['name'],\r\n      latitude: json['latitude']?.toDouble() ?? 0.0,\r\n      longitude: json['longitude']?.toDouble() ?? 0.0,\r\n      geohash: json['geohash_4'] ?? '',\r\n      geohash5: json['geohash_5'],\r\n      isWow: json['is_wow'] ?? false,\r\n      minDurationMinutes: json['min_duration_minutes'] ?? 60,\r\n      maxDurationMinutes: json['max_duration_minutes'] ?? 60,\r\n      momentPreferences: (json['moment_preferences'] is List)\r\n          ? List<String>.from(json['moment_preferences'])\r\n          : (json['moment_preferences'] is Map)\r\n          ? (json['moment_preferences'] as Map).keys.cast<String>().toList()\r\n          : [],\r\n      intensityLevel: json['intensity_level'] ?? 1,\r\n      categoryId: json['category_id'] ?? '',\r\n      subcategoryId: json['subcategory_id'],\r\n      kidFriendly: json['kid_friendly'],\r\n      wheelchairAccessible: json['wheelchair_accessible'],\r\n      metadata: json['metadata'],\r\n      ratingAvg: json['rating_avg']?.toString() ?? '0',\r\n      ratingCount: json['rating_count'] ?? 0,\r\n      basePrice: json['base_price']?.toDouble(),\r\n      bookingRequired: json['booking_required'],\r\n      weatherPreferences: json['weather_preferences'],\r\n      activitySubtype: json['activity_subtype'],\r\n      seasonPrices: json['season_prices'],\r\n      exclusionReason: json['exclusion_reason'],\r\n      totalScore: (json['total_score'] ?? 0.0).toDouble(),\r\n      subcategoryScore: (json['subcategory_score'] ?? 0.0).toDouble(),\r\n      isSuperWow: json['is_super_wow'] ?? false,\r\n      superwowValidityPeriod: json['superwow_validity_period'],\r\n      superwowScoreSnapshot: json['superwow_score_snapshot'],\r\n      superwowCriteriaMet: json['superwow_criteria_met'],\r\n    );\r\n  }\r\n\r\n  factory ActivityForProcessing.fromActivity(Activity activity) {\r\n    return ActivityForProcessing(\r\n      id: activity.id,\r\n      name: activity.name,\r\n      latitude: activity.latitude,\r\n      longitude: activity.longitude,\r\n      geohash: activity.geohash,\r\n      geohash5: activity.geohash5,\r\n      isWow: activity.isWow,\r\n      minDurationMinutes: activity.minDurationMinutes,\r\n      maxDurationMinutes: activity.maxDurationMinutes,\r\n      momentPreferences: activity.momentPreferences,\r\n      intensityLevel: activity.intensityLevel,\r\n      categoryId: activity.categoryId,\r\n      subcategoryId: activity.subcategoryId,\r\n      kidFriendly: activity.kidFriendly,\r\n      wheelchairAccessible: activity.wheelchairAccessible,\r\n      metadata: activity.metadata,\r\n      ratingAvg: activity.ratingAvg,\r\n      ratingCount: activity.ratingCount,\r\n      basePrice: activity.basePrice,\r\n      bookingRequired: activity.bookingRequired,\r\n      weatherPreferences: activity.weatherPreferences,\r\n      activitySubtype: activity.activitySubtype,\r\n      seasonPrices: activity.seasonPrices,\r\n    );\r\n  }\r\n\r\n  @override\r\n  Map<String, dynamic> toJson() {\r\n    final baseJson = super.toJson();\r\n    return {\r\n      ...baseJson,\r\n      'exclusion_reason': exclusionReason,\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_super_wow': isSuperWow,\r\n      'superwow_validity_period': superwowValidityPeriod,\r\n      'superwow_score_snapshot': superwowScoreSnapshot,\r\n      'superwow_criteria_met': superwowCriteriaMet,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 4756,
        "last_modified": "2025-04-16T13:25:26.7602682",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\scoring\\scoring_activity.dart",
      "content": "// core/domain/models/scoring/scored_activity.dart\r\n\r\nimport '../processing/activity_processing_model.dart';\r\n\r\nclass ScoredActivity {\r\n  final ActivityForProcessing activity;\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperWow;\r\n  final DateTime? superwowValidityPeriod;\r\n  final Map<String, dynamic>? superwowScoreSnapshot;\r\n\r\n  const ScoredActivity({\r\n    required this.activity,\r\n    required this.totalScore,\r\n    required this.subcategoryScore,\r\n    this.isSuperWow = false,\r\n    this.superwowValidityPeriod,\r\n    this.superwowScoreSnapshot,\r\n  });\r\n\r\n  factory ScoredActivity.fromJson(Map<String, dynamic> json, ActivityForProcessing activity) {\r\n    return ScoredActivity(\r\n      activity: activity,\r\n      totalScore: json['total_score']?.toDouble() ?? 0.0,\r\n      subcategoryScore: json['subcategory_score']?.toDouble() ?? 0.0,\r\n      isSuperWow: json['is_superwow'] ?? false,\r\n      superwowValidityPeriod: json['superwow_validity_period'] != null\r\n          ? DateTime.parse(json['superwow_validity_period'])\r\n          : null,\r\n      superwowScoreSnapshot: json['superwow_score_snapshot'],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'activity_id': activity.id,\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_superwow': isSuperWow,\r\n      'superwow_validity_period': superwowValidityPeriod?.toIso8601String(),\r\n      'superwow_score_snapshot': superwowScoreSnapshot,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 1501,
        "last_modified": "2025-04-16T13:25:26.771813",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\scoring\\scoring_config.dart",
      "content": "// core/domain/models/scoring/scoring_config.dart\r\n\r\nimport 'dart:math' as math;\r\n\r\nclass ScoringConfig {\r\n  // Pondrations\r\n  static const double subcategoryWeight = 0.5;\r\n  static const double ratingWeight = 0.4;\r\n  static const double durationWeight = 0.1;\r\n\r\n  // Scores sous-catgories\r\n  static const Map<String, double> subcategoryScores = {\r\n    'adore': 1.0,\r\n    'aime': 0.6,\r\n    'parfois': 0.3\r\n  };\r\n}",
      "info": {
        "size": 417,
        "last_modified": "2025-04-16T13:25:26.779322",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\scoring\\scoring_result.dart",
      "content": "// core/domain/models/scoring/scoring_result.dart\r\n\r\n\r\nclass ScoringResult {\r\n  final double totalScore;\r\n  final double subcategoryScore;\r\n  final bool isSuperWow;\r\n  final DateTime? superwowValidityPeriod;\r\n  final Map<String, dynamic>? superwowScoreSnapshot;\r\n\r\n  const ScoringResult({\r\n    required this.totalScore,\r\n    required this.subcategoryScore,\r\n    required this.isSuperWow,\r\n    this.superwowValidityPeriod,\r\n    this.superwowScoreSnapshot,\r\n  });\r\n\r\n  // Optionnel : Factory pour crer depuis JSON\r\n  factory ScoringResult.fromJson(Map<String, dynamic> json) {\r\n    return ScoringResult(\r\n      totalScore: json['total_score']?.toDouble() ?? 0.0,\r\n      subcategoryScore: json['subcategory_score']?.toDouble() ?? 0.0,\r\n      isSuperWow: json['is_superwow'] ?? false,\r\n      superwowValidityPeriod: json['superwow_validity_period'] != null\r\n          ? DateTime.parse(json['superwow_validity_period'])\r\n          : null,\r\n      superwowScoreSnapshot: json['superwow_score_snapshot'],\r\n    );\r\n  }\r\n\r\n  // Optionnel : Conversion en JSON\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'total_score': totalScore,\r\n      'subcategory_score': subcategoryScore,\r\n      'is_superwow': isSuperWow,\r\n      'superwow_validity_period': superwowValidityPeriod?.toIso8601String(),\r\n      'superwow_score_snapshot': superwowScoreSnapshot,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 1364,
        "last_modified": "2025-04-16T13:25:26.7853661",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\trip\\activity_model.dart",
      "content": "// core\\domain\\models\\trip_designer\\trip\\activity_model.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\n\r\nclass Activity extends Equatable {\r\n  final String id;\r\n  final String name;\r\n  final double latitude;\r\n  final double longitude;\r\n  final String geohash;\r\n  final String? geohash5;\r\n  final bool isWow;\r\n  final int minDurationMinutes;\r\n  final int maxDurationMinutes;\r\n  final List<String> momentPreferences;\r\n  final int intensityLevel;\r\n  final String categoryId;\r\n  final String? subcategoryId;\r\n  final bool? kidFriendly;\r\n  final String? wheelchairAccessible;\r\n  final Map<String, dynamic>? metadata;\r\n  final String ratingAvg;\r\n  final int ratingCount;\r\n  final double? basePrice;\r\n  final bool? bookingRequired;\r\n  final Map<String, dynamic>? weatherPreferences;\r\n  final String? activitySubtype;\r\n  final Map<String, dynamic>? seasonPrices;\r\n\r\n  const Activity({\r\n    required this.id,\r\n    required this.name,\r\n    required this.latitude,\r\n    required this.longitude,\r\n    required this.geohash,\r\n    this.geohash5,\r\n    required this.isWow,\r\n    required this.minDurationMinutes,\r\n    required this.maxDurationMinutes,\r\n    required this.momentPreferences,\r\n    required this.intensityLevel,\r\n    required this.categoryId,\r\n    this.subcategoryId,\r\n    this.kidFriendly,\r\n    this.wheelchairAccessible,\r\n    this.metadata,\r\n    required this.ratingAvg,\r\n    required this.ratingCount,\r\n    this.basePrice,\r\n    this.bookingRequired,\r\n    this.weatherPreferences,\r\n    this.activitySubtype,\r\n    this.seasonPrices,\r\n  });\r\n\r\n  factory Activity.fromJson(Map<String, dynamic> json) {\r\n    List<String> momentPrefs;\r\n    if (json['moment_preferences'] is List) {\r\n      momentPrefs = List<String>.from(json['moment_preferences']);\r\n    } else if (json['moment_preferences'] is Map) {\r\n      momentPrefs = (json['moment_preferences'] as Map).keys.cast<String>().toList();\r\n    } else {\r\n      momentPrefs = [];\r\n    }\r\n\r\n    return Activity(\r\n      id: json['id'],\r\n      name: json['name'],\r\n      latitude: json['latitude']?.toDouble() ?? 0.0,\r\n      longitude: json['longitude']?.toDouble() ?? 0.0,\r\n      geohash: json['geohash_4'] ?? '',\r\n      geohash5: json['geohash_5'],\r\n      isWow: json['is_wow'] ?? false,\r\n      minDurationMinutes: json['min_duration_minutes'] ?? 60,\r\n      maxDurationMinutes: json['max_duration_minutes'] ?? 60,\r\n      momentPreferences: momentPrefs,\r\n      intensityLevel: json['intensity_level'] ?? 1,\r\n      categoryId: json['category_id'] ?? '',\r\n      subcategoryId: json['subcategory_id'],\r\n      kidFriendly: json['kid_friendly'],\r\n      wheelchairAccessible: json['wheelchair_accessible'],\r\n      metadata: json['metadata'],\r\n      ratingAvg: json['rating_avg']?.toString() ?? '0',\r\n      ratingCount: json['rating_count'] ?? 0,\r\n      basePrice: json['base_price']?.toDouble(),\r\n      bookingRequired: json['booking_required'],\r\n      weatherPreferences: json['weather_preferences'],\r\n      activitySubtype: json['activity_subtype'],\r\n      seasonPrices: json['season_prices'],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() => {\r\n    'id': id,\r\n    'name': name,\r\n    'latitude': latitude,\r\n    'longitude': longitude,\r\n    'geohash_4': geohash,\r\n    'geohash_5': geohash5,\r\n    'is_wow': isWow,\r\n    'min_duration_minutes': minDurationMinutes,\r\n    'max_duration_minutes': maxDurationMinutes,\r\n    'moment_preferences': momentPreferences,\r\n    'intensity_level': intensityLevel,\r\n    'category_id': categoryId,\r\n    'subcategory_id': subcategoryId,\r\n    'kid_friendly': kidFriendly,\r\n    'wheelchair_accessible': wheelchairAccessible,\r\n    'metadata': metadata,\r\n    'rating_avg': ratingAvg,\r\n    'rating_count': ratingCount,\r\n    'base_price': basePrice,\r\n    'booking_required': bookingRequired,\r\n    'weather_preferences': weatherPreferences,\r\n    'activity_subtype': activitySubtype,\r\n    'season_prices': seasonPrices,\r\n  };\r\n\r\n  // Getters utilitaires\r\n  int get durationMinutes => maxDurationMinutes;\r\n  double get rating => double.tryParse(ratingAvg) ?? 0.0;\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id,\r\n    name,\r\n    latitude,\r\n    longitude,\r\n    geohash,\r\n    geohash5,\r\n    isWow,\r\n    minDurationMinutes,\r\n    maxDurationMinutes,\r\n    momentPreferences,\r\n    intensityLevel,\r\n    categoryId,\r\n    subcategoryId,\r\n    kidFriendly,\r\n    wheelchairAccessible,\r\n    metadata,\r\n    ratingAvg,\r\n    ratingCount,\r\n    basePrice,\r\n    bookingRequired,\r\n    weatherPreferences,\r\n    activitySubtype,\r\n    seasonPrices,\r\n  ];\r\n}",
      "info": {
        "size": 4505,
        "last_modified": "2025-04-16T13:25:26.7968726",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\trip\\daily_trip.dart",
      "content": "// lib/core/domain/models/trip/daily_trip.dart\r\n\r\nimport 'package:equatable/equatable.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\n\r\n\r\nclass DailyTrip extends Equatable {\r\n  final String id;\r\n  final DailyTripType type;\r\n  final DateTime date;\r\n  final LatLng startPoint;\r\n  final LatLng endPoint;\r\n  final List<String> superWowIds;  // Les IDs des SW inclus\r\n  final Duration totalDuration;     // Dure totale estime\r\n  final int totalDistance;          // Distance en mtres\r\n\r\n  const DailyTrip({\r\n    required this.id,\r\n    required this.type,\r\n    required this.date,\r\n    required this.startPoint,\r\n    required this.endPoint,\r\n    required this.superWowIds,\r\n    required this.totalDuration,\r\n    required this.totalDistance,\r\n  });\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id, type, date, startPoint, endPoint, superWowIds, totalDuration, totalDistance\r\n  ];\r\n\r\n  // Conversion depuis/vers JSON pour Supabase\r\n  factory DailyTrip.fromJson(Map<String, dynamic> json) {\r\n    return DailyTrip(\r\n      id: json['id'],\r\n      type: DailyTripType.values.firstWhere(\r\n              (e) => e.toString() == 'DailyTripType.${json['type']}'\r\n      ),\r\n      date: DateTime.parse(json['date']),\r\n      startPoint: LatLng(json['start_lat'], json['start_lng']),\r\n      endPoint: LatLng(json['end_lat'], json['end_lng']),\r\n      superWowIds: List<String>.from(json['superwow_ids']),\r\n      totalDuration: Duration(seconds: json['total_duration']),\r\n      totalDistance: json['total_distance'],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'type': type.toString().split('.').last,\r\n      'planned_date': date.toIso8601String(),\r\n      'start_lat': startPoint.latitude,\r\n      'start_lng': startPoint.longitude,\r\n      'end_lat': endPoint.latitude,\r\n      'end_lng': endPoint.longitude,\r\n      'superwow_ids': superWowIds,\r\n      'total_duration': totalDuration.inSeconds,\r\n      'total_distance': totalDistance,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 2057,
        "last_modified": "2025-04-16T13:25:26.8039295",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\models\\trip_designer\\trip\\trip_model.dart",
      "content": "// lib/core/domain/models/trip_model.dart\r\n\r\nimport '../../shared/city_model.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\nimport 'package:equatable/equatable.dart';\r\n\r\nclass Trip extends Equatable{\r\n  final String id;\r\n  final String userId;\r\n  final String title;\r\n  final DateTime startDate;\r\n  final DateTime endDate;\r\n  final double? dailyBudget;\r\n  final String status;\r\n  final Map<String, dynamic> metadata;\r\n  final TravelGroup travelGroup;\r\n  final int tripDuration;\r\n  final ActivityHours activityHours;\r\n  final String? departureCityId;\r\n  final String? departureGeohash5;\r\n  final TravelStyle? travelStyle;\r\n  final PreferredMoment? preferredMoment;\r\n  final int? maxActivitiesPerDay;\r\n  final DateTime createdAt;\r\n  final DateTime updatedAt;\r\n  final City? departureCity;\r\n  final List<ExplorationType> activeExplorationType;\r\n\r\n  Trip({\r\n    required this.id,\r\n    required this.userId,\r\n    required this.title,\r\n    required this.startDate,\r\n    required this.endDate,\r\n    this.dailyBudget,\r\n    required this.status,\r\n    required this.metadata,\r\n    required this.travelGroup,\r\n    required this.tripDuration,\r\n    required this.activityHours,\r\n    this.departureCityId,\r\n    this.departureGeohash5,\r\n    this.travelStyle,\r\n    this.preferredMoment,\r\n    this.maxActivitiesPerDay,\r\n    required this.createdAt,\r\n    required this.updatedAt,\r\n    this.departureCity,\r\n    required this.activeExplorationType,\r\n  });\r\n\r\n  factory Trip.fromJson(Map<String, dynamic> json) {\r\n    print('Raw JSON in fromJson: ${json}');\r\n\r\n    return Trip(\r\n      id: json['id'],\r\n      userId: json['user_id'],\r\n      title: json['title'],\r\n      startDate: DateTime.parse(json['start_date']),\r\n      endDate: DateTime.parse(json['end_date']),\r\n      dailyBudget: json['daily_budget']?.toDouble(),\r\n      status: json['status'],\r\n      metadata: json['metadata'] ?? {},\r\n      maxActivitiesPerDay: json['max_activities_per_day'],\r\n      travelGroup: TravelGroup.fromJson(json['travel_group'] ?? {}),\r\n      tripDuration: json['trip_duration'],\r\n      activityHours: ActivityHours.fromJson(json['activity_hours'] ?? {}),\r\n      departureCityId: json['departure_city_id'],\r\n      departureGeohash5: json['departure_geohash5'],\r\n      travelStyle: TravelStyleExtension.fromJson(json['travel_style']),\r\n      preferredMoment: PreferredMomentExtension.fromJson(json['preferred_moment']),\r\n      createdAt: DateTime.parse(json['created_at']),\r\n      updatedAt: DateTime.parse(json['updated_at']),\r\n      departureCity: json['departure_city'] != null\r\n          ? City.fromJson(json['departure_city'])\r\n          : null,\r\n      activeExplorationType: (json['active_exploration_types'] as List)\r\n          .map((type) => ExplorationTypeExtension.fromJson(type) ?? ExplorationType.around_me)\r\n          .toList(),\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'id': id,\r\n      'user_id': userId,\r\n      'title': title,\r\n      'start_date': startDate.toIso8601String(),\r\n      'end_date': endDate.toIso8601String(),\r\n      'daily_budget': dailyBudget,\r\n      'status': status,\r\n      'metadata': metadata,\r\n      'max_activities_per_day': maxActivitiesPerDay,\r\n      'travel_group': travelGroup.toJson(),\r\n      'trip_duration': tripDuration,\r\n      'activity_hours': activityHours.toJson(),\r\n      'departure_city_id': departureCityId,\r\n      'departure_geohash5': departureGeohash5,\r\n      'travel_style': travelStyle?.value,\r\n      'preferred_moment': preferredMoment?.value,\r\n      'created_at': createdAt.toIso8601String(),\r\n      'updated_at': updatedAt.toIso8601String(),\r\n      'active_exploration_types': activeExplorationType.map((e) => e.value).toList(),\r\n    };\r\n  }\r\n\r\n  @override\r\n  List<Object?> get props => [\r\n    id,\r\n    userId,\r\n    title,\r\n    startDate,\r\n    endDate,\r\n    dailyBudget,\r\n    status,\r\n    metadata,\r\n    travelGroup,\r\n    tripDuration,\r\n    activityHours,\r\n    departureCityId,\r\n    departureGeohash5,\r\n    travelStyle,\r\n    preferredMoment,\r\n    maxActivitiesPerDay,\r\n    createdAt,\r\n    updatedAt,\r\n    departureCity,\r\n    activeExplorationType,\r\n  ];\r\n}\r\n\r\nclass ActivityHours {\r\n  final String start;\r\n  final String end;\r\n  final Map<String, Map<String, String?>> daily_hours;\r\n\r\n  const ActivityHours({\r\n    required this.start,\r\n    required this.end,\r\n    required this.daily_hours,\r\n  });\r\n\r\n  factory ActivityHours.fromJson(Map<String, dynamic> json) {\r\n    print('ActivityHours JSON: $json');\r\n    return ActivityHours(\r\n      start: json['start'] ?? '',\r\n      end: json['end'] ?? '',\r\n      daily_hours: json['daily_hours'] != null\r\n          ? Map<String, Map<String, String?>>.from(\r\n        json['daily_hours'].map((key, value) => MapEntry(\r\n          key,\r\n          Map<String, String?>.from(value as Map),\r\n        )),\r\n      )\r\n          : {},\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'start': start,\r\n      'end': end,\r\n      'daily_hours': daily_hours,\r\n    };\r\n  }\r\n}\r\n\r\nclass TravelGroup {\r\n  final String type;\r\n  final TravelGroupMembers members;\r\n  final String physicalCondition;\r\n\r\n  const TravelGroup({\r\n    required this.type,\r\n    required this.members,\r\n    required this.physicalCondition,\r\n  });\r\n\r\n  factory TravelGroup.fromJson(Map<String, dynamic> json) {\r\n    return TravelGroup(\r\n      type: json['type'] ?? '',\r\n      members: TravelGroupMembers.fromJson(json['members'] ?? {}),\r\n      physicalCondition: json['physical_condition'] ?? '',\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'type': type,\r\n      'members': members.toJson(),\r\n      'physical_condition': physicalCondition,\r\n    };\r\n  }\r\n}\r\n\r\nclass TravelGroupMembers {\r\n  final bool pmr;\r\n  final int adults;\r\n  final bool seniors;\r\n  final List<int> children;\r\n  final List<int> teenagers;\r\n\r\n  const TravelGroupMembers({\r\n    required this.pmr,\r\n    required this.adults,\r\n    required this.seniors,\r\n    required this.children,\r\n    required this.teenagers,\r\n  });\r\n\r\n  factory TravelGroupMembers.fromJson(Map<String, dynamic> json) {\r\n    return TravelGroupMembers(\r\n      pmr: json['pmr'] ?? false,\r\n      adults: json['adults'] ?? 0,\r\n      seniors: json['seniors'] ?? false,\r\n      children: json['children'] != null\r\n          ? List<int>.from(json['children'])\r\n          : [],\r\n      teenagers: json['teenagers'] != null\r\n          ? List<int>.from(json['teenagers'])\r\n          : [],\r\n    );\r\n  }\r\n\r\n  Map<String, dynamic> toJson() {\r\n    return {\r\n      'pmr': pmr,\r\n      'adults': adults,\r\n      'seniors': seniors,\r\n      'children': children,\r\n      'teenagers': teenagers,\r\n    };\r\n  }\r\n}",
      "info": {
        "size": 6627,
        "last_modified": "2025-04-16T13:25:26.8099481",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\activity_hours_port.dart",
      "content": "// core/domain/ports/activity_hours_port.dart\r\n\r\nimport '../models/opening_days.dart';\r\n\r\nabstract class ActivityHoursPort {\r\n  /// Rcupre les horaires d'une activit pour une priode donne\r\n  Future<OpeningDays?> getActivityHours(\r\n      String activityId,\r\n      DateTime startDate,\r\n      DateTime endDate,\r\n      );\r\n}",
      "info": {
        "size": 330,
        "last_modified": "2025-04-16T13:25:26.8334856",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\activity_processing_port.dart",
      "content": "// core/domain/ports/activity_processing_port.dart\r\n\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\n\r\nabstract class ActivityProcessingPort {\r\n  /// Rcupre les activits brutes dans la zone du voyage\r\n  Future<List<ActivityForProcessing>> getActivitiesForTrip(String tripId);\r\n\r\n  /// Rcupre les activits avec les distances par rapport au geohash de dpart\r\n  Future<Map<String, List<String>>> getGeohashNeighbors(String geohash4, double maxDistance);\r\n\r\n  /// Applique les filtres et retourne les activits ligibles\r\n  Future<List<ActivityForProcessing>> getFilteredActivities({\r\n    required String tripId,\r\n    required Trip trip,\r\n    required List<ActivityForProcessing> activities,\r\n  });\r\n\r\n  /// Rcupre le rayon de recherche bas sur le type d'exploration\r\n  double getExplorationRadius(String explorationType);\r\n}",
      "info": {
        "size": 929,
        "last_modified": "2025-04-16T13:25:26.8384878",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\activity_scoring_port.dart",
      "content": "// core/domain/ports/activity_scoring_port.dart\r\n\r\nimport '../models/trip_designer/scoring/scoring_activity.dart';\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nabstract class ActivityScoringPort {\r\n  Future<List<ScoredActivity>> scoreActivities(String userId, List<ActivityForProcessing> activities);\r\n  Future<Map<String, double>> getUserPreferences(String userId);\r\n}",
      "info": {
        "size": 404,
        "last_modified": "2025-04-16T13:25:26.8459997",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\config\\remote_config_port.dart",
      "content": "// lib/core/domain/ports/config/remote_config_port.dart\r\n\r\nimport '../../models/config/home_section_config.dart';\r\nimport '../../models/config/app_remote_config.dart';\r\nimport '../../models/config/subcategory_section_config.dart';\r\n\r\nabstract class RemoteConfigPort {\r\n  Future<List<HomeSectionConfig>> getHomeSections();\r\n  Future<List<AppRemoteConfig>> getAppConfig();\r\n  Future<List<SubcategorySectionConfig>> getSubcategorySections(String? subcategoryId);  // Nouveau\r\n}\r\n\r\n",
      "info": {
        "size": 478,
        "last_modified": "2025-04-16T13:25:26.8515074",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\daily_trip_generation_port.dart",
      "content": "// core/domain/ports/daily_trip_generation_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../models/trip_designer/trip/daily_trip.dart';\r\nimport '../models/scored_activity.dart';\r\n\r\nabstract class DailyTripGenerationPort {\r\n  Future<List<DailyTrip>> generateHalfDayTrips({\r\n    required String tripId,\r\n    required List<ScoredActivity> superWows,\r\n    required LatLng departurePoint,\r\n    required LatLng arrivalPoint,\r\n  });\r\n\r\n  Future<List<DailyTrip>> generateFullDayTrips({\r\n    required String tripId,\r\n    required List<ScoredActivity> superWows,\r\n    required LatLng departurePoint,\r\n    required LatLng arrivalPoint,\r\n    required Map<String, dynamic> momentPreferences,\r\n  });\r\n}",
      "info": {
        "size": 727,
        "last_modified": "2025-04-16T13:25:26.8637022",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\distance_calculation_port.dart",
      "content": "// lib/core/domain/ports/distance_calculation_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nabstract class DistanceCalculationPort {\r\n  double calculateDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  });\r\n}",
      "info": {
        "size": 346,
        "last_modified": "2025-04-16T13:25:26.8702111",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\available_time_calculation.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/available_time_calculation.port.dart\r\n\r\nimport '../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\n\r\nabstract class AvailableTimeCalculationPort {\r\n  Future<int> calculateAvailableTime({\r\n    required String emptyTripId,\r\n    required Map<String, dynamic> activityHours,\r\n    required String travelStyle,\r\n    required List<String> superWowIds,\r\n  });\r\n\r\n  Future<int> calculateSuperWowDuration({\r\n    required List<String> superWowIds,\r\n    required String travelStyle,\r\n  });\r\n\r\n  int calculateMealBreaksDuration(Map<String, dynamic> activityHours, String travelStyle);\r\n\r\n  Future<Map<DateTime, int>> calculateAvailableTimeForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Map<String, Map<String, String?>> dailyHours,\r\n    required String travelStyle,\r\n  });\r\n}",
      "info": {
        "size": 834,
        "last_modified": "2025-04-16T13:25:26.8762728",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\bonus_activities_cache.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/bonus_activities_cache.port.dart\r\n\r\nabstract class BonusActivitiesCachePort {\r\n  Future<void> cacheEmptyTripBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Map<String, dynamic>> bonusActivities,\r\n  });\r\n\r\n  Future<List<Map<String, dynamic>>> getCachedBonusActivities(String emptyTripId);\r\n}",
      "info": {
        "size": 350,
        "last_modified": "2025-04-16T13:25:26.8827789",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\empty_daily_trip.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/empty_daily_trip_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../common/enums/trip_enums.dart';\r\n\r\n\r\n\r\nabstract class EmptyDailyTripPort {\r\n  /// Vrifie si un empty trip existe dj avec ces paramtres\r\n  Future<EmptyDailyTrip?> findExistingEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n  });\r\n\r\n  /// Cre un nouvel empty trip\r\n  Future<EmptyDailyTrip> createEmptyTrip({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String arrivalGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n    required List<String> traversedGeohashes,\r\n    required String routePolyline,\r\n    required int totalDuration,     // Ajout\r\n    required int totalDistance,\r\n  });\r\n\r\n  Future<EmptyDailyTrip> getEmptyTrip(String emptyTripId);\r\n\r\n}",
      "info": {
        "size": 1055,
        "last_modified": "2025-04-16T13:25:26.8887828",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\empty_trip_repository.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/empty_trip_repository.port.dart",
      "info": {
        "size": 68,
        "last_modified": "2025-04-16T13:25:26.8952975",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\geometry_calculation.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/geometry_calculation.port.dart\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nabstract class GeometryCalculationPort {\r\n  Future<double> calculateDistance(LatLng point1, LatLng point2);\r\n  Future<int> calculateMalusMinutes(double distanceMeters, String travelStyle);\r\n  Future<bool> isLocationOnPath(LatLng point, List<LatLng> pathPoints);\r\n  Future<bool> isWithinMaxDetour(LatLng point, LatLng start, LatLng end);\r\n}",
      "info": {
        "size": 474,
        "last_modified": "2025-04-16T13:25:26.9023451",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\neighbor_geohashes.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/neighbor_geohashes.port.dart\r\n\r\nabstract class NeighborGeohashesPort {\r\n  Future<void> generateAndSaveNeighbors({\r\n    required String emptyTripId,\r\n    required List<String> traversedGeohashes,\r\n  });\r\n\r\n  Future<Map<String, Map<String, dynamic>>> getNeighborGeohashes(String emptyTripId);\r\n}",
      "info": {
        "size": 330,
        "last_modified": "2025-04-16T13:25:26.9084206",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\potential_activities.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/potential_activities.port.dart\r\n\r\nimport '../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../models/trip_designer/trip/activity_model.dart';\r\n\r\nabstract class PotentialActivitiesPort {\r\n  Future<Map<String, List<Activity>>> getFilteredActivitiesForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required String tripId,\r\n    required Map<DateTime, int> availableTimeByDate,\r\n  });\r\n}",
      "info": {
        "size": 456,
        "last_modified": "2025-04-16T13:25:26.9149334",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\route_optimization.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/route_optimization.port.dart\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../models/trip_designer/trip/trip_model.dart';\r\n\r\nabstract class RouteOptimizationPort {\r\n  /// Calcule le trajet optimal entre plusieurs points\r\n  Future<Map<String, dynamic>> getOptimizedRoute(\r\n      LatLng origin,\r\n      LatLng destination,\r\n      List<LatLng> waypoints,\r\n      );\r\n\r\n  /// Obtient le temps de trajet estim entre deux points\r\n  Future<Duration> getTravelTime(\r\n      LatLng origin,\r\n      LatLng destination,\r\n      {DateTime? departureTime}\r\n      );\r\n\r\n  /// Vrifie si un dtour par un point est viable\r\n  Future<Map<String, dynamic>> evaluateDetour(\r\n      LatLng origin,\r\n      LatLng destination,\r\n      LatLng detourPoint,\r\n      Duration maxDetourTime,\r\n      );\r\n}",
      "info": {
        "size": 840,
        "last_modified": "2025-04-16T13:25:26.9289502",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\empty_trips\\superwow_management.port.dart",
      "content": "// lib/core/domain/ports/empty_trips/superwow_management.port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../models/scored_activity.dart';\r\nimport '../../models/trip_designer/empty_trips/value_objects/superwow_pair.dart';\r\n\r\n// lib/core/domain/ports/empty_trips/superwow_management.port.dart\r\n\r\nabstract class SuperWowManagementPort {\r\n  // Les mthodes existantes restent\r\n  Future<List<ScoredActivity>> getTripSuperWows(String tripId);\r\n  Future<ScoredActivity> findClosestSuperWow(\r\n      List<ScoredActivity> superWows,\r\n      LatLng fromPoint,\r\n      );\r\n\r\n  // Nouvelle mthode plus simple qui fait tout le processus\r\n  Future<List<SuperWowPair>> generateOptimizedPairs(\r\n      String tripId,\r\n      List<ScoredActivity> superWows,\r\n      LatLng departurePoint,\r\n      );\r\n}",
      "info": {
        "size": 821,
        "last_modified": "2025-04-16T13:25:26.9354588",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\geocoding_port.dart",
      "content": "// core/domain/ports/geocoding_port.dart\r\n\r\nimport '../models/shared/city_model.dart';\r\n\r\n\r\nabstract class GeocodingPort {\r\n  Future<City> getCity(String cityName);\r\n  Future<List<City>> getMultipleCities(List<String> cityNames);\r\n}",
      "info": {
        "size": 232,
        "last_modified": "2025-04-16T13:25:26.9469668",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\city_cache_port.dart",
      "content": "// lib/core/domain/ports/location/city_cache_port.dart\r\n\r\nimport '../../models/shared/city_model.dart';\r\nimport '../../models/location/place_details.dart';\r\n\r\n/// Port pour interagir avec le cache de villes dans Supabase\r\nabstract class CityCachePort {\r\n  /// Vrifie si une ville existe dans le cache par son place_id Google\r\n  Future<City?> getCityByPlaceId(String placeId);\r\n\r\n  /// Vrifie si une ville existe dans le cache par son nom\r\n  Future<City?> getCityByName(String cityName);\r\n\r\n  /// Sauvegarde les informations d'une ville dans le cache\r\n  Future<City> saveCity({\r\n    required String placeId,\r\n    required String cityName,\r\n    required double lat,\r\n    required double lon,\r\n  });\r\n\r\n  /// Convertit un PlaceDetails en City et le sauvegarde\r\n  Future<City> savePlaceDetailsAsCity(PlaceDetails placeDetails);\r\n}",
      "info": {
        "size": 830,
        "last_modified": "2025-04-16T13:25:26.9534755",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\geolocation_port.dart",
      "content": "// lib/core/domain/ports/location/geolocation_port.dart\r\n\r\nimport 'package:async/async.dart';\r\nimport '../../../domain/models/location/user_location.dart';\r\n\r\nabstract class GeolocationPort {\r\n  /// Rcupre la position actuelle de l'utilisateur\r\n  Future<Result<UserLocation>> getCurrentLocation();\r\n\r\n  /// Vrifie si les services de localisation sont activs\r\n  Future<bool> isLocationServiceEnabled();\r\n\r\n  /// Demande la permission d'accder  la localisation\r\n  Future<bool> requestLocationPermission();\r\n}",
      "info": {
        "size": 518,
        "last_modified": "2025-04-16T13:25:26.9604842",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\location_cache_port.dart",
      "content": "//lib/core/domain/ports/location/location_cache_port.dart\r\n\r\nimport '../../../domain/models/location/place_suggestion.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\n\r\nabstract class LocationCachePort {\r\n  /// Sauvegarde une suggestion de lieu dans le cache\r\n  Future<void> savePlaceSuggestion(PlaceSuggestion suggestion);\r\n\r\n  /// Sauvegarde plusieurs suggestions de lieu dans le cache\r\n  Future<void> savePlaceSuggestions(List<PlaceSuggestion> suggestions);\r\n\r\n  /// Rcupre les suggestions de lieu du cache correspondant  un prfixe\r\n  Future<List<PlaceSuggestion>> getPlaceSuggestions(String prefix, {int limit = 5});\r\n\r\n  /// Sauvegarde les dtails d'un lieu dans le cache\r\n  Future<void> savePlaceDetails(PlaceDetails details);\r\n\r\n  /// Rcupre les dtails d'un lieu du cache\r\n  Future<PlaceDetails?> getPlaceDetails(String placeId);\r\n\r\n  /// Efface le cache des lieux\r\n  Future<void> clearCache();\r\n}",
      "info": {
        "size": 940,
        "last_modified": "2025-04-16T13:25:26.9659934",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\place_details_port.dart",
      "content": "// lib/core/domain/ports/location/place_details_port.dart\r\nimport 'package:async/async.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\n\r\nabstract class PlaceDetailsPort {\r\n  /// Rcupre les dtails d'un lieu  partir de son ID\r\n  Future<Result<PlaceDetails>> getPlaceDetailsById(String placeId);\r\n}",
      "info": {
        "size": 325,
        "last_modified": "2025-04-16T13:25:26.9740084",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\location\\place_search_port.dart",
      "content": "// lib/core/domain/ports/location/place_search_port.dart\r\n\r\n\r\nimport 'package:async/async.dart';\r\nimport '../../../domain/models/location/place_suggestion.dart';\r\nimport '../../../domain/models/location/user_location.dart';\r\n\r\nabstract class PlaceSearchPort {\r\n  /// Recherche des lieux  partir d'un texte\r\n  Future<Result<List<PlaceSuggestion>>> searchPlaces(\r\n      String query, {\r\n        UserLocation? locationBias,\r\n        int radius = 50000,\r\n      });\r\n}",
      "info": {
        "size": 465,
        "last_modified": "2025-04-16T13:25:26.9805119",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\maps_port.dart",
      "content": "// core/domain/ports/maps_port.dart\r\n\r\nabstract class MapsPort {\r\n  /// Rcupre les dtails de golocalisation d'une ville\r\n  Future<Map<String, dynamic>?> getPlaceDetails(String cityName);\r\n\r\n  /// Enrichit les donnes d'une ville avec ses coordonnes\r\n  Future<bool> enrichCityData(String cityName);\r\n\r\n  /// Enrichit les donnes de plusieurs villes\r\n  Future<List<String>> enrichMultipleCities(List<String> cityNames);\r\n}",
      "info": {
        "size": 432,
        "last_modified": "2025-04-16T13:25:26.9920234",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\config\\remote_config_provider.dart",
      "content": "// lib/core/domain/ports/providers/config/remote_config_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../adapters/supabase/config/remote_config_adapter.dart';\r\nimport '../../../../domain/models/config/home_section_config.dart';\r\nimport '../../../../adapters/supabase/database_adapter.dart';\r\nimport '../../../../domain/models/config/subcategory_section_config.dart';\r\n\r\n\r\nfinal remoteConfigProvider = Provider((ref) =>\r\n    SupabaseRemoteConfigAdapter(SupabaseService.client)\r\n);\r\n\r\nfinal homeSectionsConfigProvider = FutureProvider<List<HomeSectionConfig>>((ref) async {\r\n  print(' Starting to fetch home sections');\r\n  try {\r\n    final configAdapter = ref.watch(remoteConfigProvider);\r\n    print(' Got config adapter');\r\n    final sections = await configAdapter.getHomeSections();\r\n    print(' Fetched sections: $sections');\r\n    return sections;\r\n  } catch (e) {\r\n    print(' Error fetching sections: $e');\r\n    rethrow;\r\n  }\r\n});\r\n\r\nfinal subcategorySectionsConfigProvider =\r\nFutureProvider.family<List<SubcategorySectionConfig>, String?>((ref, subcategoryId) async {\r\n  print(' Starting to fetch subcategory sections for id: $subcategoryId');\r\n  try {\r\n    final configAdapter = ref.watch(remoteConfigProvider);\r\n    print(' Got config adapter');\r\n    final sections = await configAdapter.getSubcategorySections(subcategoryId);\r\n    print(' Fetched subcategory sections: $sections');\r\n    return sections;\r\n  } catch (e) {\r\n    print(' Error fetching subcategory sections: $e');\r\n    rethrow;\r\n  }\r\n});",
      "info": {
        "size": 1583,
        "last_modified": "2025-04-16T13:25:26.999026",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\daily_trip_generation_provider.dart",
      "content": "// // lib/core/domain/ports/providers/route_optimization_providers.dart\r\n//\r\n// import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n// import '../../ports/daily_trip_generation_port.dart';\r\n// import '../../../adapters/supabase/daily_trip_generation_adapter.dart';\r\n// import 'infrastructure_providers.dart';\r\n// import 'empty_trips/route_optimization_providers.dart';\r\n// import 'empty_trips/empty_daily_trip_provider.dart';\r\n//\r\n// final dailyTripGenerationPortProvider = Provider<DailyTripGenerationPort>((ref) {\r\n//   final supabase = ref.watch(supabaseProvider);\r\n//   final routeOptimization = ref.watch(routeOptimizationPortProvider);\r\n//   final emptyTripPort = ref.watch(emptyDailyTripPortProvider);\r\n//\r\n//   return DailyTripGenerationAdapter(\r\n//     supabase,\r\n//     routeOptimization,\r\n//     emptyTripPort,\r\n//   );\r\n// });",
      "info": {
        "size": 844,
        "last_modified": "2025-04-16T13:25:27.0105446",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\bonus_activities.providers.dart",
      "content": "// lib/features/empty_trips/presentation/state/providers/bonus_activities.providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../../adapters/supabase/potential_bonus_activity.adapter.dart';\r\nimport '../../../../adapters/postgis/geometry_calculation.adapter.dart';\r\nimport '../../../services/designer/empty_trips/distance_calculation.service.dart';\r\nimport '../../../services/designer/empty_trips/bonus_activity_generation.service.dart';\r\nimport '../../../services/designer/empty_trips/available_time_calculation.service.dart';\r\nimport '../../../services/designer/empty_trips/notifier/potential_bonus_activities.notifier.dart';\r\nimport '../../../models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\n\r\n\r\n// Adapters providers\r\nfinal potentialBonusActivityAdapterProvider = Provider<PotentialBonusActivityAdapter>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return PotentialBonusActivityAdapter(supabase);\r\n});\r\n\r\nfinal geometryCalculationAdapterProvider = Provider<GeometryCalculationAdapter>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return GeometryCalculationAdapter(supabase);\r\n});\r\n\r\n// Services providers\r\nfinal distanceCalculationServiceProvider = Provider<DistanceCalculationService>((ref) {\r\n  final geometryPort = ref.watch(geometryCalculationAdapterProvider);\r\n  return DistanceCalculationService(geometryPort);\r\n});\r\n\r\nfinal bonusActivityGenerationServiceProvider = Provider<BonusActivityGenerationService>((ref) {\r\n  final geometryPort = ref.watch(geometryCalculationAdapterProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n  final availableTimeService = ref.watch(availableTimeServiceProvider); // Ajouter ce provider\r\n\r\n  return BonusActivityGenerationService(\r\n      geometryPort,\r\n      distanceService,\r\n      availableTimeService // Ajouter le 3me argument\r\n  );\r\n});\r\n\r\nfinal availableTimeServiceProvider = Provider<AvailableTimeCalculationService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return AvailableTimeCalculationService(supabase);\r\n});\r\n\r\n// State providers si ncessaire pour la gestion d'tat\r\nfinal potentialBonusActivitiesProvider = StateNotifierProvider<PotentialBonusActivitiesNotifier, AsyncValue<List<PotentialBonusActivity>>>((ref) {\r\n  final adapter = ref.watch(potentialBonusActivityAdapterProvider);\r\n  final geometryPort = ref.watch(geometryCalculationAdapterProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n  final availableTimeService = ref.watch(availableTimeServiceProvider);\r\n\r\n  final bonusService = BonusActivityGenerationService(\r\n      geometryPort,\r\n      distanceService,\r\n      availableTimeService\r\n  );\r\n\r\n  return PotentialBonusActivitiesNotifier(adapter, bonusService);\r\n});",
      "info": {
        "size": 2864,
        "last_modified": "2025-04-16T13:25:27.0165513",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\bonus_activities_cache.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/bonus_activities_cache.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../services/designer/empty_trips/bonus_activities_cache.service.dart';\r\n\r\n\r\nfinal bonusActivitiesCacheProvider = Provider<BonusActivitiesCacheService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return BonusActivitiesCacheService(supabase);\r\n});",
      "info": {
        "size": 475,
        "last_modified": "2025-04-16T13:25:27.0235609",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\distance_calculation_provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/distance_calculation.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../services/designer/empty_trips/distance_calculation.service.dart';\r\n\r\nfinal distanceCalculationServiceProvider = Provider<DistanceCalculationService>((ref) {\r\n  return DistanceCalculationService();\r\n});",
      "info": {
        "size": 357,
        "last_modified": "2025-04-16T13:25:27.0300684",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\empty_daily_trip.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/empty_daily_trip.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../empty_trips/empty_daily_trip.port.dart';\r\nimport '../../../../adapters/supabase/empty_daily_trip.adapter.dart';\r\nimport '../infrastructure_providers.dart';\r\n\r\nfinal emptyDailyTripPortProvider = Provider<EmptyDailyTripPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return EmptyDailyTripAdapter(supabase);\r\n});",
      "info": {
        "size": 480,
        "last_modified": "2025-04-16T13:25:27.0360733",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\empty_trip_generation.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/empty_trip_generation.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../services/designer/empty_trips/empty_trip_generation.service.dart';\r\nimport 'superwow_management.provider.dart';\r\nimport 'route_optimization.provider.dart';\r\nimport '../infrastructure_providers.dart';\r\nimport 'empty_daily_trip.provider.dart';\r\nimport 'neighbor_geohashes.provider.dart';\r\n\r\nfinal emptyTripGenerationServiceProvider = Provider<EmptyTripGenerationService>((ref) {\r\n  final superwowPort = ref.watch(superwowManagementPortProvider);\r\n  final routePort = ref.watch(routeOptimizationPortProvider);\r\n  final emptyTripPort = ref.watch(emptyDailyTripPortProvider);\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final neighborGeohashesService = ref.watch(neighborGeohashesProvider);\r\n\r\n  return EmptyTripGenerationService(\r\n    superwowPort,\r\n    routePort,\r\n    emptyTripPort,\r\n    neighborGeohashesService,\r\n    supabase,\r\n  );\r\n});",
      "info": {
        "size": 1006,
        "last_modified": "2025-04-16T13:25:27.0420908",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\geometry_calculation.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/geometry_calculation.provider.dart\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../../adapters/postgis/geometry_calculation.adapter.dart';\r\nimport '../../empty_trips/geometry_calculation.port.dart';\r\n\r\nfinal geometryCalculationPortProvider = Provider<GeometryCalculationPort>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return GeometryCalculationAdapter(supabase);\r\n});",
      "info": {
        "size": 515,
        "last_modified": "2025-04-16T13:25:27.0490911",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\google_ai_studio.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/google_ai_studio.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../adapters/google/google_ai_studio_service.dart';\r\nimport 'google_services_config.provider.dart';\r\n\r\nfinal googleAIStudioServiceProvider = Provider<GoogleAIStudioService?>((ref) {\r\n  final config = ref.watch(googleServicesConfigProvider);\r\n\r\n  try {\r\n    return GoogleAIStudioService(config);\r\n  } catch (e) {\r\n    print(' Erreur initialisation Google AI Studio: $e');\r\n    return null;\r\n  }\r\n});",
      "info": {
        "size": 552,
        "last_modified": "2025-04-16T13:25:27.054595",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\google_services_config.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/google_services_config.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../services/google_services_config.dart';\r\n\r\nfinal googleServicesConfigProvider = Provider<GoogleServicesConfig>((ref) {\r\n  throw UnimplementedError('Doit tre surcharg au niveau de l\\'app');\r\n});",
      "info": {
        "size": 354,
        "last_modified": "2025-04-16T13:25:27.0616071",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\neighbor_geohashes.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/neighbor_geohashes.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../services/designer/empty_trips/neighbor_geohashes.service.dart';\r\n\r\nfinal neighborGeohashesProvider = Provider<NeighborGeohashesService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return NeighborGeohashesService(supabase);\r\n});",
      "info": {
        "size": 456,
        "last_modified": "2025-04-16T13:25:27.0671124",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\potential_activities.provider.dart",
      "content": "// lib/core/domain/ports/providers/empty_trips/potential_activities.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../services/designer/empty_trips/potential_activities.service.dart';\r\n\r\nfinal potentialActivitiesProvider = Provider<PotentialActivitiesService>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  return PotentialActivitiesService(supabase);\r\n});",
      "info": {
        "size": 466,
        "last_modified": "2025-04-16T13:25:27.0741319",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\route_optimization.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/route_optimization.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../empty_trips/route_optimization.port.dart';\r\nimport '../../../../adapters/google/route_optimization.adapter.dart';\r\nimport '../infrastructure_providers.dart';\r\nimport './google_services_config.provider.dart';\r\nimport './google_ai_studio.provider.dart';\r\n\r\nfinal routeOptimizationPortProvider = Provider<RouteOptimizationPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final config = ref.watch(googleServicesConfigProvider);\r\n  final googleService = ref.watch(googleAIStudioServiceProvider);\r\n\r\n  return RouteOptimizationAdapter(supabase, config, googleService);\r\n});",
      "info": {
        "size": 734,
        "last_modified": "2025-04-16T13:25:27.0811966",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\empty_trips\\superwow_management.provider.dart",
      "content": "// core/domain/ports/providers/empty_trips/superwow_management.provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'route_optimization.provider.dart';\r\nimport 'distance_calculation_provider.dart';\r\nimport '../infrastructure_providers.dart';\r\nimport '../../empty_trips/superwow_management.port.dart';\r\nimport '../../../../adapters/supabase/superwow_management.adapter.dart';\r\nimport '../../../services/designer/empty_trips/distance_calculation.service.dart';\r\n\r\nfinal superwowManagementPortProvider = Provider<SuperWowManagementPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final routeOptimization = ref.watch(routeOptimizationPortProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n\r\n  return SuperWowManagementAdapter(\r\n    supabase,\r\n    routeOptimization,\r\n    distanceService,\r\n  );\r\n});",
      "info": {
        "size": 875,
        "last_modified": "2025-04-16T13:25:27.0871977",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\infrastructure_providers.dart",
      "content": "// core/domain/ports/providers/infrastructure_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\nfinal supabaseProvider = Provider<SupabaseClient>((ref) {\r\n  return Supabase.instance.client;\r\n});",
      "info": {
        "size": 280,
        "last_modified": "2025-04-16T13:25:27.0992589",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\location\\location_providers.dart",
      "content": "// lib/core/domain/ports/providers/location/location_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:http/http.dart' as http;\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport '../../../../domain/services/location_service.dart';\r\nimport '../../../../adapters/google_maps/maps_adapter.dart';\r\nimport '../../../../adapters/cache/hive_location_cache_adapter.dart';\r\nimport '../../../services/location/enhanced_location_service.dart';\r\nimport '../../../ports/location/location_cache_port.dart';\r\nimport '../../../ports/location/city_cache_port.dart';\r\nimport '../../../../adapters/supabase/search/city_cache_adapter.dart';\r\n\r\n// Provider pour Supabase client\r\nfinal supabaseClientProvider = Provider<SupabaseClient>((ref) {\r\n  return Supabase.instance.client;\r\n});\r\n\r\n// Provider pour le client HTTP\r\nfinal httpClientProvider = Provider<http.Client>((ref) {\r\n  return http.Client();\r\n});\r\n\r\n// Provider pour le LocationService\r\nfinal locationServiceProvider = Provider<LocationService>((ref) {\r\n  final supabase = ref.watch(supabaseClientProvider);\r\n  return LocationService(supabase);\r\n});\r\n\r\n// Provider pour l'adapter de cache de villes\r\nfinal cityCacheProvider = Provider<CityCachePort>((ref) {\r\n  final supabase = ref.watch(supabaseClientProvider);\r\n  return SupabaseCityCacheAdapter(supabase);\r\n});\r\n\r\n// Provider d'tat interne pour stocker l'instance initialise\r\nfinal initializedCacheProvider = StateProvider<HiveLocationCacheAdapter?>((ref) => null);\r\n\r\n// Provider d'initialisation qui retourne l'adaptateur une fois initialis\r\nfinal cacheInitializationProvider = FutureProvider<HiveLocationCacheAdapter>((ref) async {\r\n  // Initialisation de Hive lui-mme si pas dj fait\r\n  // Note: Normalement ceci devrait tre fait au dmarrage de l'app (main.dart)\r\n  try {\r\n    await Hive.initFlutter();\r\n  } catch (e) {\r\n    // Ignorer l'erreur si Hive est dj initialis\r\n    print('Note: Hive.initFlutter a lanc une erreur, probablement dj initialis: $e');\r\n  }\r\n\r\n  final cacheAdapter = HiveLocationCacheAdapter();\r\n  await cacheAdapter.initializeAsync();\r\n\r\n  // Stocker l'instance initialise pour qu'elle soit utilise par le provider suivant\r\n  ref.read(initializedCacheProvider.notifier).state = cacheAdapter;\r\n\r\n  return cacheAdapter;\r\n});\r\n\r\n// Provider pour le cache de localisation\r\nfinal locationCacheProvider = Provider<LocationCachePort>((ref) {\r\n  // Vrifier d'abord si nous avons dj une instance initialise\r\n  final initializedCache = ref.watch(initializedCacheProvider);\r\n  if (initializedCache != null && initializedCache.isInitialized) {\r\n    return initializedCache;\r\n  }\r\n\r\n  // Sinon, crer une nouvelle instance et l'initialiser de manire synchrone\r\n  final adapter = HiveLocationCacheAdapter();\r\n  adapter.initialize(); // Initialisation synchrone\r\n  return adapter;\r\n});\r\n\r\n// Provider pour l'adaptateur Google Maps existant\r\nfinal googleMapsAdapterProvider = Provider<GoogleMapsAdapter>((ref) {\r\n  final locationService = ref.watch(locationServiceProvider);\r\n  final httpClient = ref.watch(httpClientProvider);\r\n\r\n  return GoogleMapsAdapter(locationService, httpClient: httpClient);\r\n});\r\n\r\n\r\n// Provider pour le service de localisation avanc\r\nfinal enhancedLocationServiceProvider = Provider<EnhancedLocationService>((ref) {\r\n  final mapsAdapter = ref.watch(googleMapsAdapterProvider);\r\n  final locationCache = ref.watch(locationCacheProvider);\r\n  final cityCache = ref.watch(cityCacheProvider);\r\n\r\n  return EnhancedLocationService(\r\n    mapsAdapter: mapsAdapter,\r\n    locationCache: locationCache,\r\n    cityCache: cityCache,\r\n  );\r\n});",
      "info": {
        "size": 3710,
        "last_modified": "2025-04-16T13:25:27.1052975",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\port_providers.dart",
      "content": "// core/domain/ports/providers/port_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../adapters/trip/trip_adapter.dart';\r\nimport '../../../adapters/supabase/activity_processing_adapter.dart';\r\nimport '../trip_port.dart';\r\nimport '../activity_processing_port.dart';\r\nimport '../../../adapters/supabase/activity_hours_adapter.dart';\r\nimport '../activity_hours_port.dart';\r\n\r\nfinal supabaseProvider = Provider((ref) => Supabase.instance.client);\r\n\r\nfinal tripPortProvider = Provider<TripPort>((ref) {\r\n  final supabase = Supabase.instance.client;  // Utilisation directe de Supabase.instance\r\n  return TripAdapter(supabase);\r\n});\r\n\r\nfinal activityProcessingPortProvider = Provider<ActivityProcessingPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return ActivityProcessingAdapter(supabase);\r\n});\r\n\r\nfinal activityHoursPortProvider = Provider<ActivityHoursPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return ActivityHoursAdapter(supabase);\r\n});",
      "info": {
        "size": 1079,
        "last_modified": "2025-04-16T13:25:27.1173144",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\scoring_providers.dart",
      "content": "// core/domain/providers/scoring_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'infrastructure_providers.dart';\r\nimport '../activity_scoring_port.dart';\r\nimport '../../../adapters/supabase/activity_scoring_adapter.dart';\r\nimport '../../services/scoring_service.dart';\r\n\r\nfinal scoringServiceProvider = Provider<ScoringService>((ref) {\r\n  return ScoringService();\r\n});\r\n\r\nfinal activityScoringPortProvider = Provider<ActivityScoringPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return ActivityScoringAdapter(supabase);\r\n});",
      "info": {
        "size": 579,
        "last_modified": "2025-04-16T13:25:27.1233235",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\search\\activity_distances_provider.dart",
      "content": "// lib/core/domain/ports/providers/search/activity_distances_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../models/activity/search/searchable_activity.dart';\r\nimport '../../../ports/search/activity_distance_calculation_port.dart';\r\nimport 'distance_providers.dart';\r\n\r\nfinal activityDistancesProvider = StateNotifierProvider<ActivityDistancesNotifier, Map<String, double>>((ref) {\r\n  final distanceCalculator = ref.watch(activityDistanceProvider);\r\n  return ActivityDistancesNotifier(distanceCalculator);\r\n});\r\n\r\nclass ActivityDistancesNotifier extends StateNotifier<Map<String, double>> {\r\n  final ActivityDistanceCalculationPort _distanceCalculator;\r\n\r\n  ActivityDistancesNotifier(this._distanceCalculator) : super({});\r\n\r\n  void cacheDistances(List<SearchableActivity> activities, LatLng userLocation) {\r\n    final newDistances = <String, double>{};\r\n\r\n    for (final activity in activities) {\r\n      final distance = _distanceCalculator.calculateDistance(\r\n        activityId: activity.base.id,\r\n        userLocation: userLocation,\r\n        activityLocation: LatLng(activity.base.latitude, activity.base.longitude),\r\n        approximateDistance: activity.approxDistanceKm,\r\n      );\r\n      newDistances[activity.base.id] = distance;\r\n    }\r\n\r\n    state = {...state, ...newDistances};\r\n  }\r\n\r\n  double? getDistance(String activityId) => state[activityId];\r\n\r\n  void clearCache() {\r\n    _distanceCalculator.clearCache();\r\n    state = {};\r\n  }\r\n}",
      "info": {
        "size": 1556,
        "last_modified": "2025-04-16T13:25:27.1303275",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\search\\distance_providers.dart",
      "content": "// lib/core/domain/providers/search/distance_providers.dart\r\n\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../../ports/search/activity_distance_calculation_port.dart';\r\nimport '../../../services/search/activity_distance_service.dart';\r\n\r\nfinal activityDistanceProvider = Provider<ActivityDistanceCalculationPort>((ref) {\r\n  return ActivityDistanceService();\r\n});",
      "info": {
        "size": 371,
        "last_modified": "2025-04-16T13:25:27.1358348",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\search\\subcategory_search_provider.dart",
      "content": "// lib/core/domain/providers/search/subcategory_search_provider.dart\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../search/subcategory_search_port.dart';\r\nimport '../../../models/shared/subcategory_model.dart';\r\nimport '../../../../adapters/supabase/search/subcategory_search_adapter.dart';\r\nimport '../../../../adapters/supabase/database_adapter.dart';\r\n\r\nfinal subcategorySearchProvider = Provider<SubcategorySearchPort>((ref) {\r\n  return SubcategorySearchAdapter(SupabaseService.client);\r\n});\r\n\r\nfinal subcategoriesProvider = FutureProvider<List<Subcategory>>((ref) async {\r\n  final subcategorySearchPort = ref.read(subcategorySearchProvider);\r\n  return subcategorySearchPort.getSubcategoriesForSearch();\r\n});",
      "info": {
        "size": 722,
        "last_modified": "2025-04-16T13:25:27.1433415",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\service_providers.dart",
      "content": "// core/domain/ports/providers/service_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../adapters/google_maps/maps_adapter.dart';\r\nimport '../../../adapters/google_maps/geocoding_adapter.dart';\r\nimport '../maps_port.dart';\r\nimport '../geocoding_port.dart';\r\nimport 'infrastructure_providers.dart';\r\nimport '../../services/location_service.dart';\r\n\r\n\r\n// Service de base pour les oprations de localisation\r\nfinal locationServiceProvider = Provider<LocationService>((ref) {\r\n  return LocationService(ref.watch(supabaseProvider));\r\n});\r\n\r\n// Service Google Maps qui dpend du LocationService\r\nfinal mapsServiceProvider = Provider<MapsPort>((ref) {\r\n  return GoogleMapsAdapter(ref.watch(locationServiceProvider));\r\n});\r\n\r\n// Service Geocoding qui dpend des deux prcdents\r\nfinal geocodingServiceProvider = Provider<GeocodingPort>((ref) {\r\n  return GeocodingAdapter(\r\n      ref.watch(locationServiceProvider),\r\n      ref.watch(mapsServiceProvider)\r\n  );\r\n});",
      "info": {
        "size": 1004,
        "last_modified": "2025-04-16T13:25:27.1548492",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\trip_activities_providers.dart",
      "content": "// lib/core/domain/ports/providers/trip_activities_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../ports/trip_activities_port.dart';\r\nimport '../../../adapters/supabase/trip_activities_adapter.dart';\r\nimport 'infrastructure_providers.dart';\r\n\r\nfinal tripActivitiesPortProvider = Provider<TripActivitiesPort>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  return TripActivitiesAdapter(supabase);\r\n});",
      "info": {
        "size": 454,
        "last_modified": "2025-04-16T13:25:27.1608581",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\providers\\use_case_providers.dart",
      "content": "// core/domain/ports/providers/use_case_providers.dart\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../use_cases/create_trip_use_case.dart';\r\nimport '../../use_cases/process_activities_use_case.dart';\r\nimport 'port_providers.dart';\r\nimport 'service_providers.dart';\r\n\r\nfinal createTripUseCaseProvider = Provider((ref) {\r\n  return CreateTripUseCase(\r\n      ref.watch(tripPortProvider),\r\n      ref.watch(geocodingServiceProvider)\r\n  );\r\n});\r\n\r\nfinal processActivitiesUseCaseProvider = Provider<ProcessActivitiesUseCase>((ref) {\r\n  final processingPort = ref.watch(activityProcessingPortProvider);\r\n  final tripPort = ref.watch(tripPortProvider);\r\n  return ProcessActivitiesUseCase(processingPort, tripPort);\r\n});",
      "info": {
        "size": 735,
        "last_modified": "2025-04-16T13:25:27.1663668",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\activity_details_port.dart",
      "content": "// features/search/domain/ports/activity_details_port.dart\r\n\r\nimport '../../../../core/domain/models/shared/activity_details_model.dart';\r\n\r\nabstract class ActivityDetailsPort {\r\n  Future<ActivityDetails> getActivityDetails(String activityId);\r\n}\r\n\r\n",
      "info": {
        "size": 250,
        "last_modified": "2025-04-16T13:25:27.1783814",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\activity_distance_calculation_port.dart",
      "content": "// lib/core/domain/ports/search/activity_distance_calculation_port.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nabstract class ActivityDistanceCalculationPort {\r\n  double calculateDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  });\r\n\r\n  // Facultatif : mthode pour nettoyer le cache si ncessaire\r\n  void clearCache();\r\n}",
      "info": {
        "size": 460,
        "last_modified": "2025-04-16T13:25:27.1848912",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\activity_search_port.dart",
      "content": "// lib/core/domain/ports/activity_search_port.dart\r\n\r\nimport '../../models/activity/search/searchable_activity.dart';\r\n\r\nabstract class ActivitySearchPort {\r\n  /// Rcupre les activits avec des filtres spcifiques\r\n  Future<List<SearchableActivity>> getActivitiesWithFilters({\r\n    required double latitude,\r\n    required double longitude,\r\n    required String cityId,\r\n    double? maxDistance,\r\n    String? categoryId,\r\n    String? subcategoryId,\r\n    bool? isWow,\r\n    double? minRating,\r\n    int? minRatingCount,\r\n    int? maxRatingCount,\r\n    bool? kidFriendly,\r\n    String orderBy = 'rating_avg',\r\n    String orderDirection = 'DESC',\r\n    int limit = 10,\r\n  });\r\n}",
      "info": {
        "size": 675,
        "last_modified": "2025-04-16T13:25:27.1913967",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\city_search_port.dart",
      "content": "// lib/core/domain/ports/city_search_port.dart\r\n\r\nimport '../../models/shared/city_model.dart';\r\n\r\n\r\nabstract class CitySearchPort {\r\n  Future<List<City>> searchCities(String? query);\r\n  Future<City?> getCityById(String id);\r\n}",
      "info": {
        "size": 227,
        "last_modified": "2025-04-16T13:25:27.1983993",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\search\\subcategory_search_port.dart",
      "content": "// lib/core/domain/ports/search/subcategory_search_port.dart\r\nimport '../../models/shared/subcategory_model.dart';\r\n\r\nabstract class SubcategorySearchPort {\r\n  Future<List<Subcategory>> getSubcategoriesForSearch();\r\n}",
      "info": {
        "size": 217,
        "last_modified": "2025-04-16T13:25:27.2049068",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\trip_activities_port.dart",
      "content": "// core/domain/ports/trip_activities_port.dart\r\n\r\nimport '../models/scored_activity.dart';\r\n\r\nabstract class TripActivitiesPort {\r\n  Future<void> saveFilteredActivities({\r\n    required String tripId,\r\n    required List<ScoredActivity> activities,\r\n    required bool isSuperwow,\r\n  });\r\n\r\n  Future<List<ScoredActivity>> getSuperwowActivities(String tripId);\r\n}",
      "info": {
        "size": 359,
        "last_modified": "2025-04-16T13:25:27.2159241",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\ports\\trip_port.dart",
      "content": "// core/domain/ports/trip_port.dart\r\n\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../models/shared/city_model.dart';\r\nimport '../use_cases/create_trip_use_case.dart'; // Pour CreateTripParams\r\n\r\n/// Port dfinissant les oprations de gestion des voyages\r\nabstract class TripPort {\r\n  /// Cre un nouveau voyage\r\n  Future<Trip> createTrip(CreateTripParams params, City departureCity);\r\n\r\n  /// Rcupre un voyage par son ID\r\n  Future<Trip> getTrip(String tripId);\r\n\r\n  /// Rcupre tous les voyages d'un utilisateur\r\n  Future<List<Trip>> getTripsForUser(String userId);\r\n}",
      "info": {
        "size": 599,
        "last_modified": "2025-04-16T13:25:27.2229317",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\available_time_calculation.service.dart",
      "content": "// lib/core/domain/services/empty_trips/available_time_calculation.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/available_time_calculation.port.dart';\r\nimport '../../../../common/constants/trip_constants.dart';\r\nimport '../../../../common/exceptions/calculation_exception.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\n\r\n/// Service ddi au calcul du temps disponible pour un emptyTrip, \r\n/// intgrant la dure des SW, le temps de trajet principal, et les pauses repas.\r\nclass AvailableTimeCalculationService implements AvailableTimeCalculationPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  AvailableTimeCalculationService(this._supabase);\r\n\r\n  /// Calcule le temps disponible global pour un [emptyTripId] donn, \r\n  /// sur un crneau [activityHours], selon [travelStyle] et [superWowIds].\r\n  Future<int> calculateAvailableTime({\r\n    required String emptyTripId,\r\n    required Map<String, dynamic> activityHours,\r\n    required String travelStyle,\r\n    required List<String> superWowIds,\r\n  }) async {\r\n    try {\r\n      // 1) Rcuprer la dure totale du emptyTrip (trajet principal)\r\n      print(' Activity Hours: $activityHours'); // Debug input\r\n      final totalDuration = await _getTotalDuration(emptyTripId);\r\n      print(' Total Duration: $totalDuration');\r\n\r\n      // 2) Calculer la dure des SW (selon travelStyle)\r\n      final swDuration = await calculateSuperWowDuration(\r\n        superWowIds: superWowIds,\r\n        travelStyle: travelStyle,\r\n      );\r\n      print(' SW Duration: $swDuration');\r\n\r\n      // 3) Calculer les pauses repas (mealBreaks)\r\n      final mealBreaks = calculateMealBreaksDuration(activityHours, travelStyle);\r\n      print(' Meal Breaks: $mealBreaks');\r\n\r\n      // 4) Calculer les heures totales (start -> end)\r\n      final totalActivityHours = _calculateTotalActivityHours(activityHours);\r\n      print(' Total Hours: $totalActivityHours');\r\n\r\n      // 5) Formule finale\r\n      final timeLeft = totalActivityHours - totalDuration - swDuration - mealBreaks;\r\n      print(' Time Left: $timeLeft');\r\n\r\n      print(' Calcul timeLeft => '\r\n          'totalActivityHours=$totalActivityHours, '\r\n          'totalDuration=$totalDuration, '\r\n          'swDuration=$swDuration, '\r\n          'mealBreaks=$mealBreaks, '\r\n          'timeLeft=$timeLeft');\r\n\r\n      return timeLeft;\r\n    } catch (e) {\r\n      throw CalculationException('Error calculating available time: $e');\r\n    }\r\n  }\r\n\r\n  /// Calcule le temps de repas en minutes (midi + soir ventuellement).\r\n  /// Se base sur lintervalle [activityHours] (start, end) \r\n  /// et des slots de repas dans [TripConstants].\r\n  @override\r\n  int calculateMealBreaksDuration(Map<String, dynamic> activityHours, String travelStyle) {\r\n    final baseDuration = TripConstants.mealDurationByStyle[travelStyle] ?? TripConstants.mealDurationByStyle['balanced']!;\r\n\r\n    int breaks = 0;\r\n    if (_slotIncludesLunch(activityHours)) breaks += baseDuration;\r\n    if (_slotIncludesDinner(activityHours)) breaks += baseDuration;\r\n    return breaks;\r\n  }\r\n\r\n  /// Rcupre le [total_duration] depuis la table `empty_daily_trips`.\r\n  /// Peut tre `0` si non trouv ou s'il s'agit d'un half_day minimal.\r\n  Future<int> _getTotalDuration(String emptyTripId) async {\r\n    final response = await _supabase\r\n        .from('empty_daily_trips')\r\n        .select('total_duration')\r\n        .eq('id', emptyTripId)\r\n        .single() as Map<String, dynamic>?;\r\n\r\n    if (response == null) {\r\n      print(' Aucune donne pour emptyDailyTrip $emptyTripId. Retourne 0.');\r\n      return 0;\r\n    }\r\n\r\n    final duration = (response['total_duration'] ?? 0) / 60;  // Conversion secondes -> minutes\r\n    return (duration is int ? duration : duration.round());\r\n  }\r\n\r\n  /// Convertit [activityHours] (start, end) en minutes totales. \r\n  /// Ex: \"10:00\" -> 600, \"18:00\" -> 1080 => total 480 minutes.\r\n  int _calculateTotalActivityHours(Map<String, dynamic> activityHours) {\r\n    final startStr = activityHours['start'] as String;\r\n    final endStr = activityHours['end'] as String;\r\n\r\n    final startMins = _convertTimeStringToMinutes(startStr);\r\n    final endMins = _convertTimeStringToMinutes(endStr);\r\n\r\n    final total = endMins - startMins;\r\n    if (total < 0) {\r\n      // Si jamais l'utilisateur a invers start/end, on peut retourner 0 ou throw\r\n      print(' Intervalle horaire ngatif ($startStr -> $endStr). Retourne 0.');\r\n      return 0;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  /// Vrifie si le crneau couvre au moins [12h-13h].\r\n  bool _slotIncludesLunch(Map<String, dynamic> activityHours) {\r\n    final start = activityHours['start'] as String;\r\n    final end = activityHours['end'] as String;\r\n\r\n    final activityStart = _convertTimeStringToMinutes(start);\r\n    final activityEnd = _convertTimeStringToMinutes(end);\r\n    final lunchStart = TripConstants.mealTimeSlots['lunch']!.$1 * 60; // 12 * 60\r\n    final lunchEnd = TripConstants.mealTimeSlots['lunch']!.$2 * 60;   // 13 * 60\r\n\r\n    // On veut s'assurer que l'intervalle [activityStart, activityEnd] \r\n    // recouvre [lunchStart, lunchEnd].\r\n    return activityStart <= lunchStart && activityEnd >= lunchEnd;\r\n  }\r\n\r\n  /// Vrifie si le crneau couvre au moins [19h-20h].\r\n  bool _slotIncludesDinner(Map<String, dynamic> activityHours) {\r\n    final start = activityHours['start'] as String;\r\n    final end = activityHours['end'] as String;\r\n\r\n    final activityStart = _convertTimeStringToMinutes(start);\r\n    final activityEnd = _convertTimeStringToMinutes(end);\r\n    final dinnerStart = TripConstants.mealTimeSlots['dinner']!.$1 * 60;  // 19*60\r\n    final dinnerEnd = TripConstants.mealTimeSlots['dinner']!.$2 * 60;    // 20*60\r\n\r\n    return activityStart <= dinnerStart && activityEnd >= dinnerEnd;\r\n  }\r\n\r\n  int _convertTimeStringToMinutes(String timeString) {\r\n    final parts = timeString.split(':');\r\n    final hour = int.parse(parts[0]);\r\n    final minute = int.parse(parts[1]);\r\n    return hour * 60 + minute;\r\n  }\r\n\r\n  /// Calcule la dure totale des SW en minutes (selon min/max)\r\n  /// et le [travelStyle] (relax=prend max, active=min, balanced=moyenne).\r\n  Future<int> calculateSuperWowDuration({\r\n    required List<String> superWowIds,\r\n    required String travelStyle,\r\n  }) async {\r\n    try {\r\n      // Si la liste est vide, retourner 0\r\n      if (superWowIds.isEmpty) return 0;\r\n\r\n      // Utiliser in() plutt que des eq() multiples\r\n      final response = await _supabase\r\n          .from('activities')\r\n          .select('min_duration_minutes, max_duration_minutes')\r\n          .inFilter('id', superWowIds);\r\n\r\n      if (response == null || (response as List).isEmpty) {\r\n        throw CalculationException('No activities found for given SuperWow IDs');\r\n      }\r\n\r\n      // Calculer la dure totale\r\n      int totalDuration = 0;\r\n      for (final activity in response) {\r\n        final minDuration = (activity['min_duration_minutes'] as num).toInt();\r\n        final maxDuration = (activity['max_duration_minutes'] as num).toInt();\r\n\r\n        // Utiliser le style pour dterminer la dure\r\n        totalDuration += TravelStyle.values\r\n            .firstWhere((e) => e.name == travelStyle)\r\n            .getDurationMinutes(minDuration, maxDuration);\r\n      }\r\n\r\n      return totalDuration;\r\n    } catch (e) {\r\n      throw CalculationException('Error calculating SW duration: $e');\r\n    }\r\n  }\r\n\r\n  Future<Map<DateTime, int>> calculateAvailableTimeForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Map<String, Map<String, String?>> dailyHours,\r\n    required String travelStyle,\r\n  }) async {\r\n    Map<DateTime, int> timeByDate = {};\r\n\r\n    for (var entry in dailyHours.entries) {\r\n      final date = DateTime.parse(entry.key);\r\n      final hours = entry.value;\r\n\r\n      if (hours['start'] == null || hours['end'] == null) continue;\r\n\r\n      // Vrifier compatibilit type/dure\r\n      final isDailyTypeCompatible = _checkDailyTypeCompatibility(hours, emptyTrip.type);\r\n      if (!isDailyTypeCompatible) continue;\r\n\r\n      final timeLeft = await calculateAvailableTime(\r\n        emptyTripId: emptyTrip.id,\r\n        activityHours: {\r\n          'start': hours['start']!,\r\n          'end': hours['end']!,\r\n        },\r\n        travelStyle: travelStyle,\r\n        superWowIds: emptyTrip.sw2Id != null ? [emptyTrip.sw1Id, emptyTrip.sw2Id!] : [emptyTrip.sw1Id],\r\n      );\r\n\r\n      timeByDate[date] = timeLeft;\r\n    }\r\n\r\n    return timeByDate;\r\n  }\r\n\r\n  bool _checkDailyTypeCompatibility(Map<String, String?> hours, DailyTripType tripType) {\r\n    final startTime = _convertTimeStringToMinutes(hours['start']!);\r\n    final endTime = _convertTimeStringToMinutes(hours['end']!);\r\n    final duration = endTime - startTime;\r\n\r\n    return tripType == DailyTripType.full_day ? duration >= 360 : duration < 360; // 6h seuil\r\n  }\r\n\r\n\r\n}\r\n",
      "info": {
        "size": 8987,
        "last_modified": "2025-04-16T13:25:27.234443",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\bonus_activities_cache.service.dart",
      "content": "// lib/core/domain/services/empty_trips/bonus_activities_cache.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/bonus_activities_cache.port.dart';\r\nimport '../../../../common/exceptions/calculation_exception.dart';\r\n\r\nclass BonusActivitiesCacheService implements BonusActivitiesCachePort {\r\n  final SupabaseClient _supabase;\r\n  static const String _tableName = 'empty_trip_bonus_activities';\r\n\r\n  BonusActivitiesCacheService(this._supabase);\r\n\r\n  @override\r\n  Future<void> cacheEmptyTripBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Map<String, dynamic>> bonusActivities,\r\n  }) async {\r\n    try {\r\n      for (var activity in bonusActivities) {\r\n        // Vrifier si la combinaison existe dj\r\n        final existing = await _supabase\r\n            .from(_tableName)\r\n            .select()\r\n            .eq('empty_daily_trip_id', emptyTripId)\r\n            .eq('activity_id', activity['id'])\r\n            .maybeSingle();\r\n\r\n        if (existing == null) {\r\n          // Si elle n'existe pas, l'insrer\r\n          await _supabase\r\n              .from(_tableName)\r\n              .insert({\r\n            'empty_daily_trip_id': emptyTripId,\r\n            'activity_id': activity['id'],\r\n            'malus_vol_oiseau': activity['malus'],\r\n          });\r\n        }\r\n      }\r\n    } catch (e) {\r\n      throw CalculationException('Failed to cache bonus activities: $e');\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<List<Map<String, dynamic>>> getCachedBonusActivities(String emptyTripId) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from(_tableName)\r\n          .select()\r\n          .eq('empty_daily_trip_id', emptyTripId);\r\n\r\n      return List<Map<String, dynamic>>.from(response);\r\n    } catch (e) {\r\n      throw CalculationException('Failed to get cached bonus activities: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1893,
        "last_modified": "2025-04-16T13:25:27.2409504",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\bonus_activity_generation.service.dart",
      "content": "// lib/core/domain/services/empty_trips/bonus_activity_generation.service.dart\r\n\r\nimport 'package:uuid/uuid.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../models/trip_designer/trip/activity_model.dart';\r\nimport '../../../models/trip_designer/trip/trip_model.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\nimport '../../../../common/exceptions/geometry_calculation_exception.dart';\r\nimport '../../../ports/empty_trips/geometry_calculation.port.dart';\r\nimport 'distance_calculation.service.dart';\r\nimport 'available_time_calculation.service.dart';\r\n\r\nclass BonusActivityGenerationService {\r\n  final GeometryCalculationPort _geometryPort;\r\n  final DistanceCalculationService _distanceService;\r\n  final AvailableTimeCalculationService _availableTimeService;\r\n\r\n  BonusActivityGenerationService(\r\n      this._geometryPort,\r\n      this._distanceService,\r\n      this._availableTimeService,\r\n      );\r\n\r\n  Future<List<PotentialBonusActivity>> generatePotentialBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Activity> availableActivities,\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Trip trip,\r\n  }) async {\r\n    try {\r\n      final potentialBonusActivities = <PotentialBonusActivity>[];\r\n\r\n      for (final activity in availableActivities) {\r\n        if (_isActivitySuperWow(activity.id, emptyTrip)) continue;\r\n\r\n        try {\r\n          final malus = await _distanceService.calculateActivityMalus(\r\n            activityLocation: LatLng(\r\n                activity.latitude.toDouble(),\r\n                activity.longitude.toDouble()\r\n            ),\r\n            tripStart: _getLocationFromGeohash(emptyTrip.departureGeohash5),\r\n            tripEnd: _getLocationFromGeohash(emptyTrip.arrivalGeohash5),\r\n            travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n          );\r\n\r\n          potentialBonusActivities.add(\r\n              PotentialBonusActivity(\r\n                id: const Uuid().v4(),\r\n                emptyDailyTripId: emptyTripId,\r\n                activityId: activity.id,\r\n                malusVolOiseau: malus,\r\n                tripDate: trip.startDate,\r\n                createdAt: DateTime.now(),\r\n                updatedAt: DateTime.now(),\r\n              )\r\n          );\r\n        } catch (e) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      return potentialBonusActivities;\r\n    } catch (e) {\r\n      throw GeometryCalculationException(\r\n          'Failed to generate potential bonus activities: $e'\r\n      );\r\n    }\r\n  }\r\n\r\n  LatLng _getLocationFromGeohash(String geohash) {\r\n    try {\r\n      final GeoHasher geoHasher = GeoHasher();\r\n      final List<double> coordinates = geoHasher.decode(geohash);\r\n      // GeoHasher retourne [longitude, latitude] donc on inverse pour LatLng\r\n      return LatLng(coordinates[1], coordinates[0]);\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to decode geohash: $e');\r\n    }\r\n  }\r\n\r\n  bool _isActivitySuperWow(String activityId, EmptyDailyTrip emptyTrip) {\r\n    return activityId == emptyTrip.sw1Id || activityId == emptyTrip.sw2Id;\r\n  }\r\n\r\n  Future<Map<DateTime, int>> calculateAvailableTimeForAllDates({\r\n    required String emptyTripId,\r\n    required Map<String, Map<String, String?>> dailyHours,\r\n    required String travelStyle,\r\n    required List<String> superWowIds,\r\n  }) async {\r\n    final Map<DateTime, int> availableTimeByDate = {};\r\n\r\n    for (var entry in dailyHours.entries) {\r\n      final date = DateTime.parse(entry.key);\r\n      final hours = entry.value;\r\n\r\n      if (hours['start'] != null && hours['end'] != null) {\r\n        final activityHoursMap = {\r\n          'start': hours['start']!,\r\n          'end': hours['end']!,\r\n        };\r\n\r\n        final availableTime = await _availableTimeService.calculateAvailableTime(\r\n          emptyTripId: emptyTripId,\r\n          activityHours: activityHoursMap,\r\n          travelStyle: travelStyle,\r\n          superWowIds: superWowIds,\r\n        );\r\n\r\n        availableTimeByDate[date] = availableTime;\r\n      }\r\n    }\r\n\r\n    return availableTimeByDate;\r\n  }\r\n\r\n}",
      "info": {
        "size": 4244,
        "last_modified": "2025-04-16T13:25:27.2469497",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\distance_calculation.service.dart",
      "content": "// lib/core/domain/services/designer/empty_trips/distance_calculation.service.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'dart:math' show sin, cos, sqrt, atan2, pi;\r\nimport '../../../models/trip_designer/bonus_activities/value_objects/malus_vol_oiseau.dart';\r\nimport '../../../ports/empty_trips/geometry_calculation.port.dart';\r\nimport '../../../../common/constants/geometry_constants.dart';\r\nimport '../../../../common/exceptions/geometry_calculation_exception.dart';\r\n\r\nclass DistanceCalculationService {\r\n  final GeometryCalculationPort? _geometryPort; // Optional pour compatibilit\r\n\r\n  DistanceCalculationService([this._geometryPort]);\r\n\r\n  /// Mthodes existantes\r\n  double calculateDistance(\r\n      LatLng point1,\r\n      LatLng point2, {\r\n        double roadFactor = 1.4\r\n      }) {\r\n    const earthRadius = 6371000;\r\n\r\n    final lat1 = point1.latitude * pi / 180;\r\n    final lat2 = point2.latitude * pi / 180;\r\n    final dLat = (point2.latitude - point1.latitude) * pi / 180;\r\n    final dLon = (point2.longitude - point1.longitude) * pi / 180;\r\n\r\n    final a = sin(dLat/2) * sin(dLat/2) +\r\n        cos(lat1) * cos(lat2) * sin(dLon/2) * sin(dLon/2);\r\n    final c = 2 * atan2(sqrt(a), sqrt(1-a));\r\n\r\n    return (earthRadius * c) * roadFactor;\r\n  }\r\n\r\n  int estimateTravelTime(double distanceMeters, {double averageSpeedKmh = 50}) {\r\n    final speedMeterPerSecond = averageSpeedKmh / 3.6;\r\n    return (distanceMeters / speedMeterPerSecond).round();\r\n  }\r\n\r\n  /// Nouvelles mthodes pour bonus activities\r\n  Future<MalusVolOiseau> calculateActivityMalus({\r\n    required LatLng activityLocation,\r\n    required LatLng tripStart,\r\n    required LatLng tripEnd,\r\n    required String travelStyle,\r\n  }) async {\r\n    try {\r\n      if (_geometryPort != null) {\r\n        // Utilisation du port si disponible\r\n        final isWithinDetour = await _geometryPort!.isWithinMaxDetour(\r\n            activityLocation,\r\n            tripStart,\r\n            tripEnd\r\n        );\r\n\r\n        if (!isWithinDetour) {\r\n          throw GeometryCalculationException('Activity is outside acceptable detour range');\r\n        }\r\n\r\n        final detourDistance = await _calculateDetourDistanceWithPort(\r\n            activityLocation,\r\n            tripStart,\r\n            tripEnd\r\n        );\r\n\r\n        final malusMinutes = await _geometryPort!.calculateMalusMinutes(\r\n            detourDistance,\r\n            travelStyle\r\n        );\r\n\r\n        return MalusVolOiseau.fromInt(malusMinutes);\r\n      } else {\r\n        // Fallback vers le calcul local si pas de port\r\n        return _calculateMalusLocally(\r\n            activityLocation,\r\n            tripStart,\r\n            tripEnd,\r\n            travelStyle\r\n        );\r\n      }\r\n    } catch (e) {\r\n      throw GeometryCalculationException('Failed to calculate activity malus: $e');\r\n    }\r\n  }\r\n\r\n  Future<double> _calculateDetourDistanceWithPort(\r\n      LatLng activityPoint,\r\n      LatLng start,\r\n      LatLng end\r\n      ) async {\r\n    final directDistance = await _geometryPort!.calculateDistance(start, end);\r\n    final detourDistance = await _geometryPort!.calculateDistance(start, activityPoint) +\r\n        await _geometryPort!.calculateDistance(activityPoint, end);\r\n\r\n    return detourDistance - directDistance;\r\n  }\r\n\r\n  MalusVolOiseau _calculateMalusLocally(\r\n      LatLng activityLocation,\r\n      LatLng tripStart,\r\n      LatLng tripEnd,\r\n      String travelStyle,\r\n      ) {\r\n    final directDistance = calculateDistance(tripStart, tripEnd);\r\n    final detourDistance = calculateDistance(tripStart, activityLocation) +\r\n        calculateDistance(activityLocation, tripEnd);\r\n\r\n    if (detourDistance > directDistance + (GeometryConstants.maxDetourDistanceKm * 1000)) {\r\n      throw GeometryCalculationException('Activity is outside acceptable detour range');\r\n    }\r\n\r\n    final factor = switch(travelStyle) {\r\n      'relax' => GeometryConstants.relaxedTravelFactor,\r\n      'active' => GeometryConstants.activeTravelFactor,\r\n      _ => GeometryConstants.balancedTravelFactor\r\n    };\r\n\r\n    final estimatedMinutes = estimateTravelTime(detourDistance - directDistance) * factor / 60;\r\n\r\n    return MalusVolOiseau.fromInt(estimatedMinutes.round().clamp(\r\n        GeometryConstants.minimumMalusMinutes,\r\n        GeometryConstants.maximumMalusMinutes\r\n    ));\r\n  }\r\n}",
      "info": {
        "size": 4333,
        "last_modified": "2025-04-16T13:25:27.2534555",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\empty_trip_generation.service.dart",
      "content": "// lib/core/domain/services/empty_trips/empty_trip_generation.service.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\nimport '../../../../common/enums/trip_enums.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../models/trip_designer/empty_trips/value_objects/generation_result.dart';\r\nimport '../../../models/trip_designer/empty_trips/value_objects/superwow_pair.dart';\r\nimport '../../../models/scored_activity.dart';\r\nimport '../../../ports/empty_trips/empty_daily_trip.port.dart';\r\nimport '../../../ports/empty_trips/route_optimization.port.dart';\r\nimport '../../../ports/empty_trips/superwow_management.port.dart';\r\nimport '../../../ports/empty_trips/neighbor_geohashes.port.dart';\r\nimport '../../../../common/exceptions/empty_trip_generation_exception.dart';\r\n\r\n\r\nclass EmptyTripGenerationService {\r\n  final SuperWowManagementPort _superwowPort;\r\n  final RouteOptimizationPort _routePort;\r\n  final EmptyDailyTripPort _emptyTripPort;\r\n  final NeighborGeohashesPort _neighborGeohashesService;\r\n  final SupabaseClient _supabase;\r\n\r\n  EmptyTripGenerationService(\r\n      this._superwowPort,\r\n      this._routePort,\r\n      this._emptyTripPort,\r\n      this._neighborGeohashesService,\r\n      this._supabase);\r\n\r\n  Future<EmptyTripGenerationResult> generateEmptyTrips(String tripId) async {\r\n    try {\r\n      print(' Dbut de la gnration des empty trips');\r\n      final errors = <String>[];\r\n\r\n      final tripInfo = await _getTripInfo(tripId);\r\n      final superWows = await _superwowPort.getTripSuperWows(tripId);\r\n      final optimizedPairs = await _superwowPort.generateOptimizedPairs(\r\n        tripId,\r\n        superWows,\r\n        _getLatLngFromGeohash(tripInfo['departure_geohash5']),\r\n      );\r\n\r\n      final halfDayResults = await _generateHalfDayTrips(tripInfo, superWows);\r\n      final fullDayResults = await _generateFullDayTrips(\r\n          tripInfo, optimizedPairs);\r\n\r\n      return EmptyTripGenerationResult(\r\n        halfDayTrips: halfDayResults.$1,\r\n        fullDayTrips: fullDayResults.$1,\r\n        departureGeohash5: tripInfo['departure_geohash5'],\r\n        errors: [...halfDayResults.$2, ...fullDayResults.$2],\r\n      );\r\n    } catch (e) {\r\n      print(' Erreur gnration empty trips: $e');\r\n      throw EmptyTripGenerationException(\r\n          'Erreur lors de la gnration des empty trips: $e');\r\n    }\r\n  }\r\n\r\n  Future<(List<EmptyDailyTrip>, List<String>)> _generateHalfDayTrips(\r\n      Map<String, dynamic> tripInfo,\r\n      List<ScoredActivity> superWows,) async {\r\n    final emptyTrips = <EmptyDailyTrip>[];\r\n    final errors = <String>[];\r\n\r\n    for (final sw in superWows) {\r\n      final swLocation = LatLng(\r\n        sw.activityData['latitude'],\r\n        sw.activityData['longitude'],\r\n      );\r\n\r\n      final result = await _generateEmptyTripsCommon(\r\n        type: DailyTripType.half_day,\r\n        departureGeohash5: tripInfo['departure_geohash5'],\r\n        sw1Id: sw.id,\r\n        waypoints: [swLocation],\r\n      );\r\n\r\n      emptyTrips.addAll(result.$1);\r\n      errors.addAll(result.$2);\r\n    }\r\n\r\n    return (emptyTrips, errors);\r\n  }\r\n\r\n  Future<(List<EmptyDailyTrip>, List<String>)> _generateFullDayTrips(\r\n      Map<String, dynamic> tripInfo,\r\n      List<SuperWowPair> optimizedPairs,) async {\r\n    final emptyTrips = <EmptyDailyTrip>[];\r\n    final errors = <String>[];\r\n\r\n    for (final pair in optimizedPairs) {\r\n      final result = await _generateEmptyTripsCommon(\r\n        type: DailyTripType.full_day,\r\n        departureGeohash5: tripInfo['departure_geohash5'],\r\n        sw1Id: pair.sw1Id,\r\n        sw2Id: pair.sw2Id,\r\n        waypoints: [pair.sw1Location, pair.sw2Location],\r\n      );\r\n\r\n      emptyTrips.addAll(result.$1);\r\n      errors.addAll(result.$2);\r\n    }\r\n\r\n    return (emptyTrips, errors);\r\n  }\r\n\r\n  Future<(List<EmptyDailyTrip>, List<String>)> _generateEmptyTripsCommon({\r\n    required DailyTripType type,\r\n    required String departureGeohash5,\r\n    required String sw1Id,\r\n    String? sw2Id,\r\n    required List<LatLng> waypoints,\r\n  }) async {\r\n    final errors = <String>[];\r\n    try {\r\n      final existingTrip = await _emptyTripPort.findExistingEmptyTrip(\r\n        type: type,\r\n        departureGeohash5: departureGeohash5,\r\n        arrivalGeohash5: departureGeohash5,\r\n        sw1Id: sw1Id,\r\n        sw2Id: sw2Id,\r\n      );\r\n\r\n      if (existingTrip != null) {\r\n        return (<EmptyDailyTrip>[existingTrip], errors);\r\n      }\r\n\r\n      final departurePoint = _getLatLngFromGeohash(departureGeohash5);\r\n      final arrivalPoint = LatLng(\r\n          departurePoint.latitude + 0.001,\r\n          departurePoint.longitude + 0.001\r\n      );\r\n\r\n      final route = await _routePort.getOptimizedRoute(\r\n        departurePoint,\r\n        arrivalPoint,\r\n        waypoints,\r\n      );\r\n\r\n      final newTrip = await _emptyTripPort.createEmptyTrip(\r\n        type: type,\r\n        departureGeohash5: departureGeohash5,\r\n        arrivalGeohash5: departureGeohash5,\r\n        sw1Id: sw1Id,\r\n        sw2Id: sw2Id,\r\n        traversedGeohashes: route['traversed_geohashes'],\r\n        routePolyline: route['polyline'],\r\n        totalDistance: route['distance'],\r\n        totalDuration: route['duration'],\r\n      );\r\n\r\n      print(' About to generate neighbors');\r\n      print('  Empty Trip ID: ${newTrip.id}');\r\n      print('  Traversed geohashes: ${route['traversed_geohashes']}');\r\n\r\n      await _neighborGeohashesService.generateAndSaveNeighbors(\r\n        emptyTripId: newTrip.id,\r\n        traversedGeohashes: route['traversed_geohashes'],\r\n      );\r\n\r\n      return (<EmptyDailyTrip>[newTrip], errors);\r\n    } catch (e) {\r\n      final error = 'Erreur gnration ${type.name} pour SW$sw1Id${sw2Id != null\r\n          ? \"-$sw2Id\"\r\n          : \"\"}: $e';\r\n      print(' $error');\r\n      errors.add(error);\r\n      return (<EmptyDailyTrip>[], errors);\r\n    }\r\n  }\r\n\r\n  int _calculateTotalDistance(List? legs) {\r\n    if (legs == null || legs.isEmpty) return 0;\r\n    return legs.fold<int>(\r\n        0, (sum, leg) => sum + (leg['distance']?['value'] as int? ?? 0));\r\n  }\r\n\r\n  int _calculateTotalDuration(List? legs) {\r\n    if (legs == null || legs.isEmpty) return 0;\r\n    return legs.fold<int>(\r\n        0, (sum, leg) => sum + (leg['duration']?['value'] as int? ?? 0));\r\n  }\r\n\r\n  Future<Map<String, dynamic>> _getTripInfo(String tripId) async {\r\n    final response = await _supabase\r\n        .from('trips')\r\n        .select('departure_geohash5, active_exploration_types')\r\n        .eq('id', tripId)\r\n        .single();\r\n\r\n    if (response['departure_geohash5'] == null) {\r\n      throw EmptyTripGenerationException('Geohash de dpart manquant');\r\n    }\r\n    return response;\r\n  }\r\n\r\n  LatLng _getLatLngFromGeohash(String geohash5) {\r\n    try {\r\n      final geohasher = GeoHasher();\r\n      final coordinates = geohasher.decode(geohash5);\r\n      // Inverser coordinates[0] et coordinates[1] car GeoHasher retourne [lng, lat]\r\n      final lat = double.parse(coordinates[1].toStringAsFixed(6));\r\n      final lng = double.parse(coordinates[0].toStringAsFixed(6));\r\n\r\n      print(' Conversion geohash $geohash5  $lat,$lng');\r\n      return LatLng(lat, lng);\r\n    } catch (e) {\r\n      print(' Erreur dcodage geohash: $e');\r\n      throw EmptyTripGenerationException(\r\n          'Impossible de dcoder le geohash $geohash5');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 7477,
        "last_modified": "2025-04-16T13:25:27.2599605",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\neighbor_geohashes.service.dart",
      "content": "// lib/core/domain/services/empty_trips/neighbor_geohashes.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/neighbor_geohashes.port.dart';\r\n\r\n// lib/core/domain/services/empty_trips/neighbor_geohashes.service.dart\r\n\r\nclass NeighborGeohashesService implements NeighborGeohashesPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  NeighborGeohashesService(this._supabase);\r\n\r\n  @override\r\n  Future<void> generateAndSaveNeighbors({\r\n    required String emptyTripId,\r\n    required List<String> traversedGeohashes,\r\n  }) async {\r\n    try {\r\n      print(' Processing neighbors for empty trip: $emptyTripId');\r\n      Map<String, Map<String, dynamic>> neighborsWithClosest = {};\r\n\r\n      for (var routeGeohash in traversedGeohashes) {\r\n        final neighbors = await _supabase\r\n            .from('geohash5_distances')\r\n            .select()\r\n            .eq('geohash5_origin', routeGeohash)\r\n            .lte('center_distance_km', 30.0);\r\n\r\n        for (var neighbor in neighbors) {\r\n          final neighborGeohash = neighbor['geohash5_neighbor'];\r\n          final distance = (neighbor['center_distance_km'] * 1000).round();\r\n\r\n          if (!neighborsWithClosest.containsKey(neighborGeohash) ||\r\n              distance < neighborsWithClosest[neighborGeohash]!['distance_to_route']) {\r\n            neighborsWithClosest[neighborGeohash] = {\r\n              'closest_route_geohash5': routeGeohash,\r\n              'distance_to_route': distance\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      if (neighborsWithClosest.isNotEmpty) {\r\n        final dataToUpsert = neighborsWithClosest.entries.map((e) => ({\r\n          'empty_trip_id': emptyTripId,\r\n          'geohash5': e.key,\r\n          'closest_route_geohash5': e.value['closest_route_geohash5'],\r\n          'distance_to_route': e.value['distance_to_route'],\r\n        })).toList();\r\n\r\n        await _supabase\r\n            .from('empty_trip_neighbor_geohashes')\r\n            .upsert(dataToUpsert);\r\n\r\n        print(' Saved ${dataToUpsert.length} unique neighbors');\r\n      }\r\n    } catch (e) {\r\n      print(' Error: $e');\r\n      rethrow;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Future<Map<String, Map<String, dynamic>>> getNeighborGeohashes(String emptyTripId) async {\r\n    final response = await _supabase\r\n        .from('empty_trip_neighbor_geohashes')\r\n        .select()\r\n        .eq('empty_trip_id', emptyTripId);\r\n\r\n    return Map.fromEntries(\r\n        (response as List).map((n) => MapEntry(\r\n            n['geohash5'] as String,\r\n            {\r\n              'closest_route_geohash5': n['closest_route_geohash5'],\r\n              'distance_to_route': n['distance_to_route']\r\n            }\r\n        ))\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2725,
        "last_modified": "2025-04-16T13:25:27.2665166",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\notifier\\potential_bonus_activities.notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/potential_bonus_activities.notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../models/trip_designer/bonus_activities/potential_bonus_activity.dart';\r\nimport '../../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../../models/trip_designer/trip/activity_model.dart';\r\nimport '../../../../models/trip_designer/trip/trip_model.dart';\r\nimport '../bonus_activity_generation.service.dart';\r\nimport '../../../../../../core/adapters/supabase/potential_bonus_activity.adapter.dart';\r\n\r\n\r\nclass PotentialBonusActivitiesNotifier extends StateNotifier<AsyncValue<List<PotentialBonusActivity>>> {\r\n  final PotentialBonusActivityAdapter _adapter;\r\n  final BonusActivityGenerationService _generationService;\r\n\r\n  PotentialBonusActivitiesNotifier(this._adapter, this._generationService)\r\n      : super(const AsyncValue.loading());\r\n\r\n  Future<void> generateAndSavePotentialBonusActivities({\r\n    required String emptyTripId,\r\n    required List<Activity> availableActivities,\r\n    required EmptyDailyTrip emptyTrip,\r\n    required Trip trip,\r\n  }) async {\r\n    try {\r\n      state = const AsyncValue.loading();\r\n\r\n      final potentialActivities = await _generationService.generatePotentialBonusActivities(\r\n        emptyTripId: emptyTripId,\r\n        availableActivities: availableActivities,\r\n        emptyTrip: emptyTrip,\r\n        trip: trip,\r\n      );\r\n\r\n      await _adapter.savePotentialBonusActivities(potentialActivities);\r\n\r\n      state = AsyncValue.data(potentialActivities);\r\n    } catch (e, st) {\r\n      state = AsyncValue.error(e, st);\r\n    }\r\n  }\r\n\r\n  Future<void> loadPotentialBonusActivities(String emptyTripId) async {\r\n    try {\r\n      state = const AsyncValue.loading();\r\n\r\n      final activities = await _adapter.getPotentialBonusActivities(\r\n        emptyTripId: emptyTripId,\r\n      );\r\n\r\n      state = AsyncValue.data(activities);\r\n    } catch (e, st) {\r\n      state = AsyncValue.error(e, st);\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2030,
        "last_modified": "2025-04-16T13:25:27.2730234",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\empty_trips\\potential_activities.service.dart",
      "content": "// lib/core/domain/services/empty_trips/potential_activities.service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../ports/empty_trips/potential_activities.port.dart';\r\nimport '../../../models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../models/trip_designer/trip/activity_model.dart';\r\nimport '../../../../common/exceptions/calculation_exception.dart';\r\n\r\nclass PotentialActivitiesService implements PotentialActivitiesPort {\r\n  final SupabaseClient _supabase;\r\n\r\n  PotentialActivitiesService(this._supabase);\r\n\r\n  @override\r\n  Future<Map<String, List<Activity>>> getFilteredActivitiesForEmptyTrip({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required String tripId,\r\n    required Map<DateTime, int> availableTimeByDate,\r\n  }) async {\r\n    try {\r\n      // 1. Filtrer les dates avec du temps disponible\r\n      final validDates = availableTimeByDate.entries\r\n          .where((entry) => entry.value > 0)\r\n          .map((e) => e.key)\r\n          .toList();\r\n\r\n      if (validDates.isEmpty) return {};\r\n\r\n      // 2. Rcuprer les activits depuis trip_activities\r\n      final response = await _supabase\r\n          .from('trip_activities')\r\n          .select('activity_id, planned_date')\r\n          .eq('trip_id', tripId);\r\n\r\n      // 3. Convertir en Map date -> List<Activity>\r\n      Map<String, List<Activity>> activitiesByDate = {};\r\n\r\n      for (final date in validDates) {\r\n        final activities = await _getActivitiesForDate(\r\n          emptyTrip: emptyTrip,\r\n          tripId: tripId,\r\n          date: date,\r\n          existingActivityIds: (response as List)\r\n              .where((r) => r['planned_date'] == date.toIso8601String())\r\n              .map((r) => r['activity_id'] as String)\r\n              .toList(),\r\n        );\r\n\r\n        if (activities.isNotEmpty) {\r\n          activitiesByDate[date.toIso8601String()] = activities;\r\n        }\r\n      }\r\n\r\n      return activitiesByDate;\r\n    } catch (e) {\r\n      throw CalculationException('Error getting filtered activities: $e');\r\n    }\r\n  }\r\n\r\n  Future<List<Activity>> _getActivitiesForDate({\r\n    required EmptyDailyTrip emptyTrip,\r\n    required String tripId,\r\n    required DateTime date,\r\n    required List<String> existingActivityIds,\r\n  }) async {\r\n    // Exclure les SW\r\n    final excludeIds = [...existingActivityIds, emptyTrip.sw1Id];\r\n    if (emptyTrip.sw2Id != null) excludeIds.add(emptyTrip.sw2Id!);\r\n\r\n    // Rcuprer les activits dans le geohash5\r\n    final response = await _supabase\r\n        .from('activities')\r\n        .select()\r\n        .eq('geohash_5', emptyTrip.departureGeohash5)\r\n        .not('id', 'in', excludeIds);\r\n\r\n    return (response as List)\r\n        .map((json) => Activity.fromJson(json))\r\n        .toList();\r\n  }\r\n}",
      "info": {
        "size": 2776,
        "last_modified": "2025-04-16T13:25:27.2840375",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\designer\\trip_distance_service.dart",
      "content": "// lib/core/domain/services/distance_service.dart\r\n\r\nimport '../../../common/utils/maps_toolkit_utils.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\n\r\nclass DistanceService {\r\n  // Cache des distances calcules\r\n  final Map<String, double> _distanceCache = {};\r\n\r\n  // Cl de cache combinant l'ID de l'activit et la position utilisateur\r\n  String _getCacheKey(String activityId, LatLng userLocation) {\r\n    return '$activityId-${userLocation.latitude}-${userLocation.longitude}';\r\n  }\r\n\r\n  double getDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  }) {\r\n    final cacheKey = _getCacheKey(activityId, userLocation);\r\n\r\n    // Vrifier le cache d'abord\r\n    if (_distanceCache.containsKey(cacheKey)) {\r\n      return _distanceCache[cacheKey]!;\r\n    }\r\n\r\n    // Sinon calculer la distance prcise\r\n    final distance = MapsToolkitUtils.calculateHaversineDistance(\r\n      userLocation,\r\n      activityLocation,\r\n    );\r\n\r\n    // Mettre en cache\r\n    _distanceCache[cacheKey] = distance;\r\n\r\n    return distance;\r\n  }\r\n}",
      "info": {
        "size": 1151,
        "last_modified": "2025-04-16T13:25:27.2960534",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\google_services_config.dart",
      "content": "// core/domain/services/google_services_config.dart\r\n\r\n\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\n\r\nclass GoogleServicesConfig {\r\n  final String mapsApiKey;\r\n  final String aiStudioApiKey;\r\n\r\n  GoogleServicesConfig._({\r\n    required this.mapsApiKey,\r\n    required this.aiStudioApiKey,\r\n  });\r\n\r\n  static Future<GoogleServicesConfig> init() async {\r\n    await dotenv.load();\r\n    return GoogleServicesConfig._(\r\n      mapsApiKey: dotenv.env['GOOGLE_MAPS_API_KEY'] ?? '',\r\n      aiStudioApiKey: dotenv.env['GOOGLE_AI_STUDIO_API_KEY'] ?? '',\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 567,
        "last_modified": "2025-04-16T13:25:27.3077319",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\location\\enhanced_location_service.dart",
      "content": "// lib/core/domain/services/location/enhanced_location_service.dart\r\n\r\nimport 'package:async/async.dart';\r\nimport 'package:geolocator/geolocator.dart';\r\nimport '../../../domain/models/location/user_location.dart';\r\nimport '../../../domain/models/location/place_suggestion.dart';\r\nimport '../../../domain/models/location/place_details.dart';\r\nimport '../../../domain/models/shared/city_model.dart';\r\nimport '../../../domain/ports/location/location_cache_port.dart';\r\nimport '../../../domain/ports/location/city_cache_port.dart';\r\nimport '../../../adapters/google_maps/maps_adapter.dart';\r\nimport '../../../common/utils/debouncer.dart';\r\nimport '../../../common/constants/location_constants.dart';\r\n\r\nclass EnhancedLocationService {\r\n  final GoogleMapsAdapter _mapsAdapter;\r\n  final LocationCachePort _locationCache;\r\n  final Debouncer _searchDebouncer;\r\n  final CityCachePort _cityCache;\r\n\r\n  EnhancedLocationService({\r\n    required GoogleMapsAdapter mapsAdapter,\r\n    required LocationCachePort locationCache,\r\n    required CityCachePort cityCache,\r\n  }) : _mapsAdapter = mapsAdapter,\r\n        _locationCache = locationCache,\r\n        _cityCache = cityCache,\r\n        _searchDebouncer = Debouncer(\r\n          milliseconds: LocationConstants.searchDebounceTime,\r\n        );\r\n\r\n  /// Recherche de lieux avec debounce\r\n  void searchPlacesWithDebounce(\r\n      String query,\r\n      Function(Result<List<PlaceSuggestion>>) callback,\r\n      ) {\r\n    _searchDebouncer.run(() async {\r\n      // Recherche d'abord dans le cache\r\n      if (query.length >= 2) {\r\n        final cachedSuggestions = await _locationCache.getPlaceSuggestions(query);\r\n\r\n        if (cachedSuggestions.isNotEmpty) {\r\n          callback(Result.value(cachedSuggestions));\r\n        }\r\n      }\r\n\r\n      // Si la requte est trop courte, on arrte l\r\n      if (query.length < 3) {\r\n        return;\r\n      }\r\n\r\n      // Recherche via l'API\r\n      final result = await _mapsAdapter.searchPlaces(query);\r\n\r\n      if (result.isValue && result.asValue!.value.isNotEmpty) {\r\n        // Sauvegarder les rsultats dans le cache\r\n        await _locationCache.savePlaceSuggestions(result.asValue!.value);\r\n      }\r\n\r\n      callback(result);\r\n    });\r\n  }\r\n\r\n  /// Rcupre les dtails d'un lieu avec optimisation via la table cities\r\n  Future<Result<PlaceDetails>> getPlaceDetails(String placeId) async {\r\n    // TAPE 1: Vrifier d'abord dans le cache Hive local\r\n    final cachedDetails = await _locationCache.getPlaceDetails(placeId);\r\n    if (cachedDetails != null) {\r\n      print(' Dtails trouvs dans le cache local: ${cachedDetails.name}');\r\n      return Result.value(cachedDetails);\r\n    }\r\n\r\n    // TAPE 2: Vrifier ensuite dans la table cities de Supabase\r\n    final cachedCity = await _cityCache.getCityByPlaceId(placeId);\r\n    if (cachedCity != null) {\r\n      print(' Ville trouve dans la base de donnes: ${cachedCity.cityName}');\r\n\r\n      // Convertir City en PlaceDetails\r\n      final placeDetails = PlaceDetails(\r\n        placeId: cachedCity.placeId ?? cachedCity.id,\r\n        name: cachedCity.cityName,\r\n        formattedAddress: cachedCity.cityName,\r\n        location: UserLocation(\r\n          latitude: cachedCity.lat,\r\n          longitude: cachedCity.lon,\r\n          isFromGps: false,\r\n          timestamp: DateTime.now(),\r\n        ),\r\n        lastUpdated: DateTime.now(),\r\n      );\r\n\r\n      // Sauvegarder dans le cache local aussi\r\n      await _locationCache.savePlaceDetails(placeDetails);\r\n\r\n      return Result.value(placeDetails);\r\n    }\r\n\r\n    // TAPE 3: Si pas trouv, faire l'appel API\r\n    print(' Appel  l\\'API Google pour obtenir les dtails: $placeId');\r\n    final result = await _mapsAdapter.getPlaceDetailsById(placeId);\r\n\r\n    if (result.isValue) {\r\n      final placeDetails = result.asValue!.value;\r\n\r\n      // Sauvegarder dans le cache local\r\n      await _locationCache.savePlaceDetails(placeDetails);\r\n\r\n      // Sauvegarder dans la table cities\r\n      try {\r\n        await _cityCache.savePlaceDetailsAsCity(placeDetails);\r\n        print(' Ville sauvegarde dans la base de donnes: ${placeDetails.name}');\r\n      } catch (e) {\r\n        print(' Impossible de sauvegarder la ville: $e');\r\n        // On continue mme si la sauvegarde choue\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n\r\n  /// Rcupre la position actuelle\r\n  Future<Result<UserLocation>> getCurrentLocation() async {\r\n    try {\r\n      // Vrifier si le service de localisation est activ\r\n      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();\r\n      if (!serviceEnabled) {\r\n        return Result.error(Exception('Les services de localisation sont dsactivs.'));\r\n      }\r\n\r\n      // Vrifier les permissions\r\n      LocationPermission permission = await Geolocator.checkPermission();\r\n      if (permission == LocationPermission.denied) {\r\n        permission = await Geolocator.requestPermission();\r\n        if (permission == LocationPermission.denied) {\r\n          return Result.error(Exception('La permission de localisation a t refuse.'));\r\n        }\r\n      }\r\n\r\n      if (permission == LocationPermission.deniedForever) {\r\n        return Result.error(Exception('Les permissions de localisation sont dfinitivement refuses, veuillez les activer dans les paramtres.'));\r\n      }\r\n\r\n      // Obtenir la position actuelle\r\n      final position = await Geolocator.getCurrentPosition(\r\n        desiredAccuracy: LocationAccuracy.high,\r\n        timeLimit: const Duration(seconds: 5),\r\n      );\r\n\r\n      return Result.value(UserLocation(\r\n        latitude: position.latitude,\r\n        longitude: position.longitude,\r\n        accuracy: position.accuracy,\r\n        isFromGps: true,\r\n        timestamp: DateTime.now(),\r\n      ));\r\n    } catch (e) {\r\n      return Result.error(Exception('Erreur lors de la rcupration de la position: ${e.toString()}'));\r\n    }\r\n  }\r\n  /// Annule la recherche en cours\r\n  void cancelSearch() {\r\n    _searchDebouncer.cancel();\r\n  }\r\n}",
      "info": {
        "size": 6000,
        "last_modified": "2025-04-16T13:25:27.3142422",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\location_service.dart",
      "content": "// core/domain/services/location_service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../models/shared/city_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\n\r\n/// Service centralis pour les oprations sur les villes et localisations\r\nclass LocationService {\r\n  final SupabaseClient _supabase;\r\n\r\n  LocationService(this._supabase);\r\n\r\n  /// Vrifie si une ville existe dans la base\r\n  Future<City?> findCity(String cityName) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('city_name', cityName)\r\n          .maybeSingle();\r\n      return response != null ? City.fromJson(response) : null;\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche de la ville: $e');\r\n    }\r\n  }\r\n\r\n  /// Sauvegarde une ville dans la base\r\n  Future<City> saveCity({\r\n    required String cityName,\r\n    required double lat,\r\n    required double lon,\r\n    required String geohash5,\r\n  }) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('cities')\r\n          .upsert({\r\n        'city_name': cityName,\r\n        'lat': lat,\r\n        'lon': lon,\r\n        'geohash_5': geohash5,\r\n      }, onConflict: 'city_name')\r\n          .select()\r\n          .single();\r\n      return City.fromJson(response);\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la sauvegarde de la ville: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1445,
        "last_modified": "2025-04-16T13:25:27.3262555",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\scoring_service.dart",
      "content": "// core/domain/services/scoring_service.dart\r\n\r\nimport 'dart:math' as math;\r\nimport '../models/trip_designer/scoring/scoring_config.dart';\r\nimport '../models/trip_designer/processing/activity_processing_model.dart';\r\n\r\nclass ScoringService {\r\n  static const double SUPERWOW_TOTAL_THRESHOLD = 0.78;\r\n  static const double SUPERWOW_SUBCATEGORY_THRESHOLD = 0.6;\r\n\r\n  double calculateTotalScore(ActivityForProcessing activity, double subcategoryScore) {\r\n    final ratingScore = normalizeRating(activity.ratingCount);\r\n    final durationScore = calculateDurationBonus(activity.minDurationMinutes);\r\n\r\n    return (subcategoryScore * ScoringConfig.subcategoryWeight) +\r\n        (ratingScore * ScoringConfig.ratingWeight) +\r\n        (durationScore * ScoringConfig.durationWeight);\r\n  }\r\n\r\n  double normalizeRating(int rating) {\r\n    return rating / 100;\r\n  }\r\n\r\n  double calculateDurationBonus(int durationMinutes) {\r\n    return math.log(durationMinutes + 1) / math.log(10);\r\n  }\r\n\r\n  bool isSuperWow(double totalScore, double subcategoryScore) {\r\n    return totalScore >= SUPERWOW_TOTAL_THRESHOLD &&\r\n        subcategoryScore >= SUPERWOW_SUBCATEGORY_THRESHOLD;\r\n  }\r\n}",
      "info": {
        "size": 1162,
        "last_modified": "2025-04-16T13:25:27.3317613",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\search\\activity_distance_service.dart",
      "content": "// lib/core/domain/services/search/activity_distance_service.dart\r\n\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../ports/search/activity_distance_calculation_port.dart';\r\nimport '../../../common/utils/maps_toolkit_utils.dart';\r\n\r\nclass ActivityDistanceService implements ActivityDistanceCalculationPort {\r\n  final Map<String, double> _distanceCache = {};\r\n\r\n  String _getCacheKey(String activityId, LatLng userLocation) {\r\n    return '$activityId-${userLocation.latitude}-${userLocation.longitude}';\r\n  }\r\n\r\n  // Ajout d'une constante pour le facteur de correction\r\n  static const double ROAD_DISTANCE_FACTOR = 0.75;\r\n\r\n  @override\r\n  double calculateDistance({\r\n    required String activityId,\r\n    required LatLng userLocation,\r\n    required LatLng activityLocation,\r\n    double? approximateDistance,\r\n  }) {\r\n    final cacheKey = _getCacheKey(activityId, userLocation);\r\n\r\n    if (_distanceCache.containsKey(cacheKey)) {\r\n      return _distanceCache[cacheKey]!;\r\n    }\r\n\r\n    final rawDistance = MapsToolkitUtils.calculateHaversineDistance(\r\n      userLocation,\r\n      activityLocation,\r\n    );\r\n\r\n    // Application du facteur de correction\r\n    final correctedDistance = rawDistance * ROAD_DISTANCE_FACTOR;\r\n\r\n    _distanceCache[cacheKey] = correctedDistance;\r\n    return correctedDistance;\r\n  }\r\n\r\n  @override\r\n  void clearCache() {\r\n    _distanceCache.clear();\r\n  }\r\n}",
      "info": {
        "size": 1407,
        "last_modified": "2025-04-16T13:25:27.3387664",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\shared\\external_launcher_service.dart",
      "content": "// lib/core/domain/services/shared/external_launcher_service.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:url_launcher/url_launcher.dart' as url_launcher;\r\nimport 'package:flutter_custom_tabs/flutter_custom_tabs.dart' as custom_tabs;\r\nimport 'package:map_launcher/map_launcher.dart';\r\nimport '../../../../core/theme/app_colors.dart';\r\n\r\nclass ExternalLauncherService {\r\n  static Future<void> openMap(\r\n      double? latitude,\r\n      double? longitude,\r\n      String title,\r\n      BuildContext context,\r\n      {String? placeId}\r\n      ) async {\r\n    try {\r\n      // Si on a un Place ID, on ouvre la fiche Google Maps\r\n      if (placeId != null && placeId.isNotEmpty) {\r\n        final encodedTitle = Uri.encodeComponent(title);\r\n        final googlePlaceUrl = 'https://www.google.com/maps/search/?api=1'\r\n            '&query=$encodedTitle'\r\n            '&query_place_id=$placeId';\r\n\r\n        await openCustomTab(context, googlePlaceUrl);\r\n        return;\r\n      }\r\n\r\n      // Sinon on lance l'itinraire avec l'app de navigation par dfaut\r\n      final availableMaps = await MapLauncher.installedMaps;\r\n\r\n      if (availableMaps.isNotEmpty) {\r\n        if (latitude != null && longitude != null) {\r\n          await availableMaps.first.showDirections(\r\n            destination: Coords(latitude, longitude),\r\n            destinationTitle: title,\r\n          );\r\n        } else {\r\n          // Pour l'adresse textuelle, utiliser showMarker  la place\r\n          await availableMaps.first.showMarker(\r\n            coords: Coords(latitude ?? 0, longitude ?? 0),\r\n            title: title,\r\n          );\r\n        }\r\n      } else {\r\n        throw 'Aucune application de navigation disponible';\r\n      }\r\n    } catch (e) {\r\n      throw 'Erreur lors de l\\'ouverture de la navigation : $e';\r\n    }\r\n  }\r\n\r\n\r\n\r\n  static Future<void> openPhone(String phoneNumber) async {\r\n    try {\r\n      final Uri uri = Uri(\r\n        scheme: 'tel',\r\n        path: phoneNumber.replaceAll(RegExp(r'[^\\d+]'), ''),\r\n      );\r\n\r\n      if (await url_launcher.canLaunchUrl(uri)) {\r\n        await url_launcher.launchUrl(uri);\r\n      } else {\r\n        throw 'Aucune application de tlphone disponible';\r\n      }\r\n    } catch (e) {\r\n      throw 'Erreur lors de l\\'appel : $e';\r\n    }\r\n  }\r\n\r\n  static Future<void> openCustomTab(BuildContext context, String url) async {\r\n    try {\r\n      final Uri uri = Uri.parse(url.startsWith('http') ? url : 'https://$url');\r\n\r\n      await custom_tabs.launchUrl(\r\n        uri,\r\n        customTabsOptions: custom_tabs.CustomTabsOptions(\r\n          colorSchemes: custom_tabs.CustomTabsColorSchemes.defaults(\r\n            toolbarColor: AppColors.neutral900,\r\n          ),\r\n          shareState: custom_tabs.CustomTabsShareState.on,\r\n          urlBarHidingEnabled: true,\r\n          showTitle: true,\r\n        ),\r\n        safariVCOptions: custom_tabs.SafariViewControllerOptions(\r\n          preferredBarTintColor: AppColors.neutral900,\r\n          preferredControlTintColor: Colors.white,\r\n          barCollapsingEnabled: true,\r\n          dismissButtonStyle: custom_tabs.SafariViewControllerDismissButtonStyle.close,\r\n        ),\r\n      );\r\n    } catch (e) {\r\n      throw 'Erreur lors de l\\'ouverture du site web : $e';\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 3249,
        "last_modified": "2025-04-16T13:25:27.350273",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\travel_time_service.dart",
      "content": "// core/domain/services/travel_time_service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\n\r\nclass TravelTimeService {\r\n  final SupabaseClient _client;\r\n\r\n  TravelTimeService(this._client);\r\n\r\n  Future<int> calculateTravelTime(String originGeohash5, String destinationGeohash5) async {\r\n    // Si mme geohash5\r\n    if (originGeohash5 == destinationGeohash5) {\r\n      return 15; // 15 minutes\r\n    }\r\n\r\n    // Essayer d'abord geohash5_distances\r\n    final geohash5Response = await _client\r\n        .from('geohash5_distances')\r\n        .select()\r\n        .eq('geohash5_origin', originGeohash5)\r\n        .eq('geohash5_neighbor', destinationGeohash5)\r\n        .maybeSingle();\r\n\r\n    if (geohash5Response != null) {\r\n      double distance = geohash5Response['center_distance_km'];\r\n      return 15 + (distance.round()); // 15min + 1min/km\r\n    }\r\n\r\n    // Sinon, utiliser geohash_neighbors avec geohash4\r\n    String geohash4Origin = originGeohash5.substring(0, 4);\r\n    String geohash4Destination = destinationGeohash5.substring(0, 4);\r\n\r\n    final geohash4Response = await _client\r\n        .from('geohash_neighbors')\r\n        .select()\r\n        .eq('geohash', geohash4Origin)\r\n        .eq('neighbor_geohash', geohash4Destination)\r\n        .maybeSingle();\r\n\r\n    if (geohash4Response != null) {\r\n      double distance = geohash4Response['distance_km'];\r\n      // Appliquer les rgles de temps selon la distance\r\n      return _getTimeForDistance(distance);\r\n    }\r\n\r\n    // Par dfaut, retourner un temps maximum\r\n    return 150; // 2h30\r\n  }\r\n\r\n  int _getTimeForDistance(double distance) {\r\n    if (distance <= 30) return 45;      // 45min\r\n    if (distance <= 50) return 60;      // 1h\r\n    if (distance <= 80) return 90;      // 1h30\r\n    if (distance <= 110) return 120;    // 2h\r\n    return 150;                         // 2h30\r\n  }\r\n}",
      "info": {
        "size": 1859,
        "last_modified": "2025-04-16T13:25:27.361795",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\services\\trip_service.dart",
      "content": "// lib/core/domain/services/trip_service.dart\r\n\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../models/shared/city_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\n\r\nclass TripService {\r\n  final SupabaseClient _supabase;\r\n\r\n  TripService(this._supabase);\r\n\r\n  Future<Trip?> findTrip(String tripId) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .select('*, departure_city(*)')\r\n          .eq('id', tripId)\r\n          .maybeSingle();\r\n\r\n      if (response == null) return null;\r\n      return Trip.fromJson(response);\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la recherche du voyage: $e');\r\n    }\r\n  }\r\n\r\n  Future<Trip> saveTrip({\r\n    required String userId,\r\n    required String title,\r\n    required DateTime startDate,\r\n    required DateTime endDate,\r\n    required TravelGroup travelGroup,\r\n    required ActivityHours activityHours,\r\n    required City departureCity,\r\n    required TravelStyle travelStyle,\r\n    required PreferredMoment preferredMoment,\r\n    double? dailyBudget,\r\n  }) async {\r\n    try {\r\n      print('TripService - Dbut de saveTrip');\r\n      // Afficher les donnes qu'on va sauvegarder\r\n      print('Donnes  sauvegarder:');\r\n      final tripData = {\r\n        'user_id': userId,\r\n        'title': title,\r\n        'start_date': startDate.toIso8601String(),\r\n        'end_date': endDate.toIso8601String(),\r\n        'departure_city_id': departureCity.id,\r\n        'departure_geohash5': departureCity.geohash5,\r\n        'travel_group': travelGroup.toJson(),\r\n        'activity_hours': activityHours.toJson(),\r\n        'daily_budget': dailyBudget,\r\n        'travel_style': travelStyle.name,\r\n        'preferred_moment': preferredMoment.name,\r\n        'metadata': _generateMetadata(startDate),\r\n        'status': 'planned',\r\n        'trip_duration': endDate.difference(startDate).inDays + 1,\r\n      };\r\n      print('TripData: $tripData');\r\n\r\n      // Modification ici : on ne rcupre pas departure_city\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .insert(tripData)\r\n          .select()\r\n          .single();\r\n\r\n      // On rcupre la ville sparment si ncessaire\r\n      final cityResponse = await _supabase\r\n          .from('cities')\r\n          .select()\r\n          .eq('id', departureCity.id)\r\n          .single();\r\n\r\n      // On combine les donnes\r\n      var tripResponse = response;\r\n      tripResponse['departure_city'] = cityResponse;\r\n\r\n      return Trip.fromJson(tripResponse);\r\n    } catch (e, stackTrace) {\r\n      print('Erreur dans saveTrip: $e');\r\n      print('Stack trace: $stackTrace');\r\n      throw TripCreationException('Erreur lors de la sauvegarde du voyage: $e');\r\n    }\r\n  }\r\n\r\n  Map<String, dynamic> _generateMetadata(DateTime startDate) {\r\n    return {\r\n      'season': _getSeason(startDate),\r\n      'transport_mode': 'car',  // Par dfaut pour l'instant\r\n    };\r\n  }\r\n\r\n  String _getSeason(DateTime date) {\r\n    int month = date.month;\r\n    if (month >= 3 && month <= 5) return 'spring';\r\n    if (month >= 6 && month <= 8) return 'summer';\r\n    if (month >= 9 && month <= 11) return 'autumn';\r\n    return 'winter';\r\n  }\r\n\r\n  Future<List<Trip>> getTripsForUser(String userId) async {\r\n    try {\r\n      final response = await _supabase\r\n          .from('trips')\r\n          .select('*, departure_city(*)')\r\n          .eq('user_id', userId);\r\n      return response.map((json) => Trip.fromJson(json)).toList();\r\n    } catch (e) {\r\n      throw DataException('Erreur lors de la rcupration des voyages: $e');\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 3773,
        "last_modified": "2025-04-16T13:25:27.3683014",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\use_cases\\create_trip_use_case.dart",
      "content": "// core/domain/use_cases/create_trip_use_case.dart\r\n\r\nimport '../ports/trip_port.dart';\r\nimport '../ports/geocoding_port.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../../common/enums/trip_enums.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\n\r\n/// Use case pour crer un nouveau voyage\r\n/// Coordonne la cration d'un voyage en validant la ville de dpart\r\nclass CreateTripUseCase {\r\n  final TripPort _tripPort;\r\n  final GeocodingPort _geocodingPort;\r\n\r\n  CreateTripUseCase(this._tripPort, this._geocodingPort);\r\n\r\n  Future<Trip> execute(CreateTripParams params) async {\r\n    try {\r\n      print('CreateTripUseCase - Dbut de l\\'excution');\r\n      print('Recherche de la ville: ${params.departureCityName}');\r\n\r\n      final city = await _geocodingPort.getCity(params.departureCityName);\r\n      print('Ville trouve: ${city.cityName}');\r\n\r\n      print('Cration du voyage...');\r\n      final trip = await _tripPort.createTrip(params, city);\r\n      print('Voyage cr avec succs');\r\n\r\n      return trip;\r\n    } catch (e, stackTrace) {\r\n      print('Erreur dans CreateTripUseCase: $e');\r\n      print('Stack trace: $stackTrace');\r\n      throw TripCreationException('Erreur lors de la cration du voyage: $e');\r\n    }\r\n  }\r\n}\r\n\r\n/// Paramtres requis pour la cration d'un voyage\r\nclass CreateTripParams {\r\n  final String userId;\r\n  final String title;\r\n  final DateTime startDate;\r\n  final DateTime endDate;\r\n  final String departureCityName;\r\n  final TravelGroup travelGroup;\r\n  final ActivityHours activityHours;\r\n  final double dailyBudget;\r\n  final TravelStyle travelStyle;\r\n  final PreferredMoment preferredMoment;\r\n  final String transportMode;\r\n\r\n  CreateTripParams({\r\n    required this.userId,\r\n    required this.title,\r\n    required this.startDate,\r\n    required this.endDate,\r\n    required this.departureCityName,\r\n    required this.travelGroup,\r\n    required this.activityHours,\r\n    required this.dailyBudget,\r\n    required this.travelStyle,\r\n    required this.preferredMoment,\r\n    required this.transportMode,\r\n  });\r\n}",
      "info": {
        "size": 2086,
        "last_modified": "2025-04-16T13:25:27.379313",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\use_cases\\process_activities_use_case.dart",
      "content": "// core/domain/use_cases/process_activities_use_case.dart\r\n\r\nimport '../ports/activity_processing_port.dart';\r\nimport '../ports/trip_port.dart';\r\nimport '../../domain/models/trip_designer/processing/activity_processing_model.dart';\r\nimport '../models/trip_designer/trip/trip_model.dart';\r\nimport '../../common/exceptions/exceptions.dart';\r\nimport '../../common/exceptions/trip_exception.dart';\r\n\r\n\r\nclass ProcessActivitiesUseCase {\r\n  final ActivityProcessingPort _processingPort;\r\n  final TripPort _tripPort;\r\n\r\n  ProcessActivitiesUseCase(this._processingPort, this._tripPort);\r\n\r\n  Future<List<ActivityForProcessing>> execute(String tripId) async {\r\n    try {\r\n      print(' Dbut du processing des activits pour le voyage: $tripId');\r\n\r\n      // 1. Rcuprer les dtails du voyage\r\n      try {\r\n        final trip = await _tripPort.getTrip(tripId);\r\n        print(' Voyage rcupr: ${trip.title}');\r\n\r\n        // 2. Rcuprer les activits brutes\r\n        final activities = await _processingPort.getActivitiesForTrip(tripId);\r\n        print(' ${activities.length} activits rcupres');\r\n\r\n        // 3. Obtenir les activits filtres\r\n        return await _processingPort.getFilteredActivities(\r\n          tripId: tripId,\r\n          trip: trip,\r\n          activities: activities,\r\n        );\r\n      } on TripNotFoundException catch (e) {\r\n        print(' Voyage non trouv: $tripId');\r\n        throw TripNotFoundException('Le voyage spcifi n\\'existe pas: $tripId');\r\n      }\r\n    } catch (e) {\r\n      print(' Erreur pendant le processing: $e');\r\n      throw DomainException('Erreur pendant le traitement des activits: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 1686,
        "last_modified": "2025-04-16T13:25:27.3858231",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\domain\\use_cases\\search\\get_activities_use_case.dart",
      "content": "// lib/core/domain/use_cases/search/get_activities_use_case.dart\r\n\r\nimport '../../models/activity/search/searchable_activity.dart';\r\nimport '../../ports/search/activity_search_port.dart';\r\n\r\nfinal class GetActivitiesUseCase {\r\n  final ActivitySearchPort _searchPort;\r\n\r\n  GetActivitiesUseCase(this._searchPort);\r\n\r\n  Future<List<SearchableActivity>> executeQuery({\r\n    required double latitude,\r\n    required double longitude,\r\n    required String cityId,\r\n    required dynamic queryFilter,\r\n    String? categoryId,\r\n    String? subcategoryId,\r\n  }) async {\r\n    try {\r\n      print(' Input queryFilter: $queryFilter');\r\n\r\n      // Si c'est une String, on la convertit d'abord en Map\r\n      final Map<String, dynamic> filters;\r\n      if (queryFilter is String) {\r\n        // On retire les accolades et on split par virgule\r\n        final pairs = queryFilter\r\n            .replaceAll('{', '')\r\n            .replaceAll('}', '')\r\n            .split(',');\r\n\r\n        // On cre un Map  partir des paires cl:valeur\r\n        filters = {};\r\n        for (var pair in pairs) {\r\n          final parts = pair.split(':');\r\n          if (parts.length == 2) {\r\n            final key = parts[0].trim();\r\n            final value = parts[1].trim();\r\n            // Conversion des valeurs selon leur type\r\n            if (value == 'true') filters[key] = true;\r\n            else if (value == 'false') filters[key] = false;\r\n            else if (value == 'DESC' || value == 'ASC') filters[key] = value;\r\n            else if (value.contains('.')) filters[key] = double.tryParse(value);\r\n            else filters[key] = int.tryParse(value) ?? value;\r\n          }\r\n        }\r\n      } else {\r\n        filters = Map<String, dynamic>.from(queryFilter);\r\n      }\r\n\r\n      print(' Parsed filters: $filters');\r\n\r\n      return _searchPort.getActivitiesWithFilters(\r\n        latitude: latitude,\r\n        longitude: longitude,\r\n        cityId: cityId,\r\n        maxDistance: filters['maxDistance']?.toDouble(),\r\n        isWow: filters['isWow'],\r\n        minRating: filters['minRating']?.toDouble(),\r\n        minRatingCount: filters['minRatingCount'],\r\n        kidFriendly: filters['kidFriendly'],\r\n        categoryId: null,  // La catgorie parent si ncessaire\r\n        subcategoryId: subcategoryId,\r\n      );\r\n\r\n    } catch (e, stackTrace) {\r\n      print(' Error in executeQuery: $e');\r\n      print(' Stack trace: $stackTrace');\r\n      throw Exception('Failed to execute query: $e');\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2489,
        "last_modified": "2025-04-16T13:25:27.3923381",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\animations\\ripple_animation.dart",
      "content": "// lib/core/theme/animations/ripple_animation.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\nclass RippleAnimation extends StatefulWidget {\r\n  final Widget child;\r\n  final VoidCallback? onTap;\r\n  final Color? rippleColor;\r\n  final Duration duration;\r\n\r\n  const RippleAnimation({\r\n    super.key,\r\n    required this.child,\r\n    this.onTap,\r\n    this.rippleColor,\r\n    this.duration = const Duration(milliseconds: 600),\r\n  });\r\n\r\n  @override\r\n  State<RippleAnimation> createState() => _RippleAnimationState();\r\n}\r\n\r\nclass _RippleAnimationState extends State<RippleAnimation> with SingleTickerProviderStateMixin {\r\n  late AnimationController _controller;\r\n  late Animation<double> _animation;\r\n  Offset? _tapPosition;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _controller = AnimationController(\r\n      duration: widget.duration,\r\n      vsync: this,\r\n    );\r\n    _animation = Tween<double>(begin: 0.0, end: 1.0).animate(\r\n      CurvedAnimation(\r\n        parent: _controller,\r\n        curve: Curves.easeOut,\r\n      ),\r\n    );\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _controller.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  void _handleTapDown(TapDownDetails details) {\r\n    setState(() {\r\n      _tapPosition = details.localPosition;\r\n    });\r\n  }\r\n\r\n  void _handleTap() {\r\n    if (_tapPosition != null) {\r\n      _controller.forward(from: 0.0);\r\n      widget.onTap?.call();\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTapDown: _handleTapDown,\r\n      onTap: _handleTap,\r\n      child: Stack(\r\n        children: [\r\n          widget.child,\r\n          if (_tapPosition != null)\r\n            AnimatedBuilder(\r\n              animation: _animation,\r\n              builder: (context, child) {\r\n                return CustomPaint(\r\n                  size: Size.infinite,\r\n                  painter: CircleRipplePainter(\r\n                    position: _tapPosition!,\r\n                    progress: _animation.value,\r\n                    color: widget.rippleColor ?? Colors.white.withAlpha(50),\r\n                  ),\r\n                );\r\n              },\r\n            ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass CircleRipplePainter extends CustomPainter {\r\n  final Offset position;\r\n  final double progress;\r\n  final Color color;\r\n\r\n  CircleRipplePainter({\r\n    required this.position,\r\n    required this.progress,\r\n    required this.color,\r\n  });\r\n\r\n  @override\r\n  void paint(Canvas canvas, Size size) {\r\n    final maxRadius = size.longestSide * 1.5;  // L'onde dpasse le widget\r\n    final Paint paint = Paint()\r\n      ..color = color.withOpacity(1 - progress)\r\n      ..style = PaintingStyle.fill;\r\n\r\n    canvas.drawCircle(\r\n      position,\r\n      maxRadius * progress,\r\n      paint,\r\n    );\r\n  }\r\n\r\n  @override\r\n  bool shouldRepaint(CircleRipplePainter oldDelegate) {\r\n    return oldDelegate.progress != progress;\r\n  }\r\n}",
      "info": {
        "size": 2904,
        "last_modified": "2025-04-16T13:25:27.4170352",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_colors.dart",
      "content": "// lib/core/theme/app_colors.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\n/// Systme de couleurs de l'application Lyra\r\n///\r\n/// Cette classe contient toutes les couleurs utilises dans l'application,\r\n/// organises de manire smantique et accessibles via des getters contextuels.\r\n/// Elle gre automatiquement les thmes clairs et sombres.\r\nclass AppColors {\r\n  // Couleurs primaires\r\n  static const Color primary = Color(0xFF00798C); // Sports & Loisirs comme couleur principale\r\n  static const Color primaryDark = Color(0xFF005F70);\r\n  static const Color primaryLight = Color(0xFF4DACBD);\r\n\r\n  // Couleurs secondaires\r\n  static const Color secondary = Color(0xFF44AF69); // Nature\r\n  static const Color secondaryDark = Color(0xFF358F54);\r\n  static const Color secondaryLight = Color(0xFF7AC894);\r\n\r\n  // Couleurs d'accent\r\n  static const Color accent = Color(0xFFAD771F); // Culture\r\n  static const Color accentDark = Color(0xFF8A5E18);\r\n  static const Color accentLight = Color(0xFFD19F4F);\r\n\r\n  // Couleurs neutres\r\n  static const Color neutral900 = Color(0xFF212121); // Le plus fonc\r\n  static const Color neutral800 = Color(0xFF424242);\r\n  static const Color neutral700 = Color(0xFF616161);\r\n  static const Color neutral600 = Color(0xFF757575);\r\n  static const Color neutral500 = Color(0xFF9E9E9E);\r\n  static const Color neutral400 = Color(0xFFBDBDBD);\r\n  static const Color neutral300 = Color(0xFFE0E0E0);\r\n  static const Color neutral200 = Color(0xFFEEEEEE);\r\n  static const Color neutral100 = Color(0xFFF5F5F5);\r\n  static const Color neutral50 = Color(0xFFFAFAFA);  // Le plus clair\r\n\r\n  // Couleurs smantiques\r\n  static const Color success = Color(0xFF4CAF50);\r\n  static const Color successDark = Color(0xFF3B8C3D);\r\n  static const Color successLight = Color(0xFF81C784);\r\n\r\n  static const Color error = Color(0xFFFF5252);\r\n  static const Color errorDark = Color(0xFFD32F2F);\r\n  static const Color errorLight = Color(0xFFFF8A80);\r\n\r\n  static const Color warning = Color(0xFFFFC107);\r\n  static const Color warningDark = Color(0xFFFFA000);\r\n  static const Color warningLight = Color(0xFFFFD54F);\r\n\r\n  static const Color info = Color(0xFF2196F3);\r\n  static const Color infoDark = Color(0xFF1976D2);\r\n  static const Color infoLight = Color(0xFF64B5F6);\r\n\r\n  // Couleurs de fond\r\n  static const Color background = Color(0xFFFEFEFE);\r\n  static const Color backgroundDark = Color(0xFF121212);\r\n\r\n  static const Color surfaceLight = Color(0xFFFFFFFF);\r\n  static const Color surfaceDark = Color(0xFF1E1E1E);\r\n\r\n  // Couleurs spcifiques aux catgories\r\n  static const Color categoryGastronomie = Color(0xFF4E040F);\r\n  static const Color categoryCulture = Color(0xFFAD771F);\r\n  static const Color categoryEvenements = Color(0xFFFF390E);\r\n  static const Color categoryBienEtre = Color(0xFFE09367);\r\n  static const Color categoryDetenteSoiree = Color(0xFF041E39);\r\n  static const Color categorySportsLoisirs = Color(0xFF00798C);\r\n  static const Color categoryNature = Color(0xFF44AF69);\r\n\r\n  // Versions dark des couleurs de catgorie\r\n  static const Color categoryGastronomieDark = Color(0xFF7A0617);\r\n  static const Color categoryCultureDark = Color(0xFFD19F4F);\r\n  static const Color categoryEvenementsDark = Color(0xFFFF6E4E);\r\n  static const Color categoryBienEtreDark = Color(0xFFECB395);\r\n  static const Color categoryDetenteSoireeDark = Color(0xFF1A3C5E);\r\n  static const Color categorySportsLoisirsDark = Color(0xFF4DACBD);\r\n  static const Color categoryNatureDark = Color(0xFF7AC894);\r\n\r\n  /// Obtient les couleurs des catgories en fonction du mode clair/sombre\r\n  static Color getCategoryColor(String category, {bool isDark = false}) {\r\n    switch (category.toLowerCase()) {\r\n      case 'gastronomie':\r\n        return isDark ? categoryGastronomieDark : categoryGastronomie;\r\n      case 'culture':\r\n        return isDark ? categoryCultureDark : categoryCulture;\r\n      case 'evenements':\r\n      case 'vnements':\r\n        return isDark ? categoryEvenementsDark : categoryEvenements;\r\n      case 'bien-etre':\r\n      case 'bien tre':\r\n        return isDark ? categoryBienEtreDark : categoryBienEtre;\r\n      case 'detente-soiree':\r\n      case 'dtente et soire':\r\n        return isDark ? categoryDetenteSoireeDark : categoryDetenteSoiree;\r\n      case 'sports-loisirs':\r\n      case 'sports & loisirs':\r\n        return isDark ? categorySportsLoisirsDark : categorySportsLoisirs;\r\n      case 'nature':\r\n        return isDark ? categoryNatureDark : categoryNature;\r\n      default:\r\n        return isDark ? primaryDark : primary;\r\n    }\r\n  }\r\n\r\n  /// Gnre un ColorScheme complet pour le thme clair\r\n  static ColorScheme get lightColorScheme => ColorScheme(\r\n    primary: primary,\r\n    primaryContainer: primaryLight,\r\n    secondary: secondary,\r\n    secondaryContainer: secondaryLight,\r\n    surface: surfaceLight,\r\n    background: background,\r\n    error: error,\r\n    onPrimary: Colors.white,\r\n    onSecondary: Colors.white,\r\n    onSurface: neutral800,\r\n    onBackground: neutral900,\r\n    onError: Colors.white,\r\n    brightness: Brightness.light,\r\n  );\r\n\r\n  /// Gnre un ColorScheme complet pour le thme sombre\r\n  static ColorScheme get darkColorScheme => ColorScheme(\r\n    primary: primaryDark,\r\n    primaryContainer: primary,\r\n    secondary: secondaryDark,\r\n    secondaryContainer: secondary,\r\n    surface: surfaceDark,\r\n    background: backgroundDark,\r\n    error: errorDark,\r\n    onPrimary: Colors.white,\r\n    onSecondary: Colors.white,\r\n    onSurface: neutral200,\r\n    onBackground: neutral100,\r\n    onError: Colors.white,\r\n    brightness: Brightness.dark,\r\n  );\r\n\r\n  /// Retourne les couleurs adaptes au contexte actuel (clair/sombre)\r\n  static Color getContextualColor(BuildContext context, Color lightColor, Color darkColor) {\r\n    final brightness = Theme.of(context).brightness;\r\n    return brightness == Brightness.light ? lightColor : darkColor;\r\n  }\r\n\r\n  /// Adapte automatiquement une couleur pour le mode sombre en l'claircissant\r\n  static Color adaptToDarkMode(Color color, {double lightenFactor = 0.2}) {\r\n    final hslColor = HSLColor.fromColor(color);\r\n    return hslColor.withLightness((hslColor.lightness + lightenFactor).clamp(0.0, 1.0)).toColor();\r\n  }\r\n\r\n  // COULEURS POUR SHIMMER EFFECT\r\n  // Couleurs pour l'effet de chargement en mode clair\r\n  static const Color shimmerBaseLight = Color(0xFFE0E0E0);\r\n  static const Color shimmerHighlightLight = Color(0xFFF5F5F5);\r\n\r\n  // Couleurs pour l'effet de chargement en mode sombre\r\n  static const Color shimmerBaseDark = Color(0xFF303030);\r\n  static const Color shimmerHighlightDark = Color(0xFF383838);\r\n\r\n  // Pour la compatibilit avec l'ancien code\r\n  static const Color shimmerBase = shimmerBaseLight;\r\n  static const Color shimmerHighlight = shimmerHighlightLight;\r\n\r\n  // Getters qui renvoient la couleur approprie selon le mode\r\n  static Color getShimmerBase(bool isDark) => isDark ? shimmerBaseDark : shimmerBaseLight;\r\n  static Color getShimmerHighlight(bool isDark) => isDark ? shimmerHighlightDark : shimmerHighlightLight;\r\n\r\n}",
      "info": {
        "size": 7061,
        "last_modified": "2025-04-16T13:25:27.4291754",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_dimensions.dart",
      "content": "// lib/core/theme/app_dimensions.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\n/// Systme de dimensions et d'espacements de l'application Lyra\r\n///\r\n/// Cette classe contient toutes les valeurs standards pour les espacements,\r\n/// rayons, tailles et lvations  utiliser de manire cohrente dans toute l'application.\r\nclass AppDimensions {\r\n  // Systme d'espacement bas sur une grille de 4px\r\n  // Systme de nommage: space{N} o N est la valeur en pixels divise par 4\r\n  static const double space0 = 0;      // 0px - Pas d'espacement\r\n  static const double space1 = 4;      // 4px - Trs petit\r\n  static const double space2 = 8;      // 8px - Petit\r\n  static const double space3 = 12;     // 12px - Compact\r\n  static const double space4 = 16;     // 16px - Standard\r\n  static const double space5 = 20;     // 20px - Moyen\r\n  static const double space6 = 24;     // 24px - Confortable\r\n  static const double space8 = 32;     // 32px - Large\r\n  static const double space10 = 40;    // 40px - Trs large\r\n  static const double space12 = 48;    // 48px - Extra large\r\n  static const double space16 = 64;    // 64px - norme\r\n  static const double space20 = 80;    // 80px - Super norme\r\n  static const double space24 = 96;    // 96px - Ultra large\r\n  static const double space32 = 128;   // 128px - Maximum\r\n\r\n  // Espacements nomms smantiquement (plus facile  utiliser)\r\n  static const double spacingXxxs = space1;   // 4px\r\n  static const double spacingXxs = space2;    // 8px\r\n  static const double spacingXs = space3;     // 12px\r\n  static const double spacingS = space4;      // 16px\r\n  static const double spacingM = space6;      // 24px\r\n  static const double spacingL = space8;      // 32px\r\n  static const double spacingXl = space12;    // 48px\r\n  static const double spacingXxl = space16;   // 64px\r\n  static const double spacingXxxl = space24;  // 96px\r\n\r\n  // Paddings standards pour les containers\r\n  static const EdgeInsets paddingXxs = EdgeInsets.all(spacingXxs);\r\n  static const EdgeInsets paddingXs = EdgeInsets.all(spacingXs);\r\n  static const EdgeInsets paddingS = EdgeInsets.all(spacingS);\r\n  static const EdgeInsets paddingM = EdgeInsets.all(spacingM);\r\n  static const EdgeInsets paddingL = EdgeInsets.all(spacingL);\r\n\r\n  // Paddings horizontaux standards\r\n  static const EdgeInsets paddingHorizontalXxs = EdgeInsets.symmetric(horizontal: spacingXxs);\r\n  static const EdgeInsets paddingHorizontalXs = EdgeInsets.symmetric(horizontal: spacingXs);\r\n  static const EdgeInsets paddingHorizontalS = EdgeInsets.symmetric(horizontal: spacingS);\r\n  static const EdgeInsets paddingHorizontalM = EdgeInsets.symmetric(horizontal: spacingM);\r\n  static const EdgeInsets paddingHorizontalL = EdgeInsets.symmetric(horizontal: spacingL);\r\n\r\n  // Paddings verticaux standards\r\n  static const EdgeInsets paddingVerticalXxs = EdgeInsets.symmetric(vertical: spacingXxs);\r\n  static const EdgeInsets paddingVerticalXs = EdgeInsets.symmetric(vertical: spacingXs);\r\n  static const EdgeInsets paddingVerticalS = EdgeInsets.symmetric(vertical: spacingS);\r\n  static const EdgeInsets paddingVerticalM = EdgeInsets.symmetric(vertical: spacingM);\r\n  static const EdgeInsets paddingVerticalL = EdgeInsets.symmetric(vertical: spacingL);\r\n\r\n  // Paddings de page standards (horizontal seulement)\r\n  static const EdgeInsets pagePaddingSmall = EdgeInsets.symmetric(horizontal: spacingS);\r\n  static const EdgeInsets pagePaddingMedium = EdgeInsets.symmetric(horizontal: spacingM);\r\n  static const EdgeInsets pagePaddingLarge = EdgeInsets.symmetric(horizontal: spacingL);\r\n\r\n  // Rayons d'arrondi\r\n  static const double radiusNone = 0;                // Pas d'arrondis\r\n  static const double radiusXs = 4;                  // Trs faible arrondi\r\n  static const double radiusS = 8;                   // Faible arrondi\r\n  static const double radiusM = 12;                  // Arrondi moyen\r\n  static const double radiusL = 16;                  // Grand arrondi\r\n  static const double radiusXl = 24;                 // Trs grand arrondi\r\n  static const double radiusCircular = 1000;         // Compltement circulaire\r\n\r\n  // Border radius\r\n  static BorderRadius borderRadiusNone = BorderRadius.circular(radiusNone);\r\n  static BorderRadius borderRadiusXs = BorderRadius.circular(radiusXs);\r\n  static BorderRadius borderRadiusS = BorderRadius.circular(radiusS);\r\n  static BorderRadius borderRadiusM = BorderRadius.circular(radiusM);\r\n  static BorderRadius borderRadiusL = BorderRadius.circular(radiusL);\r\n  static BorderRadius borderRadiusXl = BorderRadius.circular(radiusXl);\r\n  static BorderRadius borderRadiusCircular = BorderRadius.circular(radiusCircular);\r\n\r\n  // Hauteurs standardises pour les composants\r\n  static const double buttonHeightS = 32;     // Petit bouton\r\n  static const double buttonHeightM = 40;     // Bouton standard\r\n  static const double buttonHeightL = 48;     // Grand bouton\r\n  static const double buttonHeightXl = 56;    // Trs grand bouton\r\n\r\n  static const double inputHeightS = 36;      // Petit champ de saisie\r\n  static const double inputHeightM = 44;      // Champ standard\r\n  static const double inputHeightL = 52;      // Grand champ\r\n\r\n  static const double appBarHeight = 56;      // Hauteur standard de la barre d'application\r\n  static const double tabBarHeight = 48;      // Hauteur de la barre d'onglets\r\n  static const double bottomNavBarHeight = 56; // Hauteur de la barre de navigation infrieure\r\n\r\n  // Tailles d'icnes\r\n  static const double iconSizeXs = 12;        // Trs petite icne\r\n  static const double iconSizeS = 16;         // Petite icne\r\n  static const double iconSizeM = 24;         // Icne standard\r\n  static const double iconSizeL = 32;         // Grande icne\r\n  static const double iconSizeXl = 48;        // Trs grande icne\r\n\r\n  // Niveaux d'lvation (pour les ombres)\r\n  static const double elevationNone = 0;      // Pas d'lvation\r\n  static const double elevationXs = 1;        // Trs faible lvation\r\n  static const double elevationS = 2;         // Faible lvation (cartes)\r\n  static const double elevationM = 4;         // lvation moyenne (barres d'app)\r\n  static const double elevationL = 8;         // Forte lvation (FAB, dialogs)\r\n  static const double elevationXl = 16;       // Trs forte lvation (modals)\r\n\r\n  // Taille de l'avatar\r\n  static const double avatarSizeS = 32;       // Petit avatar\r\n  static const double avatarSizeM = 40;       // Avatar moyen\r\n  static const double avatarSizeL = 56;       // Grand avatar\r\n  static const double avatarSizeXl = 80;      // Trs grand avatar\r\n\r\n  // paisseurs de bordure\r\n  static const double borderWidthThin = 1;    // Bordure fine\r\n  static const double borderWidthRegular = 2; // Bordure standard\r\n  static const double borderWidthThick = 3;   // Bordure paisse\r\n\r\n  // Breakpoints pour le design responsive\r\n  static const double breakpointXs = 0;       // Extra petit (tlphones en portrait)\r\n  static const double breakpointS = 480;      // Petit (tlphones en paysage)\r\n  static const double breakpointM = 768;      // Moyen (tablettes)\r\n  static const double breakpointL = 1024;     // Large (tablettes paysage / petits ordinateurs)\r\n  static const double breakpointXl = 1440;    // Extra large (ordinateurs)\r\n\r\n  // Mthodes utilitaires pour le responsive\r\n\r\n  /// Dtermine si l'cran actuel est considr comme petit (tlphone en portrait)\r\n  static bool isSmallScreen(BuildContext context) {\r\n    return MediaQuery.of(context).size.width < breakpointS;\r\n  }\r\n\r\n  /// Dtermine si l'cran actuel est considr comme moyen (tablette)\r\n  static bool isMediumScreen(BuildContext context) {\r\n    final width = MediaQuery.of(context).size.width;\r\n    return width >= breakpointS && width < breakpointL;\r\n  }\r\n\r\n  /// Dtermine si l'cran actuel est considr comme large (tablette paysage / petit ordinateur)\r\n  static bool isLargeScreen(BuildContext context) {\r\n    final width = MediaQuery.of(context).size.width;\r\n    return width >= breakpointL && width < breakpointXl;\r\n  }\r\n\r\n  /// Dtermine si l'cran actuel est considr comme extra large (ordinateur)\r\n  static bool isExtraLargeScreen(BuildContext context) {\r\n    return MediaQuery.of(context).size.width >= breakpointXl;\r\n  }\r\n\r\n  /// Retourne une valeur qui s'adapte  la taille de l'cran\r\n  static double responsiveSize(\r\n      BuildContext context, {\r\n        required double small,\r\n        double? medium,\r\n        double? large,\r\n        double? extraLarge,\r\n      }) {\r\n    final screenWidth = MediaQuery.of(context).size.width;\r\n\r\n    if (screenWidth >= breakpointXl && extraLarge != null) {\r\n      return extraLarge;\r\n    } else if (screenWidth >= breakpointL && large != null) {\r\n      return large;\r\n    } else if (screenWidth >= breakpointS && medium != null) {\r\n      return medium;\r\n    } else {\r\n      return small;\r\n    }\r\n  }\r\n\r\n  /// Obtient le padding horizontal de page adapt  la taille de l'cran\r\n  static EdgeInsets getResponsivePagePadding(BuildContext context) {\r\n    if (isSmallScreen(context)) {\r\n      return pagePaddingSmall;\r\n    } else if (isMediumScreen(context)) {\r\n      return pagePaddingMedium;\r\n    } else {\r\n      return pagePaddingLarge;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 9281,
        "last_modified": "2025-04-16T13:25:27.4366898",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_filters.dart",
      "content": "// lib/core/theme/app_filters.dart\r\n\r\nimport 'package:flutter/material.dart';\r\n\r\nabstract class AppFilters {\r\n  // Dsaturation de 10%\r\n  static const ColorFilter desaturate = ColorFilter.matrix([\r\n    0.8, 0, 0, 0, 0,    // Rouge  90%\r\n    0, 0.8, 0, 0, 0,    // Vert  90%\r\n    0, 0, 0.8, 0, 0,    // Bleu  90%\r\n    0, 0, 0, 1, 0,      // Alpha inchang\r\n  ]);\r\n\r\n  // Filtre beige\r\n  static final Color beigeOverlay = const Color(0xFFDE7C5A).withAlpha(20); // ~0.1 opacity\r\n}",
      "info": {
        "size": 485,
        "last_modified": "2025-04-16T13:25:27.4432061",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_fonts.dart",
      "content": "// lib/core/theme/app_fonts.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:google_fonts/google_fonts.dart';\r\n\r\n/// Configuration centralise des polices de l'application\r\n///\r\n/// Cette classe permet de changer facilement la police principale\r\n/// utilise dans toute l'application.\r\nclass AppFonts {\r\n  // Empcher l'instanciation\r\n  AppFonts._();\r\n\r\n  /// Dfinit la police principale de l'application\r\n  /// Changer uniquement cette valeur pour modifier la police partout\r\n  static String _primaryFontFamily = 'Work Sans';\r\n\r\n  /// Dfinit si on utilise Google Fonts ou une police locale\r\n  static bool _useGoogleFonts = true;\r\n\r\n  /// Change la police principale de l'application\r\n  /// Exemple: AppFonts.changePrimaryFont('Roboto');\r\n  static void changePrimaryFont(String fontFamily, {bool useGoogleFonts = true}) {\r\n    _primaryFontFamily = fontFamily;\r\n    _useGoogleFonts = useGoogleFonts;\r\n  }\r\n\r\n  /// Mthode principale pour obtenir un TextStyle avec la police configure\r\n  static TextStyle getFont({\r\n    required double fontSize,\r\n    FontWeight fontWeight = FontWeight.normal,\r\n    Color? color,\r\n    double? height,\r\n    double? letterSpacing,\r\n    TextDecoration? decoration,\r\n    FontStyle? fontStyle,\r\n  }) {\r\n    // Si on utilise Google Fonts\r\n    if (_useGoogleFonts) {\r\n      // Appel dynamique  la mthode GoogleFonts correspondante\r\n      return _getGoogleFont(\r\n        fontSize: fontSize,\r\n        fontWeight: fontWeight,\r\n        color: color,\r\n        height: height,\r\n        letterSpacing: letterSpacing,\r\n        decoration: decoration,\r\n        fontStyle: fontStyle,\r\n      );\r\n    }\r\n    // Sinon, on utilise une police locale\r\n    else {\r\n      return TextStyle(\r\n        fontFamily: _primaryFontFamily,\r\n        fontSize: fontSize,\r\n        fontWeight: fontWeight,\r\n        color: color,\r\n        height: height,\r\n        letterSpacing: letterSpacing,\r\n        decoration: decoration,\r\n        fontStyle: fontStyle,\r\n      );\r\n    }\r\n  }\r\n\r\n  /// Mthode pour obtenir un TextTheme complet avec la police configure\r\n  static TextTheme getTextTheme(TextTheme baseTheme) {\r\n    if (_useGoogleFonts) {\r\n      // Appel dynamique  la mthode GoogleFonts correspondante\r\n      switch (_primaryFontFamily.toLowerCase()) {\r\n        case 'inter':\r\n          return GoogleFonts.interTextTheme(baseTheme);\r\n        case 'worksans':\r\n        case 'work sans':\r\n          return GoogleFonts.workSansTextTheme(baseTheme);\r\n        case 'roboto':\r\n          return GoogleFonts.robotoTextTheme(baseTheme);\r\n        case 'lato':\r\n          return GoogleFonts.latoTextTheme(baseTheme);\r\n        case 'poppins':\r\n          return GoogleFonts.poppinsTextTheme(baseTheme);\r\n      // Ajoutez d'autres polices courantes au besoin\r\n        default:\r\n        // Fallback: on utilise une technique gnrique mais moins optimise\r\n          return baseTheme.apply(fontFamily: _primaryFontFamily);\r\n      }\r\n    } else {\r\n      return baseTheme.apply(fontFamily: _primaryFontFamily);\r\n    }\r\n  }\r\n\r\n  /// Mthode prive qui appelle dynamiquement la mthode GoogleFonts approprie\r\n  static TextStyle _getGoogleFont({\r\n    required double fontSize,\r\n    FontWeight fontWeight = FontWeight.normal,\r\n    Color? color,\r\n    double? height,\r\n    double? letterSpacing,\r\n    TextDecoration? decoration,\r\n    FontStyle? fontStyle,\r\n  }) {\r\n    // Paramtres communs  toutes les polices\r\n    final Map<String, dynamic> textStyleParams = {\r\n      'fontSize': fontSize,\r\n      'fontWeight': fontWeight,\r\n      'color': color,\r\n      'height': height,\r\n      'letterSpacing': letterSpacing,\r\n      'decoration': decoration,\r\n      'fontStyle': fontStyle,\r\n    };\r\n\r\n    // Appel dynamique en fonction de la police choisie\r\n    switch (_primaryFontFamily.toLowerCase()) {\r\n      case 'inter':\r\n        return GoogleFonts.inter(\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n      case 'worksans':\r\n      case 'work sans':\r\n        return GoogleFonts.workSans(\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n      case 'poppins':\r\n        return GoogleFonts.poppins(\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n    // Ajoutez d'autres polices au besoin\r\n      default:\r\n      // Fallback pour les polices non listes\r\n        return TextStyle(\r\n          fontFamily: _primaryFontFamily,\r\n          fontSize: fontSize,\r\n          fontWeight: fontWeight,\r\n          color: color,\r\n          height: height,\r\n          letterSpacing: letterSpacing,\r\n          decoration: decoration,\r\n          fontStyle: fontStyle,\r\n        );\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 5162,
        "last_modified": "2025-04-16T13:25:27.4492059",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_interactions.dart",
      "content": "// lib/core/theme/app_interactions.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_touch_ripple/flutter_touch_ripple.dart';\r\n\r\nclass AppInteractions {\r\n  static Widget addCircularRipple({\r\n    required Widget child,\r\n    required VoidCallback? onTap,\r\n    Color? rippleColor,\r\n  }) {\r\n    return TouchRipple(\r\n      onTap: onTap,\r\n      rippleColor: rippleColor?.withAlpha(20),\r\n      rippleScale: 1.8,\r\n      // Plus grand maintenant qu'on a le clipping\r\n      rippleBlurRadius: 3.0,\r\n      previewDuration: const Duration(milliseconds: 300),\r\n      tappableDuration: const Duration(milliseconds: 300),\r\n      focusColor: Colors.transparent,\r\n      hoverColor: Colors.transparent,\r\n      useFocusEffect: false,\r\n      useHoverEffect: false,\r\n      rippleBorderRadius: BorderRadius.circular(100),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  /// Dure trs courte (100ms) - Pour micro-interactions\r\n  static const Duration durationFast = Duration(milliseconds: 100);\r\n\r\n  /// Dure courte (200ms) - Pour la plupart des interactions simples\r\n  static const Duration durationShort = Duration(milliseconds: 200);\r\n\r\n  /// Dure standard (300ms) - Pour les animations standards\r\n  static const Duration durationMedium = Duration(milliseconds: 300);\r\n\r\n  /// Dure longue (400ms) - Pour les transitions plus complexes\r\n  static const Duration durationLong = Duration(milliseconds: 400);\r\n\r\n  /// Dure trs longue (600ms) - Pour les animations d'entre/sortie d'cran\r\n  static const Duration durationXLong = Duration(milliseconds: 600);\r\n\r\n  // COURBES D'ANIMATION\r\n\r\n  /// Standard pour la plupart des animations\r\n  static const Curve standardEasing = Curves.easeInOut;\r\n\r\n  /// Pour les lments qui entrent  l'cran\r\n  static const Curve inEasing = Curves.easeOut;\r\n\r\n  /// Pour les lments qui sortent de l'cran\r\n  static const Curve outEasing = Curves.easeIn;\r\n\r\n  /// Pour les animations emphathiques (rebonds)\r\n  static const Curve emphasisEasing = Curves.elasticOut;\r\n\r\n  /// Pour les dplacements naturels (acclration puis dclration)\r\n  static const Curve naturalEasing = Curves.easeInOutCubic;\r\n\r\n  /// Pour un effet de ressort raliste\r\n  static const Curve springEasing = Curves.elasticOut;\r\n\r\n  // DLAIS\r\n\r\n  /// Dlai court pour dcaler lgrement des animations\r\n  static const Duration delayShort = Duration(milliseconds: 50);\r\n\r\n  /// Dlai moyen pour squencer des animations\r\n  static const Duration delayMedium = Duration(milliseconds: 150);\r\n\r\n  /// Dlai long pour sparer clairement des animations\r\n  static const Duration delayLong = Duration(milliseconds: 300);\r\n\r\n  // MTHODES D'ANIMATION\r\n\r\n  /// Cre une animation fade-in\r\n  static Widget fadeIn({\r\n    required Widget child,\r\n    Duration duration = durationMedium,\r\n    Curve curve = inEasing,\r\n    Duration delay = Duration.zero,\r\n  }) {\r\n    return TweenAnimationBuilder<double>(\r\n      tween: Tween<double>(begin: 0.0, end: 1.0),\r\n      duration: duration,\r\n      curve: curve,\r\n      builder: (context, value, child) => Opacity(\r\n        opacity: value,\r\n        child: child,\r\n      ),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  /// Cre une animation slide-in depuis le bas\r\n  static Widget slideInFromBottom({\r\n    required Widget child,\r\n    Duration duration = durationMedium,\r\n    Curve curve = inEasing,\r\n    double offset = 50.0,\r\n  }) {\r\n    return TweenAnimationBuilder<double>(\r\n      tween: Tween<double>(begin: offset, end: 0.0),\r\n      duration: duration,\r\n      curve: curve,\r\n      builder: (context, value, child) => Transform.translate(\r\n        offset: Offset(0, value),\r\n        child: child,\r\n      ),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  /// Cre une animation combine fade-in et slide-in\r\n  static Widget fadeSlideIn({\r\n    required Widget child,\r\n    Duration duration = durationMedium,\r\n    Curve curve = inEasing,\r\n    double offset = 30.0,\r\n    Duration delay = Duration.zero,\r\n  }) {\r\n    return TweenAnimationBuilder<double>(\r\n      tween: Tween<double>(begin: 0.0, end: 1.0),\r\n      duration: duration,\r\n      curve: curve,\r\n      builder: (context, value, child) => Opacity(\r\n        opacity: value,\r\n        child: Transform.translate(\r\n          offset: Offset(0, offset * (1 - value)),\r\n          child: child,\r\n        ),\r\n      ),\r\n      child: child,\r\n    );\r\n  }\r\n\r\n\r\n  /// Effet de ripple personnalis pour les interactions tactiles\r\n  static Widget withRipple({\r\n    required Widget child,\r\n    required VoidCallback onTap,\r\n    Color? splashColor,\r\n    BorderRadius? borderRadius,\r\n    Duration duration = durationShort,\r\n  }) {\r\n    return Material(\r\n      color: Colors.transparent,\r\n      child: InkWell(\r\n        onTap: onTap,\r\n        splashColor: splashColor,\r\n        borderRadius: borderRadius,\r\n        child: child,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Animation squentielle pour les listes d'lments\r\n  static List<Widget> staggeredList({\r\n    required List<Widget> children,\r\n    Duration initialDelay = Duration.zero,\r\n    Duration staggerDelay = delayShort,\r\n    Duration itemDuration = durationMedium,\r\n    Curve curve = inEasing,\r\n    double offset = 30.0,\r\n  }) {\r\n    List<Widget> result = [];\r\n\r\n    for (int i = 0; i < children.length; i++) {\r\n      final delay = initialDelay + (staggerDelay * i);\r\n      result.add(\r\n        AnimatedBuilder(\r\n          animation: Listenable.merge([]),  // Dummy animation\r\n          builder: (context, _) {\r\n            return FutureBuilder(\r\n              future: Future.delayed(delay),\r\n              builder: (context, snapshot) {\r\n                if (snapshot.connectionState == ConnectionState.done) {\r\n                  return fadeSlideIn(\r\n                    child: children[i],\r\n                    duration: itemDuration,\r\n                    curve: curve,\r\n                    offset: offset,\r\n                  );\r\n                } else {\r\n                  return Opacity(opacity: 0, child: children[i]);\r\n                }\r\n              },\r\n            );\r\n          },\r\n        ),\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // TRANSITIONS DE PAGE\r\n\r\n  /// Transition de page avec fade\r\n  static PageRouteBuilder<T> fadeTransition<T>({\r\n    required Widget page,\r\n    Duration duration = durationLong,\r\n  }) {\r\n    return PageRouteBuilder<T>(\r\n      pageBuilder: (context, animation, secondaryAnimation) => page,\r\n      transitionDuration: duration,\r\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\r\n        return FadeTransition(\r\n          opacity: animation,\r\n          child: child,\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  /// Transition de page avec slide depuis la droite\r\n  static PageRouteBuilder<T> slideTransition<T>({\r\n    required Widget page,\r\n    Duration duration = durationLong,\r\n  }) {\r\n    return PageRouteBuilder<T>(\r\n      pageBuilder: (context, animation, secondaryAnimation) => page,\r\n      transitionDuration: duration,\r\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\r\n        const begin = Offset(1.0, 0.0);\r\n        const end = Offset.zero;\r\n        final tween = Tween(begin: begin, end: end);\r\n        final offsetAnimation = animation.drive(tween);\r\n\r\n        return SlideTransition(\r\n          position: offsetAnimation,\r\n          child: child,\r\n        );\r\n      },\r\n    );\r\n  }\r\n}\r\n",
      "info": {
        "size": 7337,
        "last_modified": "2025-04-16T13:25:27.4553447",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_theme.dart",
      "content": "// lib/core/theme/app_theme.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'app_colors.dart';\r\nimport 'app_typography.dart';\r\nimport 'app_dimensions.dart';\r\nimport 'app_fonts.dart';\r\nimport 'package:flutter/services.dart';\r\n\r\n/// Configuration complte du thme de l'application Lyra\r\n///\r\n/// Cette classe centralise dfinit l'apparence globale de l'application\r\n/// en intgrant les couleurs, typographies et dimensions dfinies ailleurs.\r\nclass AppTheme {\r\n  // Empche l'instanciation de la classe\r\n  AppTheme._();\r\n\r\n  /// Gnre le thme clair de l'application\r\n  static ThemeData lightTheme(BuildContext context) {\r\n    return _buildTheme(context, Brightness.light);\r\n  }\r\n\r\n  /// Gnre le thme sombre de l'application\r\n  static ThemeData darkTheme(BuildContext context) {\r\n    return _buildTheme(context, Brightness.dark);\r\n  }\r\n\r\n  /// Construit le thme avec la luminosit spcifie\r\n  static ThemeData _buildTheme(BuildContext context, Brightness brightness) {\r\n    final isDark = brightness == Brightness.dark;\r\n    final colorScheme = isDark ? AppColors.darkColorScheme : AppColors.lightColorScheme;\r\n\r\n\r\n    // Construction du thme de base\r\n    return ThemeData(\r\n      useMaterial3: true,\r\n      brightness: brightness,\r\n      colorScheme: colorScheme,\r\n\r\n      // Couleurs de l'application\r\n      primaryColor: colorScheme.primary,\r\n      scaffoldBackgroundColor: colorScheme.background,\r\n      canvasColor: colorScheme.background,\r\n\r\n      // Configuration de la barre d'tat\r\n      appBarTheme: AppBarTheme(\r\n        backgroundColor: colorScheme.surface,\r\n        foregroundColor: colorScheme.onSurface,\r\n        elevation: AppDimensions.elevationS,\r\n        systemOverlayStyle: isDark\r\n            ? SystemUiOverlayStyle.light.copyWith(\r\n          statusBarColor: Colors.transparent,\r\n        )\r\n            : SystemUiOverlayStyle.dark.copyWith(\r\n          statusBarColor: Colors.transparent,\r\n        ),\r\n        centerTitle: false,\r\n        iconTheme: IconThemeData(\r\n          color: colorScheme.onSurface,\r\n          size: AppDimensions.iconSizeM,\r\n        ),\r\n        titleTextStyle: context.titleLarge,\r\n      ),\r\n\r\n      // Configuration des cartes\r\n      cardTheme: CardTheme(\r\n        color: colorScheme.surface,\r\n        elevation: AppDimensions.elevationS,\r\n        margin: EdgeInsets.zero,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n        ),\r\n        clipBehavior: Clip.hardEdge,\r\n      ),\r\n\r\n      // Configuration de l'lvation\r\n      elevatedButtonTheme: ElevatedButtonThemeData(\r\n        style: ElevatedButton.styleFrom(\r\n          backgroundColor: colorScheme.primary,\r\n          foregroundColor: colorScheme.onPrimary,\r\n          elevation: AppDimensions.elevationXs,\r\n          padding: AppDimensions.paddingHorizontalS.add(AppDimensions.paddingVerticalXs),\r\n          shape: RoundedRectangleBorder(\r\n            borderRadius: AppDimensions.borderRadiusS,\r\n          ),\r\n          minimumSize: Size(0, AppDimensions.buttonHeightM),\r\n          textStyle: context.buttonStyle,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du bouton texte\r\n      textButtonTheme: TextButtonThemeData(\r\n        style: TextButton.styleFrom(\r\n          foregroundColor: colorScheme.primary,\r\n          padding: AppDimensions.paddingHorizontalS.add(AppDimensions.paddingVerticalXxs),\r\n          shape: RoundedRectangleBorder(\r\n            borderRadius: AppDimensions.borderRadiusS,\r\n          ),\r\n          minimumSize: Size(0, AppDimensions.buttonHeightM),\r\n          textStyle: context.buttonStyle,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du bouton avec contour\r\n      outlinedButtonTheme: OutlinedButtonThemeData(\r\n        style: OutlinedButton.styleFrom(\r\n          foregroundColor: colorScheme.primary,\r\n          side: BorderSide(\r\n            color: colorScheme.primary,\r\n            width: AppDimensions.borderWidthThin,\r\n          ),\r\n          padding: AppDimensions.paddingHorizontalS.add(AppDimensions.paddingVerticalXs),\r\n          shape: RoundedRectangleBorder(\r\n            borderRadius: AppDimensions.borderRadiusS,\r\n          ),\r\n          minimumSize: Size(0, AppDimensions.buttonHeightM),\r\n          textStyle: context.buttonStyle,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du bouton flottant d'action\r\n      floatingActionButtonTheme: FloatingActionButtonThemeData(\r\n        backgroundColor: colorScheme.primary,\r\n        foregroundColor: colorScheme.onPrimary,\r\n        elevation: AppDimensions.elevationM,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusCircular,\r\n        ),\r\n      ),\r\n\r\n      // Configuration de la barre infrieure\r\n      bottomNavigationBarTheme: BottomNavigationBarThemeData(\r\n        backgroundColor: colorScheme.surface,\r\n        selectedItemColor: colorScheme.primary,\r\n        unselectedItemColor: colorScheme.onSurface.withOpacity(0.6),\r\n        elevation: AppDimensions.elevationM,\r\n        type: BottomNavigationBarType.fixed,\r\n        showSelectedLabels: true,\r\n        showUnselectedLabels: true,\r\n      ),\r\n\r\n      // Configuration des champs de saisie\r\n      inputDecorationTheme: InputDecorationTheme(\r\n        filled: true,\r\n        fillColor: isDark\r\n            ? AppColors.neutral800.withOpacity(0.5)\r\n            : AppColors.neutral100,\r\n        border: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide.none,\r\n        ),\r\n        enabledBorder: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide.none,\r\n        ),\r\n        focusedBorder: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide(\r\n            color: colorScheme.primary,\r\n            width: AppDimensions.borderWidthThin,\r\n          ),\r\n        ),\r\n        errorBorder: OutlineInputBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n          borderSide: BorderSide(\r\n            color: colorScheme.error,\r\n            width: AppDimensions.borderWidthThin,\r\n          ),\r\n        ),\r\n        contentPadding: AppDimensions.paddingS,\r\n        hintStyle: context.bodyMedium,\r\n        labelStyle: context.labelMedium,\r\n        errorStyle: context.labelSmall\r\n            .copyWith(color: colorScheme.error),\r\n      ),\r\n\r\n      // Configuration des listes\r\n      listTileTheme: ListTileThemeData(\r\n        contentPadding: AppDimensions.paddingHorizontalS,\r\n        minLeadingWidth: AppDimensions.space8,\r\n        minVerticalPadding: AppDimensions.space3,\r\n        tileColor: Colors.transparent,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n        ),\r\n      ),\r\n\r\n      // Configuration du SnackBar\r\n      snackBarTheme: SnackBarThemeData(\r\n        backgroundColor: isDark\r\n            ? AppColors.neutral800\r\n            : AppColors.neutral900,\r\n        contentTextStyle: AppFonts.getFont(\r\n          fontSize: 14,\r\n          color: Colors.white,\r\n        ),\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusM,\r\n        ),\r\n        behavior: SnackBarBehavior.floating,\r\n        elevation: AppDimensions.elevationM,\r\n      ),\r\n\r\n      // Configuration des onglets\r\n      tabBarTheme: TabBarTheme(\r\n        labelColor: colorScheme.primary,\r\n        unselectedLabelColor: colorScheme.onSurface.withOpacity(0.7),\r\n        indicatorColor: colorScheme.primary,\r\n        labelStyle: context.labelMedium,\r\n        unselectedLabelStyle: context.labelMedium,\r\n      ),\r\n\r\n      // Configuration des diviseurs\r\n      dividerTheme: DividerThemeData(\r\n        color: isDark\r\n            ? AppColors.neutral700\r\n            : AppColors.neutral300,\r\n        thickness: 1,\r\n        space: AppDimensions.space2,\r\n      ),\r\n\r\n      // Configuration du switch\r\n      switchTheme: SwitchThemeData(\r\n        thumbColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.selected)) {\r\n            return colorScheme.primary;\r\n          }\r\n          return isDark ? AppColors.neutral400 : AppColors.neutral500;\r\n        }),\r\n        trackColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.selected)) {\r\n            return colorScheme.primary.withOpacity(0.5);\r\n          }\r\n          return isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n        }),\r\n      ),\r\n\r\n      // Configuration du thme des icnes\r\n      iconTheme: IconThemeData(\r\n        color: colorScheme.onSurface,\r\n        size: AppDimensions.iconSizeM,\r\n      ),\r\n\r\n      // Configuration des dialogues\r\n      dialogTheme: DialogTheme(\r\n        backgroundColor: colorScheme.surface,\r\n        elevation: AppDimensions.elevationL,\r\n        shape: RoundedRectangleBorder(\r\n          borderRadius: AppDimensions.borderRadiusL,\r\n        ),\r\n      ),\r\n\r\n      // Typographie complte\r\n      textTheme: AppTypography.createTextTheme(context.isDark),\r\n    );\r\n  }\r\n\r\n  /// Configure les styles de l'application pour les versions iOS et Android\r\n  static void setupSystemUI({required bool isDarkMode}) {\r\n    // Configurer la barre d'tat\r\n    SystemChrome.setSystemUIOverlayStyle(\r\n      isDarkMode\r\n          ? SystemUiOverlayStyle.light.copyWith(\r\n        statusBarColor: Colors.transparent,\r\n        systemNavigationBarColor: AppColors.backgroundDark,\r\n        systemNavigationBarIconBrightness: Brightness.light,\r\n      )\r\n          : SystemUiOverlayStyle.dark.copyWith(\r\n        statusBarColor: Colors.transparent,\r\n        systemNavigationBarColor: AppColors.background,\r\n        systemNavigationBarIconBrightness: Brightness.dark,\r\n      ),\r\n    );\r\n\r\n    // Orienter l'application en mode portrait uniquement\r\n    SystemChrome.setPreferredOrientations([\r\n      DeviceOrientation.portraitUp,\r\n      DeviceOrientation.portraitDown,\r\n    ]);\r\n  }\r\n}",
      "info": {
        "size": 9944,
        "last_modified": "2025-04-16T13:25:27.4623739",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\app_typography.dart",
      "content": "// lib/core/theme/app_typography.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:google_fonts/google_fonts.dart';\r\nimport 'app_colors.dart';\r\nimport 'app_fonts.dart';\r\n\r\n/// Systme typographique simplifi de l'application\r\n///\r\n/// Dfinit 9 styles principaux (3 niveaux pour chaque catgorie)\r\n/// et prend en compte les modes clair/sombre automatiquement.\r\nclass AppTypography {\r\n\r\n  // Paramtres communs\r\n  static const double _lineHeightNormal = 1.5;\r\n  static const double _lineHeightCompact = 1.3;\r\n  static const double _letterSpacingNormal = 0.0;\r\n\r\n  // TITRES (3 niveaux)\r\n\r\n  /// Grand titre (ex: titres de page)\r\n  static TextStyle titleLarge({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 24,\r\n    fontWeight: FontWeight.bold,\r\n    letterSpacing: -0.5,\r\n    color: isDark ? AppColors.neutral50 : AppColors.neutral900,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Titre moyen (ex: titres de section)\r\n  static TextStyle titleMedium({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 20,\r\n    fontWeight: FontWeight.w600,\r\n    letterSpacing: -0.25,\r\n    color: isDark ? AppColors.neutral50 : AppColors.neutral900,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Petit titre (ex: titres de carte/lment)\r\n  static TextStyle titleSmall({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 16,\r\n    fontWeight: FontWeight.w600,\r\n    letterSpacing: 0,\r\n    color: isDark ? AppColors.neutral50 : AppColors.neutral900,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  // CORPS DE TEXTE (3 niveaux)\r\n\r\n  /// Grand texte (ex: contenu important)\r\n  static TextStyle bodyLarge({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 16,\r\n    fontWeight: FontWeight.normal,\r\n    letterSpacing: _letterSpacingNormal,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightNormal,\r\n  );\r\n\r\n  /// Texte moyen (ex: contenu standard)\r\n  static TextStyle bodyMedium({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.normal,\r\n    letterSpacing: _letterSpacingNormal,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightNormal,\r\n  );\r\n\r\n  /// Petit texte (ex: notes secondaires)\r\n  static TextStyle bodySmall({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 12,\r\n    fontWeight: FontWeight.normal,\r\n    letterSpacing: _letterSpacingNormal,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightNormal,\r\n  );\r\n\r\n  // LABELS (3 niveaux)\r\n\r\n  /// Grand label (ex: grands chips/filtres)\r\n  static TextStyle labelLarge({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.w500,\r\n    letterSpacing: 0.1,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Label moyen (ex: boutons, chips)\r\n  static TextStyle labelMedium({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 12,\r\n    fontWeight: FontWeight.w500,\r\n    letterSpacing: 0.1,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Petit label (ex: petites annotations)\r\n  static TextStyle labelSmall({bool isDark = false, bool isSecondary = false}) => AppFonts.getFont(\r\n    fontSize: 10,\r\n    fontWeight: FontWeight.w500,\r\n    letterSpacing: 0.1,\r\n    color: _getBodyColor(isDark, isSecondary),\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  // STYLES SPCIAUX COURANTS\r\n\r\n  /// Style pour les boutons\r\n  static TextStyle buttonStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.w600,\r\n    letterSpacing: 0.1,\r\n    height: _lineHeightCompact,\r\n  );\r\n\r\n  /// Style pour les chips normaux\r\n  static TextStyle chipLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    fontWeight: FontWeight.w500,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n    height: _lineHeightCompact,\r\n    letterSpacing: 0.1,\r\n  );\r\n\r\n  /// Style pour les chips slectionns\r\n  static TextStyle chipSelectedLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    fontWeight: FontWeight.bold,\r\n    color: AppColors.primary,\r\n  );\r\n\r\n  /// Style pour les titres de carte d'activit\r\n  static TextStyle cardTitleStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 16,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    color: Colors.white,\r\n    fontWeight: FontWeight.bold,\r\n  );\r\n\r\n  /// Style pour les catgories de carte d'activit\r\n  static TextStyle cardCategoryStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    color: Colors.white,\r\n  );\r\n\r\n  /// Style pour les sous-titres de carte d'activit\r\n  static TextStyle cardSubtitleStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 13,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    color: Colors.white.withOpacity(0.8),\r\n  );\r\n\r\n  /// Style pour les items normaux dans la navigation\r\n  static TextStyle itemLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n    fontSize: 14,\r\n    color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n    // isSecondary: true,\r\n  );\r\n\r\n  /// Style pour les items slectionns dans la navigation\r\n  static TextStyle itemSelectedLabelStyle({bool isDark = false}) => AppFonts.getFont(\r\n      fontSize: 14,\r\n      color: isDark ? AppColors.neutral200 : AppColors.neutral800,\r\n  ).copyWith(\r\n    fontWeight: FontWeight.bold,\r\n    color: AppColors.primary,\r\n  );\r\n\r\n  // HELPERS\r\n\r\n  /// Obtient la couleur approprie pour le texte corps selon le mode et l'importance\r\n  static Color _getBodyColor(bool isDark, bool isSecondary) {\r\n    if (isSecondary) {\r\n      return isDark ? AppColors.neutral400 : AppColors.neutral600;\r\n    } else {\r\n      return isDark ? AppColors.neutral100 : AppColors.neutral900;\r\n    }\r\n  }\r\n\r\n  /// Cre un TextTheme complet pour le ThemeData\r\n  static TextTheme createTextTheme(bool isDark) {\r\n    final baseTheme = TextTheme(\r\n      // Titres\r\n      headlineLarge: titleLarge(isDark: isDark),\r\n      headlineMedium: titleMedium(isDark: isDark),\r\n      headlineSmall: titleSmall(isDark: isDark),\r\n\r\n      // Corps\r\n      bodyLarge: bodyLarge(isDark: isDark),\r\n      bodyMedium: bodyMedium(isDark: isDark),\r\n      bodySmall: bodySmall(isDark: isDark),\r\n\r\n      // Divers\r\n      titleLarge: titleLarge(isDark: isDark),\r\n      titleMedium: titleMedium(isDark: isDark),\r\n      titleSmall: titleSmall(isDark: isDark),\r\n      labelLarge: labelLarge(isDark: isDark),\r\n      labelMedium: labelMedium(isDark: isDark),\r\n      labelSmall: labelSmall(isDark: isDark),\r\n    );\r\n    return AppFonts.getTextTheme(baseTheme);\r\n  }\r\n}\r\n\r\n/// Extension sur BuildContext pour faciliter l'accs aux thmes et typographies\r\nextension ThemeHelperExtension on BuildContext {\r\n  /// Indique si le thme actuel est en mode sombre\r\n  bool get isDark =>\r\n      Theme\r\n          .of(this)\r\n          .brightness == Brightness.dark;\r\n\r\n  /// Accs rapide aux styles typographiques en tenant compte du thme actuel\r\n\r\n  // Titres\r\n  TextStyle get titleLarge => AppTypography.titleLarge(isDark: isDark);\r\n\r\n  TextStyle get titleMedium => AppTypography.titleMedium(isDark: isDark);\r\n\r\n  TextStyle get titleSmall => AppTypography.titleSmall(isDark: isDark);\r\n\r\n  // Corps de texte\r\n  TextStyle get bodyLarge => AppTypography.bodyLarge(isDark: isDark);\r\n\r\n  TextStyle get bodyMedium => AppTypography.bodyMedium(isDark: isDark);\r\n\r\n  TextStyle get bodySmall => AppTypography.bodySmall(isDark: isDark);\r\n\r\n  // Labels\r\n  TextStyle get labelLarge => AppTypography.labelLarge(isDark: isDark);\r\n\r\n  TextStyle get labelMedium => AppTypography.labelMedium(isDark: isDark);\r\n\r\n  TextStyle get labelSmall => AppTypography.labelSmall(isDark: isDark);\r\n\r\n  // Corps de texte secondaire\r\n  TextStyle get bodyLargeSecondary =>\r\n      AppTypography.bodyLarge(isDark: isDark, isSecondary: true);\r\n\r\n  TextStyle get bodyMediumSecondary =>\r\n      AppTypography.bodyMedium(isDark: isDark, isSecondary: true);\r\n\r\n  TextStyle get bodySmallSecondary =>\r\n      AppTypography.bodySmall(isDark: isDark, isSecondary: true);\r\n\r\n  // Styles spciaux\r\n  TextStyle get buttonStyle => AppTypography.buttonStyle(isDark: isDark);\r\n\r\n  TextStyle get chipLabel => AppTypography.chipLabelStyle(isDark: isDark);\r\n\r\n  TextStyle get chipSelectedLabel =>\r\n      AppTypography.chipSelectedLabelStyle(isDark: isDark);\r\n\r\n  TextStyle get cardTitle => AppTypography.cardTitleStyle(isDark: isDark);\r\n\r\n  TextStyle get cardCategory => AppTypography.cardCategoryStyle(isDark: isDark);\r\n\r\n  TextStyle get cardSubtitle => AppTypography.cardSubtitleStyle(isDark: isDark);\r\n\r\n  TextStyle get itemLabel => AppTypography.itemLabelStyle(isDark: isDark);\r\n\r\n  TextStyle get itemSelectedLabel =>\r\n      AppTypography.itemSelectedLabelStyle(isDark: isDark);\r\n}",
      "info": {
        "size": 9142,
        "last_modified": "2025-04-16T13:25:27.4684179",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_button.dart",
      "content": "// lib/core/theme/atoms/app_button.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../theme/app_colors.dart';\r\nimport '../../theme/app_dimensions.dart';\r\nimport '../../theme/app_interactions.dart';\r\nimport '../../theme/app_typography.dart';\r\n\r\n/// Enum dfinissant les diffrentes variantes de boutons\r\nenum AppButtonVariant {\r\n  primary,\r\n  secondary,\r\n  outlined,\r\n  text,\r\n  error,\r\n  success,\r\n  category,\r\n}\r\n\r\n/// Enum dfinissant les diffrentes tailles de boutons\r\nenum AppButtonSize {\r\n  small,\r\n  medium,\r\n  large,\r\n}\r\n\r\n/// Bouton personnalis rutilisable suivant le design system de Lyra\r\n///\r\n/// Composant atomique fondamental pour toutes les actions utilisateur.\r\nclass AppButton extends StatelessWidget {\r\n  /// Label du bouton\r\n  final String label;\r\n\r\n  /// Fonction appele quand le bouton est press\r\n  final VoidCallback? onPressed;\r\n\r\n  /// Variante stylistique du bouton\r\n  final AppButtonVariant variant;\r\n\r\n  /// Taille du bouton\r\n  final AppButtonSize size;\r\n\r\n  /// Icne  afficher avant le texte (optionnel)\r\n  final IconData? leadingIcon;\r\n\r\n  /// Icne  afficher aprs le texte (optionnel)\r\n  final IconData? trailingIcon;\r\n\r\n  /// Si true, le bouton prendra toute la largeur disponible\r\n  final bool isFullWidth;\r\n\r\n  /// Indique si le bouton est en tat de chargement\r\n  final bool isLoading;\r\n\r\n  /// Style personnalis pour le texte du bouton (optionnel)\r\n  final TextStyle? customTextStyle;\r\n\r\n  /// Couleur de catgorie (utilise uniquement avec AppButtonVariant.category)\r\n  final Color? categoryColor;\r\n\r\n  /// Ombre personnalise (optionnel)\r\n  final List<BoxShadow>? customShadow;\r\n\r\n  /// Radius personnalis pour les coins (optionnel)\r\n  final BorderRadius? customBorderRadius;\r\n\r\n  const AppButton({\r\n    Key? key,\r\n    required this.label,\r\n    required this.onPressed,\r\n    this.variant = AppButtonVariant.primary,\r\n    this.size = AppButtonSize.medium,\r\n    this.leadingIcon,\r\n    this.trailingIcon,\r\n    this.isFullWidth = false,\r\n    this.isLoading = false,\r\n    this.customTextStyle,\r\n    this.categoryColor,\r\n    this.customShadow,\r\n    this.customBorderRadius,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    // Dterminer si le bouton est dsactiv\r\n    final bool isDisabled = onPressed == null || isLoading;\r\n\r\n    // Appliquer les dimensions en fonction de la taille choisie\r\n    final double height = _getHeight();\r\n    final EdgeInsets padding = _getPadding();\r\n    final double iconSize = _getIconSize();\r\n\r\n    // Configurer les couleurs et styles en fonction de la variante\r\n    final ButtonStyle buttonStyle = _getButtonStyle(context, isDisabled);\r\n\r\n    // Construire le contenu du bouton (texte et/ou icnes)\r\n    Widget buttonContent = _buildButtonContent(context, iconSize, isDisabled);\r\n\r\n    // Ajouter l'indicateur de chargement si ncessaire\r\n    if (isLoading) {\r\n      buttonContent = Stack(\r\n        alignment: Alignment.center,\r\n        children: [\r\n          Opacity(opacity: 0, child: buttonContent),\r\n          SizedBox(\r\n            height: iconSize,\r\n            width: iconSize,\r\n            child: CircularProgressIndicator(\r\n              strokeWidth: 2,\r\n              valueColor: AlwaysStoppedAnimation<Color>(_getButtonContentColor(context, isDisabled)),\r\n            ),\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    // Crer le bouton final avec tous les attributs configurs\r\n    return SizedBox(\r\n      height: height,\r\n      width: isFullWidth ? double.infinity : null,\r\n      child: variant == AppButtonVariant.text\r\n          ? TextButton(\r\n        onPressed: isDisabled ? null : onPressed,\r\n        style: buttonStyle,\r\n        child: buttonContent,\r\n      )\r\n          : ElevatedButton(\r\n        onPressed: isDisabled ? null : onPressed,\r\n        style: buttonStyle,\r\n        child: buttonContent,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Construit le contenu interne du bouton (texte et icnes)\r\n  Widget _buildButtonContent(BuildContext context, double iconSize, bool isDisabled) {\r\n    final TextStyle textStyle = customTextStyle ??\r\n        _getTextStyle(context, isDisabled);\r\n\r\n    // Liste des lments  afficher horizontalement\r\n    final List<Widget> rowChildren = [];\r\n\r\n    // Ajouter l'icne de gauche si prsente\r\n    if (leadingIcon != null) {\r\n      rowChildren.add(\r\n        Icon(\r\n          leadingIcon,\r\n          size: iconSize,\r\n          color: textStyle.color,\r\n        ),\r\n      );\r\n      rowChildren.add(SizedBox(width: AppDimensions.space2));\r\n    }\r\n\r\n    // Ajouter le texte\r\n    rowChildren.add(\r\n      Text(\r\n        label,\r\n        style: textStyle,\r\n      ),\r\n    );\r\n\r\n    // Ajouter l'icne de droite si prsente\r\n    if (trailingIcon != null) {\r\n      rowChildren.add(SizedBox(width: AppDimensions.space2));\r\n      rowChildren.add(\r\n        Icon(\r\n          trailingIcon,\r\n          size: iconSize,\r\n          color: textStyle.color,\r\n        ),\r\n      );\r\n    }\r\n\r\n    // Retourner la range complte\r\n    return Row(\r\n      mainAxisSize: MainAxisSize.min,\r\n      mainAxisAlignment: MainAxisAlignment.center,\r\n      children: rowChildren,\r\n    );\r\n  }\r\n\r\n  /// Dtermine la hauteur du bouton selon sa taille\r\n  double _getHeight() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return AppDimensions.buttonHeightS;\r\n      case AppButtonSize.medium:\r\n        return AppDimensions.buttonHeightM;\r\n      case AppButtonSize.large:\r\n        return AppDimensions.buttonHeightL;\r\n    }\r\n  }\r\n\r\n  /// Dtermine le padding interne du bouton selon sa taille\r\n  EdgeInsets _getPadding() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return EdgeInsets.symmetric(\r\n          horizontal: AppDimensions.space3,\r\n          vertical: AppDimensions.space1,\r\n        );\r\n      case AppButtonSize.medium:\r\n        return EdgeInsets.symmetric(\r\n          horizontal: AppDimensions.space4,\r\n          vertical: AppDimensions.space2,\r\n        );\r\n      case AppButtonSize.large:\r\n        return EdgeInsets.symmetric(\r\n          horizontal: AppDimensions.space5,\r\n          vertical: AppDimensions.space2,\r\n        );\r\n    }\r\n  }\r\n\r\n  /// Dtermine la taille des icnes selon la taille du bouton\r\n  double _getIconSize() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return AppDimensions.iconSizeS;\r\n      case AppButtonSize.medium:\r\n        return AppDimensions.iconSizeM;\r\n      case AppButtonSize.large:\r\n        return AppDimensions.iconSizeM;\r\n    }\r\n  }\r\n\r\n  /// Configuration complte du style du bouton selon sa variante\r\n  ButtonStyle _getButtonStyle(BuildContext context, bool isDisabled) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Border radius selon la taille\r\n    final BorderRadius borderRadius = customBorderRadius ?? _getBorderRadius();\r\n\r\n    // Couleur de fond selon la variante\r\n    final Color backgroundColor = _getBackgroundColor(context, isDisabled);\r\n\r\n    // Couleur du contenu (texte et icnes)\r\n    final Color contentColor = _getButtonContentColor(context, isDisabled);\r\n\r\n    // Grer le cas spcial du bouton outlined\r\n    if (variant == AppButtonVariant.outlined) {\r\n      return ButtonStyle(\r\n        backgroundColor: MaterialStateProperty.all(Colors.transparent),\r\n        foregroundColor: MaterialStateProperty.all(contentColor),\r\n        overlayColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.pressed)) {\r\n            return contentColor.withOpacity(0.1);\r\n          }\r\n          if (states.contains(MaterialState.hovered)) {\r\n            return contentColor.withOpacity(0.05);\r\n          }\r\n          return null;\r\n        }),\r\n        side: MaterialStateProperty.all(\r\n          BorderSide(\r\n            color: isDisabled\r\n                ? (isDark ? AppColors.neutral700 : AppColors.neutral300)\r\n                : contentColor,\r\n            width: 1.0,\r\n          ),\r\n        ),\r\n        shape: MaterialStateProperty.all(\r\n          RoundedRectangleBorder(borderRadius: borderRadius),\r\n        ),\r\n        padding: MaterialStateProperty.all(_getPadding()),\r\n        elevation: MaterialStateProperty.all(0),\r\n      );\r\n    }\r\n\r\n    // Grer le cas du bouton texte\r\n    if (variant == AppButtonVariant.text) {\r\n      return ButtonStyle(\r\n        backgroundColor: MaterialStateProperty.all(Colors.transparent),\r\n        foregroundColor: MaterialStateProperty.all(contentColor),\r\n        overlayColor: MaterialStateProperty.resolveWith((states) {\r\n          if (states.contains(MaterialState.pressed)) {\r\n            return contentColor.withOpacity(0.1);\r\n          }\r\n          if (states.contains(MaterialState.hovered)) {\r\n            return contentColor.withOpacity(0.05);\r\n          }\r\n          return null;\r\n        }),\r\n        shape: MaterialStateProperty.all(\r\n          RoundedRectangleBorder(borderRadius: borderRadius),\r\n        ),\r\n        padding: MaterialStateProperty.all(_getPadding()),\r\n        elevation: MaterialStateProperty.all(0),\r\n      );\r\n    }\r\n\r\n    // Style pour les autres variantes (primary, secondary, etc.)\r\n    return ButtonStyle(\r\n      backgroundColor: MaterialStateProperty.all(backgroundColor),\r\n      foregroundColor: MaterialStateProperty.all(contentColor),\r\n      overlayColor: MaterialStateProperty.resolveWith((states) {\r\n        if (states.contains(MaterialState.pressed)) {\r\n          return Colors.black.withOpacity(0.1);\r\n        }\r\n        return null;\r\n      }),\r\n      shape: MaterialStateProperty.all(\r\n        RoundedRectangleBorder(borderRadius: borderRadius),\r\n      ),\r\n      padding: MaterialStateProperty.all(_getPadding()),\r\n      elevation: MaterialStateProperty.resolveWith((states) {\r\n        if (states.contains(MaterialState.disabled)) {\r\n          return 0;\r\n        }\r\n        if (states.contains(MaterialState.pressed)) {\r\n          return 1;\r\n        }\r\n        return variant == AppButtonVariant.primary ? 2 : 0;\r\n      }),\r\n      shadowColor: MaterialStateProperty.all(\r\n        variant == AppButtonVariant.primary\r\n            ? colorScheme.primary.withOpacity(0.5)\r\n            : Colors.black.withOpacity(0.3),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Obtient le style de texte appropri selon la variante et l'tat\r\n  TextStyle _getTextStyle(BuildContext context, bool isDisabled) {\r\n    // Utiliser le style de bouton standard comme base\r\n    final baseStyle = context.buttonStyle;\r\n\r\n    // Adapter selon la taille du bouton\r\n    TextStyle adjustedStyle = baseStyle;\r\n    if (size == AppButtonSize.small) {\r\n      adjustedStyle = baseStyle.copyWith(\r\n        fontSize: 14,\r\n      );\r\n    } else if (size == AppButtonSize.large) {\r\n      adjustedStyle = baseStyle.copyWith(\r\n        fontSize: 16,\r\n      );\r\n    }\r\n\r\n    // Appliquer la couleur selon l'tat et la variante\r\n    return adjustedStyle.copyWith(\r\n      color: _getButtonContentColor(context, isDisabled),\r\n    );\r\n  }\r\n\r\n  /// Obtient la couleur d'arrire-plan selon la variante\r\n  Color _getBackgroundColor(BuildContext context, bool isDisabled) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Si le bouton est dsactiv, il a une couleur grise\r\n    if (isDisabled) {\r\n      return isDark ? AppColors.neutral800 : AppColors.neutral200;\r\n    }\r\n\r\n    // Sinon, choisir la couleur selon la variante\r\n    switch (variant) {\r\n      case AppButtonVariant.primary:\r\n        return colorScheme.primary;\r\n      case AppButtonVariant.secondary:\r\n        return colorScheme.secondary;\r\n      case AppButtonVariant.outlined:\r\n        return Colors.transparent;\r\n      case AppButtonVariant.text:\r\n        return Colors.transparent;\r\n      case AppButtonVariant.error:\r\n        return colorScheme.error;\r\n      case AppButtonVariant.success:\r\n        return AppColors.success;\r\n      case AppButtonVariant.category:\r\n        return categoryColor ?? AppColors.primary;\r\n    }\r\n  }\r\n\r\n  /// Obtient la couleur du contenu (texte/icnes) selon la variante\r\n  Color _getButtonContentColor(BuildContext context, bool isDisabled) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Si le bouton est dsactiv\r\n    if (isDisabled) {\r\n      if (variant == AppButtonVariant.outlined || variant == AppButtonVariant.text) {\r\n        return isDark ? AppColors.neutral600 : AppColors.neutral400;\r\n      }\r\n      return isDark ? AppColors.neutral500 : AppColors.neutral500;\r\n    }\r\n\r\n    // Pour les variantes transparentes\r\n    if (variant == AppButtonVariant.outlined || variant == AppButtonVariant.text) {\r\n      switch (variant) {\r\n        case AppButtonVariant.outlined:\r\n        case AppButtonVariant.text:\r\n          if (variant == AppButtonVariant.error) {\r\n            return colorScheme.error;\r\n          } else if (variant == AppButtonVariant.success) {\r\n            return AppColors.success;\r\n          } else if (variant == AppButtonVariant.category) {\r\n            return categoryColor ?? colorScheme.primary;\r\n          } else {\r\n            return colorScheme.primary;\r\n          }\r\n        default:\r\n          return colorScheme.primary;\r\n      }\r\n    }\r\n\r\n    // Pour les variantes avec fond color (texte gnralement blanc)\r\n    return Colors.white;\r\n  }\r\n\r\n  /// Obtient le border radius selon la taille du bouton\r\n  BorderRadius _getBorderRadius() {\r\n    switch (size) {\r\n      case AppButtonSize.small:\r\n        return AppDimensions.borderRadiusS;\r\n      case AppButtonSize.medium:\r\n        return AppDimensions.borderRadiusM;\r\n      case AppButtonSize.large:\r\n        return AppDimensions.borderRadiusM;\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 13760,
        "last_modified": "2025-04-16T13:25:27.4749708",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_card.dart",
      "content": "// lib/core/theme/atoms/app_card.dart",
      "info": {
        "size": 37,
        "last_modified": "2025-04-16T13:25:27.4820061",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_input.dart",
      "content": "// lib/core/theme/atoms/app_input.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter/services.dart';\r\nimport '../../theme/app_colors.dart';\r\nimport '../../theme/app_dimensions.dart';\r\nimport '../../theme/app_typography.dart';\r\n\r\n/// Types de champs d'entre disponibles\r\nenum AppInputType {\r\n  text,\r\n  email,\r\n  password,\r\n  number,\r\n  phone,\r\n  search,\r\n  multiline,\r\n}\r\n\r\n/// Variantes visuelles des champs\r\nenum AppInputVariant {\r\n  filled,    // Fond color\r\n  outlined,  // Bordure visible\r\n  underlined, // Seulement une ligne en dessous\r\n  plain,     // Sans dcoration (transparent)\r\n}\r\n\r\n/// Tailles disponibles\r\nenum AppInputSize {\r\n  small,\r\n  medium,\r\n  large,\r\n}\r\n\r\n/// Champ d'entre rutilisable suivant le design system de Lyra\r\nclass AppInput extends StatefulWidget {\r\n  /// Controlleur du champ (optionnel)\r\n  final TextEditingController? controller;\r\n\r\n  /// Libell du champ\r\n  final String? label;\r\n\r\n  /// Texte d'indication quand le champ est vide\r\n  final String? placeholder;\r\n\r\n  /// Type du champ d'entre\r\n  final AppInputType type;\r\n\r\n  /// Variante visuelle\r\n  final AppInputVariant variant;\r\n\r\n  /// Taille du champ\r\n  final AppInputSize size;\r\n\r\n  /// Icne  afficher  gauche (optionnel)\r\n  final IconData? prefixIcon;\r\n\r\n  /// Icne  afficher  droite (optionnel)\r\n  final IconData? suffixIcon;\r\n\r\n  /// Action  effectuer quand on appuie sur l'icne de droite\r\n  final VoidCallback? onSuffixIconPressed;\r\n\r\n  /// Formatters pour le texte\r\n  final List<TextInputFormatter>? inputFormatters;\r\n\r\n  /// Si le champ doit tre en lecture seule\r\n  final bool readOnly;\r\n\r\n  /// Si le champ doit tre dsactiv\r\n  final bool disabled;\r\n\r\n  /// Si le contenu doit tre centr\r\n  final bool isCentered;\r\n\r\n  /// Couleur de fond personnalise\r\n  final Color? backgroundColor;\r\n\r\n  /// Texte d'erreur  afficher en dessous du champ\r\n  final String? errorText;\r\n\r\n  /// Texte d'aide  afficher en dessous du champ\r\n  final String? helperText;\r\n\r\n  /// Fonction appele quand le texte change\r\n  final ValueChanged<String>? onChanged;\r\n\r\n  /// Fonction appele quand le champ perd le focus\r\n  final VoidCallback? onFieldSubmitted;\r\n\r\n  /// Nombre maximum de caractres\r\n  final int? maxLength;\r\n\r\n  /// Nombre maximum de lignes (pour multiline)\r\n  final int? maxLines;\r\n\r\n  /// Nombre minimum de lignes (pour multiline)\r\n  final int? minLines;\r\n\r\n  /// Validation personnalise\r\n  final String? Function(String?)? validator;\r\n\r\n  /// Action du clavier\r\n  final TextInputAction? textInputAction;\r\n\r\n  /// Si le champ doit recevoir le focus automatiquement\r\n  final bool autofocus;\r\n\r\n  /// Focus node personnalis\r\n  final FocusNode? focusNode;\r\n\r\n  const AppInput({\r\n    Key? key,\r\n    this.controller,\r\n    this.label,\r\n    this.placeholder,\r\n    this.type = AppInputType.text,\r\n    this.variant = AppInputVariant.filled,\r\n    this.size = AppInputSize.medium,\r\n    this.prefixIcon,\r\n    this.suffixIcon,\r\n    this.onSuffixIconPressed,\r\n    this.inputFormatters,\r\n    this.readOnly = false,\r\n    this.disabled = false,\r\n    this.isCentered = false,\r\n    this.backgroundColor,\r\n    this.errorText,\r\n    this.helperText,\r\n    this.onChanged,\r\n    this.onFieldSubmitted,\r\n    this.maxLength,\r\n    this.maxLines,\r\n    this.minLines,\r\n    this.validator,\r\n    this.textInputAction,\r\n    this.autofocus = false,\r\n    this.focusNode,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  State<AppInput> createState() => _AppInputState();\r\n}\r\n\r\nclass _AppInputState extends State<AppInput> {\r\n  bool _obscureText = true;\r\n  late FocusNode _focusNode;\r\n  bool _isFocused = false;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _focusNode = widget.focusNode ?? FocusNode();\r\n    _focusNode.addListener(_handleFocusChange);\r\n\r\n    if (widget.autofocus) {\r\n      Future.delayed(Duration.zero, () {\r\n        _focusNode.requestFocus();\r\n      });\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    if (widget.focusNode == null) {\r\n      _focusNode.removeListener(_handleFocusChange);\r\n      _focusNode.dispose();\r\n    }\r\n    super.dispose();\r\n  }\r\n\r\n  void _handleFocusChange() {\r\n    setState(() {\r\n      _isFocused = _focusNode.hasFocus;\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n\r\n    // Configuration du clavier\r\n    final TextInputType keyboardType = _getKeyboardType();\r\n\r\n    // Dterminer si l'icne mot de passe doit tre affiche\r\n    final bool isPassword = widget.type == AppInputType.password;\r\n\r\n    // Icnes  afficher\r\n    Widget? prefixIconWidget = widget.prefixIcon != null\r\n        ? Icon(\r\n      widget.prefixIcon,\r\n      color: _getIconColor(context),\r\n      size: _getIconSize(),\r\n    )\r\n        : null;\r\n\r\n    Widget? suffixIconWidget;\r\n\r\n    if (isPassword) {\r\n      suffixIconWidget = IconButton(\r\n        icon: Icon(\r\n          _obscureText ? Icons.visibility_outlined : Icons.visibility_off_outlined,\r\n          color: _getIconColor(context),\r\n          size: _getIconSize(),\r\n        ),\r\n        onPressed: () {\r\n          setState(() {\r\n            _obscureText = !_obscureText;\r\n          });\r\n        },\r\n      );\r\n    } else if (widget.suffixIcon != null) {\r\n      suffixIconWidget = IconButton(\r\n        icon: Icon(\r\n          widget.suffixIcon,\r\n          color: _getIconColor(context),\r\n          size: _getIconSize(),\r\n        ),\r\n        onPressed: widget.onSuffixIconPressed,\r\n      );\r\n    }\r\n\r\n    // Style du texte\r\n    final TextStyle textStyle = _getTextStyle(context);\r\n\r\n    // Style du placeholder\r\n    final TextStyle placeholderStyle = _getPlaceholderStyle(context);\r\n\r\n    // Hauteur du champ\r\n    final double height = _getHeight();\r\n\r\n    // Couleurs et bordures selon la variante\r\n    final InputDecoration decoration = _getInputDecoration(\r\n      context,\r\n      prefixIconWidget,\r\n      suffixIconWidget,\r\n      isDark,\r\n      placeholderStyle,\r\n    );\r\n\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      mainAxisSize: MainAxisSize.min,\r\n      children: [\r\n        // Libell au-dessus (si prsent)\r\n        if (widget.label != null) ...[\r\n          Text(\r\n            widget.label!,\r\n            style: context.labelMedium,\r\n          ),\r\n          SizedBox(height: AppDimensions.space2),\r\n        ],\r\n\r\n        // Le champ lui-mme\r\n        SizedBox(\r\n          height: widget.type == AppInputType.multiline ? null : height,\r\n          child: TextFormField(\r\n            controller: widget.controller,\r\n            focusNode: _focusNode,\r\n            obscureText: isPassword && _obscureText,\r\n            readOnly: widget.readOnly,\r\n            enabled: !widget.disabled,\r\n            textAlign: widget.isCentered ? TextAlign.center : TextAlign.start,\r\n            style: textStyle,\r\n            keyboardType: keyboardType,\r\n            textInputAction: widget.textInputAction,\r\n            maxLength: widget.maxLength,\r\n            maxLines: widget.type == AppInputType.multiline\r\n                ? widget.maxLines ?? 5\r\n                : 1,\r\n            minLines: widget.type == AppInputType.multiline\r\n                ? widget.minLines ?? 3\r\n                : 1,\r\n            inputFormatters: _getInputFormatters(),\r\n            decoration: decoration,\r\n            onChanged: widget.onChanged,\r\n            onFieldSubmitted: (value) {\r\n              if (widget.onFieldSubmitted != null) {\r\n                widget.onFieldSubmitted!();\r\n              }\r\n            },\r\n            validator: widget.validator,\r\n            autovalidateMode: AutovalidateMode.onUserInteraction,\r\n          ),\r\n        ),\r\n\r\n        // Texte d'aide sous le champ (si prsent)\r\n        if (widget.helperText != null && widget.errorText == null) ...[\r\n          SizedBox(height: AppDimensions.space1),\r\n          Text(\r\n            widget.helperText!,\r\n            style: context.labelSmall,\r\n          ),\r\n        ],\r\n      ],\r\n    );\r\n  }\r\n\r\n  TextInputType _getKeyboardType() {\r\n    switch (widget.type) {\r\n      case AppInputType.email:\r\n        return TextInputType.emailAddress;\r\n      case AppInputType.number:\r\n        return TextInputType.number;\r\n      case AppInputType.phone:\r\n        return TextInputType.phone;\r\n      case AppInputType.multiline:\r\n        return TextInputType.multiline;\r\n      default:\r\n        return TextInputType.text;\r\n    }\r\n  }\r\n\r\n  List<TextInputFormatter>? _getInputFormatters() {\r\n    if (widget.inputFormatters != null) {\r\n      return widget.inputFormatters;\r\n    }\r\n\r\n    // Formatters par dfaut selon le type\r\n    switch (widget.type) {\r\n      case AppInputType.number:\r\n        return [FilteringTextInputFormatter.digitsOnly];\r\n      case AppInputType.phone:\r\n        return [FilteringTextInputFormatter.digitsOnly];\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  double _getHeight() {\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return AppDimensions.inputHeightS;\r\n      case AppInputSize.medium:\r\n        return AppDimensions.inputHeightM;\r\n      case AppInputSize.large:\r\n        return AppDimensions.inputHeightL;\r\n    }\r\n  }\r\n\r\n  double _getIconSize() {\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return AppDimensions.iconSizeS;\r\n      case AppInputSize.medium:\r\n        return AppDimensions.iconSizeM;\r\n      case AppInputSize.large:\r\n        return AppDimensions.iconSizeM;\r\n    }\r\n  }\r\n\r\n  BorderRadius _getBorderRadius() {\r\n    if (widget.variant == AppInputVariant.underlined) {\r\n      return BorderRadius.zero;\r\n    }\r\n\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return AppDimensions.borderRadiusS;\r\n      case AppInputSize.medium:\r\n        return AppDimensions.borderRadiusM;\r\n      case AppInputSize.large:\r\n        return AppDimensions.borderRadiusM;\r\n    }\r\n  }\r\n\r\n  TextStyle _getTextStyle(BuildContext context) {\r\n    switch (widget.size) {\r\n      case AppInputSize.small:\r\n        return context.bodySmall;\r\n      case AppInputSize.medium:\r\n        return context.bodyMedium;\r\n      case AppInputSize.large:\r\n        return context.bodyLarge;\r\n    }\r\n  }\r\n\r\n  TextStyle _getPlaceholderStyle(BuildContext context) {\r\n    final baseStyle = _getTextStyle(context);\r\n    return baseStyle.copyWith(\r\n      color: Theme.of(context).brightness == Brightness.dark\r\n          ? AppColors.neutral500\r\n          : AppColors.neutral500,\r\n      fontWeight: FontWeight.normal,\r\n    );\r\n  }\r\n\r\n  Color _getIconColor(BuildContext context) {\r\n    final bool hasError = widget.errorText != null;\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n\r\n    if (hasError) {\r\n      return Theme.of(context).colorScheme.error;\r\n    } else if (widget.disabled) {\r\n      return isDark ? AppColors.neutral600 : AppColors.neutral400;\r\n    } else if (_isFocused) {\r\n      return Theme.of(context).colorScheme.primary;\r\n    } else {\r\n      return isDark ? AppColors.neutral500 : AppColors.neutral600;\r\n    }\r\n  }\r\n\r\n  InputDecoration _getInputDecoration(\r\n      BuildContext context,\r\n      Widget? prefixIconWidget,\r\n      Widget? suffixIconWidget,\r\n      bool isDark,\r\n      TextStyle placeholderStyle,\r\n      ) {\r\n    final bool hasError = widget.errorText != null;\r\n\r\n    // Couleurs selon l'tat\r\n    Color fillColor;\r\n    Color borderColor;\r\n\r\n    if (widget.disabled) {\r\n      fillColor = isDark ? AppColors.neutral800.withOpacity(0.5) : AppColors.neutral200;\r\n      borderColor = isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n    } else if (hasError) {\r\n      fillColor = isDark\r\n          ? AppColors.errorDark.withOpacity(0.1)\r\n          : AppColors.errorLight.withOpacity(0.1);\r\n      borderColor = Theme.of(context).colorScheme.error;\r\n    } else if (_isFocused) {\r\n      fillColor = isDark\r\n          ? AppColors.neutral800.withOpacity(0.7)\r\n          : AppColors.neutral100;\r\n      borderColor = Theme.of(context).colorScheme.primary;\r\n    } else {\r\n      fillColor = widget.backgroundColor ?? (isDark\r\n          ? AppColors.neutral800.withOpacity(0.5)\r\n          : AppColors.neutral100);\r\n      borderColor = isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n    }\r\n\r\n    // Configurations spcifiques  la variante\r\n    final BorderRadius borderRadius = _getBorderRadius();\r\n\r\n    switch (widget.variant) {\r\n      case AppInputVariant.filled:\r\n        return InputDecoration(\r\n          filled: true,\r\n          fillColor: fillColor,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide.none,\r\n          ),\r\n          enabledBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide.none,\r\n          ),\r\n          focusedBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide.none,\r\n          ),\r\n          errorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedErrorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n        );\r\n\r\n      case AppInputVariant.outlined:\r\n        return InputDecoration(\r\n          filled: false,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          enabledBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.primary,\r\n              width: 2,\r\n            ),\r\n          ),\r\n          errorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedErrorBorder: OutlineInputBorder(\r\n            borderRadius: borderRadius,\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 2,\r\n            ),\r\n          ),\r\n        );\r\n\r\n      case AppInputVariant.underlined:\r\n        return InputDecoration(\r\n          filled: false,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          enabledBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: borderColor,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.primary,\r\n              width: 2,\r\n            ),\r\n          ),\r\n          errorBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 1,\r\n            ),\r\n          ),\r\n          focusedErrorBorder: UnderlineInputBorder(\r\n            borderSide: BorderSide(\r\n              color: Theme.of(context).colorScheme.error,\r\n              width: 2,\r\n            ),\r\n          ),\r\n        );\r\n\r\n      case AppInputVariant.plain:\r\n        return InputDecoration(\r\n          filled: false,\r\n          hintText: widget.placeholder,\r\n          hintStyle: placeholderStyle,\r\n          errorText: widget.errorText,\r\n          errorStyle: context.labelSmall\r\n              .copyWith(color: Theme.of(context).colorScheme.error),\r\n          prefixIcon: prefixIconWidget,\r\n          suffixIcon: suffixIconWidget,\r\n          contentPadding: _getContentPadding(),\r\n          border: InputBorder.none,\r\n          enabledBorder: InputBorder.none,\r\n          focusedBorder: InputBorder.none,\r\n          errorBorder: InputBorder.none,\r\n          focusedErrorBorder: InputBorder.none,\r\n        );\r\n    }\r\n  }\r\n\r\n  EdgeInsets _getContentPadding() {\r\n    final double verticalPadding = widget.size == AppInputSize.small\r\n        ? AppDimensions.space2\r\n        : AppDimensions.space3;\r\n\r\n    final double horizontalPadding = widget.prefixIcon != null || widget.suffixIcon != null\r\n        ? AppDimensions.space2\r\n        : AppDimensions.space4;\r\n\r\n    return EdgeInsets.symmetric(\r\n      vertical: verticalPadding,\r\n      horizontal: horizontalPadding,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 17923,
        "last_modified": "2025-04-16T13:25:27.4880056",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "core\\theme\\atoms\\app_text.dart",
      "content": "// lib/core/theme/atoms/app_text.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../theme/app_typography.dart';\r\nimport '../../theme/app_colors.dart';\r\n\r\n/// Variantes de style de texte disponibles\r\nenum AppTextVariant {\r\n  displayLarge,\r\n  displayMedium,\r\n  displaySmall,\r\n  headlineLarge,\r\n  headlineMedium,\r\n  headlineSmall,\r\n  titleLarge,\r\n  titleMedium,\r\n  titleSmall,\r\n  bodyLarge,\r\n  bodyMedium,\r\n  bodySmall,\r\n  labelLarge,\r\n  labelMedium,\r\n  labelSmall,\r\n  button,\r\n  link,\r\n  price,\r\n  category,\r\n}\r\n\r\n/// Composant texte rutilisable suivant le design system de Lyra\r\n///\r\n/// Permet d'appliquer facilement les styles typographiques de l'application\r\n/// avec des options supplmentaires (couleur, alignement, etc).\r\nclass AppText extends StatelessWidget {\r\n  /// Le texte  afficher\r\n  final String text;\r\n\r\n  /// La variante de style  appliquer\r\n  final AppTextVariant variant;\r\n\r\n  /// Si le texte doit tre affich en secondaire (gris)\r\n  final bool isSecondary;\r\n\r\n  /// Couleur personnalise (optionnel)\r\n  final Color? color;\r\n\r\n  /// Alignement du texte\r\n  final TextAlign? textAlign;\r\n\r\n  /// Nombre maximum de lignes\r\n  final int? maxLines;\r\n\r\n  /// Comportement lors du dpassement\r\n  final TextOverflow? overflow;\r\n\r\n  /// Style personnalis supplmentaire  appliquer\r\n  final TextStyle? style;\r\n\r\n  /// Si le texte doit tre en gras\r\n  final bool isBold;\r\n\r\n  /// Si le texte doit tre en italique\r\n  final bool isItalic;\r\n\r\n  /// Si le texte doit avoir un soulignement\r\n  final bool isUnderlined;\r\n\r\n  const AppText(\r\n      this.text, {\r\n        Key? key,\r\n        required this.variant,\r\n        this.isSecondary = false,\r\n        this.color,\r\n        this.textAlign,\r\n        this.maxLines,\r\n        this.overflow,\r\n        this.style,\r\n        this.isBold = false,\r\n        this.isItalic = false,\r\n        this.isUnderlined = false,\r\n      }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Text(\r\n      text,\r\n      style: _getStyle(context).copyWith(\r\n        color: color,\r\n        fontWeight: isBold ? FontWeight.bold : null,\r\n        fontStyle: isItalic ? FontStyle.italic : null,\r\n        decoration: isUnderlined ? TextDecoration.underline : null,\r\n      ),\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: overflow ?? (maxLines != null ? TextOverflow.ellipsis : null),\r\n    );\r\n  }\r\n\r\n  TextStyle _getStyle(BuildContext context) {\r\n    final baseStyle = _getBaseStyle(context);\r\n\r\n    if (style != null) {\r\n      return baseStyle.merge(style);\r\n    }\r\n\r\n    return baseStyle;\r\n  }\r\n\r\n  TextStyle _getBaseStyle(BuildContext context) {\r\n    // Cas spcial pour les variantes avec paramtres additionnels\r\n    if (variant == AppTextVariant.category && color != null) {\r\n      return context.labelMedium.copyWith(\r\n        color: color,\r\n        fontWeight: FontWeight.w600,\r\n      );\r\n    }\r\n\r\n    // Utilisation du pattern match pour une meilleure gestion des cas\r\n    return switch (variant) {\r\n    // Titres (regroups par taille)\r\n      AppTextVariant.displayLarge ||\r\n      AppTextVariant.headlineLarge ||\r\n      AppTextVariant.titleLarge => context.titleLarge,\r\n\r\n      AppTextVariant.displayMedium ||\r\n      AppTextVariant.headlineMedium ||\r\n      AppTextVariant.titleMedium => context.titleMedium,\r\n\r\n      AppTextVariant.displaySmall ||\r\n      AppTextVariant.headlineSmall ||\r\n      AppTextVariant.titleSmall => context.titleSmall,\r\n\r\n    // Corps - utilise l'extension avec gestion du isSecondary\r\n      AppTextVariant.bodyLarge => isSecondary ? context.bodyLargeSecondary : context.bodyLarge,\r\n      AppTextVariant.bodyMedium => isSecondary ? context.bodyMediumSecondary : context.bodyMedium,\r\n      AppTextVariant.bodySmall => isSecondary ? context.bodySmallSecondary : context.bodySmall,\r\n\r\n    // Labels - mme logique que les corps\r\n      AppTextVariant.labelLarge => isSecondary\r\n          ? AppTypography.labelLarge(isDark: context.isDark, isSecondary: true)\r\n          : context.labelLarge,\r\n      AppTextVariant.labelMedium => isSecondary\r\n          ? AppTypography.labelMedium(isDark: context.isDark, isSecondary: true)\r\n          : context.labelMedium,\r\n      AppTextVariant.labelSmall => isSecondary\r\n          ? AppTypography.labelSmall(isDark: context.isDark, isSecondary: true)\r\n          : context.labelSmall,\r\n\r\n    // Styles spciaux\r\n      AppTextVariant.button => context.buttonStyle,\r\n      AppTextVariant.link => context.labelMedium.copyWith(\r\n        color: AppColors.primary,\r\n        decoration: TextDecoration.underline,\r\n      ),\r\n      AppTextVariant.price => context.titleSmall.copyWith(\r\n        fontWeight: FontWeight.bold,\r\n      ),\r\n      AppTextVariant.category => context.labelMedium.copyWith(\r\n        color: color ?? AppColors.primary,\r\n        fontWeight: FontWeight.w600,\r\n      )\r\n    };\r\n  }\r\n\r\n  /// Constructeurs de commodit pour les variantes communes\r\n\r\n  /// Titre principal (grand)\r\n  static Widget displayLarge(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.displayLarge,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isBold: isBold,\r\n    );\r\n  }\r\n\r\n  /// Titre de section\r\n  static Widget headline(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.headlineMedium,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isBold: isBold,\r\n    );\r\n  }\r\n\r\n  /// Titre d'lment (par ex. carte)\r\n  static Widget title(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        int? maxLines,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.titleMedium,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: TextOverflow.ellipsis,\r\n      style: style,\r\n      isBold: isBold,\r\n    );\r\n  }\r\n\r\n  /// Texte courant\r\n  static Widget body(\r\n      String text, {\r\n        bool isSecondary = false,\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        int? maxLines,\r\n        TextStyle? style,\r\n        bool isBold = false,\r\n        bool isItalic = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.bodyMedium,\r\n      isSecondary: isSecondary,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: maxLines != null ? TextOverflow.ellipsis : null,\r\n      style: style,\r\n      isBold: isBold,\r\n      isItalic: isItalic,\r\n    );\r\n  }\r\n\r\n  /// Petit texte / lgende\r\n  static Widget caption(\r\n      String text, {\r\n        bool isSecondary = true,\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        int? maxLines,\r\n        TextStyle? style,\r\n        bool isItalic = false,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.labelMedium,\r\n      isSecondary: isSecondary,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      maxLines: maxLines,\r\n      overflow: maxLines != null ? TextOverflow.ellipsis : null,\r\n      style: style,\r\n      isItalic: isItalic,\r\n    );\r\n  }\r\n\r\n  /// Affichage du prix\r\n  static Widget price(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.price,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isBold: true,\r\n    );\r\n  }\r\n\r\n  /// Texte cliquable\r\n  static Widget link(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        VoidCallback? onTap,\r\n        TextStyle? style,\r\n      }) {\r\n    final linkText = AppText(\r\n      text,\r\n      variant: AppTextVariant.link,\r\n      color: color ?? AppColors.primary,\r\n      textAlign: textAlign,\r\n      style: style,\r\n      isUnderlined: true,\r\n    );\r\n\r\n    if (onTap != null) {\r\n      return GestureDetector(\r\n        onTap: onTap,\r\n        child: linkText,\r\n      );\r\n    }\r\n\r\n    return linkText;\r\n  }\r\n\r\n  /// Texte de catgorie\r\n  static Widget category(\r\n      String text, {\r\n        Color? color,\r\n        TextAlign? textAlign,\r\n        TextStyle? style,\r\n      }) {\r\n    return AppText(\r\n      text,\r\n      variant: AppTextVariant.category,\r\n      color: color,\r\n      textAlign: textAlign,\r\n      style: style,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 8633,
        "last_modified": "2025-04-16T13:25:27.4950423",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\pages\\empty_trips_test_page.dart",
      "content": "// lib/features/empty_trips/presentation/pages/empty_trips_test_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../state/test/empty_trips_test_provider.dart';\r\nimport '../state/test/route_optimization_test_provider.dart';\r\nimport '../state/test/empty_trip_generation_test_provider.dart';\r\nimport '../state/test/available_time_test_provider.dart';\r\n\r\nclass EmptyTripsTestPage extends ConsumerWidget {\r\n  const EmptyTripsTestPage({Key? key}) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final emptyTripsState = ref.watch(emptyTripsTestProvider);\r\n    final routeOptState = ref.watch(routeOptimizationTestProvider);\r\n    final emptyTripGenerationState = ref.watch(emptyTripGenerationTestProvider);\r\n    final availableTimeState = ref.watch(availableTimeTestProvider);\r\n\r\n    return Scaffold(\r\n      appBar: AppBar(title: const Text('Test Empty Trips')),\r\n      body: Padding(\r\n        padding: const EdgeInsets.all(16.0),\r\n        child: Column(\r\n          children: [\r\n            // Boutons de test\r\n            Wrap(\r\n              spacing: 8, // Espacement horizontal entre les boutons\r\n              runSpacing: 8, // Espacement vertical entre les lignes de boutons\r\n              children: [\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(emptyTripsTestProvider.notifier).testSuperwowManagement(),\r\n                  child: const Text('SuperWow'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(routeOptimizationTestProvider.notifier).testRouteOptimization(),\r\n                  child: const Text('Routes'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(emptyTripGenerationTestProvider.notifier).testEmptyTripGeneration(),\r\n                  child: const Text('Empty Trips'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testMealBreaksCalculation(),\r\n                  child: const Text('Pause repas'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testSuperWowDuration(),\r\n                  child: const Text('Dures SW'),\r\n                ),\r\n                ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testAvailableTimePerDay(),\r\n                  child: const Text('Temps Dispo/Jour'),\r\n                ),ElevatedButton(\r\n                  onPressed: () => ref.read(availableTimeTestProvider.notifier).testGetFilteredActivities(),\r\n                  child: const Text('Activits Filtres'),\r\n                ),\r\n              ],\r\n            ),\r\n            const SizedBox(height: 16),\r\n            // Contenu du test\r\n            Expanded( // Ajout d'Expanded ici\r\n              child: SingleChildScrollView(\r\n                child: Column(\r\n                  children: [\r\n                    // Rsultat SuperWow Management\r\n                    emptyTripsState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text('Erreur SuperWow: $error', style: const TextStyle(color: Colors.red)),\r\n                    ),\r\n                    // Rsultat Route Optimization\r\n                    routeOptState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text('Erreur Route: $error', style: const TextStyle(color: Colors.red)),\r\n                    ),\r\n                    // Rsultat Empty Trip Generation\r\n                    emptyTripGenerationState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text('Erreur Empty Trip Generation: $error', style: const TextStyle(color: Colors.red)),\r\n                    ),\r\n                    availableTimeState.when(\r\n                      initial: () => const SizedBox.shrink(),\r\n                      loading: () => const Center(child: CircularProgressIndicator()),\r\n                      success: (data) => _buildContent(data),\r\n                      error: (error) => Text(\r\n                          'Erreur Available Time: $error',\r\n                          style: const TextStyle(color: Colors.red)\r\n                      ),\r\n                    ),\r\n                  ],\r\n                ),\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  // Fonction pour afficher le contenu en fonction de l'tat (spare pour plus de clart)\r\n  Widget _buildContent(Map<String, dynamic> data) {\r\n    if (data['testType'] == 'superwow_management') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Text('Ville de dpart: ${data['departureCity']}'),\r\n          Text('Nombre de SuperWow: ${data['totalSuperWows']}'),\r\n          const SizedBox(height: 16),\r\n          Text('SuperWow le plus proche: ${data['closestSuperWow']['name']}'),\r\n          Text('Score: ${data['closestSuperWow']['score']}'),\r\n          const SizedBox(height: 16),\r\n          const Text('Top 3 paires:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ...data['top3Pairs'].map<Widget>((pair) => Padding(\r\n            padding: const EdgeInsets.only(left: 16, top: 8),\r\n            child: Text('${pair['sw1']}  ${pair['sw2']} (${pair['distance']}, ${pair['duration']})'),\r\n          )).toList(),\r\n        ],\r\n      );\r\n    } else if (data['testType'] == 'route_optimization') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Text('Origine: ${data['origin']}'),\r\n          Text('Destination: ${data['destination']}'),\r\n          Text('Point intermdiaire: ${data['waypoint']}'),\r\n          const SizedBox(height: 16),\r\n          const Text('Route:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Status: ${data['route']['status']}'),\r\n          Text('Polyline: ${data['route']['polyline']}'),\r\n          const SizedBox(height: 16),\r\n          Text('Temps de trajet: ${data['travelTime']}'),\r\n          const SizedBox(height: 16),\r\n          const Text('valuation dtour:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Status: ${data['detourEvaluation']['status']}'),\r\n          Text('Faisable: ${data['detourEvaluation']['feasible']}'),\r\n        ],\r\n      );\r\n    } else if (data['testType'] == 'empty_trip_generation') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Gnration Empty Trips'),\r\n          const SizedBox(height: 16),\r\n          const Text('Half-Day Trips:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(), // Important pour dsactiver le scroll de ListView\r\n            itemCount: data['halfDayTrips'].length,\r\n            itemBuilder: (context, index) {\r\n              final trip = data['halfDayTrips'][index];\r\n              return Padding(\r\n                padding: const EdgeInsets.only(left: 16, top: 8),\r\n                child: Text('ID: ${trip['id']}\\nSW: ${trip['sw1Id']}\\nGeohash: ${trip['geohash']}'),\r\n              );\r\n            },\r\n          ),\r\n          const SizedBox(height: 16),\r\n          const Text('Full-Day Trips:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(), // Important pour dsactiver le scroll de ListView\r\n            itemCount: data['fullDayTrips'].length,\r\n            itemBuilder: (context, index) {\r\n              final trip = data['fullDayTrips'][index];\r\n              return Padding(\r\n                padding: const EdgeInsets.only(left: 16, top: 8),\r\n                child: Text('ID: ${trip['id']}\\nSW1: ${trip['sw1Id']}\\nSW2: ${trip['sw2Id']}\\nGeohash: ${trip['geohash']}'),\r\n              );\r\n            },\r\n          ),\r\n\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'bonus_activities') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Bonus Activities', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 16),\r\n          Text('Nombre d\\'activits gnres: ${data['bonusActivities'].length}'),\r\n\r\n          const SizedBox(height: 16),\r\n          const Text('Statistiques de distance:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Distance moyenne: ${data['distanceStats']['averageDistance'].toStringAsFixed(2)} km'),\r\n          Text('Distance min: ${data['distanceStats']['minDistance'].toStringAsFixed(2)} km'),\r\n          Text('Distance max: ${data['distanceStats']['maxDistance'].toStringAsFixed(2)} km'),\r\n\r\n          const SizedBox(height: 16),\r\n          const Text('Statistiques de malus:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          Text('Malus moyen: ${data['malusStats']['averageMalus']} minutes'),\r\n          Text('Malus min: ${data['malusStats']['minMalus']} minutes'),\r\n          Text('Malus max: ${data['malusStats']['maxMalus']} minutes'),\r\n\r\n          const SizedBox(height: 16),\r\n          const Text('Activits:', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['bonusActivities'].length,\r\n            itemBuilder: (context, index) {\r\n              final activity = data['bonusActivities'][index];\r\n              return Padding(\r\n                padding: const EdgeInsets.only(left: 16, top: 8),\r\n                child: Text(\r\n                    'ID: ${activity.id}\\n'\r\n                        'Malus: ${activity.malusVolOiseau.minutes} minutes'\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'meal_breaks') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Pauses Repas', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 16),\r\n          Text('Trip ID: ${data['tripId']}'),\r\n          Text('Priode: ${data['dates']['start']} -> ${data['dates']['end']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(8.0),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text(test['case']),\r\n                      Text('Horaires: ${test['input']['start']}-${test['input']['end']}'),\r\n                      Text('Pause calcule: ${test['result']} minutes'),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'superwow_duration') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Dures SuperWow', style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Style de voyage du trip: ${data['tripStyle']}',\r\n              style: const TextStyle(fontSize: 16, color: Colors.blue)),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.only(bottom: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text(test['case'], style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      const SizedBox(height: 8),\r\n                      Text('SuperWow IDs: ${(test['input']['superWowIds'] as List).join(\", \")}'),\r\n                      Text('Style de voyage: ${test['input']['style']}'),\r\n                      const Divider(),\r\n                      Text(\r\n                        'Dure calcule: ${test['result']} minutes',\r\n                        style: const TextStyle(color: Colors.blue),\r\n                      ),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'available_time_per_day') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test du Temps Disponible par Jour',\r\n              style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Trip ID: ${data['tripId']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.only(bottom: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text('Empty Trip: ${test['emptyTripId']}',\r\n                          style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      Text('Type: ${test['type']}'),\r\n                      const Divider(),\r\n                      ...(test['timeByDate'] as Map<String, dynamic>).entries.map(\r\n                            (entry) => Text(\r\n                          'Date ${entry.key}: ${entry.value} minutes',\r\n                          style: const TextStyle(color: Colors.blue),\r\n                        ),\r\n                      ),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }    else if (data['testType'] == 'bonus_activities_generation') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test de Gnration des Bonus Activities',\r\n              style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Trip: ${data['tripId']}'),\r\n          Text('Priode: ${data['tripDates']['start']}  ${data['tripDates']['end']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.symmetric(vertical: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text('Empty Trip: ${test['emptyTripId']} (${test['type']})',\r\n                          style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      const Divider(),\r\n                      const Text('Activits par jour:',\r\n                          style: TextStyle(fontWeight: FontWeight.bold)),\r\n                      ...(test['resultsByDate'] as Map<String, dynamic>)\r\n                          .entries.map((dateEntry) => Column(\r\n                        crossAxisAlignment: CrossAxisAlignment.start,\r\n                        children: [\r\n                          Text(dateEntry.key,\r\n                              style: const TextStyle(fontWeight: FontWeight.w500)),\r\n                          ...(dateEntry.value as List).map((activity) => Padding(\r\n                            padding: const EdgeInsets.only(left: 16),\r\n                            child: Text(\r\n                              'ID: ${activity['activityId']} - Malus: ${activity['malus']} min',\r\n                            ),\r\n                          )),\r\n                          const SizedBox(height: 8),\r\n                        ],\r\n                      )),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n    else if (data['testType'] == 'filtered_activities') {\r\n      return Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          const Text('Test des Activits Filtres',\r\n              style: TextStyle(fontWeight: FontWeight.bold)),\r\n          const SizedBox(height: 8),\r\n          Text('Trip ID: ${data['tripId']}'),\r\n          const SizedBox(height: 16),\r\n\r\n          ListView.builder(\r\n            shrinkWrap: true,\r\n            physics: const NeverScrollableScrollPhysics(),\r\n            itemCount: data['tests'].length,\r\n            itemBuilder: (context, index) {\r\n              final test = data['tests'][index];\r\n              return Card(\r\n                margin: const EdgeInsets.only(bottom: 8),\r\n                child: Padding(\r\n                  padding: const EdgeInsets.all(12),\r\n                  child: Column(\r\n                    crossAxisAlignment: CrossAxisAlignment.start,\r\n                    children: [\r\n                      Text('Empty Trip: ${test['emptyTripId']}',\r\n                          style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                      Text('Type: ${test['type']}'),\r\n                      const Divider(),\r\n                      ...(test['activities'] as Map<String, dynamic>).entries.map((dateEntry) {\r\n                        final activities = dateEntry.value as List;\r\n                        return Column(\r\n                          crossAxisAlignment: CrossAxisAlignment.start,\r\n                          children: [\r\n                            Text(\r\n                                'Date: ${dateEntry.key}',\r\n                                style: const TextStyle(fontWeight: FontWeight.w500)\r\n                            ),\r\n                            Text('${activities.length} activits trouves'),\r\n                            ...activities.map((act) => Padding(\r\n                              padding: const EdgeInsets.only(left: 16),\r\n                              child: Text(\r\n                                '${act['name']} (${act['geohash5']})',\r\n                                style: const TextStyle(fontSize: 12),\r\n                              ),\r\n                            )),\r\n                            const SizedBox(height: 8),\r\n                          ],\r\n                        );\r\n                      }),\r\n                    ],\r\n                  ),\r\n                ),\r\n              );\r\n            },\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    return const Text('Type de test inconnu');\r\n  }\r\n}",
      "info": {
        "size": 20331,
        "last_modified": "2025-04-16T13:25:27.5172739",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/test/available_time_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:dart_geohash/dart_geohash.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/available_time_calculation.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/bonus_activity_generation.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/potential_activities.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/bonus_activities_cache.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/neighbor_geohashes.service.dart';\r\nimport '../../../../../core/adapters/trip/trip_adapter.dart';\r\nimport '../../../../../core/adapters/supabase/empty_daily_trip.adapter.dart';\r\nimport '../../../../../core/domain/models/trip_designer/empty_trips/empty_daily_trip.dart';\r\nimport '../../../../../core/domain/models/trip_designer/trip/activity_model.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/geometry_calculation.port.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/neighbor_geohashes.port.dart';\r\nimport './available_time_test_state.dart';\r\n\r\nclass AvailableTimeTestNotifier extends StateNotifier<AvailableTimeTestState> {\r\n  final AvailableTimeCalculationService _service;\r\n  final BonusActivityGenerationService _bonusService;\r\n  final TripAdapter _tripAdapter;\r\n  final EmptyDailyTripAdapter _emptyTripAdapter;\r\n  final PotentialActivitiesService _potentialActivitiesService;\r\n  final BonusActivitiesCacheService _cacheService;\r\n  final GeometryCalculationPort _geometryPort;\r\n  final NeighborGeohashesPort _neighborGeohashesPort;\r\n  static const String TEST_TRIP_ID = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n\r\n  AvailableTimeTestNotifier(\r\n      this._service,\r\n      this._bonusService,\r\n      this._tripAdapter,\r\n      this._potentialActivitiesService,\r\n      this._cacheService,\r\n      this._geometryPort,\r\n      this._neighborGeohashesPort,\r\n      ) : _emptyTripAdapter = EmptyDailyTripAdapter(Supabase.instance.client),\r\n        super(const AvailableTimeTestState.initial());\r\n\r\n  Future<void> testMealBreaksCalculation() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print(' Dbut du test des pauses repas');\r\n\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n      print(' Dates du voyage: ${trip.startDate} -> ${trip.endDate}');\r\n\r\n      final dailyHours = trip.activityHours.daily_hours;\r\n      print(' Horaires journaliers rcuprs: ${dailyHours.length} jours');\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (var entry in dailyHours.entries) {\r\n        final date = entry.key;\r\n        final hours = entry.value;\r\n\r\n        if (hours['start'] != null && hours['end'] != null) {\r\n          final hoursMap = {\r\n            'start': hours['start']!,\r\n            'end': hours['end']!,\r\n          };\r\n\r\n          final result = _service.calculateMealBreaksDuration(hoursMap,trip.travelStyle?.name ?? 'balanced');\r\n          tests.add({\r\n            'case': 'Jour: $date',\r\n            'input': hoursMap,\r\n            'result': result,\r\n          });\r\n          print(' $date: ${hours['start']}-${hours['end']} => $result min de pause');\r\n        } else {\r\n          print(' $date: Horaires non dfinis');\r\n        }\r\n      }\r\n\r\n      final testResults = <String, dynamic>{\r\n        'testType': 'meal_breaks',\r\n        'tripId': TEST_TRIP_ID,\r\n        'dates': {\r\n          'start': trip.startDate.toString(),\r\n          'end': trip.endDate.toString(),\r\n        },\r\n        'tests': tests\r\n      };\r\n\r\n      state = AvailableTimeTestState.success(testResults);\r\n      print(' Test termin');\r\n    } catch (e) {\r\n      print(' Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testSuperWowDuration() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print(' Test du calcul de dure des SuperWow');\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n      print(' Travel Style du trip: ${trip.travelStyle?.name}');\r\n\r\n      final emptyTripIds = [\r\n        '16ce0368-acb2-42ea-9dc0-2e71ff78f384',\r\n        '1e41d5f2-7c24-4dbc-a8c5-b3c5db8ac12d',\r\n        '3496302f-bd36-4a7a-9e27-2cba8ad9d80e',\r\n      ];\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (final emptyTripId in emptyTripIds) {\r\n        print(' Test pour empty trip: $emptyTripId');\r\n\r\n        final response = await Supabase.instance.client\r\n            .from('empty_daily_trips')\r\n            .select('type, sw1_id, sw2_id')\r\n            .eq('id', emptyTripId)\r\n            .single();\r\n\r\n        final List<String> superWowIds = [response['sw1_id']];\r\n        if (response['sw2_id'] != null) {\r\n          superWowIds.add(response['sw2_id']);\r\n        }\r\n\r\n        print(' SuperWow IDs trouvs: $superWowIds');\r\n\r\n        final duration = await _service.calculateSuperWowDuration(\r\n          superWowIds: superWowIds,\r\n          travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n        );\r\n\r\n        tests.add({\r\n          'case': 'EmptyTrip: $emptyTripId (${response['type']})',\r\n          'input': {\r\n            'style': trip.travelStyle?.name ?? 'balanced',\r\n            'superWowIds': superWowIds,\r\n          },\r\n          'result': duration,\r\n        });\r\n        print(' ${trip.travelStyle?.name} => $duration minutes');\r\n      }\r\n\r\n      state = AvailableTimeTestState.success({\r\n        'testType': 'superwow_duration',\r\n        'tripStyle': trip.travelStyle?.name ?? 'balanced',\r\n        'tests': tests,\r\n      });\r\n      print(' Test termin');\r\n    } catch (e) {\r\n      print(' Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testAvailableTimePerDay() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print(' Dbut du test du temps disponible par jour');\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n\r\n      final emptyTripIds = [\r\n        '16ce0368-acb2-42ea-9dc0-2e71ff78f384',\r\n        '1e41d5f2-7c24-4dbc-a8c5-b3c5db8ac12d',\r\n        '3496302f-bd36-4a7a-9e27-2cba8ad9d80e',\r\n      ];\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (final etId in emptyTripIds) {\r\n        final emptyTrip = await _emptyTripAdapter.getEmptyTrip(etId);\r\n\r\n        final timeByDate = await _service.calculateAvailableTimeForEmptyTrip(\r\n          emptyTrip: emptyTrip,\r\n          dailyHours: trip.activityHours.daily_hours,\r\n          travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n        );\r\n\r\n        tests.add({\r\n          'emptyTripId': etId,\r\n          'type': emptyTrip.type.toString().split('.').last,\r\n          'timeByDate': Map.fromEntries(\r\n              timeByDate.entries.map((e) => MapEntry(e.key.toString(), e.value))\r\n          ),\r\n        });\r\n\r\n        for (var entry in timeByDate.entries) {\r\n          print(' [$etId] ${entry.key} => ${entry.value} minutes dispos');\r\n        }\r\n      }\r\n\r\n      state = AvailableTimeTestState.success({\r\n        'testType': 'available_time_per_day',\r\n        'tripId': TEST_TRIP_ID,\r\n        'tests': tests,\r\n      });\r\n      print(' Test termin');\r\n    } catch (e) {\r\n      print(' Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testGetFilteredActivities() async {\r\n    state = const AvailableTimeTestState.loading();\r\n    try {\r\n      print(' Test rcupration activits filtres');\r\n      final trip = await _tripAdapter.getTrip(TEST_TRIP_ID);\r\n      final emptyTripIds = [\r\n        '16ce0368-acb2-42ea-9dc0-2e71ff78f384',\r\n        '1e41d5f2-7c24-4dbc-a8c5-b3c5db8ac12d',\r\n        '3496302f-bd36-4a7a-9e27-2cba8ad9d80e',\r\n      ];\r\n\r\n      final List<Map<String, dynamic>> tests = [];\r\n\r\n      for (final etId in emptyTripIds) {\r\n        print('\\n Test pour empty trip: $etId');\r\n        final emptyTrip = await _emptyTripAdapter.getEmptyTrip(etId);\r\n\r\n        // 1. Temps disponible\r\n        final availableTime = await _service.calculateAvailableTimeForEmptyTrip(\r\n          emptyTrip: emptyTrip,\r\n          dailyHours: trip.activityHours.daily_hours,\r\n          travelStyle: trip.travelStyle?.name ?? 'balanced',\r\n        );\r\n\r\n        // 2. Activits filtres\r\n        final activities = await _potentialActivitiesService.getFilteredActivitiesForEmptyTrip(\r\n          emptyTrip: emptyTrip,\r\n          tripId: trip.id,\r\n          availableTimeByDate: availableTime,\r\n        );\r\n\r\n        // 3. Vrifier le cache\r\n        final cachedActivities = await _cacheService.getCachedBonusActivities(etId);\r\n\r\n        if (cachedActivities.isEmpty) {\r\n          final List<Map<String, dynamic>> activitiesToCache = []; // Correction ici\r\n          // Traiter chaque activit par date\r\n          for (var dateActivities in activities.values) {\r\n            for (var activity in dateActivities) {\r\n              final malus = await _calculateMalus(activity, emptyTrip);\r\n              activitiesToCache.add({\r\n                'id': activity.id,\r\n                'malus': malus,\r\n              });\r\n            }\r\n          }\r\n\r\n          if (activitiesToCache.isNotEmpty) {\r\n            await _cacheService.cacheEmptyTripBonusActivities(\r\n              emptyTripId: etId,\r\n              bonusActivities: activitiesToCache,\r\n            );\r\n            print(' Cached ${activitiesToCache.length} activities for $etId');\r\n          }\r\n        } else {\r\n          print(' Found ${cachedActivities.length} cached activities for $etId');\r\n        }\r\n\r\n        tests.add({\r\n          'emptyTripId': etId,\r\n          'type': emptyTrip.type.toString().split('.').last,\r\n          'activities': activities.map((date, acts) =>\r\n              MapEntry(date, acts.map((a) => {\r\n                'id': a.id,\r\n                'name': a.name,\r\n                'geohash5': a.geohash5,\r\n              }).toList())\r\n          ),\r\n        });\r\n      }\r\n\r\n      state = AvailableTimeTestState.success({\r\n        'testType': 'filtered_activities',\r\n        'tripId': TEST_TRIP_ID,\r\n        'tests': tests,\r\n      });\r\n      print(' Test termin');\r\n    } catch (e) {\r\n      print(' Erreur lors du test: $e');\r\n      state = AvailableTimeTestState.error(e);\r\n    }\r\n  }\r\n\r\n  Future<int> _calculateMalus(Activity activity, EmptyDailyTrip emptyTrip) async {\r\n    try {\r\n      print(' Calculating malus for:');\r\n      print('  Activity: ${activity.id} (${activity.name})');\r\n      print('  Location: ${activity.geohash5}');\r\n      print('  EmptyTrip: ${emptyTrip.id}');\r\n\r\n      final neighbors = await _neighborGeohashesPort.getNeighborGeohashes(emptyTrip.id);\r\n      final neighbor = neighbors[activity.geohash5];\r\n      if (neighbor != null) {\r\n        final distance = neighbor['distance_to_route'];\r\n        final closestGeohash = neighbor['closest_route_geohash5'];\r\n      }\r\n\r\n      if (neighbor == null) {\r\n        print(' No matching neighbor found');\r\n        return 3000; // 30km par dfaut\r\n      }\r\n\r\n      final malus = (neighbor['distance_to_route'] as int) ~/ 100; // 1min par 100m\r\n      print('  Distance to route: ${neighbor['distance_to_route']}m');\r\n      print('  Malus: $malus minutes');\r\n      return malus;\r\n    } catch (e) {\r\n      print(' Error: $e');\r\n      return 3000; // 30km par dfaut en cas d'erreur\r\n    }\r\n  }\r\n\r\n  Future<int> _calculateVolOiseauMalus({\r\n    required double lat,\r\n    required double lng,\r\n    required String geohash5,\r\n  }) async {\r\n    final response = await Supabase.instance.client.rpc(\r\n      'calculate_vol_oiseau_minutes',\r\n      params: {\r\n        'point1_lat': lat,\r\n        'point1_lng': lng,\r\n        'geohash5': geohash5,\r\n      },\r\n    );\r\n\r\n    return (response as num).toInt();\r\n  }\r\n}\r\n\r\n",
      "info": {
        "size": 12081,
        "last_modified": "2025-04-16T13:25:27.5288549",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/test/available_time_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\n\r\n// Imports de vos services / adapters\r\nimport '../../../../../core/domain/services/designer/empty_trips/available_time_calculation.service.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/bonus_activity_generation.service.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/bonus_activities_cache.provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/neighbor_geohashes.provider.dart';\r\nimport '../../../../../core/adapters/trip/trip_adapter.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/distance_calculation_provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/geometry_calculation.provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/potential_activities.provider.dart';\r\n\r\nimport './available_time_test_notifier.dart';\r\nimport './available_time_test_state.dart';\r\n\r\nfinal availableTimeTestProvider = StateNotifierProvider<AvailableTimeTestNotifier, AvailableTimeTestState>((ref) {\r\n  final supabase = Supabase.instance.client;\r\n  final service = AvailableTimeCalculationService(supabase);\r\n  final tripAdapter = TripAdapter(supabase);\r\n  final potentialActivitiesService = ref.watch(potentialActivitiesProvider);\r\n  final cacheService = ref.watch(bonusActivitiesCacheProvider);\r\n  final geometryPort = ref.watch(geometryCalculationPortProvider);\r\n  final neighborGeohashesService = ref.watch(neighborGeohashesProvider);\r\n  final distanceService = ref.watch(distanceCalculationServiceProvider);\r\n\r\n  final bonusService = BonusActivityGenerationService(\r\n    geometryPort,\r\n    distanceService,\r\n    service,\r\n  );\r\n\r\n  return AvailableTimeTestNotifier(\r\n    service,\r\n    bonusService,\r\n    tripAdapter,\r\n    potentialActivitiesService,\r\n    cacheService,\r\n    geometryPort,\r\n    neighborGeohashesService,\r\n  );\r\n});",
      "info": {
        "size": 2073,
        "last_modified": "2025-04-16T13:25:27.5353717",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/test/available_time_test_state.dart\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'available_time_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass AvailableTimeTestState with _$AvailableTimeTestState {\r\n  const factory AvailableTimeTestState.initial() = _Initial;\r\n  const factory AvailableTimeTestState.loading() = _Loading;\r\n  const factory AvailableTimeTestState.success(Map<String, dynamic> data) = _Success;\r\n  const factory AvailableTimeTestState.error(Object error) = _Error;\r\n}",
      "info": {
        "size": 552,
        "last_modified": "2025-04-16T13:25:27.5424124",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\available_time_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'available_time_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$AvailableTimeTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $AvailableTimeTestStateCopyWith<$Res> {\n  factory $AvailableTimeTestStateCopyWith(AvailableTimeTestState value,\n          $Res Function(AvailableTimeTestState) then) =\n      _$AvailableTimeTestStateCopyWithImpl<$Res, AvailableTimeTestState>;\n}\n\n/// @nodoc\nclass _$AvailableTimeTestStateCopyWithImpl<$Res,\n        $Val extends AvailableTimeTestState>\n    implements $AvailableTimeTestStateCopyWith<$Res> {\n  _$AvailableTimeTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements AvailableTimeTestState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements AvailableTimeTestState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl implements _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data) : _data = data;\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success implements AvailableTimeTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$AvailableTimeTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.error);\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'AvailableTimeTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements AvailableTimeTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n\n  Object get error;\n\n  /// Create a copy of AvailableTimeTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18575,
        "last_modified": "2025-04-16T13:25:27.5484124",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trips_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/superwow_management.port.dart';\r\nimport 'empty_trips_test_state.dart';\r\n\r\nclass EmptyTripsTestNotifier extends StateNotifier<EmptyTripsTestState> {\r\n  final SupabaseClient _supabase;\r\n  final SuperWowManagementPort _superwowManagementPort;\r\n\r\n  EmptyTripsTestNotifier(\r\n      this._supabase,\r\n      this._superwowManagementPort,\r\n      ) : super(const EmptyTripsTestState.initial());\r\n\r\n// lib/features/empty_trips/presentation/state/empty_trips_test_notifier.dart\r\n\r\n  Future<void> testSuperwowManagement() async {\r\n    state = const EmptyTripsTestState.loading();\r\n\r\n    try {\r\n      print(' Test de gestion des SuperWow');\r\n      final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n\r\n      // Rcuprer point de dpart\r\n      final tripResponse = await _supabase\r\n          .from('trips')\r\n          .select('departure_city_id, cities!trips_departure_city_id_fkey(lat, lon, city_name)')\r\n          .eq('id', tripId)\r\n          .single();\r\n\r\n      final departurePoint = LatLng(\r\n        tripResponse['cities']['lat'].toDouble(),\r\n        tripResponse['cities']['lon'].toDouble(),\r\n      );\r\n      print(' Point de dpart: ${tripResponse['cities']['city_name']}');\r\n\r\n      // Rcuprer tous les SuperWows\r\n      final superWows = await _superwowManagementPort.getTripSuperWows(tripId);\r\n      print(' ${superWows.length} SuperWow rcuprs');\r\n\r\n      if (superWows.isEmpty) {\r\n        throw Exception('Aucun SuperWow trouv pour ce trip');\r\n      }\r\n\r\n      // Gnrer toutes les paires optimises\r\n      final optimizedPairs = await _superwowManagementPort.generateOptimizedPairs(\r\n        tripId,\r\n        superWows,\r\n        departurePoint,\r\n      );\r\n\r\n      // Organiser les rsultats par SW de dpart\r\n      final pairsByStartingSW = <String, List<Map<String, dynamic>>>{};\r\n      for (final pair in optimizedPairs) {\r\n        final sw1 = superWows.firstWhere((sw) => sw.id == pair.sw1Id);\r\n        final sw2 = superWows.firstWhere((sw) => sw.id == pair.sw2Id);\r\n\r\n        if (!pairsByStartingSW.containsKey(sw1.id)) {\r\n          pairsByStartingSW[sw1.id] = [];\r\n        }\r\n\r\n        pairsByStartingSW[sw1.id]!.add({\r\n          'sw1Name': sw1.activityData['name'],\r\n          'sw2Name': sw2.activityData['name'],\r\n          'distance': '${(pair.distanceInKm).toStringAsFixed(2)} km',\r\n          'duration': '${pair.travelTime.inMinutes} minutes',\r\n          'sw1Preferences': sw1.activityData['moment_preferences'],\r\n          'sw2Preferences': sw2.activityData['moment_preferences'],\r\n        });\r\n      }\r\n\r\n      state = EmptyTripsTestState.success({\r\n        'testType': 'superwow_management',\r\n        'departureCity': tripResponse['cities']['city_name'],\r\n        'totalSuperWows': superWows.length,\r\n        'optimizedPairs': pairsByStartingSW.entries.map((entry) {\r\n          final sw = superWows.firstWhere((sw) => sw.id == entry.key);\r\n          return {\r\n            'startingSW': sw.activityData['name'],\r\n            'pairs': entry.value,\r\n          };\r\n        }).toList(),\r\n      });\r\n\r\n    } catch (e) {\r\n      print(' Erreur dans le test de gestion SuperWow: $e');\r\n      state = EmptyTripsTestState.error(e);\r\n    }\r\n  }\r\n\r\n}",
      "info": {
        "size": 3500,
        "last_modified": "2025-04-16T13:25:27.5549292",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trips_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/ports/providers/infrastructure_providers.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/superwow_management.provider.dart';\r\nimport 'empty_trips_test_notifier.dart';\r\nimport 'empty_trips_test_state.dart';\r\n\r\nfinal emptyTripsTestProvider = StateNotifierProvider<EmptyTripsTestNotifier, EmptyTripsTestState>((ref) {\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final superwowManagement = ref.watch(superwowManagementPortProvider);\r\n  return EmptyTripsTestNotifier(supabase, superwowManagement);\r\n});",
      "info": {
        "size": 702,
        "last_modified": "2025-04-16T13:25:27.5619644",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trips_test_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'empty_trips_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass EmptyTripsTestState with _$EmptyTripsTestState {\r\n  const factory EmptyTripsTestState.initial() = _Initial;\r\n  const factory EmptyTripsTestState.loading() = _Loading;\r\n  const factory EmptyTripsTestState.success(Map<String, dynamic> data) = _Success;\r\n  const factory EmptyTripsTestState.error(Object error) = _Error;\r\n}",
      "info": {
        "size": 525,
        "last_modified": "2025-04-16T13:25:27.5684818",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trips_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'empty_trips_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$EmptyTripsTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $EmptyTripsTestStateCopyWith<$Res> {\n  factory $EmptyTripsTestStateCopyWith(\n          EmptyTripsTestState value, $Res Function(EmptyTripsTestState) then) =\n      _$EmptyTripsTestStateCopyWithImpl<$Res, EmptyTripsTestState>;\n}\n\n/// @nodoc\nclass _$EmptyTripsTestStateCopyWithImpl<$Res, $Val extends EmptyTripsTestState>\n    implements $EmptyTripsTestStateCopyWith<$Res> {\n  _$EmptyTripsTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements EmptyTripsTestState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements EmptyTripsTestState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl implements _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data) : _data = data;\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success implements EmptyTripsTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$EmptyTripsTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.error);\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'EmptyTripsTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements EmptyTripsTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n\n  Object get error;\n\n  /// Create a copy of EmptyTripsTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18469,
        "last_modified": "2025-04-16T13:25:27.5752006",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trip_generation_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/services/designer/empty_trips/empty_trip_generation.service.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/neighbor_geohashes.port.dart';\r\nimport 'empty_trip_generation_test_state.dart';\r\n\r\nclass EmptyTripGenerationTestNotifier extends StateNotifier<EmptyTripGenerationTestState> {\r\n  final EmptyTripGenerationService _emptyTripGenerationService;\r\n  final NeighborGeohashesPort _neighborGeohashesPort;\r\n\r\n  EmptyTripGenerationTestNotifier(\r\n      this._emptyTripGenerationService,\r\n      this._neighborGeohashesPort,\r\n      ) : super(const EmptyTripGenerationTestState.initial());\r\n\r\n  Future<void> testEmptyTripGeneration() async {\r\n    state = const EmptyTripGenerationTestState.loading();\r\n\r\n    try {\r\n      print(' Test de gnration des Empty Trips et leurs voisins');\r\n      final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n\r\n      final result = await _emptyTripGenerationService.generateEmptyTrips(tripId);\r\n      print(' Empty trips gnrs');\r\n\r\n      // Vrifier les neighbors pour chaque empty trip\r\n      for (final trip in [...result.halfDayTrips, ...result.fullDayTrips]) {\r\n        final neighbors = await _neighborGeohashesPort.getNeighborGeohashes(trip.id);\r\n        print(' ${trip.id}: ${neighbors.length} voisins trouvs');\r\n      }\r\n\r\n      state = EmptyTripGenerationTestState.success({\r\n        'testType': 'empty_trip_generation',\r\n        'halfDayTrips': result.halfDayTrips.map((trip) => {\r\n          'id': trip.id,\r\n          'sw1Id': trip.sw1Id,\r\n          'geohash': trip.departureGeohash5,\r\n          'neighbor_count': trip.traversedGeohashes.length,\r\n        }).toList(),\r\n        'fullDayTrips': result.fullDayTrips.map((trip) => {\r\n          'id': trip.id,\r\n          'sw1Id': trip.sw1Id,\r\n          'sw2Id': trip.sw2Id,\r\n          'geohash': trip.departureGeohash5,\r\n          'neighbor_count': trip.traversedGeohashes.length,\r\n        }).toList(),\r\n      });\r\n\r\n    } catch (e) {\r\n      print(' Erreur dans le test de gnration: $e');\r\n      state = EmptyTripGenerationTestState.error(e);\r\n    }\r\n  }}",
      "info": {
        "size": 2269,
        "last_modified": "2025-04-16T13:25:27.5812704",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trip_generation_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/empty_trip_generation.provider.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/neighbor_geohashes.provider.dart';\r\nimport 'empty_trip_generation_test_notifier.dart';\r\nimport 'empty_trip_generation_test_state.dart';\r\n\r\nfinal emptyTripGenerationTestProvider = StateNotifierProvider<EmptyTripGenerationTestNotifier, EmptyTripGenerationTestState>((ref) {\r\n  final emptyTripGenerationService = ref.watch(emptyTripGenerationServiceProvider);\r\n  final neighborGeohashesPort = ref.watch(neighborGeohashesProvider);\r\n\r\n  return EmptyTripGenerationTestNotifier(\r\n    emptyTripGenerationService,\r\n    neighborGeohashesPort,\r\n  );\r\n});",
      "info": {
        "size": 858,
        "last_modified": "2025-04-16T13:25:27.5872711",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/empty_trip_generation_test_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\n\r\npart 'empty_trip_generation_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass EmptyTripGenerationTestState with _$EmptyTripGenerationTestState {\r\n  const factory EmptyTripGenerationTestState.initial() = _Initial;\r\n\r\n  const factory EmptyTripGenerationTestState.loading() = _Loading;\r\n\r\n  const factory EmptyTripGenerationTestState.success(\r\n      Map<String, dynamic> data) = _Success;\r\n\r\n  const factory EmptyTripGenerationTestState.error(Object error) = _Error;\r\n\r\n  const EmptyTripGenerationTestState._();\r\n\r\n}",
      "info": {
        "size": 660,
        "last_modified": "2025-04-16T13:25:27.5943078",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\empty_trip_generation_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'empty_trip_generation_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$EmptyTripGenerationTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $EmptyTripGenerationTestStateCopyWith<$Res> {\n  factory $EmptyTripGenerationTestStateCopyWith(\n          EmptyTripGenerationTestState value,\n          $Res Function(EmptyTripGenerationTestState) then) =\n      _$EmptyTripGenerationTestStateCopyWithImpl<$Res,\n          EmptyTripGenerationTestState>;\n}\n\n/// @nodoc\nclass _$EmptyTripGenerationTestStateCopyWithImpl<$Res,\n        $Val extends EmptyTripGenerationTestState>\n    implements $EmptyTripGenerationTestStateCopyWith<$Res> {\n  _$EmptyTripGenerationTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl extends _Initial {\n  const _$InitialImpl() : super._();\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial extends EmptyTripGenerationTestState {\n  const factory _Initial() = _$InitialImpl;\n  const _Initial._() : super._();\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl extends _Loading {\n  const _$LoadingImpl() : super._();\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading extends EmptyTripGenerationTestState {\n  const factory _Loading() = _$LoadingImpl;\n  const _Loading._() : super._();\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl extends _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data)\n      : _data = data,\n        super._();\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success extends EmptyTripGenerationTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n  const _Success._() : super._();\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$EmptyTripGenerationTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl extends _Error {\n  const _$ErrorImpl(this.error) : super._();\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'EmptyTripGenerationTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error extends EmptyTripGenerationTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n  const _Error._() : super._();\n\n  Object get error;\n\n  /// Create a copy of EmptyTripGenerationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18966,
        "last_modified": "2025-04-16T13:25:27.6003077",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_notifier.dart",
      "content": "// lib/features/empty_trips/presentation/state/route_optimization_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../../core/domain/ports/empty_trips/route_optimization.port.dart';\r\nimport 'route_optimization_test_state.dart';\r\n\r\nclass RouteOptimizationTestNotifier extends StateNotifier<RouteOptimizationTestState> {\r\n  final RouteOptimizationPort _routeOptimizationPort;\r\n\r\n  RouteOptimizationTestNotifier(this._routeOptimizationPort)\r\n      : super(const RouteOptimizationTestState.initial());\r\n\r\n  Future<void> testRouteOptimization() async {\r\n    state = const RouteOptimizationTestState.loading();\r\n\r\n    try {\r\n      print(' Test d\\'optimisation des routes');\r\n\r\n      // Points de test en Dordogne\r\n      final origin = const LatLng(45.1909, 0.7167);      // Prigueux\r\n      final destination = const LatLng(44.8883, 1.2162);  // Sarlat\r\n      final waypoint = const LatLng(44.9171, 1.0669);     // Les Eyzies\r\n\r\n      final optimizedRoute = await _routeOptimizationPort.getOptimizedRoute(\r\n        origin,\r\n        destination,\r\n        [waypoint],\r\n      );\r\n\r\n      final travelTime = await _routeOptimizationPort.getTravelTime(\r\n        origin,\r\n        destination,\r\n      );\r\n\r\n      final detourEvaluation = await _routeOptimizationPort.evaluateDetour(\r\n        origin,\r\n        destination,\r\n        waypoint,\r\n        const Duration(minutes: 30),\r\n      );\r\n\r\n      state = RouteOptimizationTestState.success({\r\n        'testType': 'route_optimization',\r\n        'origin': 'Prigueux',\r\n        'destination': 'Sarlat',\r\n        'waypoint': 'Les Eyzies',\r\n        'route': {\r\n          ...optimizedRoute,\r\n          'polyline': (optimizedRoute['polyline'] != null)\r\n              ? '${optimizedRoute['polyline'].toString().substring(0, 50)}...'\r\n              : 'Pas de polyline',\r\n        },\r\n        'travelTime': '${travelTime.inMinutes} minutes',\r\n        'detourEvaluation': detourEvaluation,\r\n      });\r\n\r\n    } catch (e) {\r\n      print(' Erreur dans le test d\\'optimisation des routes: $e');\r\n      state = RouteOptimizationTestState.error(e);\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 2208,
        "last_modified": "2025-04-16T13:25:27.607416",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_provider.dart",
      "content": "// lib/features/empty_trips/presentation/state/route_optimization_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/ports/providers/empty_trips/route_optimization.provider.dart';\r\nimport 'route_optimization_test_notifier.dart';\r\nimport 'route_optimization_test_state.dart';\r\n\r\nfinal routeOptimizationTestProvider = StateNotifierProvider<RouteOptimizationTestNotifier, RouteOptimizationTestState>((ref) {\r\n  final routeOptimization = ref.watch(routeOptimizationPortProvider);\r\n  return RouteOptimizationTestNotifier(routeOptimization);\r\n});",
      "info": {
        "size": 604,
        "last_modified": "2025-04-16T13:25:27.6129334",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_state.dart",
      "content": "// lib/features/empty_trips/presentation/state/route_optimization_test_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\npart 'route_optimization_test_state.freezed.dart';\r\n\r\n@freezed\r\nclass RouteOptimizationTestState with _$RouteOptimizationTestState {\r\n  const factory RouteOptimizationTestState.initial() = _Initial;\r\n  const factory RouteOptimizationTestState.loading() = _Loading;\r\n  const factory RouteOptimizationTestState.success(Map<String, dynamic> data) = _Success;\r\n  const factory RouteOptimizationTestState.error(Object error) = _Error;\r\n\r\n  const RouteOptimizationTestState._();\r\n\r\n}",
      "info": {
        "size": 624,
        "last_modified": "2025-04-16T13:25:27.6199336",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\empty_trips\\presentation\\state\\test\\route_optimization_test_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'route_optimization_test_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$RouteOptimizationTestState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $RouteOptimizationTestStateCopyWith<$Res> {\n  factory $RouteOptimizationTestStateCopyWith(RouteOptimizationTestState value,\n          $Res Function(RouteOptimizationTestState) then) =\n      _$RouteOptimizationTestStateCopyWithImpl<$Res,\n          RouteOptimizationTestState>;\n}\n\n/// @nodoc\nclass _$RouteOptimizationTestStateCopyWithImpl<$Res,\n        $Val extends RouteOptimizationTestState>\n    implements $RouteOptimizationTestStateCopyWith<$Res> {\n  _$RouteOptimizationTestStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl extends _Initial {\n  const _$InitialImpl() : super._();\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial extends RouteOptimizationTestState {\n  const factory _Initial() = _$InitialImpl;\n  const _Initial._() : super._();\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl extends _Loading {\n  const _$LoadingImpl() : super._();\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading extends RouteOptimizationTestState {\n  const factory _Loading() = _$LoadingImpl;\n  const _Loading._() : super._();\n}\n\n/// @nodoc\nabstract class _$$SuccessImplCopyWith<$Res> {\n  factory _$$SuccessImplCopyWith(\n          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =\n      __$$SuccessImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Map<String, dynamic> data});\n}\n\n/// @nodoc\nclass __$$SuccessImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$SuccessImpl>\n    implements _$$SuccessImplCopyWith<$Res> {\n  __$$SuccessImplCopyWithImpl(\n      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? data = null,\n  }) {\n    return _then(_$SuccessImpl(\n      null == data\n          ? _value._data\n          : data // ignore: cast_nullable_to_non_nullable\n              as Map<String, dynamic>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$SuccessImpl extends _Success {\n  const _$SuccessImpl(final Map<String, dynamic> data)\n      : _data = data,\n        super._();\n\n  final Map<String, dynamic> _data;\n  @override\n  Map<String, dynamic> get data {\n    if (_data is EqualUnmodifiableMapView) return _data;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableMapView(_data);\n  }\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.success(data: $data)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$SuccessImpl &&\n            const DeepCollectionEquality().equals(other._data, _data));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return success(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return success?.call(data);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(data);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return success(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return success?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (success != null) {\n      return success(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Success extends RouteOptimizationTestState {\n  const factory _Success(final Map<String, dynamic> data) = _$SuccessImpl;\n  const _Success._() : super._();\n\n  Map<String, dynamic> get data;\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({Object error});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$RouteOptimizationTestStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? error = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == error ? _value.error : error,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl extends _Error {\n  const _$ErrorImpl(this.error) : super._();\n\n  @override\n  final Object error;\n\n  @override\n  String toString() {\n    return 'RouteOptimizationTestState.error(error: $error)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            const DeepCollectionEquality().equals(other.error, error));\n  }\n\n  @override\n  int get hashCode =>\n      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(Map<String, dynamic> data) success,\n    required TResult Function(Object error) error,\n  }) {\n    return error(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(Map<String, dynamic> data)? success,\n    TResult? Function(Object error)? error,\n  }) {\n    return error?.call(this.error);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(Map<String, dynamic> data)? success,\n    TResult Function(Object error)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this.error);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Success value) success,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Success value)? success,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Success value)? success,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error extends RouteOptimizationTestState {\n  const factory _Error(final Object error) = _$ErrorImpl;\n  const _Error._() : super._();\n\n  Object get error;\n\n  /// Create a copy of RouteOptimizationTestState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18888,
        "last_modified": "2025-04-16T13:25:27.6260997",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\pages\\home_page.dart",
      "content": "// lib/features/home/presentation/pages/home_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:collection/collection.dart';\r\nimport '../widgets/navigation/lyra_navigation.dart';\r\nimport '../../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../../core/common/utils/activity_mapper.dart';\r\nimport '../../../../../core/domain/models/config/home_section_config.dart';\r\nimport '../../../search/application/state/home_activities_state.dart';\r\nimport '../../../search/presentation/pages/subcategory_page.dart';\r\nimport '../../../search/application/state/selected_subcategory_state.dart';\r\nimport '../../../shared_ui/presentation/widgets/shimmer/shimmer_section.dart';\r\nimport '../../../shared_ui/presentation/widgets/sections/activity_section.dart';\r\n\r\n\r\nclass HomePage extends ConsumerWidget {\r\n  const HomePage({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n\r\n    return Stack(\r\n      children: [\r\n        // Page d'accueil\r\n        AnimatedOpacity(\r\n          duration: const Duration(milliseconds: 200),\r\n          opacity: selectedSubcategory == null ? 1.0 : 0.0,\r\n          child: IgnorePointer(\r\n            ignoring: selectedSubcategory != null,\r\n            child: const HomeContent(),\r\n          ),\r\n        ),\r\n        // Page de sous-catgorie\r\n        AnimatedOpacity(\r\n          duration: const Duration(milliseconds: 200),\r\n          opacity: selectedSubcategory != null ? 1.0 : 0.0,\r\n          child: IgnorePointer(\r\n            ignoring: selectedSubcategory == null,\r\n            child: const SubcategoryPage(),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n}\r\n\r\n// lib/features/home/presentation/pages/home_page.dart\r\n\r\nclass HomeContent extends ConsumerWidget {\r\n  const HomeContent({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final sectionsAsync = ref.watch(homeSectionsConfigProvider);\r\n\r\n    return LyraNavigation(\r\n      child: sectionsAsync.when(\r\n        loading: () => _buildLoadingShimmer(),\r\n        error: (error, stack) => Center(\r\n          child: Text('Erreur de chargement des sections: $error'),\r\n        ),\r\n        data: (sections) => SingleChildScrollView(\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: sections\r\n                .toList()\r\n                .sorted((a, b) => a.priority.compareTo(b.priority))\r\n                .map((section) => _buildSectionWithActivities(ref, section))\r\n                .toList(),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSectionWithActivities(WidgetRef ref, HomeSectionConfig section) {\r\n    return Consumer(\r\n      builder: (context, ref, child) {\r\n        final activitiesAsync = ref.watch(sectionActivitiesProvider(section));\r\n\r\n        return activitiesAsync.when(\r\n          loading: () => ShimmerSection(isFirstSection: false),\r\n          error: (error, stack) => const SizedBox.shrink(), // On cache la section en erreur\r\n          data: (activities) => ActivitySection(\r\n            title: section.title,\r\n            activities: ActivityMapper.mapToActivityCards(activities),\r\n            isFirstSection: false, //  grer si ncessaire\r\n          ),\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingShimmer() => SingleChildScrollView(\r\n    child: Column(\r\n      children: List.generate(\r\n        3,\r\n            (index) => ShimmerSection(isFirstSection: index == 0),\r\n      ),\r\n    ),\r\n  );\r\n}",
      "info": {
        "size": 3653,
        "last_modified": "2025-04-16T13:25:27.6552136",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\city_picker.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/city_picker.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../search/application/state/selected_city_state.dart';\r\nimport '../../../../search/application/state/place_details_notifier.dart';\r\nimport '../../../../../core/adapters/cache/hive_adapters.dart';\r\nimport 'city_picker_modal.dart';\r\n\r\nclass CityPicker extends ConsumerWidget {\r\n  const CityPicker({super.key});\r\n\r\n  void _showCityPicker(BuildContext context, WidgetRef ref) {\r\n    // Rinitialiser l'tat du dtail de lieu avant d'ouvrir le modal\r\n    ref.read(placeDetailsNotifierProvider.notifier).reset();\r\n\r\n    // Ouvrir directement le modal sans vrification supplmentaire\r\n    showModalBottomSheet(\r\n      context: context,\r\n      isScrollControlled: true,\r\n      backgroundColor: Colors.transparent,\r\n      builder: (context) => const CityPickerModal(),\r\n    );\r\n  }\r\n\r\n  String _formatCityName(String? cityName) {\r\n    if (cityName == null) return 'Paris';\r\n    return cityName.length > 14 ? '${cityName.substring(0, 14)}...' : cityName;\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return Material(\r\n      color: Colors.transparent,\r\n      child: InkWell(\r\n        onTap: () => _showCityPicker(context, ref),\r\n        borderRadius: BorderRadius.circular(4),\r\n        splashColor: Colors.white.withOpacity(0.1),\r\n        highlightColor: Colors.white.withOpacity(0.1),\r\n        child: Padding(\r\n          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),\r\n          child: Row(\r\n            mainAxisSize: MainAxisSize.min,\r\n            children: [\r\n              Text(\r\n                _formatCityName(ref.watch(selectedCityProvider)?.cityName),\r\n                style: Theme.of(context).textTheme.bodyMedium?.copyWith(\r\n                  color: Colors.white,\r\n                  shadows: [],\r\n                ),\r\n              ),\r\n              const SizedBox(width: 4),\r\n              const Icon(\r\n                Icons.arrow_drop_down,\r\n                color: Colors.white,\r\n                size: 20,\r\n              ),\r\n            ],\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2289,
        "last_modified": "2025-04-16T13:25:27.6664384",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\city_picker_modal.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/city_picker_modal.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/domain/models/location/place_details.dart';\r\nimport '../../../../../core/domain/models/shared/city_model.dart';\r\nimport '../../../../../core/common/utils/geohash.dart';\r\nimport '../../../../search/application/state/city_search_provider.dart';\r\nimport '../../../../search/application/state/selected_city_state.dart';\r\nimport '../../../../search/application/state/place_details_notifier.dart';\r\nimport '../../../../search/application/state/place_details_state.dart';\r\nimport '../../../../search/application/state/place_search_notifier.dart';\r\nimport '../../../../search/presentation/widgets/location/location_search_bar.dart';\r\nimport '../../../../search/presentation/widgets/location/current_location_button.dart';\r\n\r\nclass CityPickerModal extends ConsumerStatefulWidget {\r\n  const CityPickerModal({Key? key}) : super(key: key);\r\n\r\n  @override\r\n  ConsumerState<CityPickerModal> createState() => _CityPickerModalState();\r\n}\r\n\r\nclass _CityPickerModalState extends ConsumerState<CityPickerModal> {\r\n  final searchController = TextEditingController();\r\n\r\n  @override\r\n  void dispose() {\r\n    searchController.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      height: MediaQuery.of(context).size.height * 0.8,\r\n      decoration: BoxDecoration(\r\n        color: Theme.of(context).scaffoldBackgroundColor,\r\n        borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),\r\n      ),\r\n      child: Column(\r\n        children: [\r\n          // Drag indicator\r\n          const SizedBox(height: 8),\r\n          Container(\r\n            width: 40,\r\n            height: 4,\r\n            decoration: BoxDecoration(\r\n              color: Colors.grey.shade300,\r\n              borderRadius: BorderRadius.circular(2),\r\n            ),\r\n          ),\r\n          const SizedBox(height: 16),\r\n\r\n          // Enhanced Search bar with Google Places integration\r\n          Padding(\r\n            padding: const EdgeInsets.symmetric(horizontal: 20),\r\n            child: Row(\r\n              children: [\r\n                IconButton(\r\n                  icon: const Icon(LucideIcons.arrowLeft),\r\n                  onPressed: () => Navigator.pop(context),\r\n                ),\r\n                Expanded(\r\n                  child: LocationSearchBar(\r\n                    initialQuery: searchController.text,\r\n                    onLocationButtonPressed: (_) {\r\n                      // Demander la position actuelle et convertir en City\r\n                      ref.read(placeDetailsNotifierProvider.notifier)\r\n                          .getCurrentLocation();\r\n                    },\r\n                    onSubmitted: (placeId) {\r\n                      // Charger les dtails du lieu\r\n                      ref.read(placeDetailsNotifierProvider.notifier)\r\n                          .getLocationDetails(placeId);\r\n                    },\r\n                  ),\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n          const SizedBox(height: 20),\r\n\r\n          // Location details state handling\r\n          Expanded(\r\n            child: Consumer(\r\n              builder: (context, ref, child) {\r\n                final placeDetailsState = ref.watch(placeDetailsNotifierProvider);\r\n\r\n                return placeDetailsState.when(\r\n                  initial: () => _buildSearchResults(),\r\n\r\n                  loading: () => const Center(\r\n                    child: Column(\r\n                      mainAxisSize: MainAxisSize.min,\r\n                      children: [\r\n                        CircularProgressIndicator(),\r\n                        SizedBox(height: 16),\r\n                        Text('Chargement des dtails...'),\r\n                      ],\r\n                    ),\r\n                  ),\r\n\r\n                  loaded: (details) {\r\n                    // Crer le geohash correct\r\n                    final String geohash5 = Geohash.encode(\r\n                        details.location.latitude,\r\n                        details.location.longitude\r\n                    );\r\n\r\n                    // Cration de l'objet City\r\n                    final city = City(\r\n                      id: details.placeId,\r\n                      cityName: details.name,\r\n                      lat: details.location.latitude,\r\n                      lon: details.location.longitude,\r\n                      geohash5: geohash5,\r\n                      createdAt: DateTime.now(),\r\n                      updatedAt: DateTime.now(),\r\n                    );\r\n\r\n                    // Logs de debug structurs\r\n                    print(' VILLE SLECTIONNE: ${details.name}');\r\n                    print('   Latitude: ${details.location.latitude}');\r\n                    print('   Longitude: ${details.location.longitude}');\r\n                    print('   Geohash: $geohash5');\r\n\r\n                    // Mettre  jour le state et fermer le modal\r\n                    WidgetsBinding.instance.addPostFrameCallback((_) {\r\n                      ref.read(selectedCityProvider.notifier).state = city;\r\n                      Navigator.pop(context);\r\n                    });\r\n\r\n                    return const SizedBox.shrink();\r\n                  },\r\n\r\n                  error: (message) => Column(\r\n                    children: [\r\n                      // Message d'erreur amlior\r\n                      Padding(\r\n                        padding: const EdgeInsets.all(20),\r\n                        child: Container(\r\n                          padding: const EdgeInsets.all(16),\r\n                          decoration: BoxDecoration(\r\n                            color: Colors.red.shade50,\r\n                            borderRadius: BorderRadius.circular(12),\r\n                            border: Border.all(color: Colors.red.shade200),\r\n                          ),\r\n                          child: Column(\r\n                            crossAxisAlignment: CrossAxisAlignment.start,\r\n                            children: [\r\n                              Row(\r\n                                children: [\r\n                                  Icon(Icons.error_outline, color: Colors.red.shade700),\r\n                                  const SizedBox(width: 12),\r\n                                  Expanded(\r\n                                    child: Text(\r\n                                      'Erreur de recherche',\r\n                                      style: TextStyle(\r\n                                        color: Colors.red.shade700,\r\n                                        fontWeight: FontWeight.bold,\r\n                                        fontSize: 16,\r\n                                      ),\r\n                                    ),\r\n                                  ),\r\n                                ],\r\n                              ),\r\n                              const SizedBox(height: 8),\r\n                              Text(\r\n                                message,\r\n                                style: TextStyle(color: Colors.red.shade700),\r\n                              ),\r\n                              const SizedBox(height: 8),\r\n                              Text(\r\n                                'Veuillez ressayer ou choisir une autre ville.',\r\n                                style: TextStyle(color: Colors.red.shade700),\r\n                              ),\r\n                            ],\r\n                          ),\r\n                        ),\r\n                      ),\r\n\r\n                      // Rsultats de recherche alternatifs\r\n                      Expanded(child: _buildSearchResults()),\r\n                    ],\r\n                  ),\r\n                );\r\n              },\r\n            ),\r\n          ),        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSearchResults() {\r\n    // Garde la fonctionnalit existante de recherche de villes\r\n    final query = searchController.text;\r\n    if (query.isEmpty) {\r\n      return Padding(\r\n        padding: const EdgeInsets.symmetric(horizontal: 20),\r\n        child: Column(\r\n          crossAxisAlignment: CrossAxisAlignment.start,\r\n          children: [\r\n            // Bouton pour utiliser la position actuelle uniquement\r\n            Card(\r\n              shape: RoundedRectangleBorder(\r\n                borderRadius: BorderRadius.circular(12),\r\n              ),\r\n              child: CurrentLocationButton(\r\n                onLocationSelected: () {\r\n                  ref.read(placeDetailsNotifierProvider.notifier)\r\n                      .getCurrentLocation();\r\n                },\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      );\r\n    }\r\n\r\n    final citiesAsync = ref.watch(citiesSearchResultsProvider(query));\r\n\r\n    return citiesAsync.when(\r\n      data: (cities) => ListView.builder(\r\n        padding: const EdgeInsets.symmetric(horizontal: 20),\r\n        itemCount: cities.take(10).length,\r\n        itemBuilder: (context, index) {\r\n          final city = cities[index];\r\n          return Container(\r\n            margin: const EdgeInsets.only(bottom: 8),\r\n            decoration: BoxDecoration(\r\n              color: AppColors.neutral200,\r\n              borderRadius: BorderRadius.circular(12),\r\n            ),\r\n            child: ListTile(\r\n              title: Text(\r\n                city.cityName,\r\n                style: const TextStyle(fontSize: 16),\r\n              ),\r\n              onTap: () {\r\n                ref.read(selectedCityProvider.notifier).state = city;\r\n                Navigator.pop(context);\r\n              },\r\n            ),\r\n          );\r\n        },\r\n      ),\r\n      loading: () => Center(\r\n        child: Column(\r\n          mainAxisAlignment: MainAxisAlignment.center,\r\n          children: [\r\n            const CircularProgressIndicator(),\r\n            const SizedBox(height: 8),\r\n            Text(\r\n              'Recherche en cours...',\r\n              style: Theme.of(context).textTheme.bodyMedium,\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n      error: (_, __) => const SizedBox.shrink(),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 10386,
        "last_modified": "2025-04-16T13:25:27.6729551",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\lyra_footer.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/lyra_footer.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport 'package:glossy/glossy.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\n\r\n\r\nclass LyraFooter extends StatelessWidget {\r\n  const LyraFooter({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return SizedBox(\r\n      height: AppDimensions.bottomNavBarHeight,\r\n      child: GlossyContainer(\r\n        width: double.infinity,\r\n        height: AppDimensions.bottomNavBarHeight,\r\n        strengthX: 5,\r\n        strengthY: 5,\r\n        opacity: 0.3,\r\n        border: Border.all(color: Colors.transparent),\r\n        color: AppColors.neutral900,\r\n        child: Container(\r\n          color: Color.fromRGBO(\r\n            AppColors.neutral900.red,\r\n            AppColors.neutral900.green,\r\n            AppColors.neutral900.blue,\r\n            0.7,\r\n          ),\r\n          child: SafeArea(\r\n            top: false,\r\n            child: Row(\r\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\r\n              children: [\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.home,\r\n                  label: 'Home',\r\n                  isSelected: true,\r\n                ),\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.heart,\r\n                  label: 'Favoris',\r\n                ),\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.sparkles,\r\n                  label: 'Wow',\r\n                ),\r\n                _buildFooterItem(\r\n                  context,\r\n                  icon: LucideIcons.user,\r\n                  label: 'Profil',\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildFooterItem(\r\n      BuildContext context, {\r\n        required IconData icon,\r\n        required String label,\r\n        bool isSelected = false,\r\n      }) {\r\n    final color = isSelected\r\n        ? AppColors.accent // Utilise la couleur corail pour l'item slectionn\r\n        : Colors.white;// Les autres items restent en blanc\r\n    return Expanded(  // Ajout pour une meilleure distribution de l'espace\r\n      child: InkWell(\r\n        onTap: () {},\r\n        child: SizedBox(  // Assure une hauteur fixe\r\n          height: AppDimensions.bottomNavBarHeight - MediaQuery.of(context).padding.bottom,\r\n          child: Column(\r\n            mainAxisAlignment: MainAxisAlignment.center,  // Centre verticalement\r\n            mainAxisSize: MainAxisSize.min,\r\n            children: [\r\n              const SizedBox(height: 8),\r\n              Icon(icon, color: color),\r\n              const SizedBox(height: 1),\r\n              Text(\r\n                label,\r\n                style: isSelected\r\n                    ? context.labelMedium.copyWith(\r\n                    fontWeight: FontWeight.bold,\r\n                    color: Theme.of(context).colorScheme.primary\r\n                ) // Style pour l'item slectionn\r\n                    : context.labelMedium.copyWith(\r\n                    color: AppColors.neutral500\r\n                ),\r\n              ),// Style par dfaut\r\n            ],\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3455,
        "last_modified": "2025-04-16T13:25:27.6799914",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\lyra_header.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/lyra_header.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:glossy/glossy.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport 'package:flutter_svg/flutter_svg.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/adapters/supabase/database_adapter.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../home/presentation/widgets/navigation/city_picker.dart';\r\nimport 'subcategories_list.dart';\r\n\r\n\r\n\r\n\r\nclass LyraHeader extends StatelessWidget {\r\n  final String? title;\r\n\r\n  const LyraHeader({\r\n    super.key,\r\n    this.title,\r\n  });\r\n\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      mainAxisSize: MainAxisSize.min,\r\n      children: [\r\n        GlossyContainer(\r\n          width: double.infinity,\r\n          height: MediaQuery.of(context).padding.top + 55,\r\n          strengthX: 5,\r\n          strengthY: 5,\r\n          opacity: 0.1,\r\n          border: Border.all(color: Colors.transparent),\r\n          color: AppColors.neutral900,\r\n          child: Container(\r\n            color: AppColors.neutral900,\r\n            padding: EdgeInsets.only(top: MediaQuery.of(context).padding.top),\r\n            child: _buildMainHeader(context),\r\n          ),\r\n        ),\r\n        Container(\r\n          color: AppColors.neutral900,\r\n          padding: const EdgeInsets.only(bottom: 8),  // Ajout du padding bottom\r\n          child: SizedBox(\r\n            height: 50,\r\n            child: const SubcategoriesList(),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n\r\n  Widget _buildMainHeader(BuildContext context) {\r\n    return Padding(\r\n      padding: EdgeInsets.only(\r\n        left: AppDimensions.spacingM,\r\n        right: AppDimensions.spacingXs,\r\n        bottom: AppDimensions.spacingS,\r\n        top: 8,  // Ajout pour descendre le header de 8px\r\n      ),\r\n      child: Row(\r\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\r\n        children: [\r\n          // Logo\r\n          SvgPicture.network(\r\n            '${SupabaseService.client.storage.from('images').getPublicUrl('branding/light.svg')}',\r\n            height: 55,\r\n          ),\r\n\r\n          // Ville au centre\r\n          Expanded(  // Wrap avec Expanded\r\n            child: Center(  // Centrer le contenu\r\n              child: Row(\r\n                mainAxisSize: MainAxisSize.min,  // Prendre la taille minimale ncessaire\r\n                children: [\r\n                  const Icon(\r\n                    LucideIcons.mapPin,\r\n                    size: 16,\r\n                    color: Colors.white,\r\n                    shadows: [], // Pas d'ombre\r\n                  ),\r\n                  const SizedBox(width: 4),\r\n                  const CityPicker(),\r\n                ],\r\n              ),\r\n            ),\r\n          ),\r\n\r\n// Boutons  droite\r\n          Padding(\r\n            padding: EdgeInsets.zero,\r\n            child: Row(\r\n              mainAxisSize: MainAxisSize.min,\r\n              children: [\r\n                IconButton(\r\n                  icon: const Icon(\r\n                    LucideIcons.slidersHorizontal,\r\n                    color: Colors.white,\r\n                    size: AppDimensions.iconSizeM,\r\n                  ),\r\n                  visualDensity: VisualDensity.compact,\r\n                  padding: EdgeInsets.zero,\r\n                  onPressed: () {},\r\n                ),\r\n                IconButton(\r\n                  icon: const Icon(\r\n                    LucideIcons.search,\r\n                    color: Colors.white,\r\n                    size: AppDimensions.iconSizeM,\r\n                  ),\r\n                  visualDensity: VisualDensity.compact,\r\n                  padding: EdgeInsets.zero,\r\n                  constraints: const BoxConstraints(\r\n                    minWidth: AppDimensions.iconSizeM,\r\n                    maxWidth: AppDimensions.iconSizeM,\r\n                  ),\r\n                  onPressed: () {},\r\n                ),\r\n              ],\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4143,
        "last_modified": "2025-04-16T13:25:27.6865065",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\lyra_navigation.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/lyra_navigation.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'lyra_header.dart';\r\nimport 'lyra_footer.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\n\r\n\r\n// Provider pour la visibilit du header\r\nfinal headerVisibilityProvider = StateProvider<bool>((ref) => true);\r\n\r\nclass LyraNavigation extends ConsumerWidget {  // tait StatelessWidget avant\r\n  final Widget child;\r\n  final String? title;\r\n\r\n  const LyraNavigation({\r\n    super.key,\r\n    required this.child,\r\n    this.title,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {  // Ajout de WidgetRef\r\n    final headerVisible = ref.watch(headerVisibilityProvider);\r\n\r\n    return Scaffold(\r\n      body: Stack(\r\n        children: [\r\n          CustomScrollView(\r\n            slivers: [\r\n              SliverToBoxAdapter(\r\n                child: SizedBox(height: MediaQuery.of(context).padding.top + 90),\r\n              ),\r\n              SliverToBoxAdapter(\r\n                child: child,\r\n              ),\r\n              const SliverToBoxAdapter(\r\n                child: SizedBox(height: 80),\r\n              ),\r\n            ],\r\n          ),\r\n          AnimatedPositioned(\r\n            duration: const Duration(milliseconds: 600),\r\n            curve: Curves.easeOutSine,\r\n            top: headerVisible ? 0 : -(MediaQuery.of(context).padding.top + 90),\r\n            left: 0,\r\n            right: 0,\r\n            child: Container(\r\n              color: AppColors.neutral900, // Mme couleur que le header\r\n              child: LyraHeader(\r\n                title: title,\r\n              ),\r\n            ),\r\n          ),\r\n          const Positioned(\r\n            bottom: 0,\r\n            left: 0,\r\n            right: 0,\r\n            child: LyraFooter(),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1912,
        "last_modified": "2025-04-16T13:25:27.6930227",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\home\\presentation\\widgets\\navigation\\subcategories_list.dart",
      "content": "// lib/features/home/presentation/widgets/navigation/subcategories_list.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/domain/models/shared/subcategory_model.dart';\r\nimport '../../../../../core/domain/ports/providers/search/subcategory_search_provider.dart';\r\nimport '../../../../../core/common/constants/subcategory_icons.dart';\r\nimport '../../../../search/application/state/selected_subcategory_state.dart';\r\n\r\nclass SubcategoriesList extends ConsumerWidget {\r\n  const SubcategoriesList({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return SizedBox(\r\n      height: 35,\r\n      child: _buildContent(context, ref),\r\n    );\r\n  }\r\n\r\n  Widget _buildContent(BuildContext context, WidgetRef ref) {\r\n    final subcategoriesAsync = ref.watch(subcategoriesProvider);\r\n\r\n    return SingleChildScrollView(\r\n      scrollDirection: Axis.horizontal,\r\n      padding: const EdgeInsets.symmetric(horizontal: 8),\r\n      clipBehavior: Clip.none, // Pour viter le clipping des ombres/effets\r\n      child: ConstrainedBox(\r\n        constraints: const BoxConstraints(maxWidth: double.infinity),\r\n        child: Row(\r\n          mainAxisSize: MainAxisSize.min, // Le Row s'adapte  la largeur de son contenu\r\n          children: [\r\n            _buildCategoryChip(\r\n              context,\r\n              ref,\r\n              icon: LucideIcons.compass,\r\n              label: 'Explorer',\r\n              subcategory: null,\r\n            ),\r\n            ...subcategoriesAsync.when(\r\n              data: (subcategories) => subcategories.map((subcategory) {\r\n                final isSelected = ref.watch(selectedSubcategoryProvider) == subcategory;\r\n                return _buildCategoryChip(\r\n                  context,\r\n                  ref,\r\n                  icon: SubcategoryIcons.getIcon(subcategory.icon),\r\n                  label: subcategory.name,\r\n                  subcategory: subcategory,\r\n                  isSelected: isSelected,\r\n                );\r\n              }),\r\n              loading: () => [\r\n                Padding(\r\n                  padding: const EdgeInsets.symmetric(horizontal: 16),\r\n                  child: SizedBox(\r\n                    width: 20,\r\n                    height: 20,\r\n                    child: CircularProgressIndicator(\r\n                      color: AppColors.neutral200,\r\n                      strokeWidth: 2,\r\n                    ),\r\n                  ),\r\n                )\r\n              ],\r\n              error: (_, __) => [\r\n                Icon(LucideIcons.alertCircle, color: AppColors.neutral200)\r\n              ],\r\n            ),\r\n            const SizedBox(width: 8), // Espace  droite pour compenser\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildCategoryChip(\r\n      BuildContext context,\r\n      WidgetRef ref, {\r\n        required IconData icon,\r\n        required String label,\r\n        Subcategory? subcategory,\r\n        bool? isSelected,\r\n      }) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n    final selected = subcategory == null\r\n        ? selectedSubcategory == null // \"Explorer\" est slectionn seulement si aucune sous-catgorie n'est slectionne\r\n        : subcategory.id == selectedSubcategory?.id;\r\n\r\n    if (subcategory == null) {\r\n      return Padding(\r\n        padding: const EdgeInsets.symmetric(horizontal: 1),\r\n        child: IntrinsicWidth(\r\n          child: GestureDetector(\r\n            onTap: () {\r\n              ref.read(selectedSubcategoryProvider.notifier).reset();\r\n            },\r\n            child: Container(\r\n              // Supprimez width: double.infinity pour laisser la largeur s'ajuster\r\n              height: 30,\r\n              decoration: BoxDecoration(\r\n                color: selected ? AppColors.neutral200 : AppColors.neutral800,\r\n                borderRadius: BorderRadius.circular(20),\r\n              ),\r\n              child: Padding(\r\n                padding: const EdgeInsets.symmetric(horizontal: 16),\r\n                child: Center(\r\n                  child: Row(\r\n                    mainAxisSize: MainAxisSize.min,\r\n                    mainAxisAlignment: MainAxisAlignment.center,\r\n                    children: [\r\n                      Icon(\r\n                        icon,\r\n                        size: 16,\r\n                        color: selected ? AppColors.neutral900 : Colors.white,\r\n                      ),\r\n                      const SizedBox(width: 8),\r\n                      Text(\r\n                        label,\r\n                        style: selected\r\n                            ? context.chipSelectedLabel\r\n                            : context.chipLabel,\r\n                      ),\r\n                    ],\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n\r\n    return Padding(\r\n      padding: const EdgeInsets.symmetric(horizontal: 4),\r\n      child: IntrinsicWidth(\r\n        child: GestureDetector(\r\n          onTap: () {\r\n            ref.read(selectedSubcategoryProvider.notifier).selectSubcategory(subcategory);\r\n          },\r\n          child: Container(\r\n            // Supprimez galement width: double.infinity ici\r\n            height: 32,\r\n            decoration: BoxDecoration(\r\n              color: selected ? AppColors.neutral200 : AppColors.neutral800,\r\n              borderRadius: BorderRadius.circular(20),\r\n            ),\r\n            child: Padding(\r\n              padding: const EdgeInsets.symmetric(horizontal: 16),\r\n              child: Center(\r\n                child: Row(\r\n                  mainAxisSize: MainAxisSize.min,\r\n                  mainAxisAlignment: MainAxisAlignment.center,\r\n                  children: [\r\n                    Icon(\r\n                      icon,\r\n                      size: 16,\r\n                      color: selected ? AppColors.neutral900 : Colors.white,\r\n                    ),\r\n                    const SizedBox(width: 8),\r\n                    Text(\r\n                      label,\r\n                      style: selected\r\n                          ? context.chipSelectedLabel\r\n                          : context.chipLabel,\r\n                    ),\r\n                  ],\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 6548,
        "last_modified": "2025-04-16T13:25:27.6990228",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\services\\city_selection_service.dart",
      "content": "// lib/features/search/application/services/city_selection_service.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../../../core/domain/models/shared/city_model.dart';\r\nimport '../../../../core/domain/models/location/place_details.dart';\r\nimport '../../../../core/domain/services/location/enhanced_location_service.dart';\r\nimport '../../../../core/domain/ports/providers/location/location_providers.dart';\r\nimport '../state/selected_city_state.dart';\r\n\r\n/// Service qui gre la logique de slection de ville et la rcupration de ses coordonnes\r\nclass CitySelectionService {\r\n  final EnhancedLocationService _locationService;\r\n  final Ref _ref;\r\n\r\n  CitySelectionService(this._locationService, this._ref);\r\n\r\n  /// Slectionne une ville  partir de son place_id Google\r\n  /// et met  jour les providers associs\r\n  Future<bool> selectCityByPlaceId(String placeId) async {\r\n    try {\r\n      // Rcuprer les dtails complets du lieu (incluant lat/lng)\r\n      final placeDetailsResult = await _locationService.getPlaceDetails(placeId);\r\n\r\n      if (placeDetailsResult.isError) {\r\n        print(' Erreur lors de la rcupration des dtails: ${placeDetailsResult.asError!.error}');\r\n        return false;\r\n      }\r\n\r\n      // Extraire l'objet PlaceDetails du Result\r\n      final placeDetails = placeDetailsResult.asValue!.value;\r\n\r\n      // Crer un objet City avec les coordonnes\r\n      final city = City(\r\n        id: placeId,\r\n        cityName: placeDetails.name,\r\n        lat: placeDetails.location.latitude,\r\n        lon: placeDetails.location.longitude,\r\n        geohash5: '', //  gnrer si ncessaire\r\n        createdAt: DateTime.now(),\r\n        updatedAt: DateTime.now(),\r\n      );\r\n\r\n      // Mettre  jour le provider de ville slectionne\r\n      _ref.read(selectedCityProvider.notifier).state = city;\r\n\r\n      print(' Ville slectionne: ${city.cityName} (${city.lat}, ${city.lon})');\r\n      return true;\r\n    } catch (e) {\r\n      print(' Erreur lors de la slection de la ville: $e');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /// Rcupre les coordonnes de la ville actuellement slectionne\r\n  /// ou null si aucune ville n'est slectionne\r\n  LatLng? getSelectedCityCoordinates() {\r\n    final city = _ref.read(selectedCityProvider);\r\n    if (city == null) return null;\r\n\r\n    return LatLng(city.lat, city.lon);\r\n  }\r\n}\r\n\r\n// Provider pour accder au service\r\nfinal citySelectionServiceProvider = Provider<CitySelectionService>((ref) {\r\n  final locationService = ref.watch(enhancedLocationServiceProvider);\r\n  return CitySelectionService(locationService, ref);\r\n});",
      "info": {
        "size": 2750,
        "last_modified": "2025-04-16T13:25:27.7271696",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\activity_details_state.dart",
      "content": "// lib/features/search/application/state/activity_details_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../core/domain/ports/search/activity_details_port.dart';\r\nimport '../../../../core/adapters/supabase/database_adapter.dart';\r\nimport '../../../../core/adapters/supabase/search/activity_details_adapter.dart';\r\n\r\npart 'activity_details_state.freezed.dart';\r\n\r\n@freezed\r\nclass ActivityDetailsState with _$ActivityDetailsState {\r\n  const factory ActivityDetailsState.initial() = _Initial;\r\n  const factory ActivityDetailsState.loading() = _Loading;\r\n  const factory ActivityDetailsState.loaded(ActivityDetails details) = _Loaded;\r\n  const factory ActivityDetailsState.error(String message) = _Error;\r\n}\r\n\r\nclass ActivityDetailsNotifier extends StateNotifier<ActivityDetailsState> {\r\n  final ActivityDetailsPort _port;\r\n\r\n  ActivityDetailsNotifier(this._port) : super(const ActivityDetailsState.initial());\r\n\r\n  Future<void> loadActivityDetails(String activityId) async {\r\n    print('StateNotifier: Loading details for activity: $activityId');\r\n    state = const ActivityDetailsState.loading();\r\n    try {\r\n      print('StateNotifier: Calling port.getActivityDetails');\r\n      final details = await _port.getActivityDetails(activityId);\r\n      print('StateNotifier: Got details successfully');\r\n      state = ActivityDetailsState.loaded(details);\r\n    } catch (e) {\r\n      print('StateNotifier: Error loading details: $e');\r\n      state = ActivityDetailsState.error(e.toString());\r\n    }\r\n  }\r\n}\r\n\r\n// Un seul provider qui combine tout\r\nfinal activityDetailsProvider = StateNotifierProvider.autoDispose<ActivityDetailsNotifier, ActivityDetailsState>((ref) {\r\n  return ActivityDetailsNotifier(\r\n      ActivityDetailsAdapter(SupabaseService.client)\r\n  );\r\n});",
      "info": {
        "size": 1938,
        "last_modified": "2025-04-16T13:25:27.7397191",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\activity_details_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'activity_details_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$ActivityDetailsState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $ActivityDetailsStateCopyWith<$Res> {\n  factory $ActivityDetailsStateCopyWith(ActivityDetailsState value,\n          $Res Function(ActivityDetailsState) then) =\n      _$ActivityDetailsStateCopyWithImpl<$Res, ActivityDetailsState>;\n}\n\n/// @nodoc\nclass _$ActivityDetailsStateCopyWithImpl<$Res,\n        $Val extends ActivityDetailsState>\n    implements $ActivityDetailsStateCopyWith<$Res> {\n  _$ActivityDetailsStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements ActivityDetailsState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements ActivityDetailsState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadedImplCopyWith<$Res> {\n  factory _$$LoadedImplCopyWith(\n          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =\n      __$$LoadedImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({ActivityDetails details});\n\n  $ActivityDetailsCopyWith<$Res> get details;\n}\n\n/// @nodoc\nclass __$$LoadedImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$LoadedImpl>\n    implements _$$LoadedImplCopyWith<$Res> {\n  __$$LoadedImplCopyWithImpl(\n      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? details = null,\n  }) {\n    return _then(_$LoadedImpl(\n      null == details\n          ? _value.details\n          : details // ignore: cast_nullable_to_non_nullable\n              as ActivityDetails,\n    ));\n  }\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $ActivityDetailsCopyWith<$Res> get details {\n    return $ActivityDetailsCopyWith<$Res>(_value.details, (value) {\n      return _then(_value.copyWith(details: value));\n    });\n  }\n}\n\n/// @nodoc\n\nclass _$LoadedImpl implements _Loaded {\n  const _$LoadedImpl(this.details);\n\n  @override\n  final ActivityDetails details;\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.loaded(details: $details)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$LoadedImpl &&\n            (identical(other.details, details) || other.details == details));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, details);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loaded(details);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loaded?.call(details);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(details);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loaded(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loaded?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loaded implements ActivityDetailsState {\n  const factory _Loaded(final ActivityDetails details) = _$LoadedImpl;\n\n  ActivityDetails get details;\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({String message});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$ActivityDetailsStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? message = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == message\n          ? _value.message\n          : message // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.message);\n\n  @override\n  final String message;\n\n  @override\n  String toString() {\n    return 'ActivityDetailsState.error(message: $message)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            (identical(other.message, message) || other.message == message));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, message);\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(ActivityDetails details) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return error(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(ActivityDetails details)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return error?.call(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(ActivityDetails details)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(message);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements ActivityDetailsState {\n  const factory _Error(final String message) = _$ErrorImpl;\n\n  String get message;\n\n  /// Create a copy of ActivityDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18644,
        "last_modified": "2025-04-16T13:25:27.746252",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\city_search_provider.dart",
      "content": "// lib/features/search/application/state/city_search_provider.dart\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../../../core/adapters/supabase/search/city_search_adapter.dart';\r\nimport '../../../../core/domain/models/shared/city_model.dart';\r\nimport '../../../../core/adapters/supabase/database_adapter.dart';\r\n\r\nfinal citySearchAdapter = CitySearchAdapter(SupabaseService.client);\r\n\r\nfinal citySearchProvider = Provider<CitySearchAdapter>((ref) => citySearchAdapter);\r\n\r\nfinal citiesSearchResultsProvider = FutureProvider.family<List<City>, String?>((ref, query) async {\r\n  print('DEBUG: Searching cities with query: $query');\r\n  try {\r\n    final citySearchAdapter = ref.read(citySearchProvider);\r\n    final results = await citySearchAdapter.searchCities(query);\r\n    print('DEBUG: Found ${results.length} cities');\r\n    return results;\r\n  } catch (e) {\r\n    print('DEBUG: Error in citiesSearchResultsProvider: $e');\r\n    rethrow;\r\n  }\r\n});",
      "info": {
        "size": 951,
        "last_modified": "2025-04-16T13:25:27.7532897",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\home_activities_state.dart",
      "content": "// lib/features/search/application/state/home_activities_state.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../../../../core/domain/models/activity/search/searchable_activity.dart';\r\nimport '../../../../core/domain/models/config/home_section_config.dart';\r\nimport '../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport '../state/selected_city_state.dart';\r\nimport '../../domain/providers/search_providers.dart';\r\n\r\n// Provider pour les activits d'une section spcifique\r\nfinal sectionActivitiesProvider = FutureProvider.autoDispose.family<List<SearchableActivity>, HomeSectionConfig>(\r\n      (ref, section) async {\r\n    const latitude = 44.8333;\r\n    const longitude = 0.7333;\r\n\r\n    final selectedCity = ref.watch(selectedCityProvider);\r\n    if (selectedCity == null) return [];\r\n\r\n    final useCase = ref.watch(searchProvidersModule.firstWhere(\r\n            (provider) => provider is Provider<GetActivitiesUseCase>\r\n    ) as Provider<GetActivitiesUseCase>);\r\n\r\n    try {\r\n      final activities = await useCase.executeQuery(\r\n          latitude: latitude,\r\n          longitude: longitude,\r\n          cityId: selectedCity.id,\r\n          queryFilter: section.queryFilter\r\n      );\r\n\r\n      // Cache des distances\r\n      ref.read(activityDistancesProvider.notifier).cacheDistances(\r\n          activities,\r\n          LatLng(latitude, longitude)\r\n      );\r\n\r\n      return activities;\r\n    } catch (e) {\r\n      return [];\r\n    }\r\n  },\r\n);\r\n\r\n// Provider principal qui combine les rsultats des sections\r\nfinal homeActivitiesProvider = FutureProvider.autoDispose<Map<String, List<SearchableActivity>>>((ref) async {\r\n  final sections = await ref.watch(homeSectionsConfigProvider.future);\r\n  final results = <String, List<SearchableActivity>>{};\r\n\r\n  // Charger les sections en parallle\r\n  await Future.wait(\r\n    sections.map((section) async {\r\n      final activities = await ref.watch(sectionActivitiesProvider(section).future);\r\n      results[section.id.toString()] = activities;\r\n    }),\r\n  );\r\n\r\n  return results;\r\n});",
      "info": {
        "size": 2319,
        "last_modified": "2025-04-16T13:25:27.7603436",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_details_notifier.dart",
      "content": "// lib/features/search/application/state/place_details_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../../../core/domain/models/location/place_details.dart';\r\nimport '../../../../core/domain/services/location/enhanced_location_service.dart';\r\nimport '../../../../core/domain/ports/providers/location/location_providers.dart';\r\nimport 'place_details_state.dart';\r\n\r\nclass PlaceDetailsNotifier extends StateNotifier<PlaceDetailsState> {\r\n  final EnhancedLocationService _locationService;\r\n\r\n  PlaceDetailsNotifier(this._locationService)\r\n      : super(const PlaceDetailsState.initial());\r\n\r\n  Future<void> getLocationDetails(String placeId) async {\r\n    state = const PlaceDetailsState.loading();\r\n\r\n    final result = await _locationService.getPlaceDetails(placeId);\r\n\r\n    if (result.isError) {\r\n      state = PlaceDetailsState.error(\r\n          result.asError!.error.toString()\r\n      );\r\n      return;\r\n    }\r\n\r\n    state = PlaceDetailsState.loaded(result.asValue!.value);\r\n  }\r\n\r\n  Future<void> getCurrentLocation() async {\r\n    state = const PlaceDetailsState.loading();\r\n\r\n    final locationResult = await _locationService.getCurrentLocation();\r\n\r\n    if (locationResult.isError) {\r\n      state = PlaceDetailsState.error(\r\n          locationResult.asError!.error.toString()\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Pour la golocalisation directe, on cre un PlaceDetails simplifi\r\n    // avec les coordonnes obtenues\r\n    final userLocation = locationResult.asValue!.value;\r\n    final placeDetails = PlaceDetails(\r\n      placeId: 'current_location',\r\n      formattedAddress: 'Position actuelle',\r\n      name: 'Ma position',\r\n      location: userLocation,\r\n      lastUpdated: DateTime.now(),\r\n    );\r\n\r\n    state = PlaceDetailsState.loaded(placeDetails);\r\n  }\r\n\r\n  void reset() {\r\n    state = const PlaceDetailsState.initial();\r\n  }\r\n}\r\n\r\n// Provider pour le notifier\r\nfinal placeDetailsNotifierProvider = StateNotifierProvider<PlaceDetailsNotifier, PlaceDetailsState>((ref) {\r\n  final locationService = ref.watch(enhancedLocationServiceProvider);\r\n  return PlaceDetailsNotifier(locationService);\r\n});",
      "info": {
        "size": 2190,
        "last_modified": "2025-04-16T13:25:27.7663754",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_details_state.dart",
      "content": "// lib/features/search/application/state/place_details_state.dart (prcdemment selected_location_state.dart)\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../../../../core/domain/models/location/place_details.dart';\r\n\r\npart 'place_details_state.freezed.dart';\r\n\r\n@freezed\r\nclass PlaceDetailsState with _$PlaceDetailsState {\r\n  const factory PlaceDetailsState.initial() = _Initial;\r\n  const factory PlaceDetailsState.loading() = _Loading;\r\n  const factory PlaceDetailsState.loaded(PlaceDetails location) = _Loaded;\r\n  const factory PlaceDetailsState.error(String message) = _Error;\r\n}",
      "info": {
        "size": 613,
        "last_modified": "2025-04-16T13:25:27.7729582",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_details_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_details_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$PlaceDetailsState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceDetailsStateCopyWith<$Res> {\n  factory $PlaceDetailsStateCopyWith(\n          PlaceDetailsState value, $Res Function(PlaceDetailsState) then) =\n      _$PlaceDetailsStateCopyWithImpl<$Res, PlaceDetailsState>;\n}\n\n/// @nodoc\nclass _$PlaceDetailsStateCopyWithImpl<$Res, $Val extends PlaceDetailsState>\n    implements $PlaceDetailsStateCopyWith<$Res> {\n  _$PlaceDetailsStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements PlaceDetailsState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements PlaceDetailsState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadedImplCopyWith<$Res> {\n  factory _$$LoadedImplCopyWith(\n          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =\n      __$$LoadedImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({PlaceDetails location});\n\n  $PlaceDetailsCopyWith<$Res> get location;\n}\n\n/// @nodoc\nclass __$$LoadedImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$LoadedImpl>\n    implements _$$LoadedImplCopyWith<$Res> {\n  __$$LoadedImplCopyWithImpl(\n      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? location = null,\n  }) {\n    return _then(_$LoadedImpl(\n      null == location\n          ? _value.location\n          : location // ignore: cast_nullable_to_non_nullable\n              as PlaceDetails,\n    ));\n  }\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @override\n  @pragma('vm:prefer-inline')\n  $PlaceDetailsCopyWith<$Res> get location {\n    return $PlaceDetailsCopyWith<$Res>(_value.location, (value) {\n      return _then(_value.copyWith(location: value));\n    });\n  }\n}\n\n/// @nodoc\n\nclass _$LoadedImpl implements _Loaded {\n  const _$LoadedImpl(this.location);\n\n  @override\n  final PlaceDetails location;\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.loaded(location: $location)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$LoadedImpl &&\n            (identical(other.location, location) ||\n                other.location == location));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, location);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return loaded(location);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return loaded?.call(location);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(location);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return loaded(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loaded?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loaded implements PlaceDetailsState {\n  const factory _Loaded(final PlaceDetails location) = _$LoadedImpl;\n\n  PlaceDetails get location;\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({String message});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$PlaceDetailsStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? message = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == message\n          ? _value.message\n          : message // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.message);\n\n  @override\n  final String message;\n\n  @override\n  String toString() {\n    return 'PlaceDetailsState.error(message: $message)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            (identical(other.message, message) || other.message == message));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, message);\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(PlaceDetails location) loaded,\n    required TResult Function(String message) error,\n  }) {\n    return error(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(PlaceDetails location)? loaded,\n    TResult? Function(String message)? error,\n  }) {\n    return error?.call(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(PlaceDetails location)? loaded,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(message);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements PlaceDetailsState {\n  const factory _Error(final String message) = _$ErrorImpl;\n\n  String get message;\n\n  /// Create a copy of PlaceDetailsState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 18520,
        "last_modified": "2025-04-16T13:25:27.7789672",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_search_notifier.dart",
      "content": "// lib/features/search/application/state/place_search_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:async/async.dart';\r\nimport '../../../../core/domain/models/location/place_suggestion.dart';\r\nimport '../../../../core/domain/services/location/enhanced_location_service.dart';\r\nimport '../../../../core/domain/ports/providers/location/location_providers.dart';\r\nimport '../../../../core/common/exceptions/location_exceptions.dart';\r\nimport 'place_search_state.dart';\r\n\r\nclass PlaceSearchNotifier extends StateNotifier<PlaceSearchState> {\r\n  final EnhancedLocationService _locationService;\r\n\r\n  PlaceSearchNotifier(this._locationService)\r\n      : super(const PlaceSearchState.initial());\r\n\r\n  void searchLocation(String query) {\r\n    if (query.isEmpty) {\r\n      state = const PlaceSearchState.initial();\r\n      return;\r\n    }\r\n\r\n    if (query.length < 3) {\r\n      state = const PlaceSearchState.noResults();\r\n      return;\r\n    }\r\n\r\n    state = const PlaceSearchState.loading();\r\n\r\n    _locationService.searchPlacesWithDebounce(\r\n      query,\r\n          (Result<List<PlaceSuggestion>> result) {\r\n        if (result.isError) {\r\n          state = PlaceSearchState.error(\r\n              result.asError!.error.toString()\r\n          );\r\n          return;\r\n        }\r\n\r\n        final suggestions = result.asValue!.value;\r\n\r\n        if (suggestions.isEmpty) {\r\n          state = const PlaceSearchState.noResults();\r\n        } else {\r\n          state = PlaceSearchState.loaded(suggestions);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  void cancelSearch() {\r\n    _locationService.cancelSearch();\r\n    state = const PlaceSearchState.initial();\r\n  }\r\n\r\n  void reset() {\r\n    cancelSearch();\r\n  }\r\n}\r\n\r\n// Provider pour le notifier\r\nfinal placeSearchNotifierProvider = StateNotifierProvider<PlaceSearchNotifier, PlaceSearchState>((ref) {\r\n  final locationService = ref.watch(enhancedLocationServiceProvider);\r\n  return PlaceSearchNotifier(locationService);\r\n});",
      "info": {
        "size": 1987,
        "last_modified": "2025-04-16T13:25:27.7860215",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_search_state.dart",
      "content": "// lib/features/search/application/state/place_search_state.dart\r\n\r\nimport 'package:freezed_annotation/freezed_annotation.dart';\r\nimport '../../../../core/domain/models/location/place_suggestion.dart';\r\n\r\npart 'place_search_state.freezed.dart';\r\n\r\n@freezed\r\nclass PlaceSearchState with _$PlaceSearchState {\r\n  const factory PlaceSearchState.initial() = _Initial;\r\n  const factory PlaceSearchState.loading() = _Loading;\r\n  const factory PlaceSearchState.loaded(List<PlaceSuggestion> suggestions) = _Loaded;\r\n  const factory PlaceSearchState.noResults() = _NoResults;\r\n  const factory PlaceSearchState.error(String message) = _Error;\r\n}",
      "info": {
        "size": 634,
        "last_modified": "2025-04-16T13:25:27.7920848",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\place_search_state.freezed.dart",
      "content": "// coverage:ignore-file\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// ignore_for_file: type=lint\n// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark\n\npart of 'place_search_state.dart';\n\n// **************************************************************************\n// FreezedGenerator\n// **************************************************************************\n\nT _$identity<T>(T value) => value;\n\nfinal _privateConstructorUsedError = UnsupportedError(\n    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');\n\n/// @nodoc\nmixin _$PlaceSearchState {\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) =>\n      throw _privateConstructorUsedError;\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class $PlaceSearchStateCopyWith<$Res> {\n  factory $PlaceSearchStateCopyWith(\n          PlaceSearchState value, $Res Function(PlaceSearchState) then) =\n      _$PlaceSearchStateCopyWithImpl<$Res, PlaceSearchState>;\n}\n\n/// @nodoc\nclass _$PlaceSearchStateCopyWithImpl<$Res, $Val extends PlaceSearchState>\n    implements $PlaceSearchStateCopyWith<$Res> {\n  _$PlaceSearchStateCopyWithImpl(this._value, this._then);\n\n  // ignore: unused_field\n  final $Val _value;\n  // ignore: unused_field\n  final $Res Function($Val) _then;\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\nabstract class _$$InitialImplCopyWith<$Res> {\n  factory _$$InitialImplCopyWith(\n          _$InitialImpl value, $Res Function(_$InitialImpl) then) =\n      __$$InitialImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$InitialImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$InitialImpl>\n    implements _$$InitialImplCopyWith<$Res> {\n  __$$InitialImplCopyWithImpl(\n      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$InitialImpl implements _Initial {\n  const _$InitialImpl();\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.initial()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$InitialImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return initial();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return initial?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return initial(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return initial?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (initial != null) {\n      return initial(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Initial implements PlaceSearchState {\n  const factory _Initial() = _$InitialImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadingImplCopyWith<$Res> {\n  factory _$$LoadingImplCopyWith(\n          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =\n      __$$LoadingImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$LoadingImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$LoadingImpl>\n    implements _$$LoadingImplCopyWith<$Res> {\n  __$$LoadingImplCopyWithImpl(\n      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$LoadingImpl implements _Loading {\n  const _$LoadingImpl();\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.loading()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$LoadingImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return loading();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return loading?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return loading(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loading?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loading != null) {\n      return loading(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loading implements PlaceSearchState {\n  const factory _Loading() = _$LoadingImpl;\n}\n\n/// @nodoc\nabstract class _$$LoadedImplCopyWith<$Res> {\n  factory _$$LoadedImplCopyWith(\n          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =\n      __$$LoadedImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({List<PlaceSuggestion> suggestions});\n}\n\n/// @nodoc\nclass __$$LoadedImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$LoadedImpl>\n    implements _$$LoadedImplCopyWith<$Res> {\n  __$$LoadedImplCopyWithImpl(\n      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? suggestions = null,\n  }) {\n    return _then(_$LoadedImpl(\n      null == suggestions\n          ? _value._suggestions\n          : suggestions // ignore: cast_nullable_to_non_nullable\n              as List<PlaceSuggestion>,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$LoadedImpl implements _Loaded {\n  const _$LoadedImpl(final List<PlaceSuggestion> suggestions)\n      : _suggestions = suggestions;\n\n  final List<PlaceSuggestion> _suggestions;\n  @override\n  List<PlaceSuggestion> get suggestions {\n    if (_suggestions is EqualUnmodifiableListView) return _suggestions;\n    // ignore: implicit_dynamic_type\n    return EqualUnmodifiableListView(_suggestions);\n  }\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.loaded(suggestions: $suggestions)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$LoadedImpl &&\n            const DeepCollectionEquality()\n                .equals(other._suggestions, _suggestions));\n  }\n\n  @override\n  int get hashCode => Object.hash(\n      runtimeType, const DeepCollectionEquality().hash(_suggestions));\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return loaded(suggestions);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return loaded?.call(suggestions);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(suggestions);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return loaded(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return loaded?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (loaded != null) {\n      return loaded(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Loaded implements PlaceSearchState {\n  const factory _Loaded(final List<PlaceSuggestion> suggestions) = _$LoadedImpl;\n\n  List<PlaceSuggestion> get suggestions;\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n\n/// @nodoc\nabstract class _$$NoResultsImplCopyWith<$Res> {\n  factory _$$NoResultsImplCopyWith(\n          _$NoResultsImpl value, $Res Function(_$NoResultsImpl) then) =\n      __$$NoResultsImplCopyWithImpl<$Res>;\n}\n\n/// @nodoc\nclass __$$NoResultsImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$NoResultsImpl>\n    implements _$$NoResultsImplCopyWith<$Res> {\n  __$$NoResultsImplCopyWithImpl(\n      _$NoResultsImpl _value, $Res Function(_$NoResultsImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n}\n\n/// @nodoc\n\nclass _$NoResultsImpl implements _NoResults {\n  const _$NoResultsImpl();\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.noResults()';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType && other is _$NoResultsImpl);\n  }\n\n  @override\n  int get hashCode => runtimeType.hashCode;\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return noResults();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return noResults?.call();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (noResults != null) {\n      return noResults();\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return noResults(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return noResults?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (noResults != null) {\n      return noResults(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _NoResults implements PlaceSearchState {\n  const factory _NoResults() = _$NoResultsImpl;\n}\n\n/// @nodoc\nabstract class _$$ErrorImplCopyWith<$Res> {\n  factory _$$ErrorImplCopyWith(\n          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =\n      __$$ErrorImplCopyWithImpl<$Res>;\n  @useResult\n  $Res call({String message});\n}\n\n/// @nodoc\nclass __$$ErrorImplCopyWithImpl<$Res>\n    extends _$PlaceSearchStateCopyWithImpl<$Res, _$ErrorImpl>\n    implements _$$ErrorImplCopyWith<$Res> {\n  __$$ErrorImplCopyWithImpl(\n      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)\n      : super(_value, _then);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @pragma('vm:prefer-inline')\n  @override\n  $Res call({\n    Object? message = null,\n  }) {\n    return _then(_$ErrorImpl(\n      null == message\n          ? _value.message\n          : message // ignore: cast_nullable_to_non_nullable\n              as String,\n    ));\n  }\n}\n\n/// @nodoc\n\nclass _$ErrorImpl implements _Error {\n  const _$ErrorImpl(this.message);\n\n  @override\n  final String message;\n\n  @override\n  String toString() {\n    return 'PlaceSearchState.error(message: $message)';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    return identical(this, other) ||\n        (other.runtimeType == runtimeType &&\n            other is _$ErrorImpl &&\n            (identical(other.message, message) || other.message == message));\n  }\n\n  @override\n  int get hashCode => Object.hash(runtimeType, message);\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  @override\n  @pragma('vm:prefer-inline')\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);\n\n  @override\n  @optionalTypeArgs\n  TResult when<TResult extends Object?>({\n    required TResult Function() initial,\n    required TResult Function() loading,\n    required TResult Function(List<PlaceSuggestion> suggestions) loaded,\n    required TResult Function() noResults,\n    required TResult Function(String message) error,\n  }) {\n    return error(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? whenOrNull<TResult extends Object?>({\n    TResult? Function()? initial,\n    TResult? Function()? loading,\n    TResult? Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult? Function()? noResults,\n    TResult? Function(String message)? error,\n  }) {\n    return error?.call(message);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeWhen<TResult extends Object?>({\n    TResult Function()? initial,\n    TResult Function()? loading,\n    TResult Function(List<PlaceSuggestion> suggestions)? loaded,\n    TResult Function()? noResults,\n    TResult Function(String message)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(message);\n    }\n    return orElse();\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult map<TResult extends Object?>({\n    required TResult Function(_Initial value) initial,\n    required TResult Function(_Loading value) loading,\n    required TResult Function(_Loaded value) loaded,\n    required TResult Function(_NoResults value) noResults,\n    required TResult Function(_Error value) error,\n  }) {\n    return error(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult? mapOrNull<TResult extends Object?>({\n    TResult? Function(_Initial value)? initial,\n    TResult? Function(_Loading value)? loading,\n    TResult? Function(_Loaded value)? loaded,\n    TResult? Function(_NoResults value)? noResults,\n    TResult? Function(_Error value)? error,\n  }) {\n    return error?.call(this);\n  }\n\n  @override\n  @optionalTypeArgs\n  TResult maybeMap<TResult extends Object?>({\n    TResult Function(_Initial value)? initial,\n    TResult Function(_Loading value)? loading,\n    TResult Function(_Loaded value)? loaded,\n    TResult Function(_NoResults value)? noResults,\n    TResult Function(_Error value)? error,\n    required TResult orElse(),\n  }) {\n    if (error != null) {\n      return error(this);\n    }\n    return orElse();\n  }\n}\n\nabstract class _Error implements PlaceSearchState {\n  const factory _Error(final String message) = _$ErrorImpl;\n\n  String get message;\n\n  /// Create a copy of PlaceSearchState\n  /// with the given fields replaced by the non-null parameter values.\n  @JsonKey(includeFromJson: false, includeToJson: false)\n  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>\n      throw _privateConstructorUsedError;\n}\n",
      "info": {
        "size": 23503,
        "last_modified": "2025-04-16T13:25:27.7980843",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\section_activities_provider.dart",
      "content": "// lib/features/search/application/state/section_activities_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../core/domain/models/activity/search/searchable_activity.dart';\r\nimport '../../../../core/domain/models/config/home_section_config.dart';\r\nimport '../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../state/selected_city_state.dart';\r\nimport '../../domain/providers/search_providers.dart';\r\n\r\nfinal sectionActivitiesProvider = FutureProvider.family<List<SearchableActivity>, HomeSectionConfig>((ref, section) async {\r\n  final selectedCity = ref.watch(selectedCityProvider);\r\n  if (selectedCity == null) return [];\r\n\r\n  // Utiliser les coordonnes de la ville slectionne et non des valeurs fixes\r\n  final latitude = selectedCity.lat;\r\n  final longitude = selectedCity.lon;\r\n\r\n  print(' Recherche d\\'activits pour section: ${section.title}');\r\n  print(' Coordonnes utilises: ($latitude, $longitude)');\r\n  print(' Ville: ${selectedCity.cityName}, ID: ${selectedCity.id}');\r\n\r\n  final useCase = ref.watch(searchProvidersModule.firstWhere(\r\n          (provider) => provider is Provider<GetActivitiesUseCase>\r\n  ) as Provider<GetActivitiesUseCase>);\r\n\r\n  try {\r\n    final activities = await useCase.executeQuery(\r\n        latitude: latitude,\r\n        longitude: longitude,\r\n        cityId: selectedCity.id,\r\n        queryFilter: section.queryFilter\r\n    );\r\n\r\n    print(' ${activities.length} activits trouves pour la section ${section.title}');\r\n\r\n    // Cache des distances\r\n    ref.read(activityDistancesProvider.notifier).cacheDistances(\r\n        activities,\r\n        LatLng(latitude, longitude)\r\n    );\r\n\r\n    return activities;\r\n  } catch (e, stack) {\r\n    print(' Erreur lors de la recherche d\\'activits: $e');\r\n    print(' Stack trace: $stack');\r\n    return [];\r\n  }\r\n});",
      "info": {
        "size": 2053,
        "last_modified": "2025-04-16T13:25:27.8051323",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\selected_city_state.dart",
      "content": "// lib/features/search/application/state/selected_city_state.dart\r\n\r\nimport 'package:riverpod/riverpod.dart';\r\nimport '../../../../core/domain/models/shared/city_model.dart';\r\n\r\nfinal selectedCityProvider = StateProvider<City?>((ref) => null);",
      "info": {
        "size": 243,
        "last_modified": "2025-04-16T13:25:27.8122688",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\selected_subcategory_state.dart",
      "content": "// lib/features/search/application/state/selected_subcategory_state.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/domain/models/shared/subcategory_model.dart';\r\n\r\nclass SelectedSubcategoryState extends StateNotifier<Subcategory?> {\r\n  SelectedSubcategoryState() : super(null);\r\n\r\n  void selectSubcategory(Subcategory? subcategory) {\r\n    state = subcategory;\r\n  }\r\n\r\n  void reset() {\r\n    state = null;\r\n  }\r\n}\r\n\r\nfinal selectedSubcategoryProvider = StateNotifierProvider<SelectedSubcategoryState, Subcategory?>((ref) {\r\n  return SelectedSubcategoryState();\r\n});",
      "info": {
        "size": 607,
        "last_modified": "2025-04-16T13:25:27.818269",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\application\\state\\subcategory_activities_state.dart",
      "content": "// lib/features/search/application/state/subcategory_activities_state.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport '../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../../../../core/domain/models/activity/search/searchable_activity.dart';\r\nimport '../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport '../../../../core/domain/models/config/subcategory_section_config.dart';\r\nimport '../state/selected_city_state.dart';\r\nimport '../../domain/providers/search_providers.dart';\r\nimport '../../application/state/selected_subcategory_state.dart';\r\n\r\n// Provider granulaire pour une section spcifique\r\nfinal subcategorySectionActivitiesProvider = FutureProvider.autoDispose.family<List<SearchableActivity>, SubcategorySectionConfig>(\r\n      (ref, section) async {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n    final selectedCity = ref.watch(selectedCityProvider);\r\n    if (selectedSubcategory == null || selectedCity == null) return [];\r\n\r\n    final useCase = ref.watch(searchProvidersModule.firstWhere(\r\n            (provider) => provider is Provider<GetActivitiesUseCase>\r\n    ) as Provider<GetActivitiesUseCase>);\r\n\r\n    try {\r\n      print(' Loading activities for section: ${section.title}');\r\n      final activities = await useCase.executeQuery(\r\n          latitude: selectedCity.lat,\r\n          longitude: selectedCity.lon,\r\n          cityId: selectedCity.id,\r\n          queryFilter: section.queryFilter,\r\n          subcategoryId: selectedSubcategory.id\r\n      );\r\n\r\n      // Cache des distances\r\n      ref.read(activityDistancesProvider.notifier).cacheDistances(\r\n          activities,\r\n          LatLng(selectedCity.lat, selectedCity.lon)\r\n      );\r\n\r\n      print(' Loaded ${activities.length} activities for section ${section.title}');\r\n      return activities;\r\n    } catch (e, stack) {\r\n      print(' Error loading activities for section ${section.title}: $e');\r\n      print(' Stack trace: $stack');\r\n      return [];\r\n    }\r\n  },\r\n);\r\n\r\n// Provider principal qui combine les rsultats des sections\r\nfinal subcategoryActivitiesProvider = FutureProvider.autoDispose<Map<String, List<SearchableActivity>>>((ref) async {\r\n  final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n  final selectedCity = ref.watch(selectedCityProvider);\r\n\r\n  if (selectedSubcategory == null || selectedCity == null) return {};\r\n\r\n  final sections = await ref.watch(subcategorySectionsConfigProvider(selectedSubcategory.id).future);\r\n  final results = <String, List<SearchableActivity>>{};\r\n\r\n  // Chargement parallle des sections\r\n  await Future.wait(\r\n    sections.map((section) async {\r\n      final activities = await ref.watch(subcategorySectionActivitiesProvider(section).future);\r\n      results[section.id] = activities;\r\n    }),\r\n  );\r\n\r\n  return results;\r\n});",
      "info": {
        "size": 3061,
        "last_modified": "2025-04-16T13:25:27.8249546",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\domain\\providers\\search_providers.dart",
      "content": "// lib/features/search/domain/providers/search_providers.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/adapters/supabase/search/activity_search_adapter.dart';\r\nimport '../../../../core/domain/ports/search/activity_search_port.dart';\r\nimport '../../../../core/domain/use_cases/search/get_activities_use_case.dart';\r\nimport '../../../../core/adapters/supabase/database_adapter.dart';\r\n\r\nfinal searchProvidersModule = <Override>[\r\n  // Providers existants\r\n  Provider<ActivitySearchPort>((ref) {\r\n    return ActivitySearchAdapter(SupabaseService.client);\r\n  }),\r\n\r\n  Provider<GetActivitiesUseCase>((ref) {\r\n    return GetActivitiesUseCase(ref.watch(\r\n      Provider<ActivitySearchPort>((ref) =>\r\n          ActivitySearchAdapter(SupabaseService.client)\r\n      ),\r\n    ));\r\n  }),\r\n];",
      "info": {
        "size": 823,
        "last_modified": "2025-04-16T13:25:27.8419848",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\pages\\subcategory_page.dart",
      "content": "// lib/features/search/presentation/pages/subcategory_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:collection/collection.dart';\r\nimport '../../../../../core/common/utils/activity_mapper.dart';\r\nimport '../../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\nimport '../../../../../core/domain/models/config/subcategory_section_config.dart';\r\nimport '../../../home/presentation/widgets/navigation/lyra_navigation.dart';\r\nimport '../../application/state/selected_subcategory_state.dart';\r\nimport '../../application/state/subcategory_activities_state.dart';\r\nimport '../../../shared_ui/presentation/widgets/shimmer/shimmer_section.dart';\r\nimport '../../../shared_ui/presentation/widgets/sections/activity_section.dart';\r\n\r\n\r\n\r\nclass SubcategoryPage extends ConsumerWidget {\r\n  const SubcategoryPage({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n    final sectionsAsync = ref.watch(subcategorySectionsConfigProvider(selectedSubcategory?.id));\r\n\r\n    return LyraNavigation(\r\n      child: sectionsAsync.when(\r\n        loading: () => _buildLoadingShimmer(),\r\n        error: (error, stack) => Center(\r\n          child: Text('Erreur de chargement des sections: $error'),\r\n        ),\r\n        data: (sections) => SingleChildScrollView(\r\n          child: Column(\r\n            children: sections\r\n                .sorted((a, b) => a.priority.compareTo(b.priority))\r\n                .map((section) => _buildSectionWithActivities(ref, section))\r\n                .toList(),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSectionWithActivities(WidgetRef ref, SubcategorySectionConfig section) {\r\n    return Consumer(\r\n      builder: (context, ref, child) {\r\n        final activitiesAsync = ref.watch(subcategorySectionActivitiesProvider(section));\r\n\r\n        return activitiesAsync.when(\r\n          loading: () => ShimmerSection(isFirstSection: false),\r\n          error: (error, stack) => const SizedBox.shrink(),\r\n          data: (activities) => ActivitySection(\r\n            title: section.title,\r\n            activities: ActivityMapper.mapToActivityCards(activities),\r\n            isFirstSection: false,\r\n          ),\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingShimmer() => Column(\r\n    children: List.generate(\r\n      3,\r\n          (index) => ShimmerSection(isFirstSection: index == 0),\r\n    ),\r\n  );\r\n}",
      "info": {
        "size": 2548,
        "last_modified": "2025-04-16T13:25:27.8585798",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\location\\current_location_button.dart",
      "content": "// lib/features/search/presentation/widgets/location/current_location_button.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\n\r\nclass CurrentLocationButton extends ConsumerWidget {\r\n  final VoidCallback? onLocationSelected;\r\n\r\n  const CurrentLocationButton({\r\n    Key? key,\r\n    this.onLocationSelected,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return InkWell(\r\n      onTap: onLocationSelected,\r\n      child: Container(\r\n        padding: const EdgeInsets.symmetric(\r\n          horizontal: 16,\r\n          vertical: 12,\r\n        ),\r\n        child: Row(\r\n          children: [\r\n            Icon(\r\n              Icons.my_location,\r\n              color: AppColors.neutral200,\r\n              size: 20,\r\n            ),\r\n            const SizedBox(width: 12),\r\n            Expanded(\r\n              child: Column(\r\n                crossAxisAlignment: CrossAxisAlignment.start,\r\n                mainAxisSize: MainAxisSize.min,\r\n                children: const [\r\n                  Text(\r\n                    'Utiliser ma position actuelle',\r\n                    style: TextStyle(\r\n                      fontSize: 15,\r\n                      fontWeight: FontWeight.w500,\r\n                    ),\r\n                  ),\r\n                  SizedBox(height: 2),\r\n                  Text(\r\n                    'Position GPS de mon appareil',\r\n                    style: TextStyle(\r\n                      fontSize: 13,\r\n                      color: Colors.grey,\r\n                    ),\r\n                  ),\r\n                ],\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1763,
        "last_modified": "2025-04-16T13:25:27.8711264",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\location\\location_search_bar.dart",
      "content": "// lib/features/search/presentation/widgets/location/location_search_bar.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../application/state/place_search_notifier.dart';\r\nimport '../../../application/state/place_search_state.dart';\r\nimport '../../../application/services/city_selection_service.dart';\r\nimport 'location_suggestions_list.dart';\r\n\r\nclass LocationSearchBar extends ConsumerStatefulWidget {\r\n  final String? initialQuery;\r\n  final Function(BuildContext)? onLocationButtonPressed;\r\n  final Function(String)? onSubmitted;\r\n\r\n  const LocationSearchBar({\r\n    Key? key,\r\n    this.initialQuery,\r\n    this.onLocationButtonPressed,\r\n    this.onSubmitted,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  ConsumerState<LocationSearchBar> createState() => _LocationSearchBarState();\r\n}\r\n\r\nclass _LocationSearchBarState extends ConsumerState<LocationSearchBar> {\r\n  late TextEditingController _textController;\r\n  final FocusNode _focusNode = FocusNode();\r\n  bool _showSuggestions = false;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _textController = TextEditingController(text: widget.initialQuery);\r\n\r\n    _focusNode.addListener(() {\r\n      if (_focusNode.hasFocus) {\r\n        setState(() {\r\n          _showSuggestions = true;\r\n        });\r\n\r\n        // Dclenche la recherche si un texte est dj prsent\r\n        if (_textController.text.isNotEmpty) {\r\n          ref.read(placeSearchNotifierProvider.notifier)\r\n              .searchLocation(_textController.text);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _textController.dispose();\r\n    _focusNode.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      mainAxisSize: MainAxisSize.min,\r\n      children: [\r\n        Container(\r\n          decoration: BoxDecoration(\r\n            color: Colors.white,\r\n            borderRadius: BorderRadius.circular(12),\r\n            boxShadow: [\r\n              BoxShadow(\r\n                color: Colors.black.withOpacity(0.1),\r\n                blurRadius: 8,\r\n                offset: const Offset(0, 2),\r\n              ),\r\n            ],\r\n          ),\r\n          child: TextField(\r\n            controller: _textController,\r\n            focusNode: _focusNode,\r\n            decoration: InputDecoration(\r\n              hintText: 'Rechercher une ville',\r\n              hintStyle: TextStyle(color: Colors.grey),\r\n              border: InputBorder.none,\r\n              contentPadding: const EdgeInsets.symmetric(\r\n                horizontal: 16,\r\n                vertical: 14,\r\n              ),\r\n              suffixIcon: Row(\r\n                mainAxisSize: MainAxisSize.min,\r\n                children: [\r\n                  // Bouton pour effacer le texte\r\n                  if (_textController.text.isNotEmpty)\r\n                    IconButton(\r\n                      icon: const Icon(Icons.clear, size: 20),\r\n                      onPressed: () {\r\n                        _textController.clear();\r\n                        ref.read(placeSearchNotifierProvider.notifier).reset();\r\n                      },\r\n                    ),\r\n                ],\r\n              ),\r\n            ),\r\n            onChanged: (value) {\r\n              ref.read(placeSearchNotifierProvider.notifier)\r\n                  .searchLocation(value);\r\n            },\r\n            onSubmitted: (value) {\r\n              if (widget.onSubmitted != null && value.isNotEmpty) {\r\n                // Nous passons l'ID de lieu au widget parent\r\n                // mais nous devons d'abord le trouver  partir de l'tat\r\n                final searchState = ref.read(placeSearchNotifierProvider);\r\n                searchState.whenOrNull(\r\n                  loaded: (suggestions) {\r\n                    if (suggestions.isNotEmpty) {\r\n                      widget.onSubmitted!(suggestions.first.placeId);\r\n                    }\r\n                  },\r\n                );\r\n              }\r\n            },\r\n          ),\r\n        ),\r\n\r\n        // Liste des suggestions\r\n        if (_showSuggestions)\r\n          LocationSuggestionsList(\r\n            onSuggestionSelected: (suggestion) async {\r\n              _textController.text = suggestion.primaryText;\r\n              setState(() {\r\n                _showSuggestions = false;\r\n              });\r\n              _focusNode.unfocus();\r\n\r\n              // Utiliser le service de slection de ville pour rcuprer les dtails complets\r\n              final cityService = ref.read(citySelectionServiceProvider);\r\n              final success = await cityService.selectCityByPlaceId(suggestion.placeId);\r\n\r\n              if (success && widget.onSubmitted != null) {\r\n                // Maintenant, le placeId et les coordonnes sont disponibles via le selectedCityProvider\r\n                widget.onSubmitted!(suggestion.placeId);\r\n              }\r\n            },\r\n            onOutsideTap: () {\r\n              setState(() {\r\n                _showSuggestions = false;\r\n              });\r\n              _focusNode.unfocus();\r\n            },\r\n          ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 5320,
        "last_modified": "2025-04-16T13:25:27.878189",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\location\\location_suggestions_list.dart",
      "content": "// lib/features/search/presentation/widgets/location/location_suggestions_list.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/domain/models/location/place_suggestion.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../application/state/place_search_notifier.dart';\r\nimport '../../../application/state/place_search_state.dart';\r\n\r\nclass LocationSuggestionsList extends ConsumerWidget {\r\n  final Function(PlaceSuggestion) onSuggestionSelected;\r\n  final VoidCallback onOutsideTap;\r\n\r\n  const LocationSuggestionsList({\r\n    Key? key,\r\n    required this.onSuggestionSelected,\r\n    required this.onOutsideTap,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final searchState = ref.watch(placeSearchNotifierProvider);\r\n\r\n    return Stack(\r\n      children: [\r\n        // Zone de tap pour fermer les suggestions\r\n        Positioned.fill(\r\n          child: GestureDetector(\r\n            onTap: onOutsideTap,\r\n            behavior: HitTestBehavior.opaque,\r\n            child: Container(color: Colors.transparent),\r\n          ),\r\n        ),\r\n\r\n        // Liste des suggestions\r\n        Container(\r\n          margin: const EdgeInsets.only(top: 4),\r\n          decoration: BoxDecoration(\r\n            color: Colors.white,\r\n            borderRadius: BorderRadius.circular(8),\r\n            boxShadow: [\r\n              BoxShadow(\r\n                color: Colors.black.withOpacity(0.1),\r\n                blurRadius: 8,\r\n                offset: const Offset(0, 2),\r\n              ),\r\n            ],\r\n          ),\r\n          child: ClipRRect(\r\n            borderRadius: BorderRadius.circular(8),\r\n            child: Material(\r\n              color: Colors.transparent,\r\n              child: searchState.when(\r\n                initial: () => const SizedBox.shrink(),\r\n                loading: () => const Center(\r\n                  child: Padding(\r\n                    padding: EdgeInsets.all(16.0),\r\n                    child: CircularProgressIndicator(),\r\n                  ),\r\n                ),\r\n                loaded: (suggestions) => ListView.separated(\r\n                  shrinkWrap: true,\r\n                  padding: EdgeInsets.zero,\r\n                  itemCount: suggestions.length,\r\n                  physics: const ClampingScrollPhysics(),\r\n                  separatorBuilder: (context, index) => const Divider(height: 1),\r\n                  itemBuilder: (context, index) {\r\n                    final suggestion = suggestions[index];\r\n\r\n                    return InkWell(\r\n                      onTap: () => onSuggestionSelected(suggestion),\r\n                      child: Padding(\r\n                        padding: const EdgeInsets.symmetric(\r\n                          horizontal: 16,\r\n                          vertical: 12,\r\n                        ),\r\n                        child: Row(\r\n                          children: [\r\n                            Icon(\r\n                              suggestion.isFromCache\r\n                                  ? Icons.history\r\n                                  : Icons.location_on_outlined,\r\n                              size: 20,\r\n                              color: AppColors.accent,\r\n                            ),\r\n                            const SizedBox(width: 12),\r\n                            Expanded(\r\n                              child: Column(\r\n                                crossAxisAlignment: CrossAxisAlignment.start,\r\n                                mainAxisSize: MainAxisSize.min,\r\n                                children: [\r\n                                  Text(\r\n                                    suggestion.primaryText,\r\n                                    style: const TextStyle(\r\n                                      fontWeight: FontWeight.w500,\r\n                                    ),\r\n                                    maxLines: 1,\r\n                                    overflow: TextOverflow.ellipsis,\r\n                                  ),\r\n                                  if (suggestion.secondaryText != null)\r\n                                    Text(\r\n                                      suggestion.secondaryText!,\r\n                                      style: TextStyle(\r\n                                        color: Colors.grey[600],\r\n                                        fontSize: 13,\r\n                                      ),\r\n                                      maxLines: 1,\r\n                                      overflow: TextOverflow.ellipsis,\r\n                                    ),\r\n                                ],\r\n                              ),\r\n                            ),\r\n                          ],\r\n                        ),\r\n                      ),\r\n                    );\r\n                  },\r\n                ),\r\n                noResults: () => Padding(\r\n                  padding: const EdgeInsets.all(16.0),\r\n                  child: Center(\r\n                    child: Column(\r\n                      mainAxisSize: MainAxisSize.min,\r\n                      children: [\r\n                        Icon(Icons.search_off, color: Colors.grey[400]),\r\n                        const SizedBox(height: 8),\r\n                        Text(\r\n                          'Aucun rsultat trouv',\r\n                          style: TextStyle(color: Colors.grey[600]),\r\n                        ),\r\n                      ],\r\n                    ),\r\n                  ),\r\n                ),\r\n                error: (message) => Padding(\r\n                  padding: const EdgeInsets.all(16.0),\r\n                  child: Center(\r\n                    child: Column(\r\n                      mainAxisSize: MainAxisSize.min,\r\n                      children: [\r\n                        Icon(Icons.error_outline, color: Colors.red[400]),\r\n                        const SizedBox(height: 8),\r\n                        Text(\r\n                          'Erreur: $message',\r\n                          style: TextStyle(color: Colors.red[600]),\r\n                        ),\r\n                      ],\r\n                    ),\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 6357,
        "last_modified": "2025-04-16T13:25:27.8842249",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\search\\presentation\\widgets\\subcategory_sections_view.dart",
      "content": "// lib/features/search/presentation/widgets/subcategory_sections_view.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../application/state/selected_subcategory_state.dart';\r\nimport '../../../../../core/domain/models/config/subcategory_section_config.dart';\r\nimport '../../../../../core/domain/ports/providers/config/remote_config_provider.dart';\r\n\r\nclass SubcategorySectionsView extends ConsumerWidget {\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    final selectedSubcategory = ref.watch(selectedSubcategoryProvider);\r\n\r\n    return ref.watch(subcategorySectionsConfigProvider(selectedSubcategory?.id)).when(\r\n      data: (sections) => ListView.builder(\r\n        physics: const NeverScrollableScrollPhysics(),\r\n        shrinkWrap: true,\r\n        itemCount: sections.length,\r\n        itemBuilder: (context, index) {\r\n          final section = sections[index];\r\n          return _buildSection(section);\r\n        },\r\n      ),\r\n      loading: () => _buildLoadingState(),\r\n      error: (error, stack) => _buildErrorState(error),\r\n    );\r\n  }\r\n\r\n  Widget _buildErrorState(Object error) {\r\n    return Center(\r\n      child: Padding(\r\n        padding: const EdgeInsets.all(16),\r\n        child: Text(\r\n          'Erreur de chargement: $error',\r\n          style: const TextStyle(color: Colors.red),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingState() {\r\n    return Column(\r\n      children: List.generate(\r\n        3, // Nombre de sections en chargement\r\n            (index) => Padding(\r\n          padding: EdgeInsets.only(\r\n            top: index == 0 ? 8 : 24,\r\n          ),\r\n          child: _buildShimmerSection(),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildSection(SubcategorySectionConfig section) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        Padding(\r\n          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n          child: Text(\r\n            section.title,\r\n            style: const TextStyle(\r\n              fontSize: 18,\r\n              fontWeight: FontWeight.bold,\r\n            ),\r\n          ),\r\n        ),\r\n        SizedBox(\r\n          height: 200,\r\n          child: ListView.builder(\r\n            scrollDirection: Axis.horizontal,\r\n            padding: const EdgeInsets.symmetric(horizontal: 8),\r\n            itemBuilder: (context, index) => Padding(\r\n              padding: const EdgeInsets.symmetric(horizontal: 8),\r\n              child: _buildLoadingCard(), // Remplac ShimmerLoading par une mthode helper\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n\r\n  Widget _buildLoadingCard() {\r\n    return Container(\r\n      width: 280,\r\n      decoration: BoxDecoration(\r\n        color: Colors.grey[300],\r\n        borderRadius: BorderRadius.circular(8),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildShimmerSection() {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        Padding(\r\n          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n          child: Container(\r\n            width: 150,\r\n            height: 24,\r\n            color: Colors.grey[300],\r\n          ),\r\n        ),\r\n        SizedBox(\r\n          height: 200,\r\n          child: ListView.builder(\r\n            scrollDirection: Axis.horizontal,\r\n            padding: const EdgeInsets.symmetric(horizontal: 8),\r\n            itemCount: 3,\r\n            itemBuilder: (context, index) => Padding(\r\n              padding: const EdgeInsets.symmetric(horizontal: 8),\r\n              child: _buildLoadingCard(),\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3713,
        "last_modified": "2025-04-16T13:25:27.8962643",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\pages\\activity_details_page.dart",
      "content": "// lib/features/shared_ui/presentation/pages/activity_details_page.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/theme/app_colors.dart';\r\nimport '../../../../core/domain/models/shared/activity_image_model.dart';\r\nimport '../../../search/application/state/activity_details_state.dart';\r\nimport '../widgets/buttons/back_button_widget.dart';\r\nimport '../widgets/carousels/activity_images_carousel.dart';\r\nimport '../widgets/activity_details/activity_details_content.dart';\r\nimport '../widgets/activity_details/sections/info_buttons_section.dart';\r\n\r\nclass ActivityDetailsPage extends ConsumerStatefulWidget {\r\n  final String activityId;\r\n  final String imageUrl;\r\n  final String title;\r\n  final VoidCallback onClose;\r\n\r\n  const ActivityDetailsPage({\r\n    super.key,\r\n    required this.activityId,\r\n    required this.imageUrl,\r\n    required this.title,\r\n    required this.onClose,\r\n  });\r\n\r\n  @override\r\n  ConsumerState<ActivityDetailsPage> createState() => _ActivityDetailsPageState();\r\n}\r\n\r\nclass _ActivityDetailsPageState extends ConsumerState<ActivityDetailsPage> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    print('ActivityDetailsPage initState for activity: ${widget.activityId}');\r\n    // Charger les dtails aprs le build initial\r\n    Future.microtask(() {\r\n      print('Loading details in microtask for: ${widget.activityId}');\r\n      ref.read(activityDetailsProvider.notifier).loadActivityDetails(\r\n          widget.activityId);\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final detailsState = ref.watch(activityDetailsProvider);\r\n\r\n    return Scaffold(\r\n      body: CustomScrollView(\r\n        slivers: [\r\n          SliverAppBar(\r\n            expandedHeight: 300,\r\n            pinned: true,\r\n            backgroundColor: AppColors.neutral900,\r\n            flexibleSpace: FlexibleSpaceBar(\r\n              background: detailsState.when(\r\n                initial: () => Image.network(widget.imageUrl, fit: BoxFit.cover),\r\n                loading: () => const Center(child: CircularProgressIndicator()),\r\n                error: (message) => Center(child: Text('Error: $message')),\r\n                loaded: (details) => ActivityImagesCarousel(\r\n                  images: details.images ?? [\r\n                    ActivityImage(\r\n                      id: '0',\r\n                      mobileUrl: widget.imageUrl,\r\n                      isMain: true,\r\n                    )\r\n                  ],\r\n                ),\r\n              ),\r\n            ),\r\n            leading: Padding(\r\n              padding: const EdgeInsets.only(left: 16),\r\n              child: BackButtonWidget(onPressed: widget.onClose),\r\n            ),\r\n          ),\r\n          SliverToBoxAdapter(\r\n            child: detailsState.when(\r\n              initial: () => const SizedBox.shrink(),\r\n              loading: () => const Center(child: CircularProgressIndicator()),\r\n              error: (message) => Center(child: Text('Error: $message')),\r\n              loaded: (details) => ActivityDetailsContent(details: details),\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n      bottomNavigationBar: detailsState.when(\r\n        initial: () => null,\r\n        loading: () => null,\r\n        error: (_) => null,\r\n        loaded: (details) => Container(\r\n          decoration: BoxDecoration(\r\n            color: AppColors.neutral900,\r\n            boxShadow: [\r\n              BoxShadow(\r\n                color: Colors.black.withAlpha(25),\r\n                offset: const Offset(0, -2),\r\n                blurRadius: 4,\r\n              ),\r\n            ],\r\n          ),\r\n          child: SafeArea(\r\n            child: InfoButtonsSection(details: details),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3806,
        "last_modified": "2025-04-16T13:25:27.918456",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\activity_details_content.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/activity_details_content.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport 'sections/title_section.dart';\r\nimport 'sections/location_section.dart';\r\nimport 'sections/info_icons_section.dart';\r\nimport 'sections/schedule_section.dart';\r\nimport 'sections/description_section.dart';\r\n\r\n\r\nclass ActivityDetailsContent extends StatelessWidget {\r\n  final ActivityDetails details;\r\n  final double? distance;\r\n\r\n\r\n  const ActivityDetailsContent({\r\n    super.key,\r\n    required this.details,\r\n    this.distance,\r\n  });\r\n// Dans activity_details_content.dart :\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Padding(\r\n      padding: const EdgeInsets.fromLTRB(20, 32, 20, 20),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          // Barre de poigne optionnelle pour indiquer que c'est scrollable\r\n          Center(\r\n            child: Container(\r\n              width: 40,\r\n              height: 4,\r\n              margin: const EdgeInsets.only(bottom: 24),\r\n              decoration: BoxDecoration(\r\n                color: Colors.grey.withOpacity(0.3),\r\n                borderRadius: BorderRadius.circular(2),\r\n              ),\r\n            ),\r\n          ),\r\n          TitleSection(details: details),\r\n          const SizedBox(height: 12),\r\n          LocationSection(details: details, distance: distance),\r\n          const SizedBox(height: 12),\r\n          InfoIconsSection(details: details),\r\n          const SizedBox(height: 16),\r\n          ScheduleSection(details: details),\r\n          const SizedBox(height: 16),\r\n          DescriptionSection(details: details),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1817,
        "last_modified": "2025-04-16T13:25:27.9320423",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\description_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/description_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass DescriptionSection extends StatefulWidget {\r\n  final ActivityDetails details;\r\n\r\n  const DescriptionSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  State<DescriptionSection> createState() => _DescriptionSectionState();\r\n}\r\n\r\nclass _DescriptionSectionState extends State<DescriptionSection> {\r\n  bool _isExpanded = false;\r\n  static const int _maxLines = 5;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (widget.details.description == null || widget.details.description!.isEmpty) {\r\n      return const SizedBox.shrink();\r\n    }\r\n\r\n    return Container(\r\n      padding: const EdgeInsets.symmetric(horizontal: 20),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Text(\r\n            widget.details.description!,\r\n            style: context.bodyMedium,\r\n            maxLines: _isExpanded ? null : _maxLines,\r\n            overflow: _isExpanded ? null : TextOverflow.ellipsis,\r\n          ),\r\n          if (_shouldShowReadMore())\r\n            Padding(\r\n              padding: const EdgeInsets.only(top: 8),\r\n              child: GestureDetector(\r\n                onTap: () => setState(() => _isExpanded = !_isExpanded),\r\n                child: Text(\r\n                  _isExpanded ? 'Voir moins' : 'Lire la suite',\r\n                  style: context.bodyMedium.copyWith(\r\n                    color: AppColors.accent,\r\n                    fontWeight: FontWeight.w600,\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  bool _shouldShowReadMore() {\r\n    final TextPainter textPainter = TextPainter(\r\n      text: TextSpan(\r\n        text: widget.details.description,\r\n        style: context.bodyMedium,\r\n      ),\r\n      maxLines: _maxLines,\r\n      textDirection: TextDirection.ltr,\r\n    )..layout(maxWidth: MediaQuery.of(context).size.width - 40);\r\n\r\n    return textPainter.didExceedMaxLines;\r\n  }\r\n}",
      "info": {
        "size": 2309,
        "last_modified": "2025-04-16T13:25:27.938045",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\info_buttons_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/info_buttons_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../../core/theme/app_interactions.dart';\r\nimport '../../../../../../core/domain/services/shared/external_launcher_service.dart';\r\n\r\nclass InfoButtonsSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const InfoButtonsSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return ClipRect(  // Empche l'onde de dborder du footer\r\n        child: Container(\r\n        padding: const EdgeInsets.symmetric(horizontal: 20),\r\n    child: Row(\r\n    mainAxisAlignment: MainAxisAlignment.spaceAround,\r\n    children: [\r\n          _buildInfoButton(\r\n            context,\r\n            icon: details.googlePlaceId != null && details.googlePlaceId!.isNotEmpty\r\n                ? LucideIcons.map  // Icne pour voir la fiche Google Maps\r\n                : LucideIcons.navigation2,  // Icne pour l'itinraire\r\n            label: details.googlePlaceId != null && details.googlePlaceId!.isNotEmpty\r\n                ? 'Fiche Maps'\r\n                : 'Itinraire',\r\n            onTap: () => _onNavigationTap(context),\r\n          ),\r\n          _buildInfoButton(\r\n            context,\r\n            icon: LucideIcons.phone,\r\n            label: 'Appeler',\r\n            onTap: details.contactPhone != null\r\n                ? () => _onPhoneTap(context, details.contactPhone!)\r\n                : null,\r\n          ),\r\n          _buildInfoButton(\r\n            context,\r\n            icon: LucideIcons.globe,\r\n            label: 'Site web',\r\n            onTap: details.contactWebsite != null\r\n                ? () => _onWebsiteTap(context, details.contactWebsite!)\r\n                : null,\r\n          ),\r\n        ],\r\n      ),\r\n        ),\r\n    );\r\n  }\r\n\r\n  Widget _buildInfoButton(\r\n      BuildContext context, {\r\n        required IconData icon,\r\n        required String label,\r\n        VoidCallback? onTap,\r\n      }) {\r\n    final content = Padding(\r\n      padding: const EdgeInsets.all(8.0),\r\n      child: Column(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: [\r\n          Icon(\r\n            icon,\r\n            color: AppColors.neutral200,\r\n            size: 24,\r\n          ),\r\n          const SizedBox(height: 4),\r\n          Text(\r\n            label,\r\n            style: context.bodyMedium.copyWith(\r\n              color: AppColors.neutral200,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n\r\n    return AppInteractions.addCircularRipple(\r\n      onTap: onTap,\r\n      rippleColor: AppColors.neutral200,\r\n      child: Opacity(\r\n        opacity: onTap != null ? 1.0 : 0.5,\r\n        child: content,\r\n      ),\r\n    );\r\n  }\r\n\r\n  void _showError(BuildContext context, String message) {\r\n    ScaffoldMessenger.of(context).showSnackBar(\r\n      SnackBar(\r\n        content: Text(message),\r\n        backgroundColor: AppColors.warning,\r\n        behavior: SnackBarBehavior.floating,\r\n        margin: const EdgeInsets.all(8),\r\n        duration: const Duration(seconds: 3),\r\n      ),\r\n    );\r\n  }\r\n\r\n  void _onNavigationTap(BuildContext context) async {\r\n    try {\r\n      await ExternalLauncherService.openMap(\r\n        details.latitude,\r\n        details.longitude,\r\n        details.name,\r\n        context,\r\n        placeId: details.googlePlaceId,\r\n      );\r\n    } catch (e) {\r\n      _showError(context, e.toString());\r\n    }\r\n  }\r\n\r\n  Future<void> _onPhoneTap(BuildContext context, String phone) async {\r\n    try {\r\n      await ExternalLauncherService.openPhone(phone);\r\n    } catch (e) {\r\n      _showError(context, e.toString());\r\n    }\r\n  }\r\n\r\n\r\n  Future<void> _onWebsiteTap(BuildContext context, String website) async {\r\n    try {\r\n      await ExternalLauncherService.openCustomTab(context, website);\r\n    } catch (e) {\r\n      _showError(context, e.toString());\r\n    }\r\n  }\r\n}",
      "info": {
        "size": 4168,
        "last_modified": "2025-04-16T13:25:27.9440823",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\info_icons_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/info_icons_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\n\r\nclass InfoIconsSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const InfoIconsSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    print('Details: kidFriendly=${details.kidFriendly}, wheelchairAccessible=${details.wheelchairAccessible}, bookingRequired=${details.bookingRequired}');\r\n\r\n\r\n    final List<Widget> icons = [];\r\n\r\n    if (details.kidFriendly ?? false) {\r\n      icons.add(\r\n        buildInfoIcon(\r\n          context,\r\n          icon: LucideIcons.baby,\r\n          tooltip: 'Adapt aux enfants',\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (details.wheelchairAccessible != null) {\r\n      icons.add(\r\n        buildInfoIcon(\r\n          context,\r\n          icon: LucideIcons.accessibility,\r\n          tooltip: 'Accessible PMR',\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (details.bookingRequired ?? false) {\r\n      icons.add(\r\n        buildInfoIcon(\r\n          context,\r\n          icon: LucideIcons.calendar,\r\n          tooltip: 'Rservation requise',\r\n        ),\r\n      );\r\n    }\r\n\r\n    if (icons.isEmpty) return const SizedBox.shrink();\r\n\r\n    return Padding(\r\n      padding: const EdgeInsets.symmetric(vertical: 8),\r\n      child: Row(\r\n        children: icons.map((icon) => Padding(\r\n          padding: const EdgeInsets.only(right: 16),\r\n          child: icon,\r\n        )).toList(),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget buildInfoIcon(\r\n      BuildContext context, {\r\n        required IconData icon,\r\n        required String tooltip,\r\n      }) {\r\n    return GestureDetector(\r\n      onTap: () {\r\n        final overlay = OverlayEntry(\r\n          builder: (context) => Positioned(\r\n            top: MediaQuery.of(context).size.height / 2,\r\n            left: MediaQuery.of(context).size.width / 4,\r\n            child: Material(\r\n              color: Colors.transparent,\r\n              child: Container(\r\n                padding: const EdgeInsets.symmetric(\r\n                  horizontal: 16,\r\n                  vertical: 8,\r\n                ),\r\n                decoration: BoxDecoration(\r\n                  color: AppColors.neutral900,\r\n                  borderRadius: BorderRadius.circular(8),\r\n                  boxShadow: [\r\n                    BoxShadow(\r\n                      color: Colors.black.withAlpha(25),\r\n                      blurRadius: 4,\r\n                    ),\r\n                  ],\r\n                ),\r\n                child: Text(\r\n                  tooltip,\r\n                  style: TextStyle(\r\n                    color: AppColors.neutral200,\r\n                    fontSize: 14,\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        );\r\n\r\n        Overlay.of(context).insert(overlay);\r\n        Future.delayed(const Duration(seconds: 4), () {\r\n          overlay.remove();\r\n        });\r\n      },\r\n      child: Column(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: [\r\n          Icon(\r\n            icon,\r\n            size: 24,\r\n            color: AppColors.neutral200,\r\n          ),\r\n          const SizedBox(height: 4),\r\n          Text(\r\n            tooltip,\r\n            style: const TextStyle(\r\n              color: AppColors.neutral200,\r\n              fontSize: 10,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3633,
        "last_modified": "2025-04-16T13:25:27.9511214",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\location_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/location_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass LocationSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n  final double? distance;\r\n\r\n  const LocationSection({\r\n    super.key,\r\n    required this.details,\r\n    this.distance,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      padding: const EdgeInsets.symmetric(horizontal: 20),\r\n      child: Row(\r\n        children: [\r\n          const Icon(\r\n            LucideIcons.mapPin,\r\n            size: 20,\r\n            color: AppColors.neutral200,\r\n          ),\r\n          const SizedBox(width: 8),\r\n          Expanded(\r\n            child: Column(\r\n              crossAxisAlignment: CrossAxisAlignment.start,\r\n              children: [\r\n                if (details.address != null)\r\n                  Text(\r\n                    _buildFullAddress(),\r\n                    style: const TextStyle(\r\n                      fontSize: 16,\r\n                      color: AppColors.neutral200,\r\n                    ),\r\n                  ),\r\n                if (distance != null)\r\n                  Text(\r\n                    distance! / 1000 <= 100\r\n                        ? '~${((distance! / 1000 / 10).round() * 10)} km'\r\n                        : '~${((distance! / 1000 / 50).round() * 50)} km',\r\n                    style: context.bodyMedium,\r\n                  ),\r\n              ],\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  String _buildFullAddress() {\r\n\r\n    final List<String> addressParts = [];\r\n\r\n    if (details.address != null && details.address!.isNotEmpty) {\r\n      addressParts.add(details.address!);\r\n    }\r\n    if (details.postalCode != null && details.postalCode!.isNotEmpty) {\r\n      addressParts.add(details.postalCode!);\r\n    }\r\n    if (details.city != null && details.city!.isNotEmpty) {\r\n      addressParts.add(details.city!);\r\n    }\r\n\r\n    return addressParts.join(', ');\r\n  }\r\n}",
      "info": {
        "size": 2270,
        "last_modified": "2025-04-16T13:25:27.9571559",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\schedule_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/schedule_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass OpeningHours {\r\n  final String open;\r\n  final String close;\r\n\r\n  OpeningHours({required this.open, required this.close});\r\n\r\n  factory OpeningHours.fromJson(Map<String, dynamic> json) {\r\n    return OpeningHours(\r\n      open: json['open'] as String,\r\n      close: json['close'] as String,\r\n    );\r\n  }\r\n}\r\n\r\nfinal Map<String, String> _daysInFrench = {\r\n  'monday': 'Lundi',\r\n  'tuesday': 'Mardi',\r\n  'wednesday': 'Mercredi',\r\n  'thursday': 'Jeudi',\r\n  'friday': 'Vendredi',\r\n  'saturday': 'Samedi',\r\n  'sunday': 'Dimanche',\r\n};\r\n\r\nclass ScheduleSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const ScheduleSection({super.key, required this.details});\r\n\r\n  List<Widget> _buildOpeningHours(Map<String, dynamic> hours) {\r\n    final List<Widget> scheduleWidgets = [];\r\n\r\n    _daysInFrench.forEach((dayEn, dayFr) {\r\n      if (hours.containsKey(dayEn)) {\r\n        final List<dynamic> dayHours = hours[dayEn] as List<dynamic>;\r\n        if (dayHours.isNotEmpty) {\r\n          // Grer le cas o il y a plusieurs horaires dans une journe\r\n          for (var hour in dayHours) {\r\n            final openingHours = OpeningHours.fromJson(hour as Map<String, dynamic>);\r\n            scheduleWidgets.add(\r\n              Padding(\r\n                padding: const EdgeInsets.only(bottom: 8),\r\n                child: Row(\r\n                  children: [\r\n                    SizedBox(\r\n                      width: 100,\r\n                      child: Text(\r\n                        dayFr,\r\n                        style: const TextStyle(\r\n                          color: AppColors.neutral200,\r\n                          fontWeight: FontWeight.w500,\r\n                        ),\r\n                      ),\r\n                    ),\r\n                    Text(\r\n                      '${openingHours.open} - ${openingHours.close}',\r\n                      style: const TextStyle(\r\n                        color: AppColors.neutral200,\r\n                      ),\r\n                    ),\r\n                  ],\r\n                ),\r\n              ),\r\n            );\r\n          }\r\n        } else {\r\n          scheduleWidgets.add(\r\n            Padding(\r\n              padding: const EdgeInsets.only(bottom: 8),\r\n              child: Row(\r\n                children: [\r\n                  SizedBox( // On utilise un SizedBox pour garder l'alignement\r\n                    width: 100,\r\n                    child: Text( // On affiche le jour en franais\r\n                      dayFr,\r\n                      style: const TextStyle(\r\n                        color: AppColors.neutral200,\r\n                        fontWeight: FontWeight.w500,\r\n                      ),\r\n                    ),\r\n                  ),\r\n                  const Text(\r\n                    'Ferm',\r\n                    style: TextStyle(\r\n                      color: AppColors.neutral200,\r\n                      fontStyle: FontStyle.italic,\r\n                    ),\r\n                  ),\r\n                ],\r\n              ),\r\n            ),\r\n          );\r\n        }\r\n      }\r\n    });\r\n\r\n    return scheduleWidgets;\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (details.currentOpeningHours == null || details.currentOpeningHours!.isEmpty) {\r\n      return const SizedBox.shrink();\r\n    }\r\n\r\n    return Container(\r\n      padding: const EdgeInsets.symmetric(horizontal: 20),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Row(\r\n            children: [\r\n              const Icon(\r\n                LucideIcons.clock,\r\n                color: AppColors.neutral200,\r\n                size: 20,\r\n              ),\r\n              const SizedBox(width: 8),\r\n              Text(\r\n                'Horaires d\\'ouverture',\r\n                style: context.bodyMedium,\r\n              ),\r\n            ],\r\n          ),\r\n          const SizedBox(height: 12),\r\n          ..._buildOpeningHours(details.currentOpeningHours!),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4381,
        "last_modified": "2025-04-16T13:25:27.9631871",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\activity_details\\sections\\title_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/activity_details/sections/title_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../../core/domain/models/shared/activity_details_model.dart';\r\nimport '../../../../../../core/theme/app_typography.dart';\r\n\r\nclass TitleSection extends StatelessWidget {\r\n  final ActivityDetails details;\r\n\r\n  const TitleSection({\r\n    super.key,\r\n    required this.details,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      width: double.infinity,\r\n      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),\r\n      child: Text(\r\n        details.name,\r\n        style: context.bodyMedium,\r\n        maxLines: 2,\r\n        overflow: TextOverflow.ellipsis,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 788,
        "last_modified": "2025-04-16T13:25:27.9702095",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\atoms.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/atoms.dart\r\n\r\n/// Fichier d'exportation regroupant tous les composants atomiques\r\n///\r\n/// Les atomes sont les composants les plus simples et fondamentaux du design system,\r\n/// qui ne peuvent pas tre dcomposs davantage.\r\n\r\nexport '../../../../core/theme/atoms/app_button.dart';\r\nexport '../../../../core/theme/atoms/app_text.dart';\r\nexport '../../../../core/theme/atoms/app_input.dart';\r\nexport '../../../../core/theme/atoms/app_card.dart';",
      "info": {
        "size": 494,
        "last_modified": "2025-04-16T13:25:27.9873034",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\buttons\\back_button_widget.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/buttons/back_button_widget.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:lucide_icons/lucide_icons.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\n\r\nclass BackButtonWidget extends StatelessWidget {\r\n  final VoidCallback onPressed;\r\n  final double size;\r\n  final EdgeInsets padding;\r\n\r\n  const BackButtonWidget({\r\n    super.key,\r\n    required this.onPressed,\r\n    this.size = 40,\r\n    this.padding = const EdgeInsets.all(8),\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      decoration: BoxDecoration(\r\n        color: Colors.white,\r\n        shape: BoxShape.circle,\r\n        boxShadow: [\r\n          BoxShadow(\r\n            color: Colors.black.withOpacity(0.1),\r\n            blurRadius: 8,\r\n            offset: const Offset(0, 2),\r\n          ),\r\n        ],\r\n      ),\r\n      child: Material(\r\n        color: Colors.transparent,\r\n        child: InkWell(\r\n          onTap: onPressed,\r\n          customBorder: const CircleBorder(),\r\n          child: Padding(\r\n            padding: padding,\r\n            child: Icon(\r\n              LucideIcons.arrowLeft,\r\n              size: size * 0.5,\r\n              color: AppColors.neutral900,\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1369,
        "last_modified": "2025-04-16T13:25:27.993341",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_card.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_card.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../../core/domain/ports/providers/search/activity_distances_provider.dart';\r\nimport 'activity_card_info.dart';\r\nimport 'activity_card_image.dart';\r\n\r\nclass ActivityCard extends StatelessWidget {\r\n  final String imageUrl;\r\n  final String title;\r\n  final String city;\r\n  final String category;\r\n  final IconData categoryIcon;\r\n  final String activityId;\r\n  final double activityLat;\r\n  final double activityLng;\r\n  final double userLat;\r\n  final double userLng;\r\n  final double? distance;\r\n  final DateTime? date;\r\n  final bool isFavorite;\r\n  final VoidCallback? onTap;\r\n  final VoidCallback? onFavoritePress;\r\n\r\n  const ActivityCard({\r\n    super.key,\r\n    required this.imageUrl,\r\n    required this.title,\r\n    required this.city,\r\n    required this.category,\r\n    required this.categoryIcon,\r\n    required this.activityId,\r\n    required this.activityLat,\r\n    required this.activityLng,\r\n    required this.userLat,\r\n    required this.userLng,\r\n    this.distance,\r\n    this.date,\r\n    this.isFavorite = false,\r\n    this.onTap,\r\n    this.onFavoritePress,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: onTap,\r\n      child: Container(\r\n        width: AppDimensions.space32 * 5,\r\n        height: AppDimensions.space32 * 7,\r\n        clipBehavior: Clip.hardEdge,\r\n        decoration: BoxDecoration(\r\n          borderRadius: BorderRadius.circular(AppDimensions.radiusM),\r\n        ),\r\n        child: Column(\r\n          children: [\r\n            // Image section (55% de la hauteur)\r\n            SizedBox(\r\n              height: AppDimensions.space32 * 3,\r\n              child: Stack(\r\n                fit: StackFit.expand,\r\n                children: [\r\n                  ActivityCardImage(imageUrl: imageUrl,title: title,),\r\n                  Positioned(\r\n                    top: AppDimensions.space3,\r\n                    right: AppDimensions.space3,\r\n                    child: _ActivityFavoriteButton(\r\n                      isFavorite: isFavorite,\r\n                      onPressed: onFavoritePress,\r\n                    ),\r\n                  ),\r\n                ],\r\n              ),\r\n            ),\r\n            // Info section (45% de la hauteur)\r\n            SizedBox(\r\n              height: AppDimensions.space32  * 0.25,\r\n              child: Consumer(\r\n                builder: (context, ref, child) {\r\n                  final calculatedDistance = ref.watch(activityDistancesProvider)[activityId];\r\n                  return ActivityCardInfo(\r\n                    category: category,\r\n                    categoryIcon: categoryIcon,\r\n                    city: city,\r\n                    calculatedDistance: calculatedDistance ?? distance,\r\n                    date: date,\r\n                  );\r\n                },\r\n              ),\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _ActivityFavoriteButton extends StatelessWidget {\r\n  final bool isFavorite;\r\n  final VoidCallback? onPressed;\r\n\r\n  const _ActivityFavoriteButton({\r\n    required this.isFavorite,\r\n    this.onPressed,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return IconButton(\r\n      icon: Icon(\r\n        isFavorite ? Icons.favorite : Icons.favorite_border,\r\n        color: isFavorite ? AppColors.accent : Colors.white,\r\n      ),\r\n      onPressed: onPressed,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3650,
        "last_modified": "2025-04-16T13:25:28.0043744",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_card_image.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_card_image.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:cached_network_image/cached_network_image.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_filters.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\n\r\n\r\nclass ActivityCardImage extends StatelessWidget {\r\n  final String imageUrl;\r\n  final String title;\r\n\r\n  const ActivityCardImage({\r\n    super.key,\r\n    required this.imageUrl,\r\n    required this.title,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (imageUrl.isEmpty) {\r\n      return const _EmptyImagePlaceholder();\r\n    }\r\n\r\n    return ColorFiltered(\r\n      colorFilter: AppFilters.desaturate,\r\n      child: Stack(\r\n        fit: StackFit.expand,\r\n        children: [\r\n          CachedNetworkImage(\r\n            imageUrl: imageUrl,\r\n            fit: BoxFit.cover,\r\n            memCacheWidth: 600,\r\n            memCacheHeight: 480,\r\n            maxWidthDiskCache: 1200,\r\n            errorWidget: (context, error, stackTrace) {\r\n              print('DEBUG: Erreur de chargement image: $error');\r\n              return const _ErrorImagePlaceholder();\r\n            },\r\n            placeholder: (context, url) => const _LoadingImagePlaceholder(),\r\n            fadeInDuration: const Duration(milliseconds: 300),\r\n            fadeOutDuration: const Duration(milliseconds: 300),\r\n          ),\r\n          Container(\r\n            color: AppFilters.beigeOverlay,\r\n          ),\r\n          Positioned(\r\n            left: 12,\r\n            bottom: 8,\r\n            right: 12,\r\n            child: Text(\r\n              title,\r\n              style: context.titleMedium.copyWith(\r\n                shadows: [\r\n                  const Shadow(\r\n                    offset: Offset(0, 0),\r\n                    blurRadius: 75.0,\r\n                    color: Color.fromRGBO(0, 0, 0, 0.85),\r\n                  ),\r\n                ],\r\n              ),\r\n              maxLines: 2,\r\n              overflow: TextOverflow.ellipsis,\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _EmptyImagePlaceholder extends StatelessWidget {\r\n  const _EmptyImagePlaceholder();\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: Colors.grey,\r\n      child: const Center(\r\n        child: Icon(Icons.image_not_supported),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _ErrorImagePlaceholder extends StatelessWidget {\r\n  const _ErrorImagePlaceholder();\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: Colors.grey,\r\n      child: const Center(\r\n        child: Icon(Icons.error),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _LoadingImagePlaceholder extends StatelessWidget {\r\n  const _LoadingImagePlaceholder();\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: AppColors.neutral900.withOpacity(0.1),\r\n      child: const Center(\r\n        child: CircularProgressIndicator(\r\n          strokeWidth: 2,\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 3094,
        "last_modified": "2025-04-16T13:25:28.0114036",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_card_info.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_card_info.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\n\r\nclass ActivityCardInfo extends StatelessWidget {\r\n  final String category;\r\n  final IconData categoryIcon;\r\n  final String city;\r\n  final double? calculatedDistance;\r\n  final DateTime? date;\r\n\r\n  const ActivityCardInfo({\r\n    super.key,\r\n    required this.category,\r\n    required this.categoryIcon,\r\n    required this.city,\r\n    this.calculatedDistance,\r\n    this.date,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      color: AppColors.neutral800,\r\n      padding: const EdgeInsets.all(12),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\r\n        children: [\r\n          Row(\r\n            children: [\r\n              Icon(\r\n                  categoryIcon,\r\n                  size: 16,\r\n                  color: Colors.white\r\n              ),\r\n              const SizedBox(width: 4),\r\n              Text(\r\n                category,\r\n                style: context.titleSmall,\r\n              ),\r\n              const Spacer(),\r\n              if (date != null)\r\n                Text(\r\n                  _formatDate(date!),\r\n                  style: context.titleSmall,\r\n                )\r\n              else if (calculatedDistance != null) ...[\r\n                Text(\r\n                  calculatedDistance! / 1000 <= 100\r\n                      ? '~${((calculatedDistance! / 1000 / 10).round() * 10)} km'\r\n                      : '~${((calculatedDistance! / 1000 / 50).round() * 50)} km',\r\n                  style: context.bodySmall,\r\n                ),\r\n              ],\r\n            ],\r\n          ),\r\n          const SizedBox(height: 4),\r\n          Row(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              const SizedBox(width: 8),\r\n              Text(\r\n                _formatCity(city),\r\n                style: context.bodyMedium,\r\n                maxLines: 1,\r\n              ),\r\n            ],\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n\r\n  String _formatCity(String city) {\r\n    return city.length > 15 ? '${city.substring(0, 15)}...' : city;\r\n  }\r\n\r\n  String _formatDate(DateTime date) {\r\n    return '${date.day}/${date.month}/${date.year}';\r\n  }\r\n}",
      "info": {
        "size": 2467,
        "last_modified": "2025-04-16T13:25:28.0174039",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\cards\\activity_container.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/cards/activity_container.dart\r\n\r\nimport 'package:animations/animations.dart';\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport 'activity_card.dart';\r\nimport '../../pages/activity_details_page.dart';\r\nimport '../../../../home/presentation/widgets/navigation/lyra_navigation.dart';\r\n\r\nclass ActivityContainer extends ConsumerWidget {\r\n  static const _transitionDuration = Duration(milliseconds: 350);\r\n  static const _closedElevation = 0.0;\r\n\r\n  final ActivityCard card;\r\n  final bool headerVisible;\r\n  final VoidCallback? onHeaderVisibilityChanged;\r\n\r\n  const ActivityContainer({\r\n    super.key,\r\n    required this.card,\r\n    this.headerVisible = true,\r\n    this.onHeaderVisibilityChanged,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context, WidgetRef ref) {\r\n    return OpenContainer(\r\n      transitionDuration: _transitionDuration,\r\n      transitionType: ContainerTransitionType.fadeThrough,\r\n      openBuilder: (context, closeContainer) {\r\n        // On enlve la modification directe du state ici\r\n        return WillPopScope(\r\n          onWillPop: () async {\r\n            ref.read(headerVisibilityProvider.notifier).state = true;\r\n            closeContainer();\r\n            return false;\r\n          },\r\n          child: ActivityDetailsPage(\r\n            activityId: card.activityId,\r\n            imageUrl: card.imageUrl,\r\n            title: card.title,\r\n            onClose: () {\r\n              closeContainer();\r\n              // Dlai avant de rafficher le header\r\n              Future.delayed(\r\n                const Duration(milliseconds: 200), // Dmarre aprs la moiti de l'animation de la card\r\n                    () => ref.read(headerVisibilityProvider.notifier).state = true,\r\n              );\r\n            },\r\n          ),\r\n        );\r\n      },\r\n      closedBuilder: (context, openContainer) {\r\n        return MouseRegion(\r\n          cursor: SystemMouseCursors.click,\r\n          child: GestureDetector(\r\n            behavior: HitTestBehavior.opaque,\r\n            onTap: () {\r\n              // On dplace la modification du state dans le onTap\r\n              ref.read(headerVisibilityProvider.notifier).state = false;\r\n              onHeaderVisibilityChanged?.call();\r\n              openContainer();\r\n            },\r\n            child: card,\r\n          ),\r\n        );\r\n      },\r\n      closedShape: RoundedRectangleBorder(\r\n        borderRadius: BorderRadius.circular(AppDimensions.radiusM),\r\n      ),\r\n      openShape: const RoundedRectangleBorder(),\r\n      closedElevation: _closedElevation,\r\n      closedColor: Colors.transparent,\r\n      middleColor: Colors.transparent,\r\n      openColor: Colors.transparent,\r\n      useRootNavigator: true,\r\n      clipBehavior: Clip.antiAlias,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2887,
        "last_modified": "2025-04-16T13:25:28.0240554",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\carousels\\activity_images_carousel.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/carousels/activity_images_carousel.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'package:cached_network_image/cached_network_image.dart';\r\nimport '../../../../../core/domain/models/shared/activity_image_model.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\n\r\nclass ActivityImagesCarousel extends StatefulWidget {\r\n  final List<ActivityImage> images;\r\n  final double height;\r\n\r\n  const ActivityImagesCarousel({\r\n    super.key,\r\n    required this.images,\r\n    this.height = 300,\r\n  });\r\n\r\n  @override\r\n  State<ActivityImagesCarousel> createState() => _ActivityImagesCarouselState();\r\n}\r\n\r\nclass _ActivityImagesCarouselState extends State<ActivityImagesCarousel> {\r\n  late final PageController _pageController;\r\n  int _currentPage = 0;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _pageController = PageController();\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _pageController.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Stack(\r\n      children: [\r\n        // PageView avec les images\r\n        PageView.builder(\r\n          controller: _pageController,\r\n          onPageChanged: (index) {\r\n            setState(() => _currentPage = index);\r\n          },\r\n          itemCount: widget.images.length,\r\n          itemBuilder: (context, index) {\r\n            return CachedNetworkImage(\r\n              imageUrl: widget.images[index].mobileUrl ?? '',\r\n              fit: BoxFit.cover,\r\n              errorWidget: (context, url, error) => Container(\r\n                color: AppColors.neutral900.withAlpha(25),\r\n                child: const Icon(Icons.error),\r\n              ),\r\n            );\r\n          },\r\n        ),\r\n\r\n        // Indicateurs de page sur l'image\r\n        if (widget.images.length > 1)\r\n          Positioned(\r\n            bottom: 16,\r\n            left: 0,\r\n            right: 0,\r\n            child: Row(\r\n              mainAxisAlignment: MainAxisAlignment.center,\r\n              children: List.generate(\r\n                widget.images.length,\r\n                    (index) => Padding(\r\n                  padding: const EdgeInsets.symmetric(horizontal: 4),\r\n                  child: CircleAvatar(\r\n                    radius: 4,\r\n                    backgroundColor: _currentPage == index\r\n                        ? Colors.white\r\n                        : Colors.white.withAlpha(128),\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n      ],\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2570,
        "last_modified": "2025-04-16T13:25:28.0365699",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\index.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/index.dart\r\n\r\n/// Fichier d'exportation pour faciliter l'import des widgets partags\r\n///\r\n/// Permet d'importer tous les widgets ou une catgorie spcifique en une seule ligne:\r\n/// ```dart\r\n/// import 'package:lyra/shared/widgets/index.dart'; // Tout importer\r\n/// // ou\r\n/// import 'package:lyra/shared/widgets/atoms.dart'; // Importer seulement les atomes\r\n/// ```\r\n\r\n// Exportation par catgorie\r\nexport 'atoms.dart';\r\nexport 'molecules.dart';\r\nexport 'organisms.dart';\r\nexport 'templates.dart';\r\n\r\n// Exportation directe des widgets individuels pour simplifier l'accs\r\n// Atomes\r\nexport '../../../../core/theme/atoms/app_button.dart';\r\nexport '../../../../core/theme/atoms/app_text.dart';\r\nexport '../../../../core/theme/atoms/app_input.dart';\r\nexport '../../../../core/theme/atoms/app_card.dart';\r\n\r\n// Molcules\r\nexport 'molecules/filter_chip.dart';\r\n\r\n// Organismes\r\n\r\n\r\n// Templates\r\n",
      "info": {
        "size": 948,
        "last_modified": "2025-04-16T13:25:28.0480863",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\molecules\\filter_chip.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/molecules/filter_chip.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../../../../../core/theme/app_typography.dart';\r\nimport '../../../../../core/theme/app_interactions.dart';\r\n\r\n/// Types de puces disponibles\r\nenum FilterChipType {\r\n  standard,       // Puce standard\r\n  choice,         // Puce de choix (une seule slectionnable  la fois)\r\n  action,         // Puce d'action (dclenche une action)\r\n  category,       // Puce de catgorie (avec couleur personnalise)\r\n}\r\n\r\n/// Puce de filtre rutilisable pour l'application\r\n///\r\n/// Composant molculaire permettant  l'utilisateur de filtrer des contenus\r\n/// ou de faire des slections.\r\nclass AppFilterChip extends StatelessWidget {\r\n  /// Libell de la puce\r\n  final String label;\r\n\r\n  /// Si la puce est slectionne\r\n  final bool selected;\r\n\r\n  /// Type de puce\r\n  final FilterChipType type;\r\n\r\n  /// Fonction appele quand la puce est presse\r\n  final VoidCallback? onPressed;\r\n\r\n  /// Icne  afficher  gauche (optionnel)\r\n  final IconData? icon;\r\n\r\n  /// Couleur personnalise de la puce\r\n  final Color? color;\r\n\r\n  /// Si la puce est dsactive\r\n  final bool disabled;\r\n\r\n  /// Si la puce doit avoir une ombre\r\n  final bool hasShadow;\r\n\r\n  /// Marges externes\r\n  final EdgeInsets? margin;\r\n\r\n  const AppFilterChip({\r\n    Key? key,\r\n    required this.label,\r\n    this.selected = false,\r\n    this.type = FilterChipType.standard,\r\n    this.onPressed,\r\n    this.icon,\r\n    this.color,\r\n    this.disabled = false,\r\n    this.hasShadow = false,\r\n    this.margin,\r\n  }) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final colorScheme = Theme.of(context).colorScheme;\r\n\r\n    // Dterminer la couleur principale de la puce\r\n    Color chipColor = color ?? colorScheme.primary;\r\n    if (type == FilterChipType.category && color == null) {\r\n      // Si c'est une puce de catgorie mais sans couleur spcifie, utiliser la primaire\r\n      chipColor = colorScheme.primary;\r\n    }\r\n\r\n    // Configurer les couleurs selon l'tat\r\n    Color backgroundColor;\r\n    Color textColor;\r\n    Color borderColor;\r\n\r\n    if (disabled) {\r\n      // Puce dsactive\r\n      backgroundColor = isDark ? AppColors.neutral800 : AppColors.neutral200;\r\n      textColor = isDark ? AppColors.neutral600 : AppColors.neutral500;\r\n      borderColor = Colors.transparent;\r\n    } else if (selected) {\r\n      // Puce slectionne\r\n      backgroundColor = chipColor;\r\n      textColor = Colors.white;\r\n      borderColor = Colors.transparent;\r\n    } else {\r\n      // Puce non slectionne\r\n      backgroundColor = isDark ? AppColors.neutral800.withOpacity(0.5) : AppColors.neutral100;\r\n      textColor = isDark ? AppColors.neutral200 : AppColors.neutral800;\r\n      borderColor = isDark ? AppColors.neutral700 : AppColors.neutral300;\r\n    }\r\n\r\n    // Style du texte\r\n    final TextStyle textStyle = context.labelMedium.copyWith(\r\n      color: textColor,\r\n      fontWeight: selected ? FontWeight.bold : FontWeight.normal,\r\n    );\r\n\r\n    // Icne  afficher\r\n    Widget? iconWidget;\r\n    if (icon != null) {\r\n      iconWidget = Icon(\r\n        icon,\r\n        size: 16,\r\n        color: textColor,\r\n      );\r\n    }\r\n\r\n    // Effets de dcoration\r\n    BoxDecoration decoration = BoxDecoration(\r\n      color: backgroundColor,\r\n      borderRadius: AppDimensions.borderRadiusXl,\r\n      border: !selected\r\n          ? Border.all(color: borderColor, width: 1)\r\n          : null,\r\n    );\r\n\r\n    // Ajouter une ombre si demand\r\n    if (hasShadow && !disabled) {\r\n      decoration = decoration.copyWith(\r\n        boxShadow: [\r\n          BoxShadow(\r\n            color: isDark\r\n                ? Colors.black.withOpacity(0.2)\r\n                : Colors.black.withOpacity(0.1),\r\n            blurRadius: 4,\r\n            offset: Offset(0, 1),\r\n            spreadRadius: 0,\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    // Construire le contenu de la puce\r\n    Widget chipContent = Container(\r\n      padding: EdgeInsets.symmetric(\r\n        horizontal: AppDimensions.space3,\r\n        vertical: AppDimensions.space2,\r\n      ),\r\n      decoration: decoration,\r\n      child: Row(\r\n        mainAxisSize: MainAxisSize.min,\r\n        children: [\r\n          if (iconWidget != null) ...[\r\n            iconWidget,\r\n            SizedBox(width: AppDimensions.space2),\r\n          ],\r\n          Text(\r\n            label,\r\n            style: textStyle,\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n\r\n    // Appliquer les marges si spcifies\r\n    if (margin != null) {\r\n      chipContent = Padding(\r\n        padding: margin!,\r\n        child: chipContent,\r\n      );\r\n    }\r\n\r\n    // Rendre la puce interactive si elle n'est pas dsactive\r\n    if (!disabled && onPressed != null) {\r\n      return GestureDetector(\r\n        onTap: onPressed,\r\n        child: chipContent,\r\n      );\r\n    }\r\n\r\n    return chipContent;\r\n  }\r\n\r\n  /// Cre une liste horizontale scrollable de puces de filtre\r\n  static Widget horizontalList({\r\n    required List<AppFilterChip> chips,\r\n    EdgeInsets? padding,\r\n    double spacing = 8.0,\r\n    double height = 40.0,\r\n    bool showScrollbar = true,\r\n  }) {\r\n    return Builder(\r\n      builder: (context) {\r\n        final ScrollController scrollController = ScrollController();\r\n\r\n        return Container(\r\n          height: height,\r\n          child: showScrollbar\r\n              ? Scrollbar(\r\n            controller: scrollController,\r\n            thumbVisibility: true,\r\n            thickness: 4,\r\n            radius: Radius.circular(8),\r\n            child: _buildChipList(chips, scrollController, padding, spacing),\r\n          )\r\n              : _buildChipList(chips, scrollController, padding, spacing),\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  static Widget _buildChipList(\r\n      List<AppFilterChip> chips,\r\n      ScrollController scrollController,\r\n      EdgeInsets? padding,\r\n      double spacing,\r\n      ) {\r\n    return ListView.separated(\r\n      controller: scrollController,\r\n      scrollDirection: Axis.horizontal,\r\n      padding: padding ?? EdgeInsets.symmetric(\r\n        horizontal: AppDimensions.space4,\r\n        vertical: AppDimensions.space2,\r\n      ),\r\n      itemCount: chips.length,\r\n      separatorBuilder: (context, index) => SizedBox(width: spacing),\r\n      itemBuilder: (context, index) => chips[index],\r\n    );\r\n  }\r\n\r\n  /// Cre une grille responsive de puces de filtre\r\n  static Widget grid({\r\n    required List<AppFilterChip> chips,\r\n    EdgeInsets? padding,\r\n    double spacing = 8.0,\r\n    double runSpacing = 8.0,\r\n  }) {\r\n    return Padding(\r\n      padding: padding ?? EdgeInsets.all(AppDimensions.space4),\r\n      child: Wrap(\r\n        spacing: spacing,\r\n        runSpacing: runSpacing,\r\n        children: chips,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 6980,
        "last_modified": "2025-04-16T13:25:28.0541605",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\molecules.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/molecules.dart\r\n\r\n/// Fichier d'exportation regroupant tous les composants molculaires\r\n///\r\n/// Les molcules sont des groupes d'atomes fonctionnant ensemble comme une unit.\r\n/// Par exemple, une search_bar combine un input avec un bouton.\r\n\r\nexport 'molecules/filter_chip.dart';\r\n",
      "info": {
        "size": 334,
        "last_modified": "2025-04-16T13:25:28.065882",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\organisms.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/organisme.dart\r\n\r\n/// Fichier d'exportation regroupant tous les composants organismiques\r\n///\r\n/// Les organismes sont des assemblages complexes de molcules et atomes qui forment\r\n/// une section distincte de l'interface, comme une liste d'activits ou un header.\r\n\r\n",
      "info": {
        "size": 317,
        "last_modified": "2025-04-16T13:25:28.0729055",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\sections\\activity_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/sections/activity_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport '../cards/activity_card.dart';\r\nimport '../cards/activity_container.dart';\r\n\r\nclass ActivitySection extends StatelessWidget {\r\n  final String title;\r\n  final List<ActivityCard> activities;\r\n  final bool isFirstSection;\r\n  final VoidCallback? onActivityOpen;  // Nouveau callback pour grer le header\r\n\r\n  const ActivitySection({\r\n    super.key,\r\n    required this.title,\r\n    required this.activities,\r\n    this.isFirstSection = false,\r\n    this.onActivityOpen,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Padding(\r\n      padding: EdgeInsets.only(\r\n        top: isFirstSection ? 8 : 24,\r\n      ).add(const EdgeInsets.only(top: 20)),\r\n      child: Column(\r\n        crossAxisAlignment: CrossAxisAlignment.start,\r\n        children: [\r\n          Padding(\r\n            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\r\n            child: Text(\r\n              title,\r\n              style: Theme.of(context).textTheme.titleMedium,\r\n            ),\r\n          ),\r\n          SizedBox(\r\n            height: AppDimensions.space32 * 5,\r\n            child: ListView.builder(\r\n              scrollDirection: Axis.horizontal,\r\n              padding: const EdgeInsets.symmetric(horizontal: 16),\r\n              itemCount: activities.length,\r\n              itemExtent: AppDimensions.space32 * 7 + 16,\r\n              cacheExtent: AppDimensions.space32 * 7 * 2,\r\n              clipBehavior: Clip.none,\r\n              keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,\r\n              itemBuilder: (context, index) {\r\n                final activity = activities[index];\r\n                return Padding(\r\n                  key: ValueKey('activity-${activity.activityId}'),\r\n                  padding: const EdgeInsets.only(right: 16),\r\n                  child: ActivityContainer(\r\n                    card: activity,\r\n                    headerVisible: isFirstSection && index == 0,\r\n                    onHeaderVisibilityChanged: onActivityOpen,\r\n                  ),\r\n                );\r\n              },\r\n            ),\r\n          ),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2300,
        "last_modified": "2025-04-16T13:25:28.0789147",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\shimmer\\shimmer_loading.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/shimmer/shimmer_loading.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\n\r\n/// Composant moderne pour crer un effet de chargement brillant (shimmer)\r\n///\r\n/// Ce widget peut tre utilis de deux faons :\r\n/// 1. Comme conteneur avec un effet de chargement (ShimmerLoading.container)\r\n/// 2. Pour envelopper n'importe quel widget avec un effet shimmer (ShimmerLoading.child)\r\nclass ShimmerLoading extends StatefulWidget {\r\n  final Widget child;\r\n  final bool isLoading;\r\n  final Duration duration;\r\n\r\n  const ShimmerLoading._({\r\n    Key? key,\r\n    required this.child,\r\n    required this.isLoading,\r\n    this.duration = const Duration(milliseconds: 1500),\r\n  }) : super(key: key);\r\n\r\n  /// Cre un conteneur avec effet shimmer aux dimensions spcifies\r\n  static Widget container({\r\n    Key? key,\r\n    required double width,\r\n    required double height,\r\n    BorderRadius? borderRadius,\r\n    EdgeInsets? margin,\r\n    bool isLoading = true,\r\n    Duration duration = const Duration(milliseconds: 1500),\r\n  }) {\r\n    return ShimmerLoading._(\r\n      key: key,\r\n      isLoading: isLoading,\r\n      duration: duration,\r\n      child: Container(\r\n        width: width,\r\n        height: height,\r\n        margin: margin,\r\n        decoration: BoxDecoration(\r\n          borderRadius: borderRadius ?? BorderRadius.circular(AppDimensions.radiusM),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n\r\n  /// Enveloppe n'importe quel widget avec un effet shimmer\r\n  static Widget wrap({\r\n    Key? key,\r\n    required Widget child,\r\n    bool isLoading = true,\r\n    Duration duration = const Duration(milliseconds: 1500),\r\n  }) {\r\n    return ShimmerLoading._(\r\n      key: key,\r\n      isLoading: isLoading,\r\n      duration: duration,\r\n      child: child,\r\n    );\r\n  }\r\n\r\n  @override\r\n  State<ShimmerLoading> createState() => _ShimmerLoadingState();\r\n}\r\n\r\nclass _ShimmerLoadingState extends State<ShimmerLoading> with SingleTickerProviderStateMixin {\r\n  late AnimationController _controller;\r\n  late Animation<double> _animation;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _controller = AnimationController(\r\n      vsync: this,\r\n      duration: widget.duration,\r\n    );\r\n\r\n    _animation = Tween<double>(begin: -2, end: 2).animate(\r\n      CurvedAnimation(\r\n        parent: _controller,\r\n        curve: Curves.easeInOutSine,\r\n      ),\r\n    );\r\n\r\n    if (widget.isLoading) {\r\n      _controller.repeat();\r\n    }\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(ShimmerLoading oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n\r\n    if (widget.isLoading != oldWidget.isLoading) {\r\n      if (widget.isLoading) {\r\n        _controller.repeat();\r\n      } else {\r\n        _controller.stop();\r\n      }\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    _controller.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (!widget.isLoading) {\r\n      return widget.child;\r\n    }\r\n\r\n    final isDark = Theme.of(context).brightness == Brightness.dark;\r\n    final baseColor = isDark ? AppColors.shimmerBaseDark : AppColors.shimmerBaseLight;\r\n    final highlightColor = isDark ? AppColors.shimmerHighlightDark : AppColors.shimmerHighlightLight;\r\n\r\n    return AnimatedBuilder(\r\n      animation: _animation,\r\n      builder: (context, child) {\r\n        return ShaderMask(\r\n          blendMode: BlendMode.srcATop,\r\n          shaderCallback: (bounds) {\r\n            return LinearGradient(\r\n              colors: [\r\n                baseColor,\r\n                highlightColor,\r\n                baseColor,\r\n              ],\r\n              stops: const [0.0, 0.5, 1.0],\r\n              begin: Alignment(_animation.value, -0.5),\r\n              end: Alignment(_animation.value + 1, 0.5),\r\n              tileMode: TileMode.clamp,\r\n            ).createShader(bounds);\r\n          },\r\n          child: child,\r\n        );\r\n      },\r\n      child: Container(\r\n        color: baseColor,\r\n        child: widget.child,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4103,
        "last_modified": "2025-04-16T13:25:28.0911455",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\shimmer\\shimmer_section.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/shimmer/shimmer_section.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport 'shimmer_skeletons.dart';\r\n\r\n/// Widget pour afficher une section de shimmer (titre + liste horizontale de cartes)\r\n///\r\n/// Cette classe maintient la compatibilit avec l'ancienne implmentation\r\n/// mais utilise la nouvelle API ShimmerSkeletons sous le capot.\r\nclass ShimmerSection extends StatelessWidget {\r\n  /// Si cette section est la premire de la page (affecte le padding suprieur)\r\n  final bool isFirstSection;\r\n\r\n  /// Nombre d'lments shimmer  afficher dans la liste\r\n  final int itemCount;\r\n\r\n  const ShimmerSection({\r\n    super.key,\r\n    required this.isFirstSection,\r\n    this.itemCount = 3,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    // Utilise directement ShimmerSkeletons.section qui reproduit l'ancien comportement\r\n    return ShimmerSkeletons.section(\r\n      isFirstSection: isFirstSection,\r\n      itemCount: itemCount,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 1016,
        "last_modified": "2025-04-16T13:25:28.0981463",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\shimmer\\shimmer_skeletons.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/shimmer/shimmer_skeletons.dart\r\n\r\nimport 'package:flutter/material.dart';\r\nimport '../../../../../core/theme/app_colors.dart';\r\nimport '../../../../../core/theme/app_dimensions.dart';\r\nimport 'shimmer_loading.dart';\r\n\r\n/// Widgets prfabriqus pour les cas d'usage courants du shimmer\r\nclass ShimmerSkeletons {\r\n  /// Squelette pour une carte d'activit\r\n  static Widget activityCard({\r\n    double? width,\r\n    double? height,\r\n    EdgeInsets? margin,\r\n  }) {\r\n    return ClipRRect(\r\n      borderRadius: BorderRadius.circular(AppDimensions.radiusM),\r\n      child: ShimmerLoading.container(\r\n        width: width ?? AppDimensions.space32 * 5, // Largeur standard comme dans l'ancien code\r\n        height: height ?? AppDimensions.space32 * 7, // Hauteur standard comme dans l'ancien code\r\n        margin: margin,\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Squelette pour un texte court (titre ou label)\r\n  static Widget text({\r\n    double width = 200,\r\n    double height = 24,\r\n    EdgeInsets? margin,\r\n  }) {\r\n    return ClipRRect(\r\n      borderRadius: BorderRadius.circular(AppDimensions.radiusS),\r\n      child: ShimmerLoading.container(\r\n        width: width,\r\n        height: height,\r\n        margin: margin ?? EdgeInsets.symmetric(vertical: AppDimensions.spacingXs),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Squelette pour un paragraphe (plusieurs lignes de texte)\r\n  static Widget paragraph({\r\n    required int lines,\r\n    double width = double.infinity,\r\n    double lineHeight = 16,\r\n    double lastLineWidth = 0.66,\r\n    EdgeInsets? margin,\r\n  }) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: List.generate(\r\n        lines,\r\n            (index) => Padding(\r\n          padding: EdgeInsets.only(bottom: AppDimensions.spacingXs),\r\n          child: ClipRRect(\r\n            borderRadius: BorderRadius.circular(AppDimensions.radiusXs),\r\n            child: ShimmerLoading.container(\r\n              width: index == lines - 1 && lines > 1\r\n                  ? (width is double ? width * lastLineWidth : width)\r\n                  : width,\r\n              height: lineHeight,\r\n              margin: index == lines - 1 ? null : EdgeInsets.only(bottom: AppDimensions.spacingXs),\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /// Squelette pour une liste d'activits (compatible avec l'ancien ShimmerSection)\r\n  static Widget activityList({\r\n    required int itemCount,\r\n    double itemWidth = 280,\r\n    double itemHeight = 380,\r\n    double spacing = 16,\r\n    EdgeInsets? padding,\r\n    bool showTitle = true,\r\n    double titleWidth = 200,\r\n    double titleHeight = 24,\r\n  }) {\r\n    return Column(\r\n      crossAxisAlignment: CrossAxisAlignment.start,\r\n      children: [\r\n        // Titre en shimmer (si demand)\r\n        if (showTitle)\r\n          Padding(\r\n            padding: EdgeInsets.symmetric(\r\n              horizontal: AppDimensions.spacingM,\r\n              vertical: AppDimensions.spacingS,\r\n            ),\r\n            child: text(\r\n              width: titleWidth,\r\n              height: titleHeight,\r\n            ),\r\n          ),\r\n\r\n        // Liste de cartes en shimmer\r\n        SizedBox(\r\n          height: itemHeight,\r\n          child: ListView.builder(\r\n            scrollDirection: Axis.horizontal,\r\n            padding: padding ?? EdgeInsets.all(AppDimensions.spacingM),\r\n            itemCount: itemCount,\r\n            itemBuilder: (context, index) => Padding(\r\n              padding: EdgeInsets.only(\r\n                right: index < itemCount - 1 ? spacing : 0,\r\n              ),\r\n              child: activityCard(\r\n                width: itemWidth,\r\n                height: itemHeight,\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n\r\n  /// Squelette pour une section complte (remplacement direct de ShimmerSection)\r\n  static Widget section({\r\n    bool isFirstSection = false,\r\n    int itemCount = 3,\r\n  }) {\r\n    return Padding(\r\n      padding: EdgeInsets.only(\r\n        top: isFirstSection ? AppDimensions.spacingS : AppDimensions.spacingL,\r\n      ),\r\n      child: activityList(\r\n        itemCount: itemCount,\r\n        itemWidth: AppDimensions.space32 * 5,\r\n        itemHeight: AppDimensions.space32 * 7,\r\n        padding: EdgeInsets.symmetric(horizontal: AppDimensions.spacingM),\r\n        showTitle: true,\r\n        titleWidth: AppDimensions.space32 * 3.5,\r\n        titleHeight: AppDimensions.iconSizeM,\r\n      ),\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 4483,
        "last_modified": "2025-04-16T13:25:28.104661",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\shared_ui\\presentation\\widgets\\templates.dart",
      "content": "// lib/features/shared_ui/presentation/widgets/templates.dart\r\n\r\n/// Fichier d'exportation regroupant tous les templates\r\n///\r\n/// Les templates sont des mises en page de niveau suprieur qui regroupent\r\n/// des organismes dans un contexte de page. Ils dfinissent la structure\r\n/// gnrale des crans sans contenu spcifique.\r\n\r\n\r\n",
      "info": {
        "size": 339,
        "last_modified": "2025-04-16T13:25:28.116263",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\pages\\trip_test_page.dart",
      "content": "import 'package:flutter/material.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:travel_in_perigord_app/core/domain/models/trip_designer/trip/trip_model.dart';\r\nimport 'package:travel_in_perigord_app/features/trip/presentation/state/trip_test_provider.dart';\r\nimport '../../../../core/common/enums/trip_enums.dart';\r\n\r\nclass TripTestPage extends ConsumerStatefulWidget {\r\n  const TripTestPage({super.key});\r\n\r\n  @override\r\n  ConsumerState<TripTestPage> createState() => _TripTestPageState();\r\n}\r\n\r\nclass _TripTestPageState extends ConsumerState<TripTestPage> {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final state = ref.watch(tripTestProvider);\r\n\r\n    return Scaffold(\r\n      appBar: AppBar(title: const Text('Trip Tests')),\r\n      body: SafeArea(\r\n        child: SingleChildScrollView(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.stretch,\r\n            children: [\r\n              Wrap(\r\n                spacing: 8,\r\n                runSpacing: 8,\r\n                children: [\r\n                  ElevatedButton(\r\n                    onPressed: () =>\r\n                        ref.read(tripTestProvider.notifier).testGoogleMaps(),\r\n                    child: const Text('Add Cities'),\r\n                  ),\r\n                  ElevatedButton(\r\n                    onPressed: () =>\r\n                        ref.read(tripTestProvider.notifier).testTripCreation(),\r\n                    child: const Text('Create Trip'),\r\n                  ),\r\n                  ElevatedButton(\r\n                    onPressed: () =>\r\n                        ref.read(tripTestProvider.notifier).testActivityFiltering(),\r\n                    child: const Text('Activity Filtering'),\r\n                  ),\r\n              ElevatedButton(\r\n                onPressed: () =>\r\n                    ref.read(tripTestProvider.notifier).testActivityScoring(),\r\n                child: const Text('Scoring'),\r\n              ),\r\n              ElevatedButton(\r\n                onPressed: () => ref.read(tripTestProvider.notifier).testRouteOptimization(),\r\n                child: const Text('Route Optimization'),\r\n              ),\r\n                  ElevatedButton(\r\n                    onPressed: () => ref.read(tripTestProvider.notifier).testDailyTrip(),\r\n                    child: const Text('Daily Trip'),\r\n                  ),\r\n                ],\r\n              ),\r\n\r\n              const SizedBox(height: 20),\r\n              const SizedBox(height: 20),\r\n              if (state.isLoading)\r\n                const Center(child: CircularProgressIndicator())\r\n              else if (state.error.isNotEmpty)\r\n                Padding(\r\n                  padding: const EdgeInsets.all(16.0),\r\n                  child: Text(\r\n                    state.error,\r\n                    style: const TextStyle(color: Colors.red),\r\n                    textAlign: TextAlign.center,\r\n                  ),\r\n                )\r\n              else if (state.testResults != null)\r\n                  _buildTestResults(state.testResults!),\r\n            ],\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  Widget _buildTestResults(Map<String, dynamic> results) {\r\n    if (results['testType'] == 'trip') {\r\n      final trip = results['tripDetails'] as Trip;\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Voyage cr avec succs:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('ID: ${trip.id}'),\r\n              Text('Titre: ${trip.title}'),\r\n              Text('Ville de dpart: ${trip.departureCity?.cityName ?? \"Non dfinie\"}'),\r\n              Text('Dates: ${trip.startDate.toString()} - ${trip.endDate.toString()}'),\r\n              Text('Style: ${trip.travelStyle?.value ?? \"Non dfini\"}'),\r\n              const SizedBox(height: 8),\r\n              Text('Groupe:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              Text('Type: ${trip.travelGroup.type}'),\r\n              Text('Adultes: ${trip.travelGroup.members.adults}'),\r\n              if (trip.travelGroup.members.children.isNotEmpty)\r\n                Text('Enfants: ${trip.travelGroup.members.children.join(\", \")} ans'),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'hours') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test des horaires:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              if (results['result'] is String)\r\n                Text(results['result'])\r\n              else ...[\r\n                Text('Nombre de jours: ${results['result']['numberOfDays']}'),\r\n                const SizedBox(height: 8),\r\n                Text('Exemple d\\'horaires:',\r\n                    style: const TextStyle(fontWeight: FontWeight.bold)),\r\n                ...results['result']['sampleDays'].entries.take(3).map(\r\n                      (entry) => Text(\r\n                    '${entry.key}: ${entry.value['opens_at']} - ${entry.value['closes_at']}',\r\n                  ),\r\n                ),\r\n              ],\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'route_optimization') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test d\\'optimisation des routes:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Distance totale: ${results['route']['readable_distance']}'),\r\n              Text('Dure totale: ${results['route']['readable_duration']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Ordre des waypoints: ${results['route']['waypoint_order']}'),\r\n              Text('Temps de trajet direct: ${results['travelTime']} minutes'),\r\n              const SizedBox(height: 8),\r\n              Text('valuation du dtour:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              Text('Status: ${results['detourEvaluation']['status']}'),\r\n              Text('Faisable: ${results['detourEvaluation']['feasible']}'),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'daily_trip') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test Daily Trip:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('ID: ${results['dailyTrip']['id']}'),\r\n              Text('Type: ${results['dailyTrip']['type']}'),\r\n              Text('Distance: ${results['dailyTrip']['distance']}'),\r\n              Text('Dure: ${results['dailyTrip']['duration']}'),\r\n              Text('Nombre de SuperWow: ${results['dailyTrip']['superwows']}'),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'superwow_management') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test SuperWow Management:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Ville de dpart: ${results['departureCity']}'),\r\n              Text('Total SuperWow: ${results['totalSuperWows']}'),\r\n              const SizedBox(height: 8),\r\n              Text('SuperWow le plus proche:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              Text('Nom: ${results['closestSuperWow']['name']}'),\r\n              Text('Score: ${results['closestSuperWow']['score']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Top 3 paires:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              ...results['top3Pairs'].map<Widget>((pair) =>\r\n                  Padding(\r\n                    padding: const EdgeInsets.only(left: 8, top: 4),\r\n                    child: Column(\r\n                      crossAxisAlignment: CrossAxisAlignment.start,\r\n                      children: [\r\n                        Text('${pair['sw1']}  ${pair['sw2']}'),\r\n                        Text('Distance: ${pair['distance']} - Dure: ${pair['duration']}'),\r\n                        const SizedBox(height: 4),\r\n                      ],\r\n                    ),\r\n                  ),\r\n              ).toList(),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'half_day_generation') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test Half-Day Generation:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Ville de dpart: ${results['departureCity']}'),\r\n              Text('Total trajets gnrs: ${results['totalTrips']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Trajets:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              ...results['trips'].map<Widget>((trip) =>\r\n                  Padding(\r\n                    padding: const EdgeInsets.only(left: 8, top: 4),\r\n                    child: Column(\r\n                      crossAxisAlignment: CrossAxisAlignment.start,\r\n                      children: [\r\n                        Text(trip['superWow']),\r\n                        Text('Distance: ${trip['distance']} - Dure: ${trip['duration']}'),\r\n                        const SizedBox(height: 4),\r\n                      ],\r\n                    ),\r\n                  ),\r\n              ).toList(),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    else if (results['testType'] == 'full_day_generation') {\r\n      return Card(\r\n        child: Padding(\r\n          padding: const EdgeInsets.all(16),\r\n          child: Column(\r\n            crossAxisAlignment: CrossAxisAlignment.start,\r\n            children: [\r\n              Text('Test Full-Day Generation:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              const SizedBox(height: 8),\r\n              Text('Ville de dpart: ${results['departureCity']}'),\r\n              Text('Total trajets gnrs: ${results['totalTrips']}'),\r\n              const SizedBox(height: 8),\r\n              Text('Trajets:',\r\n                  style: const TextStyle(fontWeight: FontWeight.bold)),\r\n              ...results['trips'].map<Widget>((trip) =>\r\n                  Padding(\r\n                    padding: const EdgeInsets.only(left: 8, top: 4),\r\n                    child: Column(\r\n                      crossAxisAlignment: CrossAxisAlignment.start,\r\n                      children: [\r\n                        Text('${trip['sw1']}  ${trip['sw2']}'),\r\n                        Text('Distance: ${trip['distance']} - Dure: ${trip['duration']}'),\r\n                        const SizedBox(height: 4),\r\n                      ],\r\n                    ),\r\n                  ),\r\n              ).toList(),\r\n            ],\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n    return Container(\r\n      padding: const EdgeInsets.all(16),\r\n      decoration: BoxDecoration(\r\n        border: Border.all(color: Colors.grey),\r\n        borderRadius: BorderRadius.circular(8),\r\n      ),\r\n      child: Text(results.toString()),\r\n    );\r\n  }\r\n}\r\n",
      "info": {
        "size": 12296,
        "last_modified": "2025-04-16T13:25:28.1398969",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\state\\trip_test_notifier.dart",
      "content": "// features/trip/presentation/state/trip_test_notifier.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\r\nimport 'package:uuid/uuid.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport '../../../../core/domain/use_cases/create_trip_use_case.dart';\r\nimport '../../../../core/domain/use_cases/process_activities_use_case.dart';\r\nimport '../../../../core/domain/ports/geocoding_port.dart';\r\nimport '../../../../core/domain/ports/activity_hours_port.dart';\r\nimport '../../../../core/domain/ports/activity_scoring_port.dart';\r\nimport '../../../../core/domain/ports/empty_trips/route_optimization.port.dart';\r\nimport '../../../../core/domain/ports/trip_activities_port.dart';\r\nimport '../../../../core/domain/ports/empty_trips/superwow_management.port.dart';\r\nimport '../../../../core/domain/ports/daily_trip_generation_port.dart';\r\nimport '../../../../core/domain/models/trip_designer/trip/trip_model.dart';\r\nimport '../../../../core/domain/models/scored_activity.dart';\r\nimport '../../../../core/domain/models/trip_designer/trip/daily_trip.dart';\r\nimport '../../../../core/common/enums/trip_enums.dart';\r\nimport 'trip_test_state.dart';\r\nimport '../../../../core/common/exceptions/exceptions.dart';\r\n\r\nclass TripTestNotifier extends StateNotifier<TripTestState> {\r\n  final CreateTripUseCase _createTripUseCase;\r\n  final ProcessActivitiesUseCase _processActivitiesUseCase;\r\n  final GeocodingPort _geocodingPort;\r\n  final ActivityHoursPort _activityHoursPort;\r\n  final ActivityScoringPort _activityScoringPort;\r\n  final RouteOptimizationPort _routeOptimizationPort;\r\n  final TripActivitiesPort _tripActivitiesPort;\r\n  final SupabaseClient _supabase;\r\n  final SuperWowManagementPort _superwowManagementPort;\r\n\r\n  TripTestNotifier(\r\n      this._createTripUseCase,\r\n      this._processActivitiesUseCase,\r\n      this._geocodingPort,\r\n      this._activityHoursPort,\r\n      this._activityScoringPort,\r\n      this._routeOptimizationPort,\r\n      this._tripActivitiesPort,\r\n      this._supabase,\r\n      this._superwowManagementPort,\r\n      ) : super(TripTestState());\r\n\r\n  Future<void> testGoogleMaps() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print('Dbut du test Google Maps');\r\n      final singleResult = await _geocodingPort.getCity('Sarlat-la-Canda');\r\n      final cities = ['Prigueux', 'Bergerac', 'Montignac', 'Les Eyzies'];\r\n\r\n      // Utiliser map au lieu de Future.wait pour grer les erreurs individuellement\r\n      final multipleResults = await Future.wait(\r\n        cities.map((city) async {\r\n          try {\r\n            return await _geocodingPort.getCity(city);\r\n          } on DataException catch (e) {\r\n            print('Erreur pour la ville $city: $e');\r\n            return null; // Retourner null en cas d'erreur\r\n          }\r\n        }),\r\n      );\r\n\r\n      _setSuccessState({\r\n        'testType': 'cities',\r\n        'singleCityTest': {\r\n          'city': 'Sarlat-la-Canda',\r\n          'success': singleResult != null,\r\n          'details': singleResult.toJson(),\r\n        },\r\n        'multipleCitiesTest': {\r\n          'cities': multipleResults.map((city) => city?.toJson()).toList(),\r\n          'success': multipleResults.every((result) => result != null),\r\n        },\r\n      });\r\n      print('Test Google Maps termin avec succs');\r\n    } catch (e) {\r\n      print('Erreur lors du test Google Maps : $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testTripCreation() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      final trip = await _createTripUseCase.execute(CreateTripParams(\r\n        userId: \"123e4567-e89b-12d3-a456-426614174000\",\r\n        title: \"Test Trip to Dordogne\",\r\n        startDate: DateTime.now(),\r\n        endDate: DateTime.now().add(const Duration(days: 5)),\r\n        departureCityName: \"Sarlat-la-Canda\",\r\n        travelGroup: TravelGroup(\r\n          type: \"family\",\r\n          members: TravelGroupMembers(\r\n            pmr: false,\r\n            adults: 2,\r\n            seniors: false,\r\n            children: [7, 10],\r\n            teenagers: [],\r\n          ),\r\n          physicalCondition: \"moderate\",\r\n        ),\r\n        activityHours: ActivityHours(\r\n          start: \"10:00\",\r\n          end: \"18:00\",\r\n          daily_hours: {\r\n            DateTime.now().toIso8601String().split('T')[0]: {\r\n              'start': '10:00',\r\n              'end': '14:00'\r\n            },\r\n            DateTime.now().add(Duration(days: 1)).toIso8601String().split('T')[0]: {\r\n              'start': '09:00',\r\n              'end': '18:00'\r\n            },\r\n            DateTime.now().add(Duration(days: 2)).toIso8601String().split('T')[0]: {\r\n              'start': null,\r\n              'end': null\r\n            },\r\n            DateTime.now().add(Duration(days: 3)).toIso8601String().split('T')[0]: {\r\n              'start': '10:00',\r\n              'end': '20:00'\r\n            },\r\n            DateTime.now().add(Duration(days: 4)).toIso8601String().split('T')[0]: {\r\n              'start': '14:00',\r\n              'end': '22:00'\r\n            },\r\n          },\r\n        ),\r\n        dailyBudget: 150.00,\r\n        travelStyle: TravelStyle.balanced,\r\n        preferredMoment: PreferredMoment.morning,\r\n        transportMode: \"car\",\r\n      ));\r\n\r\n      _setSuccessState({\r\n        'testType': 'trip',\r\n        'tripDetails': trip,\r\n      });\r\n    } catch (e, stackTrace) {\r\n      print('Erreur dtaille: $e'); // Ajout du print\r\n      print('Stack trace: $stackTrace'); // Ajout du print\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testActivityHours() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      // Utilisons un ID d'activit existant dans la base\r\n      final activityId = \"votre_id_activite\"; //  remplacer par un ID valide\r\n\r\n      // Test sur une priode de 7 jours\r\n      final startDate = DateTime.now();\r\n      final endDate = startDate.add(const Duration(days: 7));\r\n\r\n      print(' Test de rcupration des horaires');\r\n      print('Activit ID: $activityId');\r\n      print('Priode: $startDate - $endDate');\r\n\r\n      final openingDays = await _activityHoursPort.getActivityHours(\r\n        activityId,\r\n        startDate,\r\n        endDate,\r\n      );\r\n\r\n      if (openingDays == null) {\r\n        _setSuccessState({\r\n          'testType': 'hours',\r\n          'result': 'Aucun horaire trouv pour cette priode',\r\n        });\r\n        return;\r\n      }\r\n\r\n      _setSuccessState({\r\n        'testType': 'hours',\r\n        'result': {\r\n          'numberOfDays': openingDays.availableDays.length,\r\n          'sampleDays': openingDays.availableDays,\r\n        },\r\n      });\r\n    } catch (e) {\r\n      print(' Erreur lors du test des horaires: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testActivityFiltering() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print(' Dbut du test de filtrage des activits');\r\n      final tripId = \"fd60d18c-116f-4e48-be32-0112a83a8a1b\"; // ID de test\r\n\r\n      print(' Processing des activits...');\r\n      final activities = await _processActivitiesUseCase.execute(tripId);\r\n      print(' ${activities.length} activits traites');\r\n\r\n      _setSuccessState({\r\n        'testType': 'filtering',\r\n        'totalActivities': activities.length,\r\n        'activities': activities.map((a) => {\r\n          'id': a.id,\r\n          'name': a.name,\r\n          'geohash': a.geohash,\r\n          'exclusionReason': a.exclusionReason,\r\n        }).toList(),\r\n      });\r\n    } catch (e, stackTrace) {\r\n      print(' Erreur dans le test de filtrage: $e');\r\n      print('Stack trace: $stackTrace');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testActivityScoring() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      final userId = \"123e4567-e89b-12d3-a456-426614174000\";\r\n      final tripId = \"fd60d18c-116f-4e48-be32-0112a83a8a1b\";\r\n\r\n      print(' Test du scoring des activits');\r\n\r\n      // 1. D'abord rcuprer les activits filtres\r\n      final activities = await _processActivitiesUseCase.execute(tripId);\r\n      print(' ${activities.length} activits rcupres aprs filtrage');\r\n\r\n      // 2. Calculer les scores (utilise le cache user_activities_score)\r\n      final scoredActivities = await _activityScoringPort.scoreActivities(userId, activities);\r\n      print(' Scores calculs ou rcuprs du cache');\r\n\r\n      print(' Dbut sauvegarde dans trip_activities');\r\n\r\n      // Convertir les activits scores au format attendu\r\n      final activitiesToSave = scoredActivities\r\n          .where((a) => a.subcategoryScore > 0)  // Ajout du filtre ici\r\n          .map((a) => ScoredActivity(\r\n        id: a.activity.id,\r\n        totalScore: a.totalScore,\r\n        subcategoryScore: a.subcategoryScore,\r\n        isSuperwow: a.isSuperWow,\r\n        activityData: {\r\n          'id': a.activity.id,\r\n          'geohash': a.activity.geohash,\r\n          'name': a.activity.name,\r\n        },\r\n      )).toList();\r\n\r\n      // Sparer les SuperWow des activits normales\r\n      final superwows = activitiesToSave.where((a) => a.isSuperwow).toList();\r\n      final normalActivities = activitiesToSave.where((a) => !a.isSuperwow).toList();\r\n\r\n      // Sauvegarder les deux types d'activits\r\n      await _tripActivitiesPort.saveFilteredActivities(\r\n        tripId: tripId,\r\n        activities: superwows,\r\n        isSuperwow: true,\r\n      );\r\n\r\n      await _tripActivitiesPort.saveFilteredActivities(\r\n        tripId: tripId,\r\n        activities: normalActivities,\r\n        isSuperwow: false,\r\n      );\r\n\r\n      print(' Sauvegarde termine');\r\n\r\n      _setSuccessState({\r\n        'testType': 'scoring',\r\n        'totalActivities': scoredActivities.length,\r\n        'superwowCount': superwows.length,\r\n        'normalActivities': normalActivities.length,\r\n        'activities': scoredActivities.map((a) => {\r\n          'name': a.activity.name,\r\n          'totalScore': a.totalScore,\r\n          'subcategoryScore': a.subcategoryScore,\r\n          'isSuperWow': a.isSuperWow,\r\n        }).toList(),\r\n      });\r\n\r\n    } catch (e) {\r\n      print(' Erreur dans le test de scoring: $e');\r\n      print('Dtails de l\\'erreur: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testDailyTrip() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print(' Test de cration d\\'un Daily Trip');\r\n\r\n      // Test avec les donnes de notre trajet d'exemple Prigueux-Sarlat\r\n      final testTrip = DailyTrip(\r\n        id: const Uuid().v4(),  // Gnration d'un nouvel UUID\r\n        type: DailyTripType.full_day,\r\n        date: DateTime.now(),\r\n        startPoint: const LatLng(45.1909, 0.7167),  // Prigueux\r\n        endPoint: const LatLng(44.8883, 1.2162),    // Sarlat\r\n        superWowIds: [\r\n          '1d6a2c9e-b8a9-4a2a-b1e2-d8f6a1b03df9',  // Exemple d'ID de SuperWow\r\n          'e31cf556-f916-410f-94f3-1b830a0bfa12'\r\n        ],\r\n        totalDuration: const Duration(hours: 3),\r\n        totalDistance: 72630,  // ~72.63 km\r\n      );\r\n\r\n      // On essaie d'insrer dans Supabase\r\n      final result = await _supabase.from('daily_trips').insert(\r\n          testTrip.toJson()..addAll({\r\n            'trip_id': 'fd60d18c-116f-4e48-be32-0112a83a8a1b',  // ID du trip test\r\n          })\r\n      ).select();\r\n\r\n      print(' Daily Trip cr avec succs');\r\n\r\n      _setSuccessState({\r\n        'testType': 'daily_trip',\r\n        'dailyTrip': {\r\n          'id': testTrip.id,\r\n          'type': testTrip.type.toString(),\r\n          'distance': '${(testTrip.totalDistance / 1000).toStringAsFixed(2)} km',\r\n          'duration': '${testTrip.totalDuration.inMinutes} minutes',\r\n          'superwows': testTrip.superWowIds.length,\r\n        }\r\n      });\r\n\r\n    } catch (e) {\r\n      print(' Erreur dans le test de Daily Trip: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  Future<void> testRouteOptimization() async {\r\n    _setLoadingState();\r\n\r\n    try {\r\n      print(' Test d\\'optimisation des routes');\r\n\r\n      // Test avec des coordonnes de la Dordogne\r\n      final origin = LatLng(45.1909, 0.7167);      // Prigueux\r\n      final destination = LatLng(44.8883, 1.2162);  // Sarlat\r\n      final waypoint = LatLng(44.9171, 1.0669);     // Les Eyzies\r\n\r\n      // Test du calcul de route optimise\r\n      final optimizedRoute = await _routeOptimizationPort.getOptimizedRoute(\r\n        origin,\r\n        destination,\r\n        [waypoint],\r\n      );\r\n\r\n      // Vrification des donnes retournes\r\n      if (optimizedRoute['status'] != 'OK') {\r\n        throw Exception('Status de la route non valide: ${optimizedRoute['status']}');\r\n      }\r\n\r\n      print(' Distance totale: ${(optimizedRoute['distance'] / 1000).toStringAsFixed(2)} km');\r\n      print(' Dure totale: ${(optimizedRoute['duration'] / 60).toStringAsFixed(0)} minutes');\r\n      print(' Ordre des waypoints: ${optimizedRoute['waypoint_order']}');\r\n\r\n      // Test du temps de trajet\r\n      final travelTime = await _routeOptimizationPort.getTravelTime(\r\n        origin,\r\n        destination,\r\n      );\r\n\r\n      // Test d'valuation d'un dtour\r\n      final detourEvaluation = await _routeOptimizationPort.evaluateDetour(\r\n        origin,\r\n        destination,\r\n        waypoint,\r\n        Duration(minutes: 30),\r\n      );\r\n\r\n      _setSuccessState({\r\n        'testType': 'route_optimization',\r\n        'route': {\r\n          ...optimizedRoute,\r\n          'readable_distance': '${(optimizedRoute['distance'] / 1000).toStringAsFixed(2)} km',\r\n          'readable_duration': '${(optimizedRoute['duration'] / 60).toStringAsFixed(0)} minutes',\r\n        },\r\n        'travelTime': travelTime.inMinutes,\r\n        'detourEvaluation': detourEvaluation,\r\n      });\r\n    } catch (e) {\r\n      print(' Erreur dans le test d\\'optimisation des routes: $e');\r\n      _setErrorState(e);\r\n    }\r\n  }\r\n\r\n  // Future<void> testHalfDayTripGeneration() async {\r\n  //   _setLoadingState();\r\n  //\r\n  //   try {\r\n  //     print(' Test gnration des half-day trips');\r\n  //\r\n  //     // Rcuprer les informations du trip et de la ville de dpart\r\n  //     final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n  //     final tripResponse = await _supabase\r\n  //         .from('trips')\r\n  //         .select('departure_city_id, cities!trips_departure_city_id_fkey(lat, lon, city_name), active_exploration_types')\r\n  //         .eq('id', tripId)\r\n  //         .single();\r\n  //\r\n  //     final departurePoint = LatLng(\r\n  //       tripResponse['cities']['lat'].toDouble(),\r\n  //       tripResponse['cities']['lon'].toDouble(),\r\n  //     );\r\n  //\r\n  //     // Pour ce test, on utilise le mme point d'arrive que de dpart\r\n  //     final arrivalPoint = departurePoint;\r\n  //\r\n  //     // Rcuprer les SuperWow\r\n  //     final superWows = await _superwowManagementPort.getTripSuperWows(tripId);\r\n  //     print(' ${superWows.length} SuperWow rcuprs');\r\n  //\r\n  //     // Gnrer les half-day trips\r\n  //     final halfDayTrips = await _dailyTripGenerationPort.generateHalfDayTrips(\r\n  //       tripId: tripId,\r\n  //       superWows: superWows,\r\n  //       departurePoint: departurePoint,\r\n  //       arrivalPoint: arrivalPoint,\r\n  //     );\r\n  //\r\n  //     _setSuccessState({\r\n  //       'testType': 'half_day_generation',\r\n  //       'departureCity': tripResponse['cities']['city_name'],\r\n  //       'totalTrips': halfDayTrips.length,\r\n  //       'trips': halfDayTrips.map((trip) => {\r\n  //         'id': trip.id,\r\n  //         'distance': '${(trip.totalDistance / 1000).toStringAsFixed(2)} km',\r\n  //         'duration': '${trip.totalDuration.inMinutes} minutes',\r\n  //         'superWow': superWows\r\n  //             .firstWhere((sw) => sw.id == trip.superWowIds.first)\r\n  //             .activityData['name'],\r\n  //       }).toList(),\r\n  //     });\r\n  //\r\n  //   } catch (e) {\r\n  //     print(' Erreur dans le test de gnration: $e');\r\n  //     _setErrorState(e);\r\n  //   }\r\n  // }\r\n  //\r\n  // Future<void> testFullDayTripGeneration() async {\r\n  //   _setLoadingState();\r\n  //\r\n  //   try {\r\n  //     print(' Test gnration des full-day trips');\r\n  //\r\n  //     // Rcuprer les informations du trip et de la ville de dpart\r\n  //     final tripId = 'fd60d18c-116f-4e48-be32-0112a83a8a1b';\r\n  //     final tripResponse = await _supabase\r\n  //         .from('trips')\r\n  //         .select('departure_city_id, cities!trips_departure_city_id_fkey(lat, lon, city_name), active_exploration_types')\r\n  //         .eq('id', tripId)\r\n  //         .single();\r\n  //\r\n  //     final departurePoint = LatLng(\r\n  //       tripResponse['cities']['lat'].toDouble(),\r\n  //       tripResponse['cities']['lon'].toDouble(),\r\n  //     );\r\n  //\r\n  //     // Convertir le JSON en liste d'ExplorationType\r\n  //     final explorationTypes = (tripResponse['active_exploration_types'] as List)\r\n  //         .map((type) => ExplorationType.values.firstWhere(\r\n  //             (e) => e.value == type.toString(),\r\n  //         orElse: () => ExplorationType.around_me))\r\n  //         .toList();\r\n  //\r\n  //     // Obtenir les limites combines\r\n  //     final (minTime, maxTime) = ExplorationTypeExtension.getCombinedTimeLimits(explorationTypes);\r\n  //     print(' Limites de temps combines: $minTime-$maxTime minutes');\r\n  //\r\n  //     // Pour ce test, point d'arrive = point de dpart\r\n  //     final arrivalPoint = departurePoint;\r\n  //\r\n  //     // Rcuprer les SuperWow\r\n  //     final superWows = await _superwowManagementPort.getTripSuperWows(tripId);\r\n  //     print(' ${superWows.length} SuperWow rcuprs');\r\n  //\r\n  //     // Prfrences horaires\r\n  //     final momentPreferences = {\r\n  //       \"evening\": false,\r\n  //       \"morning\": true,\r\n  //       \"afternoon\": true\r\n  //     };\r\n  //\r\n  //     // Gnrer les full-day trips\r\n  //\r\n  //     final fullDayTrips = await _dailyTripGenerationPort.generateFullDayTrips(\r\n  //       tripId: tripId,\r\n  //       superWows: superWows,\r\n  //       departurePoint: departurePoint,\r\n  //       arrivalPoint: arrivalPoint,\r\n  //       momentPreferences: momentPreferences,\r\n  //     );\r\n  //\r\n  //     _setSuccessState({\r\n  //       'testType': 'full_day_generation',\r\n  //       'departureCity': tripResponse['cities']['city_name'],\r\n  //       'totalTrips': fullDayTrips.length,\r\n  //       'trips': fullDayTrips.map((trip) => {\r\n  //         'id': trip.id,\r\n  //         'sw1': superWows.firstWhere((sw) => sw.id == trip.superWowIds[0]).activityData['name'],\r\n  //         'sw2': superWows.firstWhere((sw) => sw.id == trip.superWowIds[1]).activityData['name'],\r\n  //         'distance': '${(trip.totalDistance / 1000).toStringAsFixed(2)} km',\r\n  //         'duration': '${trip.totalDuration.inMinutes} minutes',\r\n  //       }).toList(),\r\n  //     });\r\n  //\r\n  //   } catch (e) {\r\n  //     print(' Erreur dans le test de gnration full-day: $e');\r\n  //     _setErrorState(e);\r\n  //   }\r\n  // }\r\n\r\n  // Helper methods to manage state\r\n  void _setLoadingState() {\r\n    state = state.copyWith(isLoading: true, error: '', testResults: null);\r\n  }\r\n\r\n  void _setSuccessState(Map<String, dynamic> testResults) {\r\n    state = state.copyWith(isLoading: false, testResults: testResults);\r\n  }\r\n\r\n  void _setErrorState(dynamic error) {\r\n    state = state.copyWith(\r\n      isLoading: false,\r\n      error: error.toString(),\r\n    );\r\n  }\r\n}\r\n",
      "info": {
        "size": 19410,
        "last_modified": "2025-04-16T13:25:28.1519429",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\state\\trip_test_provider.dart",
      "content": "// features/trip/presentation/state/trip_test_provider.dart\r\n\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../../../../core/domain/ports/providers/use_case_providers.dart';\r\nimport '../../../../core/domain/ports/providers/service_providers.dart';\r\nimport '../../../../core/domain/ports/providers/port_providers.dart';\r\nimport '../../../../core/domain/ports/providers/scoring_providers.dart';\r\nimport '../../../../core/domain/ports/providers/empty_trips/route_optimization.provider.dart';\r\nimport '../../../../core/domain/ports/providers/trip_activities_providers.dart';\r\nimport '../../../../core/domain/ports/providers/empty_trips/superwow_management.provider.dart';\r\nimport '../../../../core/domain/ports/providers/daily_trip_generation_provider.dart';\r\nimport 'trip_test_notifier.dart';\r\nimport 'trip_test_state.dart';\r\n\r\nfinal tripTestProvider = StateNotifierProvider<TripTestNotifier, TripTestState>((ref) {\r\n  final createTripUseCase = ref.watch(createTripUseCaseProvider);\r\n  final processActivitiesUseCase = ref.watch(processActivitiesUseCaseProvider);\r\n  final geocodingService = ref.watch(geocodingServiceProvider);\r\n  final activityHoursPort = ref.watch(activityHoursPortProvider);\r\n  final activityScoringPort = ref.watch(activityScoringPortProvider);\r\n  final routeOptimizationPort = ref.watch(routeOptimizationPortProvider);\r\n  final tripActivitiesPort = ref.watch(tripActivitiesPortProvider);\r\n  final supabase = ref.watch(supabaseProvider);\r\n  final superwowManagementPort = ref.watch(superwowManagementPortProvider);\r\n\r\n  return TripTestNotifier(\r\n    createTripUseCase,\r\n    processActivitiesUseCase,\r\n    geocodingService,\r\n    activityHoursPort,\r\n    activityScoringPort,\r\n    routeOptimizationPort,\r\n    tripActivitiesPort,\r\n    supabase,\r\n    superwowManagementPort,\r\n  );\r\n});",
      "info": {
        "size": 1820,
        "last_modified": "2025-04-16T13:25:28.1584588",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "features\\trip\\presentation\\state\\trip_test_state.dart",
      "content": "// lib/features/trip/presentation/state/trip_test_state.dart\r\n\r\nclass TripTestState {\r\n  final bool isLoading;\r\n  final String error;\r\n  final Map<String, dynamic>? testResults;\r\n\r\n  TripTestState({\r\n    this.isLoading = false,\r\n    this.error = '',\r\n    this.testResults,\r\n  });\r\n\r\n  TripTestState copyWith({\r\n    bool? isLoading,\r\n    String? error,\r\n    Map<String, dynamic>? testResults,\r\n  }) {\r\n    return TripTestState(\r\n      isLoading: isLoading ?? this.isLoading,\r\n      error: error ?? this.error,\r\n      testResults: testResults ?? this.testResults,\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 577,
        "last_modified": "2025-04-16T13:25:28.1649763",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    },
    {
      "path": "main.dart",
      "content": "import 'package:flutter/material.dart';\r\nimport 'package:supabase_flutter/supabase_flutter.dart';\r\nimport 'package:hive_flutter/hive_flutter.dart';\r\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\r\nimport 'features/home/presentation/pages/home_page.dart';\r\nimport 'features/trip/presentation/pages/trip_test_page.dart';\r\nimport 'features/empty_trips/presentation/pages/empty_trips_test_page.dart';\r\nimport '/core/adapters/supabase/database_adapter.dart';\r\nimport 'core/adapters/cache/hive_adapters.dart';\r\nimport 'core/theme/app_theme.dart';\r\nimport 'core/theme/app_colors.dart';\r\nimport 'core/theme/app_typography.dart';\r\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\r\nimport '../core/domain/ports/providers/empty_trips/google_services_config.provider.dart';\r\nimport '../core/domain/services/google_services_config.dart';\r\nimport '../core/adapters/cache/hive_location_cache_adapter.dart';\r\n\r\nvoid main() async {\r\n  try {\r\n    WidgetsFlutterBinding.ensureInitialized();\r\n\r\n    // Initialisation de Hive pour le cache de localisation\r\n    await Hive.initFlutter();\r\n\r\n    // Enregistrement des adaptateurs pour les objets de localisation\r\n    if (!Hive.isAdapterRegistered(userLocationTypeId)) {\r\n      Hive.registerAdapter(UserLocationAdapter());\r\n    }\r\n    if (!Hive.isAdapterRegistered(placeDetailsTypeId)) {\r\n      Hive.registerAdapter(PlaceDetailsAdapter());\r\n    }\r\n    if (!Hive.isAdapterRegistered(placeSuggestionTypeId)) {\r\n      Hive.registerAdapter(PlaceSuggestionAdapter());\r\n    }\r\n\r\n    // Initialisation des botes Hive\r\n    final cacheAdapter = HiveLocationCacheAdapter();\r\n    await cacheAdapter.initializeAsync();\r\n    print(' Initialisation du cache Hive termine au dmarrage de l\\'application');\r\n\r\n    // Initialisations existantes\r\n    await dotenv.load(fileName: \".env\");\r\n    await SupabaseService.initialize();\r\n    final googleConfig = await GoogleServicesConfig.init();\r\n\r\n    runApp(\r\n        ProviderScope(\r\n            overrides: [\r\n              // Ajout de la surcharge ici\r\n              googleServicesConfigProvider.overrideWithValue(googleConfig),\r\n            ],\r\n            child: const MyApp()\r\n        )\r\n    );\r\n  } catch (e) {\r\n    print('Error initializing app: $e');\r\n  }\r\n}\r\n\r\nclass MyApp extends StatelessWidget {\r\n  const MyApp({super.key});\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MaterialApp(\r\n      debugShowCheckedModeBanner: false,\r\n      theme: AppTheme.lightTheme(context),  // Utilise le thme clair complet\r\n      darkTheme: AppTheme.darkTheme(context),  // Ajoute le support du thme sombre\r\n      themeMode: ThemeMode.system,  // Ou ThemeMode.light si vous prfrez forcer le thme clair\r\n      initialRoute: '/',\r\n      routes: {\r\n        '/': (context) => const HomePage(),\r\n        '/trip-test': (context) => const TripTestPage(),\r\n        '/empty-trips-test': (context) => const EmptyTripsTestPage(),\r\n      },\r\n    );\r\n  }\r\n}",
      "info": {
        "size": 2943,
        "last_modified": "2025-04-16T13:25:28.1932974",
        "mime_type": "text/plain",
        "extension": ".dart"
      }
    }
  ]
}