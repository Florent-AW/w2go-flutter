# Journal technique: Optimisation du comportement de défilement dans Category Page

## Mise à jour: Mai 2025

### Problématique traitée: Scroll-to-top intempestif

Un comportement non désiré a été identifié dans l'implémentation de `CategoryPage` où la position de défilement vertical était systématiquement réinitialisée au sommet lors du changement de catégorie, nuisant gravement à l'expérience utilisateur.

### Diagnostic approfondi

Plusieurs causes potentielles ont été successivement identifiées et traitées:

1. **Reconstruction complète des delegates**
    - La recréation systématique de `CategoryCoverWithTabsDelegate` à chaque cycle de rebuild déclenchait un relayout complet
    - Même avec `shouldRebuild` optimisé, le changement d'instance provoquait une réinitialisation du header

2. **Clés dynamiques provoquant des reflows**
    - L'utilisation de `PageStorageKey('featured_${widget.currentCategory.id}')` entraînait la disparition puis réapparition des slivers
    - Lorsque le scroll viewport perdait un enfant, son offset était recalculé et "clampé" à 0

3. **Cause racine finale**: `Scrollable.ensureVisible()` dans la méthode de centrage des tabs
    - Cette méthode affectait **tous** les scrollables ancêtres, y compris le CustomScrollView vertical principal
    - Lors du changement de tab, elle repositionnait verticalement le scroll pour "centrer" la tab-bar

### Solutions implémentées

```dart
// Fichiers modifiés
├── features/categories/presentation/
│   ├── controllers/
│   │   └── cover_controller.dart           # Nouveau: Centralise les changements d'état
│   ├── widgets/
│   │   ├── delegates/
│   │   │   ├── category_cover_delegate.dart       # Optimisé: shouldRebuild
│   │   │   ├── category_cover_with_tabs_delegate.dart # Refactorisé: AnimatedBuilder
│   │   │   └── category_tabs_delegate.dart        # Corrigé: calcul d'offset horizontal
│   │   └── templates/
│   │       └── category_page_template.dart        # Optimisé: delegate stable + PageStorageKey
```

#### 1. Stabilisation du `SliverPersistentHeader`
- Création d'un controller dédié pour gérer les transitions sans reconstruire la structure
- Optimisation des méthodes `shouldRebuild` pour ne se déclencher que sur les changements dimensionnels
- Conservation d'une instance stable du delegate dans le state

```dart
// Dans CategoryCoverWithTabsDelegate
@override
bool shouldRebuild(covariant CategoryCoverWithTabsDelegate oldDelegate) {
  return oldDelegate._maxExtent != _maxExtent;
}
```

#### 2. Immutabilité et réactivité contrôlée
- Ajout d'un `CoverController` réactif avec `ChangeNotifier`
- Animation des transitions via `AnimatedBuilder` et `AnimatedSwitcher`
- Transitions fluides à l'intérieur de structures stables

#### 3. Solution définitive: Centrage horizontal sans défilement vertical
- Remplacement de `Scrollable.ensureVisible()` par un calcul d'offset horizontal précis:

```dart
void _centerCategoryTab(int index) {
  // Au lieu d'utiliser Scrollable.ensureVisible qui affecte tous les scrollables
  // On calcule et anime seulement l'offset horizontal
  final renderTab = ctx.findRenderObject() as RenderBox?;
  final tabOffset = renderTab.localToGlobal(Offset.zero, ancestor: renderTrack).dx;
  final wanted = _tabScrollController.offset + tabOffset - (viewportW - tabWidth) / 2;
  
  _tabScrollController.animateTo(wanted.clamp(...), ...);
}
```

#### 4. Sécurisation additionnelle
- Utilisation de `PageStorageKey` constants pour préserver l'état de défilement
- Optimisation des transitions avec `RepaintBoundary`
- Précachage des images pour des transitions fluides

### Optimisations complémentaires
- Implémentation de shimmer "structure-preserving" pendant les chargements
- Technique Stack+Opacity pour éviter les sauts pendant les transitions de contenu
- Préchargement proactif des catégories adjacentes

### Bénéfices validés
1. Préservation complète de la position de scroll lors des changements de catégorie
2. Transitions visuelles fluides (300ms fade) entre catégories
3. Chargement des données sans impact sur l'expérience de défilement

Cette série d'optimisations représente un exemple concret de l'application des principes SOLID et de Clean Architecture pour résoudre des problèmes complexes d'interface utilisateur tout en préservant la séparation des responsabilités.