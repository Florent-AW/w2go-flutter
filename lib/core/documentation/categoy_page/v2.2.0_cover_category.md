# Journal technique: Images et descriptions localisées pour Category Page

## Mise à jour: v2.2.0 (Mai 2025)

### Problématique traitée: Contextualisation géographique du contenu

Implémentation d'un système permettant d'afficher des images et descriptions de catégories spécifiques par département, adaptées automatiquement en fonction de la localisation/ville sélectionnée par l'utilisateur.

### Architecture implémentée

```
Supabase                        Riverpod                         UI
┌──────────────┐                ┌────────────────────┐           ┌────────────────┐
│category_     │                │categoryDepartment  │           │AnimatedSwitcher│
│department_   │◄───Adapter────►│CoverProvider       │◄──watch───┤                │
│covers        │                │                    │           │                │
└──────────────┘                └────────────────────┘           └────────────────┘
       ▲                                  ▲                              ▲
       │                                  │                              │
       │                         ┌────────────────────┐                  │
       └───Department Code───────┤selectedCityProvider│◄─────observe─────┘
                                 └────────────────────┘
```

### Composants développés

#### 1. Modèle de domaine et persistence

Nouvelle table Supabase permettant de stocker les variantes géographiques:

```sql
CREATE TABLE public.category_department_covers (
  id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
  category_id UUID REFERENCES public.categories(id),
  department_code TEXT NOT NULL,
  department_name TEXT NOT NULL,
  cover_url TEXT NOT NULL,
  description TEXT,
  priority INTEGER DEFAULT 10,
  CONSTRAINT unique_category_department UNIQUE (category_id, department_code)
);
```

#### 2. Interface et Ports

Nouvelle interface pour accéder aux données localisées:

```dart
abstract class CategoryCoversPort {
  Future<String?> getCoverUrlForCategoryAndDepartment(
      String categoryId,
      String departmentCode
      );

  Future<String?> getDescriptionForCategoryAndDepartment(
      String categoryId,
      String departmentCode
      );

  Future<List<CategoryDepartmentCover>> getAllCoversForCategory(String categoryId);
}
```

#### 3. Providers réactifs

Deux nouveaux providers qui:
- Observent la ville sélectionnée par l'utilisateur
- Extraient le code département automatiquement
- Récupèrent le contenu localisé correspondant
- Retombent sur le contenu par défaut si nécessaire

#### 4. Intégration UI non-invasive

- Intégration via `Consumer` sans restructuration majeure du UI
- Transitions animées via `AnimatedSwitcher` et `ValueKey` composites
- Fallback gracieux vers contenu par défaut pendant chargement/erreurs

#### 5. MeasuredSwitcher pour transitions fluides

Nouveau composant atomique pour éliminer les sauts verticaux pendant les transitions:

```dart
// lib/core/theme/components/molecules/measured_switcher.dart
class MeasuredSwitcher extends StatefulWidget {
  const MeasuredSwitcher({
    Key? key,
    required this.child,
    this.duration = const Duration(milliseconds: 220),
  }) : super(key: key);

  final Widget child;
  final Duration duration;

  @override
  State<MeasuredSwitcher> createState() => _MeasuredSwitcherState();
}
```

Ce widget:
- Maintient la hauteur du contenu pendant les transitions asynchrones
- Combine `AnimatedSize` et `AnimatedSwitcher` pour des transitions fluides
- Évite les sauts verticaux causés par des chargements désynchronisés
- Est réutilisable dans toute l'application

### Fichiers créés

```
lib/
├── core/
│   ├── domain/
│   │   ├── models/
│   │   │   └── shared/
│   │   │       └── category_department_cover_model.dart   # Modèle de données pour les couvertures départementales
│   │   └── ports/
│   │       └── search/
│   │           └── category_covers_port.dart              # Interface pour accéder aux couvertures
│   ├── adapters/
│   │   └── supabase/
│   │       └── search/
│   │           └── category_covers_adapter.dart           # Implémentation Supabase de l'interface
│   └── theme/
│       └── components/
│           └── molecules/
│               └── measured_switcher.dart                 # Widget pour transitions fluides
└── core/
    └── domain/
        └── ports/
            └── providers/
                └── search/
                    └── category_covers_provider.dart      # Providers Riverpod pour les couvertures
```

### Pattern implémenté: Providers paramétrés réactifs

L'implémentation utilise la puissance des `FutureProvider.family` de Riverpod pour:

```dart
final categoryDepartmentCoverProvider = FutureProvider.family<String, CategoryViewModel>(
        (ref, category) async {
      final adapter = ref.watch(categoryCoversPortProvider);
      final selectedCity = ref.watch(selectedCityProvider);

      // Extraction automatique du département à partir de la ville sélectionnée
      final departmentCode = _extractDepartmentCode(selectedCity?.postalCode);
      if (departmentCode == null) return category.imageUrl;

      // Tentative de récupération du contenu localisé
      final departmentCover = await adapter.getCoverUrlForCategoryAndDepartment(
          category.id, departmentCode
      );

      return departmentCover ?? category.imageUrl;
    }
);
```

### Résolution du bug de saut vertical

Le problème de saut vertical durant les transitions a été résolu en identifiant trois causes principales:

1. **Asynchronisme des providers** - L'image et la description se chargeaient indépendamment
2. **Remplacement complet via AnimatedSwitcher** - Perte temporaire de hauteur pendant la transition
3. **Recalcul du layout** - Flutter recalculait le layout lors de la fenêtre critique

Solution implémentée:
- Widget `MeasuredSwitcher` qui capture et maintient la hauteur du contenu pendant les transitions
- Optimisation des méthodes `setState` pour éviter les recalculs superflus
- Utilisation de clés dynamiques pour garantir des transitions correctes

### Optimisations futures possibles

1. **Cache proactif**: Pré-charger les images des départements adjacents/fréquents
2. **Délai optimisé**: Implémenter un délai d'attente (debounce) pour réduire les requêtes lors de la navigation rapide
3. **Préchargement intelligent**: Surveiller la géolocalisation pour précharger le contenu du département actuel avant sélection explicite
4. **Extension du concept**: Appliquer la même approche à d'autres contenus (activités, descriptions d'attractions)
5. **Test de non-régression**: Implémenter des tests widget pour vérifier la stabilité de la hauteur du header pendant les transitions

Cette implémentation respecte les principes SOLID et Clean Architecture en isolant clairement les responsabilités tout en offrant une expérience utilisateur contextualisée géographiquement et visuellement cohérente.