# üìã **InfinitePagingCarousel v1.0 - Widget de pagination infinie optimis√©**

## üéØ **Vue d'ensemble**

`InfinitePagingCarousel` est un widget Flutter avanc√© qui combine la navigation infinie avec un syst√®me de pagination intelligent. Il remplace l'ancien `InfiniteCarousel` basique en ajoutant le lazy loading T2, le pr√©-cache d'images et une gestion optimis√©e de la performance.

### **Fonctionnalit√©s principales**
- ‚úÖ **Navigation infinie** : Scroll continu dans les deux sens sans limites
- ‚úÖ **Lazy loading T2** : Chargement automatique de donn√©es suppl√©mentaires
- ‚úÖ **Pr√©-cache images** : Pr√©chargement intelligent des images √† venir
- ‚úÖ **Position initiale correcte** : D√©marre toujours sur le premier item
- ‚úÖ **Performance optimis√©e** : Gestion m√©moire et cache intelligent
- ‚úÖ **Configuration flexible** : Seuils et comportements personnalisables

---

## üèóÔ∏è **Architecture du widget**

### **Fichier source**
```
lib/core/theme/components/molecules/infinite_paging_carousel.dart
```

### **Structure de classe**
```dart
class InfinitePagingCarousel<T> extends StatefulWidget {
// Configuration g√©n√©rale
final List<T> items;
final Widget Function(BuildContext, T, int) itemBuilder;
final double height;

// Contr√¥leurs
final InfiniteScrollController? scrollController;

// Lazy loading T2
final VoidCallback? onLoadMore;
final bool hasMore;
final bool isLoading;
final int lookAhead;

// Pr√©-cache images
final int precacheAhead;
final String? Function(T)? getImageUrl;
}
```

### **√âtat interne**
```dart
class _InfinitePagingCarouselState<T> extends State<InfinitePagingCarousel<T>> {
// Contr√¥leur infini avec position centrale
late final InfiniteScrollController _infiniteController;

// Tracking de l'index r√©el
late final ValueNotifier<int> _currentRealIndexNotifier;

// Cache pour √©viter triggers multiples
final Set<int> _triggeredOffsets = <int>{};
final Set<String> _precachedUrls = <String>{};

// Position absolue pour lazy loading correct
int _absoluteIndex = 1 << 20;
}
```

---

## üîÑ **Gestion de l'infini**

### **Position centrale**
```dart
static const int kMiddle = 1 << 29; // ~536M pour position centrale

// ‚úÖ Position initiale corrig√©e pour d√©marrer sur item 0
final initialPosition = widget.items.isNotEmpty
? (1 << 20) - ((1 << 20) % widget.items.length)
    : 1 << 20;

_infiniteController = InfiniteScrollController(
initialItem: initialPosition,
);
```

### **Calcul d'index logique**
```dart
// Dans itemBuilder
final logical = (realIndex % widget.items.length + widget.items.length) % widget.items.length;
final item = widget.items[logical];
```

**Avantages** :
- **Navigation bidirectionnelle** : Scroll infini vers la gauche et la droite
- **Pas de saut visuel** : Transition fluide entre les extr√©mit√©s
- **Performance** : Position centrale √©vite les recadrages fr√©quents

---

## üöÄ **Syst√®me Lazy Loading T2**

### **D√©tection de seuil intelligent**
```dart
void _checkLoadMore(int absoluteIndex) {
if (widget.onLoadMore == null || widget.isLoading || !widget.hasMore) return;

final totalItems = widget.items.length;
final itemsSeen = absoluteIndex - (1 << 20); // Items vus depuis le d√©but
final remaining = totalItems - itemsSeen;

// ‚úÖ D√©clencher si on approche de la fin
if (remaining <= widget.lookAhead && itemsSeen > 0) {
final triggerKey = itemsSeen ~/ widget.lookAhead;

if (!_triggeredOffsets.contains(triggerKey)) {
_triggeredOffsets.add(triggerKey);
print('üöÄ INFINITE CAROUSEL: Lazy load trigger √† itemsSeen=$itemsSeen');
widget.onLoadMore!();
}
}
}
```

### **Configuration des seuils**
```dart
class InfinitePagingCarouselConfig {
static const int defaultLookAhead = 10;     // Seuil de d√©clenchement
static const int defaultPrecacheAhead = 3;  // Images √† pr√©-cacher
}
```

**Logique** :
- **lookAhead = 10** : D√©clenche `onLoadMore()` quand il reste 10 items √† voir
- **Pas de doublons** : Syst√®me de triggers avec cache des offsets d√©j√† trait√©s
- **Index absolu** : √âvite les faux triggers dus au modulo

---

## üñºÔ∏è **Pr√©-cache intelligent d'images**

### **Syst√®me de pr√©cache**
```dart
void _precacheImages(int realIndex) {
if (widget.getImageUrl == null) return;

try {
// ‚úÖ Pr√©-cache en avant (items suivants)
for (var i = 1; i <= widget.precacheAhead; i++) {
final targetIndex = (realIndex + i) % widget.items.length;
_precacheImageAtIndex(targetIndex);
}

// ‚úÖ Pr√©-cache en arri√®re (pour scroll inverse)
final behindIndex = (realIndex - 1 + widget.items.length) % widget.items.length;
_precacheImageAtIndex(behindIndex);
} catch (e) {
print('‚ùå INFINITE CAROUSEL: Erreur pr√©-cache: $e');
}
}
```

### **Impl√©mentation robuste**
```dart
void _precacheImageAtIndex(int index) {
if (index >= widget.items.length) return;

try {
final item = widget.items[index];
final imageUrl = widget.getImageUrl!(item);

if (imageUrl == null || _precachedUrls.contains(imageUrl)) return;

final provider = CachedNetworkImageProvider(imageUrl);
precacheImage(provider, context).then((_) {
if (mounted) _precachedUrls.add(imageUrl);
}).catchError((error) {
// Silent fail pour ne pas bloquer l'UX
});
} catch (e) {
// Error handling robuste
}
}
```

**Avantages** :
- **UX fluide** : Pas de blancs visuels lors du scroll
- **Cache d√©duplication** : √âvite le t√©l√©chargement multiple des m√™mes images
- **Bidirectionnel** : Pr√©cache aussi vers l'arri√®re pour scroll inverse

---

## ‚öôÔ∏è **Configuration et utilisation**

### **Usage dans GenericExperienceCarousel**
```dart
return InfinitePagingCarousel<ExperienceItem>(
items: widget.experiences!,
height: AppDimensions.activityCardHeight - 20,

// ‚úÖ T2 Lazy loading
onLoadMore: widget.onLoadMore,
hasMore: true, // Depuis PaginationState
isLoading: false, // Depuis PaginationState
lookAhead: 10,

// ‚úÖ Pr√©-cache images
precacheAhead: 3,
getImageUrl: (experience) => experience.mainImageUrl,

// ‚úÖ Builder personnalis√©
itemBuilder: (context, experience, index) {
return FeaturedExperienceCard(
heroTag: 'activity-hero-${experience.id}',
experience: experience,
onTap: () => NavigationUtils.navigateToDetail(context, experience),
);
},
);
```

### **Param√®tres de configuration**
| Param√®tre | Type | Default | Description |
|-----------|------|---------|-------------|
| `items` | `List<T>` | requis | Liste des items √† afficher |
| `itemBuilder` | `Function` | requis | Builder pour chaque item |
| `height` | `double` | 240.0 | Hauteur du carousel |
| `onLoadMore` | `VoidCallback?` | null | Callback pour lazy loading |
| `hasMore` | `bool` | true | Indique s'il reste du contenu |
| `isLoading` | `bool` | false | Indique un chargement en cours |
| `lookAhead` | `int` | 10 | Seuil de d√©clenchement T2 |
| `precacheAhead` | `int` | 3 | Nombre d'images √† pr√©-cacher |
| `getImageUrl` | `Function?` | null | Extracteur d'URL d'image |

---

## üîß **Points techniques importants**

### **Gestion du cycle de vie**
```dart
@override
void didUpdateWidget(covariant InfinitePagingCarousel<T> oldWidget) {
super.didUpdateWidget(oldWidget);

// ‚úÖ Reset cache quand items augmentent (loadMore r√©ussi)
if (widget.items.length > oldWidget.items.length) {
_triggeredOffsets.clear();
_precachedUrls.clear();
print('üîÑ INFINITE CAROUSEL: Reset cache (items = ${widget.items.length})');
}
}

@override
void dispose() {
_infiniteController.removeListener(_onScroll);
_currentRealIndexNotifier.dispose();

if (widget.scrollController == null) {
_infiniteController.dispose();
}
super.dispose();
}
```

### **Layout et dimensions**
```dart
@override
Widget build(BuildContext context) {
return SizedBox(
height: widget.height,
child: LayoutBuilder(
builder: (context, constraints) {
final cardWidth = AppDimensions.calculateCarouselCardWidth(constraints);
final itemExtent = cardWidth + AppDimensions.spacingS;

return RepaintBoundary(
child: InfiniteCarousel.builder(
controller: _infiniteController,
itemCount: widget.items.length,
itemExtent: itemExtent,
anchor: 0.0,
velocityFactor: 0.8,
loop: true,
onIndexChanged: _handleIndexChange,
physics: LoopSnapScrollPhysics(itemExtent: itemExtent),
itemBuilder: (context, itemIndex, realIndex) => _buildItem(context, realIndex),
),
);
},
),
);
}
```

---

## üö® **Erreurs courantes √† √©viter**

### **1. Position initiale incorrecte**
```dart
// ‚ùå INCORRECT - D√©marre sur item 1
_infiniteController = InfiniteScrollController(initialItem: 1 << 20);

// ‚úÖ CORRECT - D√©marre sur item 0
final initialPosition = (1 << 20) - ((1 << 20) % widget.items.length);
_infiniteController = InfiniteScrollController(initialItem: initialPosition);
```

### **2. Lazy loading sur index modulo**
```dart
// ‚ùå INCORRECT - Faux triggers
final remaining = widget.items.length - (realIndex % widget.items.length);

// ‚úÖ CORRECT - Index absolu
final itemsSeen = absoluteIndex - (1 << 20);
final remaining = widget.items.length - itemsSeen;
```

### **3. Cache d'images non nettoy√©**
```dart
// ‚ùå PROBL√àME - Cache grandit ind√©finiment
_precachedUrls.add(imageUrl);

// ‚úÖ SOLUTION - Reset cache sur mise √† jour
if (widget.items.length > oldWidget.items.length) {
_precachedUrls.clear();
}
```

---

## üìä **Performance et monitoring**

### **M√©triques importantes**
```dart
// Logs de debug utiles
print('üéØ INDEX CHANGE: absoluteIndex=$absoluteIndex ‚Üí logical=$logical');
print('üöÄ INFINITE CAROUSEL: Lazy load trigger √† itemsSeen=$itemsSeen');
print('üîÑ INFINITE CAROUSEL: Reset cache (items = ${widget.items.length})');
```

### **Optimisations appliqu√©es**
- **RepaintBoundary** : √âvite les rebuilds non n√©cessaires
- **ValueNotifier** : Tracking d'index optimis√©
- **Set pour caches** : D√©duplication O(1)
- **Silent fail** : Pr√©-cache robuste sans bloquer l'UI

---

## üîÆ **Extensions futures**

### **Am√©liorations pr√©vues**
- **Adaptive lookAhead** : Seuil qui s'adapte √† la vitesse de scroll
- **Memory limit** : √âviction automatique du cache d'images
- **Analytics** : M√©triques de performance T2
- **Offline support** : Gestion gracieuse hors ligne

### **Configuration avanc√©e**
```dart
// Future enhancement
InfinitePagingCarousel(
adaptiveLookAhead: true,           // Seuil adaptatif
maxCacheSize: 100,                 // Limite m√©moire cache
enableAnalytics: true,             // M√©triques performance
offlineGraceful: true,             // Mode d√©grad√© offline
);
```

---

## ‚úÖ **Checklist d'int√©gration**

### **Pour d√©veloppeurs**
- [ ] Import correct : `import 'path/to/infinite_paging_carousel.dart'`
- [ ] Type g√©n√©rique : `InfinitePagingCarousel<MonType>`
- [ ] Builder obligatoire : `itemBuilder` bien impl√©ment√©
- [ ] Lazy loading : `onLoadMore` connect√© au PaginationController
- [ ] Images : `getImageUrl` fournie pour pr√©-cache
- [ ] Hauteur : `height` appropri√©e au design
- [ ] Contr√¥leur : `scrollController` optionnel mais recommand√©

### **Tests de validation**
- [ ] Position initiale : Premier item visible au d√©marrage
- [ ] Navigation infinie : Scroll continu sans saut
- [ ] Lazy loading : Trigger au bon moment
- [ ] Pr√©-cache : Images charg√©es √† l'avance
- [ ] Performance : Pas de lag lors du scroll rapide
- [ ] Memory : Pas de fuite m√©moire apr√®s navigation

**‚úÖ InfinitePagingCarousel pr√™t pour production, optimis√© et document√©.**