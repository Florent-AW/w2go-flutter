# 📍 Documentation Technique - Système de Distance Unifié

## Mise à jour: v1.1.0 (1er Juin 2025)

## 🎯 Vue d'ensemble

Le système de distance unifié fournit une **API centralisée** pour calculer et gérer les distances entre les activités et la position de référence de l'utilisateur (ville sélectionnée ou GPS). Il garantit une **cohérence parfaite** dans toute l'application avec un cache intelligent et une auto-invalidation.

### ✨ Fonctionnalités Clés
- 🎯 **API publique unique** pour toute l'application
- 📊 **Cache intelligent** avec auto-invalidation
- 🏙️ **Position de référence** : ville sélectionnée → GPS fallback
- ⚡ **Calcul batch optimisé** pour les listes/carousels
- 🔄 **Auto-invalidation** sur changement de ville
- 🕒 **TTL cache** position GPS (15min)
- 📏 **Facteur correction routière** (1.3x distance vol d'oiseau)

---

## 🏗️ Architecture Finale

### 📊 Diagramme de Flux
```
User Interface
    ↓
activityDistancesProvider (API publique)
    ↓
ActivityDistancesNotifier (State management)
    ↓
ActivityDistanceManager (Service centralisé)
    ↓
ActivityDistanceService (Calculs Haversine)
    ↓
Cache + Position de référence
```

### 🎭 Pattern Architectural
- **Clean Architecture** : Port/Adapter pattern respecté
- **State Management** : Riverpod StateNotifier
- **Injection de dépendance** : Providers Riverpod
- **Cache hybride** : Manager + State local
- **Position intelligente** : Ville → GPS fallback

---

## 📁 Fichiers du Système

### 🎯 **Cœur du Système**

#### `lib/core/domain/ports/providers/location/activity_distance_manager_providers.dart`
**Rôle** : API publique et orchestrateur principal du système
- **`activityDistancesProvider`** : Provider principal (StateNotifier)
- **`ActivityDistancesNotifier`** : Gestion du state et cache local
- **`cityChangeListener`** : Auto-invalidation sur changement de ville
- **`distanceCacheStatsProvider`** : Statistiques debug

#### `lib/core/domain/services/location/activity_distance_manager.dart`
**Rôle** : Service centralisé pour la gestion des distances
- Cache intelligent avec TTL
- Position de référence unifiée (ville → GPS)
- Calcul batch optimisé
- Invalidation sélective du cache

### ⚙️ **Services de Base**

#### `lib/core/domain/services/search/activity_distance_service.dart`
**Rôle** : Service de calcul des distances Haversine
- Calcul distance vol d'oiseau + facteur correction (1.3x)
- Cache basique Map<String, double>
- Implémente `ActivityDistanceCalculationPort`

#### `lib/core/domain/ports/providers/search/distance_providers.dart`
**Rôle** : Provider pour le service de calcul de base
- Injecte `ActivityDistanceService`
- Utilisé par `ActivityDistanceManager`

### 🎨 **Composants UI**

#### `lib/core/theme/components/atoms/activity_distance_badge.dart`
**Rôle** : Badge de distance avec code couleur (< 5km vert, >= 5km gris)
- **Utilise** : `ref.watch(activityDistancesProvider)`
- **Règle** : Ne jamais utiliser `ref.read` dans build()

### 🎠 **Carousels d'Activités**

#### `lib/features/shared_ui/presentation/widgets/organisms/featured_activities_carousel.dart`
**Rôle** : Carousel des activités recommandées
- **Utilise** : `ref.watch(activityDistancesProvider)`
- **Méthode** : `_precacheDistancesIfNeeded` pour éviter boucles infinies
- **Variable** : `allDistances` (naming cohérent)

#### `lib/features/shared_ui/presentation/widgets/organisms/generic_activity_carousel.dart`
**Rôle** : Carousel générique réutilisable
- **Utilise** : `ref.watch(activityDistancesProvider)`
- **Méthode** : `_precacheDistancesIfNeeded` identique au featured
- **Variable** : `allDistances` (naming cohérent)

### 📄 **Pages et State Management**

#### `lib/features/activity_detail/application/state/activity_detail_notifier.dart`
**Rôle** : Notifier pour les détails d'activité
- **Méthode** : `_calculateAndCacheDistance` alimente le cache unifié
- **Utilise** : `ref.read(activityDistancesProvider.notifier)`

#### `lib/features/search/application/state/activity_providers.dart`
**Rôle** : Providers pour les activités de recherche
- **Utilise** : `cacheActivitiesDistances` avec format record (id, lat, lon)
- **2 usages** : featuredActivities + subcategoryActivities

---

## 🔌 API Publique

### 📊 **Provider Principal**
```dart
// Accès au cache des distances
final distances = ref.watch(activityDistancesProvider);
final distance = distances[activityId];

// Notifier pour actions
final notifier = ref.read(activityDistancesProvider.notifier);
```

### 🎯 **Méthodes Clés**

#### Calcul Batch (Carousels/Listes)
```dart
await notifier.cacheActivitiesDistances([
  (id: activity.id, lat: activity.latitude, lon: activity.longitude),
  // ... autres activités
]);
```

#### Distance Individuelle
```dart
final distance = await notifier.getActivityDistance(
  activityId: id,
  activityLat: lat,
  activityLon: lon,
);
```

#### Gestion Cache
```dart
notifier.clearCache();                    // Vider tout le cache
notifier.invalidateOnReferenceChange();   // Invalider sur changement ville
```

---

## 🧩 **Intégration dans les Composants**

### ✅ **Pattern Correct (Widgets UI)**
```dart
class MyWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ✅ TOUJOURS watch dans build()
    final distances = ref.watch(activityDistancesProvider);
    final distance = distances[activityId];
    
    return YourWidget(distance: distance);
  }
}
```

### ✅ **Pattern Correct (Carousels avec Pré-cache)**
```dart
// Dans build()
WidgetsBinding.instance.addPostFrameCallback((_) {
  _precacheDistancesIfNeeded(activities, ref, distances);
});

// Méthode helper
Future<void> _precacheDistancesIfNeeded(
  List<Activity> activities,
  WidgetRef ref,
  Map<String, double> currentDistances,
) async {
  final missing = activities.where((a) => 
    !currentDistances.containsKey(a.id)
  ).toList();
  
  if (missing.isEmpty) return; // ⚡ Guard clause importante
  
  final notifier = ref.read(activityDistancesProvider.notifier);
  await notifier.cacheActivitiesDistances(/* ... */);
}
```

### ❌ **Patterns À Éviter**
```dart
// ❌ ref.read dans build() = pas de réactivité
final distances = ref.read(activityDistancesProvider);

// ❌ Calcul sans guard = boucle infinie possible
await notifier.cacheActivitiesDistances(/* sans vérifier si déjà en cache */);

// ❌ Accès direct aux anciens services
final service = ref.read(activityDistanceServiceProvider); // Bypasse l'API unifiée
```

---

## 🚀 **Mise en Œuvre (Nouveaux Développeurs)**

### 1️⃣ **Ajouter Distance dans un Nouveau Widget**
```dart
class NewActivityWidget extends ConsumerWidget {
  final String activityId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final distances = ref.watch(activityDistancesProvider);
    final distance = distances[activityId];
    
    if (distance == null) {
      return Text('Distance non disponible');
    }
    
    return Text('${(distance / 1000).toStringAsFixed(1)} km');
  }
}
```

### 2️⃣ **Pré-calculer pour une Liste**
```dart
Future<void> _loadActivitiesWithDistances() async {
  final activities = await loadActivities();
  
  final notifier = ref.read(activityDistancesProvider.notifier);
  await notifier.cacheActivitiesDistances(
    activities.map((a) => (id: a.id, lat: a.lat, lon: a.lon)).toList()
  );
}
```

### 3️⃣ **Écouter les Changements de Ville**
Le système s'occupe automatiquement de l'invalidation via `cityChangeListener`.

---

## 🔧 **Configuration et Constantes**

### 📊 **Constantes Systèmes**
```dart
// Dans ActivityDistanceManager
static const Duration _referencePositionTtl = Duration(minutes: 15);
static const double _roadDistanceFactor = 1.3;
```

### 🎨 **Logique Badge Couleur**
```dart
// Dans ActivityDistanceBadge
Color _getDistanceColor(double distanceInMeters) {
  final distanceKm = distanceInMeters / 1000;
  return distanceKm < 5 ? Colors.green.shade600 : Colors.grey.shade600;
}
```

---

## 🐛 **Troubleshooting**

### ❌ **"Distance non disponible"**
- Vérifier que la ville est sélectionnée (`selectedCityProvider`)
- Vérifier les permissions GPS si pas de ville
- Check logs : "Position de référence indisponible"

### ❌ **"Distances pas mises à jour"**
- Utiliser `ref.watch` au lieu de `ref.read` dans build()
- Vérifier que `cacheActivitiesDistances` est appelé

### ❌ **"Performance dégradée"**
- Vérifier que les guard clauses évitent les recalculs
- Utiliser `RepaintBoundary` sur les carousels
- Check cache stats via `distanceCacheStatsProvider`

### 🔍 **Debug Commands**
```dart
// Statistiques cache
final stats = ref.read(distanceCacheStatsProvider);
print('Cache stats: $stats');

// Vider cache manuellement
ref.read(activityDistancesProvider.notifier).clearCache();
```

---

## 📈 **Évolutions Futures**

### 🎯 **Extensions Possibles**
- **Distance routière réelle** via Google Directions API
- **Cache persistant** avec Hive/SharedPreferences
- **Calcul parallèle** pour gros datasets
- **Précision géolocalisation** variable selon contexte
- **Historique distances** pour analytics

### 🏗️ **Points d'Extension**
- **`ActivityDistanceManager`** : ajouter nouveaux algorithmes
- **`ActivityDistanceCalculationPort`** : implémenter nouveaux calculateurs
- **`ActivityDistancesNotifier`** : ajouter logiques métier
- **Badge/UI** : personnaliser affichage selon contexte

---

## ✅ **Checklist Validation**

### 🧪 **Tests à Effectuer**
- [ ] Distance affichée correctement dans badges
- [ ] Cache fonctionne (pas de recalcul inutile)
- [ ] Changement ville invalide cache
- [ ] Fallback GPS quand pas de ville
- [ ] Performance carousels (pas de lag)
- [ ] Pas d'erreurs console

### 📋 **Code Review Points**
- [ ] `ref.watch` dans tous les widgets UI
- [ ] Guard clauses dans pré-cache methods
- [ ] Naming cohérent (`allDistances`)
- [ ] Pas d'accès direct aux anciens services
- [ ] Imports corrects vers le système unifié

---

**🎉 Architecture 100% Unifiée et Production-Ready !**