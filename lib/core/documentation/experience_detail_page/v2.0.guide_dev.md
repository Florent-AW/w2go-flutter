# Documentation Technique: Guide dÃ©veloppeur & Migration v2.0

*Documentation v2.0 - Guide pour Ã©quipe dÃ©veloppement - 08/06/2025*

## ğŸ¯ Vue d'ensemble

Ce guide explique comment travailler avec la nouvelle architecture unifiÃ©e des dÃ©tails d'expÃ©rience, comment migrer l'ancien code, et comment Ã©tendre le systÃ¨me pour de nouveaux types d'expÃ©riences.

---

## ğŸš€ Guide de dÃ©marrage rapide

### **Navigation vers page de dÃ©tail**
```dart
// âœ… Pour une Activity
final experienceItem = ExperienceItem.activity(searchableActivity);
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (_) => ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () => Navigator.pop(context),
    ),
  ),
);

// âœ… Pour un Event
final experienceItem = ExperienceItem.event(searchableEvent);
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (_) => ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () => Navigator.pop(context),
    ),
  ),
);
```

### **OpenBuilder pattern (recommandÃ©)**
```dart
// âœ… Dans les carousels
openBuilder: (context, action, activity) {
  final experienceItem = ExperienceItem.activity(activity);
  return ExperienceDetailPage(
    experienceItem: experienceItem,
    onClose: action,
  );
}
```

### **Provider pour charger les dÃ©tails**
```dart
// âœ… Auto-loading dans ExperienceDetailPage
class _ExperienceDetailPageState extends ConsumerState<ExperienceDetailPage> {
  @override
  void initState() {
    super.initState();
    
    // Chargement automatique
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref
          .read(experienceDetailProvider(widget.experienceItem).notifier)
          .loadExperienceDetails(widget.experienceItem);
    });
  }
}
```

---

## ğŸ”„ Migration depuis l'ancien systÃ¨me

### **Migration ActivityDetailPage**

#### **Avant (ancien systÃ¨me)**
```dart
// âŒ ANCIEN
ActivityDetailPage(
  activityId: activity.base.id,
  initialImageUrl: activity.mainImageUrl ?? '',
  title: activity.base.name,
  categoryName: activity.categoryName,
  subcategoryName: activity.subcategoryName,
  subcategoryIcon: activity.subcategoryIcon,
  city: activity.base.city,
  onClose: () => Navigator.pop(),
)
```

#### **AprÃ¨s (systÃ¨me unifiÃ©)**
```dart
// âœ… NOUVEAU
final experienceItem = ExperienceItem.activity(activity);
ExperienceDetailPage(
  experienceItem: experienceItem,
  onClose: () => Navigator.pop(),
)
```

### **Migration EventDetailPage**

#### **Avant (si existait)**
```dart
// âŒ ANCIEN
EventDetailPage(
  eventId: event.base.id,
  title: event.base.name,
  startDate: event.startDate,
  endDate: event.endDate,
  onClose: () => Navigator.pop(),
)
```

#### **AprÃ¨s (systÃ¨me unifiÃ©)**
```dart
// âœ… NOUVEAU
final experienceItem = ExperienceItem.event(event);
ExperienceDetailPage(
  experienceItem: experienceItem,
  onClose: () => Navigator.pop(),
)
```

### **Migration NavigationUtils**

#### **Avant**
```dart
// âŒ ANCIEN
NavigationUtils.navigateToActivityDetail(context, activity: activity);
NavigationUtils.navigateToEventDetail(context, event: event);
```

#### **AprÃ¨s**
```dart
// âœ… NOUVEAU
final activityItem = ExperienceItem.activity(activity);
NavigationUtils.navigateToExperience(context, experienceItem: activityItem);

final eventItem = ExperienceItem.event(event);
NavigationUtils.navigateToExperience(context, experienceItem: eventItem);
```

---

## ğŸ†• Ajouter un nouveau type d'expÃ©rience

### **Ã‰tape 1 : CrÃ©er les modÃ¨les de base**

#### **Base model**
```dart
// lib/core/domain/models/restaurant/base/restaurant_base.dart
@freezed
class RestaurantBase with _$RestaurantBase {
  const factory RestaurantBase({
    required String id,
    required String name,
    String? description,
    required double latitude,
    required double longitude,
    required String categoryId,
    String? city,
    // SpÃ©cifique restaurant
    required String cuisineType,
    String? priceRange,
    bool? hasDelivery,
  }) = _RestaurantBase;
}
```

#### **Searchable model**
```dart
// lib/core/domain/models/restaurant/search/searchable_restaurant.dart
@freezed
class SearchableRestaurant with _$SearchableRestaurant {
  const factory SearchableRestaurant({
    required RestaurantBase base,
    String? categoryName,
    String? subcategoryName,
    String? subcategoryIcon,
    String? mainImageUrl,
    double? distance,
    double? rating,
    int? ratingCount,
  }) = _SearchableRestaurant;
}
```

#### **Details model**
```dart
// lib/core/domain/models/restaurant/details/restaurant_details.dart
@freezed
class RestaurantDetails with _$RestaurantDetails {
  const factory RestaurantDetails({
    required String id,
    required String name,
    String? description,
    required double latitude,
    required double longitude,
    String? city,
    List<RestaurantImage>? images,
    // SpÃ©cifique restaurant
    required String cuisineType,
    String? priceRange,
    bool? hasDelivery,
    String? menuUrl,
    List<String>? specialties,
  }) = _RestaurantDetails;
}
```

### **Ã‰tape 2 : Ã‰tendre ExperienceItem**

```dart
// lib/core/domain/models/shared/experience_item.dart
@freezed
class ExperienceItem with _$ExperienceItem {
  const factory ExperienceItem.activity(SearchableActivity activity) = ActivityExperience;
  const factory ExperienceItem.event(SearchableEvent event) = EventExperience;
  const factory ExperienceItem.restaurant(SearchableRestaurant restaurant) = RestaurantExperience; // âœ… NOUVEAU

  const ExperienceItem._();

  // âœ… Ajouter getters pour restaurant
  String? get cuisineType => when(
    activity: (_) => null,
    event: (_) => null,
    restaurant: (restaurant) => restaurant.base.cuisineType,
  );

  bool get isRestaurant => when(
    activity: (_) => false,
    event: (_) => false,
    restaurant: (_) => true,
  );
}
```

### **Ã‰tape 3 : Ã‰tendre ExperienceDetails**

```dart
// lib/core/domain/models/shared/experience_details_model.dart
@freezed
class ExperienceDetails with _$ExperienceDetails {
  const factory ExperienceDetails.activity(ActivityDetails details) = ActivityExperienceDetails;
  const factory ExperienceDetails.event(EventDetails details) = EventExperienceDetails;
  const factory ExperienceDetails.restaurant(RestaurantDetails details) = RestaurantExperienceDetails; // âœ… NOUVEAU

  const ExperienceDetails._();

  // âœ… Ajouter getters unifiÃ©s
  String? get cuisineType => when(
    activity: (_) => null,
    event: (_) => null,
    restaurant: (details) => details.cuisineType,
  );

  RestaurantDetails? get asRestaurant => when(
    activity: (_) => null,
    event: (_) => null,
    restaurant: (details) => details,
  );
}
```

### **Ã‰tape 4 : CrÃ©er ports et adapters**

#### **Port**
```dart
// lib/core/domain/ports/search/restaurant_details_port.dart
abstract class RestaurantDetailsPort {
  Future<RestaurantDetails> getRestaurantDetails(String restaurantId);
}
```

#### **Adapter**
```dart
// lib/core/adapters/supabase/search/restaurant_details_adapter.dart
class RestaurantDetailsAdapter implements RestaurantDetailsPort {
  @override
  Future<RestaurantDetails> getRestaurantDetails(String restaurantId) async {
    final response = await _client
        .from('restaurants')
        .select('*')
        .eq('id', restaurantId)
        .single();

    return RestaurantDetails.fromJson(response);
  }
}
```

### **Ã‰tape 5 : CrÃ©er Use Case**

```dart
// lib/features/restaurant_detail/domain/usecases/get_restaurant_details_use_case.dart
class GetRestaurantDetailsUseCase {
  final RestaurantDetailsPort _port;

  const GetRestaurantDetailsUseCase(this._port);

  Future<RestaurantDetails> execute(String restaurantId) async {
    return await _port.getRestaurantDetails(restaurantId);
  }
}
```

### **Ã‰tape 6 : Ã‰tendre GetExperienceDetailsUseCase**

```dart
// lib/features/experience_detail/domain/usecases/get_experience_details_use_case.dart
class GetExperienceDetailsUseCase {
  final GetActivityDetailsUseCase _activityUseCase;
  final GetEventDetailsUseCase _eventUseCase;
  final GetRestaurantDetailsUseCase _restaurantUseCase; // âœ… NOUVEAU

  Future<ExperienceDetails> execute(ExperienceItem item) async {
    if (item.isEvent) {
      final eventDetails = await _eventUseCase.execute(item.id);
      return ExperienceDetails.event(eventDetails);
    } else if (item.isRestaurant) { // âœ… NOUVEAU
      final restaurantDetails = await _restaurantUseCase.execute(item.id);
      return ExperienceDetails.restaurant(restaurantDetails);
    } else {
      final activityDetails = await _activityUseCase.execute(item.id);
      return ExperienceDetails.activity(activityDetails);
    }
  }
}
```

### **Ã‰tape 7 : Ã‰tendre ExperienceInfoFactory**

```dart
// lib/core/domain/services/shared/experience_info_factory.dart
abstract class ExperienceInfoFactory {
  static List<InfoItem> createInfoItems(ExperienceDetails details) {
    return details.when(
      activity: (activityDetails) => ActivityInfoFactory.createInfoItems(activityDetails),
      event: (eventDetails) => _createEventInfoItems(eventDetails),
      restaurant: (restaurantDetails) => _createRestaurantInfoItems(restaurantDetails), // âœ… NOUVEAU
    );
  }

  /// âœ… NOUVEAU : Factory pour restaurants
  static List<InfoItem> _createRestaurantInfoItems(RestaurantDetails details) {
    final items = <InfoItem>[];

    // Type de cuisine
    items.add(InfoItem(
      iconName: 'utensils',
      value: 'Cuisine : ${details.cuisineType}',
      type: InfoItemType.cuisine,
    ));

    // Gamme de prix
    if (details.priceRange != null) {
      items.add(InfoItem(
        iconName: 'euro',
        value: 'Prix : ${details.priceRange}',
        type: InfoItemType.price,
      ));
    }

    // Livraison
    if (details.hasDelivery == true) {
      items.add(InfoItem(
        iconName: 'truck',
        value: 'Livraison disponible',
        type: InfoItemType.delivery,
      ));
    }

    return items;
  }
}
```

### **Ã‰tape 8 : Ã‰tendre FloatingActionBar**

```dart
// lib/features/experience_detail/presentation/organisms/experience_floating_action_bar.dart
Widget build(BuildContext context, WidgetRef ref) {
  return detailState.when(
    loaded: (details) {
      if (experienceItem.isEvent) {
        return _buildEventActions(context);
      } else if (experienceItem.isRestaurant) { // âœ… NOUVEAU
        return _buildRestaurantActions(context, details.asRestaurant!);
      } else {
        return details.asActivity != null 
            ? ActionButtonsRow(details: details.asActivity!)
            : _buildErrorState();
      }
    },
  );
}

Widget _buildRestaurantActions(BuildContext context, RestaurantDetails details) {
  return Row(
    children: [
      Expanded(
        child: ElevatedButton.icon(
          onPressed: () => _openMenu(details.menuUrl),
          icon: Icon(Icons.menu_book),
          label: Text('Menu'),
        ),
      ),
      if (details.hasDelivery == true) ...[
        SizedBox(width: 8),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: () => _orderDelivery(),
            icon: Icon(Icons.delivery_dining),
            label: Text('Livraison'),
          ),
        ),
      ],
    ],
  );
}
```

### **Ã‰tape 9 : Test de validation**

```dart
// âœ… Test du nouveau type
final restaurant = SearchableRestaurant(
  base: RestaurantBase(
    id: 'rest_001',
    name: 'La Table du PÃ©rigord',
    cuisineType: 'FranÃ§aise',
    latitude: 44.8378,
    longitude: 0.5792,
    categoryId: 'restaurants',
  ),
);

final experienceItem = ExperienceItem.restaurant(restaurant);

// âœ… ExperienceDetailPage fonctionne automatiquement !
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (_) => ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () => Navigator.pop(),
    ),
  ),
);
```

---

## ğŸ§ª Tests et validation

### **Tests unitaires Factory**
```dart
group('ExperienceInfoFactory', () {
  test('creates restaurant info items correctly', () {
    final restaurantDetails = RestaurantDetails(
      id: 'rest_001',
      name: 'Test Restaurant',
      cuisineType: 'Italienne',
      priceRange: 'â‚¬â‚¬',
      hasDelivery: true,
    );

    final details = ExperienceDetails.restaurant(restaurantDetails);
    final items = ExperienceInfoFactory.createInfoItems(details);

    expect(items.length, 3);
    expect(items[0].iconName, 'utensils');
    expect(items[0].value, 'Cuisine : Italienne');
    expect(items[1].value, 'Prix : â‚¬â‚¬');
    expect(items[2].value, 'Livraison disponible');
  });
});
```

### **Tests d'intÃ©gration**
```dart
testWidgets('ExperienceDetailPage works with restaurant', (tester) async {
  final restaurant = createMockRestaurant();
  final experienceItem = ExperienceItem.restaurant(restaurant);
  
  await tester.pumpWidget(
    ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () {},
    ),
  );

  expect(find.text('Cuisine : Italienne'), findsOneWidget);
  expect(find.text('Menu'), findsOneWidget);
});
```

---

## ğŸ”§ Conventions de dÃ©veloppement

### **Nommage des fichiers**
```
ğŸ“ [type]_detail/
â”œâ”€â”€ domain/usecases/get_[type]_details_use_case.dart
â”œâ”€â”€ models/[type]/base/[type]_base.dart
â”œâ”€â”€ models/[type]/search/searchable_[type].dart
â”œâ”€â”€ models/[type]/details/[type]_details.dart
â”œâ”€â”€ ports/search/[type]_details_port.dart
â””â”€â”€ adapters/supabase/search/[type]_details_adapter.dart
```

### **Conventions Factory**
```dart
// âœ… MÃ©thode privÃ©e spÃ©cifique au type
static List<InfoItem> _create[Type]InfoItems([Type]Details details) {
  final items = <InfoItem>[];
  
  // Ajouter infos spÃ©cifiques au type
  
  return items;
}

// âœ… Extension enum si nouveaux types
enum InfoItemType {
  family,
  booking,
  duration,
  accessibility,
  cuisine,     // âœ… Nouveau pour restaurants
  delivery,    // âœ… Nouveau pour restaurants
}
```

### **Conventions Providers**
```dart
// âœ… Provider pour nouvel adapter
final [type]DetailsAdapterProvider = Provider<[Type]DetailsPort>((ref) {
  return [Type]DetailsAdapter(Supabase.instance.client);
});

// âœ… Provider pour nouveau use case
final get[Type]DetailsUseCaseProvider = Provider<Get[Type]DetailsUseCase>((ref) {
  final port = ref.read([type]DetailsAdapterProvider);
  return Get[Type]DetailsUseCase(port);
});
```

---

## ğŸš¨ Points d'attention

### **Gestion d'erreurs**
```dart
// âœ… Toujours wrapper dans try/catch
Future<ExperienceDetails> execute(ExperienceItem item) async {
  try {
    if (item.isRestaurant) {
      final details = await _restaurantUseCase.execute(item.id);
      return ExperienceDetails.restaurant(details);
    }
    // ...
  } catch (e, stackTrace) {
    debugPrint('Erreur rÃ©cupÃ©ration dÃ©tails: $e');
    throw DataException('Impossible de rÃ©cupÃ©rer les dÃ©tails');
  }
}
```

### **Migration Base de donnÃ©es**
```sql
-- âœ… CrÃ©er nouvelle table pour nouveau type
CREATE TABLE restaurants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  latitude NUMERIC NOT NULL,
  longitude NUMERIC NOT NULL,
  cuisine_type TEXT NOT NULL,
  price_range TEXT,
  has_delivery BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### **Performance**
```dart
// âœ… Ã‰viter les rebuilds inutiles
final experienceDetailProvider = StateNotifierProvider.family.autoDispose<
  ExperienceDetailNotifier, 
  ExperienceDetailState, 
  ExperienceItem  // âœ… autoDispose pour Ã©viter memory leaks
>(
  (ref, experienceItem) => ExperienceDetailNotifier(useCase, ref),
);
```

---

## ğŸ“š Ressources et rÃ©fÃ©rences

### **Fichiers clÃ©s Ã  connaÃ®tre**
- `experience_detail_page.dart` - Page unique
- `experience_detail_template.dart` - Template unifiÃ©
- `experience_info_factory.dart` - Factory principal
- `get_experience_details_use_case.dart` - Use case unifiÃ©

### **Patterns Ã  suivre**
- **Factory Pattern** pour logique conditionnelle
- **Union Types** avec pattern matching
- **Provider.family** pour cache par instance
- **Atomic Design** pour composants UI

### **Anti-patterns Ã  Ã©viter**
- âŒ Logique `if/else` dans les widgets UI
- âŒ Composants spÃ©cifiques par type dans UI
- âŒ Duplication de logique entre types
- âŒ Navigation diffÃ©rente par type

---

## ğŸ¯ Checklist migration

### **Pour migrer un nouveau type**
- [ ] CrÃ©er modÃ¨les base/search/details
- [ ] Ã‰tendre ExperienceItem et ExperienceDetails
- [ ] CrÃ©er port et adapter
- [ ] CrÃ©er use case spÃ©cifique
- [ ] Ã‰tendre GetExperienceDetailsUseCase
- [ ] Ã‰tendre ExperienceInfoFactory
- [ ] Adapter FloatingActionBar si nÃ©cessaire
- [ ] CrÃ©er tests unitaires
- [ ] Tester navigation et affichage
- [ ] Valider Factory patterns

### **Pour migrer l'ancien code**
- [ ] Identifier usages ActivityDetailPage/EventDetailPage
- [ ] Remplacer par ExperienceDetailPage + ExperienceItem
- [ ] Mettre Ã  jour navigation/openBuilder
- [ ] Tester transitions et states
- [ ] Supprimer ancien code
- [ ] Valider non-rÃ©gression

---

**Guide dÃ©veloppeur = Migration facilitÃ©e + Extensions simples + Code maintenable** ğŸ› ï¸

*Guide conforme aux standards Clean Architecture + SOLID + Atomic Design selon Matej Resetar.*