# Documentation Technique: Guide d√©veloppeur & Migration v2.0

*Documentation v2.0 - Guide pour √©quipe d√©veloppement - 08/06/2025*

## üéØ Vue d'ensemble

Ce guide explique comment travailler avec la nouvelle architecture unifi√©e des d√©tails d'exp√©rience, comment migrer l'ancien code, et comment √©tendre le syst√®me pour de nouveaux types d'exp√©riences.

---

## üöÄ Guide de d√©marrage rapide

### **Navigation vers page de d√©tail**
```dart
// ‚úÖ Pour une Activity
final experienceItem = ExperienceItem.activity(searchableActivity);
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (_) => ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () => Navigator.pop(context),
    ),
  ),
);

// ‚úÖ Pour un Event
final experienceItem = ExperienceItem.event(searchableEvent);
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (_) => ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () => Navigator.pop(context),
    ),
  ),
);
```

### **OpenBuilder pattern (recommand√©)**
```dart
// ‚úÖ Dans les carousels
openBuilder: (context, action, activity) {
  final experienceItem = ExperienceItem.activity(activity);
  return ExperienceDetailPage(
    experienceItem: experienceItem,
    onClose: action,
  );
}
```

### **Provider pour charger les d√©tails**
```dart
// ‚úÖ Auto-loading dans ExperienceDetailPage
class _ExperienceDetailPageState extends ConsumerState<ExperienceDetailPage> {
  @override
  void initState() {
    super.initState();
    
    // Chargement automatique
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref
          .read(experienceDetailProvider(widget.experienceItem).notifier)
          .loadExperienceDetails(widget.experienceItem);
    });
  }
}
```

---

## üîÑ Migration depuis l'ancien syst√®me

### **Migration ActivityDetailPage**

#### **Avant (ancien syst√®me)**
```dart
// ‚ùå ANCIEN
ActivityDetailPage(
  activityId: activity.base.id,
  initialImageUrl: activity.mainImageUrl ?? '',
  title: activity.base.name,
  categoryName: activity.categoryName,
  subcategoryName: activity.subcategoryName,
  subcategoryIcon: activity.subcategoryIcon,
  city: activity.base.city,
  onClose: () => Navigator.pop(),
)
```

#### **Apr√®s (syst√®me unifi√©)**
```dart
// ‚úÖ NOUVEAU
final experienceItem = ExperienceItem.activity(activity);
ExperienceDetailPage(
  experienceItem: experienceItem,
  onClose: () => Navigator.pop(),
)
```

### **Migration EventDetailPage**

#### **Avant (si existait)**
```dart
// ‚ùå ANCIEN
EventDetailPage(
  eventId: event.base.id,
  title: event.base.name,
  startDate: event.startDate,
  endDate: event.endDate,
  onClose: () => Navigator.pop(),
)
```

#### **Apr√®s (syst√®me unifi√©)**
```dart
// ‚úÖ NOUVEAU
final experienceItem = ExperienceItem.event(event);
ExperienceDetailPage(
  experienceItem: experienceItem,
  onClose: () => Navigator.pop(),
)
```

### **Migration NavigationUtils**

#### **Avant**
```dart
// ‚ùå ANCIEN
NavigationUtils.navigateToActivityDetail(context, activity: activity);
NavigationUtils.navigateToEventDetail(context, event: event);
```

#### **Apr√®s**
```dart
// ‚úÖ NOUVEAU
final activityItem = ExperienceItem.activity(activity);
NavigationUtils.navigateToExperience(context, experienceItem: activityItem);

final eventItem = ExperienceItem.event(event);
NavigationUtils.navigateToExperience(context, experienceItem: eventItem);
```

---

## üÜï Ajouter un nouveau type d'exp√©rience

### **√âtape 1 : Cr√©er les mod√®les de base**

#### **Base model**
```dart
// lib/core/domain/models/restaurant/base/restaurant_base.dart
@freezed
class RestaurantBase with _$RestaurantBase {
  const factory RestaurantBase({
    required String id,
    required String name,
    String? description,
    required double latitude,
    required double longitude,
    required String categoryId,
    String? city,
    // Sp√©cifique restaurant
    required String cuisineType,
    String? priceRange,
    bool? hasDelivery,
  }) = _RestaurantBase;
}
```

#### **Searchable model**
```dart
// lib/core/domain/models/restaurant/search/searchable_restaurant.dart
@freezed
class SearchableRestaurant with _$SearchableRestaurant {
  const factory SearchableRestaurant({
    required RestaurantBase base,
    String? categoryName,
    String? subcategoryName,
    String? subcategoryIcon,
    String? mainImageUrl,
    double? distance,
    double? rating,
    int? ratingCount,
  }) = _SearchableRestaurant;
}
```

#### **Details model**
```dart
// lib/core/domain/models/restaurant/details/restaurant_details.dart
@freezed
class RestaurantDetails with _$RestaurantDetails {
  const factory RestaurantDetails({
    required String id,
    required String name,
    String? description,
    required double latitude,
    required double longitude,
    String? city,
    List<RestaurantImage>? images,
    // Sp√©cifique restaurant
    required String cuisineType,
    String? priceRange,
    bool? hasDelivery,
    String? menuUrl,
    List<String>? specialties,
  }) = _RestaurantDetails;
}
```

### **√âtape 2 : √âtendre ExperienceItem**

```dart
// lib/core/domain/models/shared/experience_item.dart
@freezed
class ExperienceItem with _$ExperienceItem {
  const factory ExperienceItem.activity(SearchableActivity activity) = ActivityExperience;
  const factory ExperienceItem.event(SearchableEvent event) = EventExperience;
  const factory ExperienceItem.restaurant(SearchableRestaurant restaurant) = RestaurantExperience; // ‚úÖ NOUVEAU

  const ExperienceItem._();

  // ‚úÖ Ajouter getters pour restaurant
  String? get cuisineType => when(
    activity: (_) => null,
    event: (_) => null,
    restaurant: (restaurant) => restaurant.base.cuisineType,
  );

  bool get isRestaurant => when(
    activity: (_) => false,
    event: (_) => false,
    restaurant: (_) => true,
  );
}
```

### **√âtape 3 : √âtendre ExperienceDetails**

```dart
// lib/core/domain/models/shared/experience_details_model.dart
@freezed
class ExperienceDetails with _$ExperienceDetails {
  const factory ExperienceDetails.activity(ActivityDetails details) = ActivityExperienceDetails;
  const factory ExperienceDetails.event(EventDetails details) = EventExperienceDetails;
  const factory ExperienceDetails.restaurant(RestaurantDetails details) = RestaurantExperienceDetails; // ‚úÖ NOUVEAU

  const ExperienceDetails._();

  // ‚úÖ Ajouter getters unifi√©s
  String? get cuisineType => when(
    activity: (_) => null,
    event: (_) => null,
    restaurant: (details) => details.cuisineType,
  );

  RestaurantDetails? get asRestaurant => when(
    activity: (_) => null,
    event: (_) => null,
    restaurant: (details) => details,
  );
}
```

### **√âtape 4 : Cr√©er ports et adapters**

#### **Port**
```dart
// lib/core/domain/ports/search/restaurant_details_port.dart
abstract class RestaurantDetailsPort {
  Future<RestaurantDetails> getRestaurantDetails(String restaurantId);
}
```

#### **Adapter**
```dart
// lib/core/adapters/supabase/search/restaurant_details_adapter.dart
class RestaurantDetailsAdapter implements RestaurantDetailsPort {
  @override
  Future<RestaurantDetails> getRestaurantDetails(String restaurantId) async {
    final response = await _client
        .from('restaurants')
        .select('*')
        .eq('id', restaurantId)
        .single();

    return RestaurantDetails.fromJson(response);
  }
}
```

### **√âtape 5 : Cr√©er Use Case**

```dart
// lib/features/restaurant_detail/domain/usecases/get_restaurant_details_use_case.dart
class GetRestaurantDetailsUseCase {
  final RestaurantDetailsPort _port;

  const GetRestaurantDetailsUseCase(this._port);

  Future<RestaurantDetails> execute(String restaurantId) async {
    return await _port.getRestaurantDetails(restaurantId);
  }
}
```

### **√âtape 6 : √âtendre GetExperienceDetailsUseCase**

```dart
// lib/features/experience_detail/domain/usecases/get_experience_details_use_case.dart
class GetExperienceDetailsUseCase {
  final GetActivityDetailsUseCase _activityUseCase;
  final GetEventDetailsUseCase _eventUseCase;
  final GetRestaurantDetailsUseCase _restaurantUseCase; // ‚úÖ NOUVEAU

  Future<ExperienceDetails> execute(ExperienceItem item) async {
    if (item.isEvent) {
      final eventDetails = await _eventUseCase.execute(item.id);
      return ExperienceDetails.event(eventDetails);
    } else if (item.isRestaurant) { // ‚úÖ NOUVEAU
      final restaurantDetails = await _restaurantUseCase.execute(item.id);
      return ExperienceDetails.restaurant(restaurantDetails);
    } else {
      final activityDetails = await _activityUseCase.execute(item.id);
      return ExperienceDetails.activity(activityDetails);
    }
  }
}
```

### **√âtape 7 : √âtendre ExperienceInfoFactory**

```dart
// lib/core/domain/services/shared/experience_info_factory.dart
abstract class ExperienceInfoFactory {
  static List<InfoItem> createInfoItems(ExperienceDetails details) {
    return details.when(
      activity: (activityDetails) => ActivityInfoFactory.createInfoItems(activityDetails),
      event: (eventDetails) => _createEventInfoItems(eventDetails),
      restaurant: (restaurantDetails) => _createRestaurantInfoItems(restaurantDetails), // ‚úÖ NOUVEAU
    );
  }

  /// ‚úÖ NOUVEAU : Factory pour restaurants
  static List<InfoItem> _createRestaurantInfoItems(RestaurantDetails details) {
    final items = <InfoItem>[];

    // Type de cuisine
    items.add(InfoItem(
      iconName: 'utensils',
      value: 'Cuisine : ${details.cuisineType}',
      type: InfoItemType.cuisine,
    ));

    // Gamme de prix
    if (details.priceRange != null) {
      items.add(InfoItem(
        iconName: 'euro',
        value: 'Prix : ${details.priceRange}',
        type: InfoItemType.price,
      ));
    }

    // Livraison
    if (details.hasDelivery == true) {
      items.add(InfoItem(
        iconName: 'truck',
        value: 'Livraison disponible',
        type: InfoItemType.delivery,
      ));
    }

    return items;
  }
}
```

### **√âtape 8 : √âtendre FloatingActionBar**

```dart
// lib/features/experience_detail/presentation/organisms/experience_floating_action_bar.dart
Widget build(BuildContext context, WidgetRef ref) {
  return detailState.when(
    loaded: (details) {
      if (experienceItem.isEvent) {
        return _buildEventActions(context);
      } else if (experienceItem.isRestaurant) { // ‚úÖ NOUVEAU
        return _buildRestaurantActions(context, details.asRestaurant!);
      } else {
        return details.asActivity != null 
            ? ActionButtonsRow(details: details.asActivity!)
            : _buildErrorState();
      }
    },
  );
}

Widget _buildRestaurantActions(BuildContext context, RestaurantDetails details) {
  return Row(
    children: [
      Expanded(
        child: ElevatedButton.icon(
          onPressed: () => _openMenu(details.menuUrl),
          icon: Icon(Icons.menu_book),
          label: Text('Menu'),
        ),
      ),
      if (details.hasDelivery == true) ...[
        SizedBox(width: 8),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: () => _orderDelivery(),
            icon: Icon(Icons.delivery_dining),
            label: Text('Livraison'),
          ),
        ),
      ],
    ],
  );
}
```

### **√âtape 9 : Test de validation**

```dart
// ‚úÖ Test du nouveau type
final restaurant = SearchableRestaurant(
  base: RestaurantBase(
    id: 'rest_001',
    name: 'La Table du P√©rigord',
    cuisineType: 'Fran√ßaise',
    latitude: 44.8378,
    longitude: 0.5792,
    categoryId: 'restaurants',
  ),
);

final experienceItem = ExperienceItem.restaurant(restaurant);

// ‚úÖ ExperienceDetailPage fonctionne automatiquement !
Navigator.push(
  context,
  MaterialPageRoute(
    builder: (_) => ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () => Navigator.pop(),
    ),
  ),
);
```

---

## üß™ Tests et validation

### **Tests unitaires Factory**
```dart
group('ExperienceInfoFactory', () {
  test('creates restaurant info items correctly', () {
    final restaurantDetails = RestaurantDetails(
      id: 'rest_001',
      name: 'Test Restaurant',
      cuisineType: 'Italienne',
      priceRange: '‚Ç¨‚Ç¨',
      hasDelivery: true,
    );

    final details = ExperienceDetails.restaurant(restaurantDetails);
    final items = ExperienceInfoFactory.createInfoItems(details);

    expect(items.length, 3);
    expect(items[0].iconName, 'utensils');
    expect(items[0].value, 'Cuisine : Italienne');
    expect(items[1].value, 'Prix : ‚Ç¨‚Ç¨');
    expect(items[2].value, 'Livraison disponible');
  });
});
```

### **Tests d'int√©gration**
```dart
testWidgets('ExperienceDetailPage works with restaurant', (tester) async {
  final restaurant = createMockRestaurant();
  final experienceItem = ExperienceItem.restaurant(restaurant);
  
  await tester.pumpWidget(
    ExperienceDetailPage(
      experienceItem: experienceItem,
      onClose: () {},
    ),
  );

  expect(find.text('Cuisine : Italienne'), findsOneWidget);
  expect(find.text('Menu'), findsOneWidget);
});
```

---

## üîß Conventions de d√©veloppement

### **Nommage des fichiers**
```
üìÅ [type]_detail/
‚îú‚îÄ‚îÄ domain/usecases/get_[type]_details_use_case.dart
‚îú‚îÄ‚îÄ models/[type]/base/[type]_base.dart
‚îú‚îÄ‚îÄ models/[type]/search/searchable_[type].dart
‚îú‚îÄ‚îÄ models/[type]/details/[type]_details.dart
‚îú‚îÄ‚îÄ ports/search/[type]_details_port.dart
‚îî‚îÄ‚îÄ adapters/supabase/search/[type]_details_adapter.dart
```

### **Conventions Factory**
```dart
// ‚úÖ M√©thode priv√©e sp√©cifique au type
static List<InfoItem> _create[Type]InfoItems([Type]Details details) {
  final items = <InfoItem>[];
  
  // Ajouter infos sp√©cifiques au type
  
  return items;
}

// ‚úÖ Extension enum si nouveaux types
enum InfoItemType {
  family,
  booking,
  duration,
  accessibility,
  cuisine,     // ‚úÖ Nouveau pour restaurants
  delivery,    // ‚úÖ Nouveau pour restaurants
}
```

### **Conventions Providers**
```dart
// ‚úÖ Provider pour nouvel adapter
final [type]DetailsAdapterProvider = Provider<[Type]DetailsPort>((ref) {
  return [Type]DetailsAdapter(Supabase.instance.client);
});

// ‚úÖ Provider pour nouveau use case
final get[Type]DetailsUseCaseProvider = Provider<Get[Type]DetailsUseCase>((ref) {
  final port = ref.read([type]DetailsAdapterProvider);
  return Get[Type]DetailsUseCase(port);
});
```

---

## üö® Points d'attention

### **Gestion d'erreurs**
```dart
// ‚úÖ Toujours wrapper dans try/catch
Future<ExperienceDetails> execute(ExperienceItem item) async {
  try {
    if (item.isRestaurant) {
      final details = await _restaurantUseCase.execute(item.id);
      return ExperienceDetails.restaurant(details);
    }
    // ...
  } catch (e, stackTrace) {
    debugPrint('Erreur r√©cup√©ration d√©tails: $e');
    throw DataException('Impossible de r√©cup√©rer les d√©tails');
  }
}
```

### **Migration Base de donn√©es**
```sql
-- ‚úÖ Cr√©er nouvelle table pour nouveau type
CREATE TABLE restaurants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  latitude NUMERIC NOT NULL,
  longitude NUMERIC NOT NULL,
  cuisine_type TEXT NOT NULL,
  price_range TEXT,
  has_delivery BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### **Performance**
```dart
// ‚úÖ √âviter les rebuilds inutiles
final experienceDetailProvider = StateNotifierProvider.family.autoDispose<
  ExperienceDetailNotifier, 
  ExperienceDetailState, 
  ExperienceItem  // ‚úÖ autoDispose pour √©viter memory leaks
>(
  (ref, experienceItem) => ExperienceDetailNotifier(useCase, ref),
);
```

---

## üìö Ressources et r√©f√©rences

### **Fichiers cl√©s √† conna√Ætre**
- `experience_detail_page.dart` - Page unique
- `experience_detail_template.dart` - Template unifi√©
- `experience_info_factory.dart` - Factory principal
- `get_experience_details_use_case.dart` - Use case unifi√©

### **Patterns √† suivre**
- **Factory Pattern** pour logique conditionnelle
- **Union Types** avec pattern matching
- **Provider.family** pour cache par instance
- **Atomic Design** pour composants UI

### **Anti-patterns √† √©viter**
- ‚ùå Logique `if/else` dans les widgets UI
- ‚ùå Composants sp√©cifiques par type dans UI
- ‚ùå Duplication de logique entre types
- ‚ùå Navigation diff√©rente par type

---

## üéØ Checklist migration

### **Pour migrer un nouveau type**
- [ ] Cr√©er mod√®les base/search/details
- [ ] √âtendre ExperienceItem et ExperienceDetails
- [ ] Cr√©er port et adapter
- [ ] Cr√©er use case sp√©cifique
- [ ] √âtendre GetExperienceDetailsUseCase
- [ ] √âtendre ExperienceInfoFactory
- [ ] Adapter FloatingActionBar si n√©cessaire
- [ ] Cr√©er tests unitaires
- [ ] Tester navigation et affichage
- [ ] Valider Factory patterns

### **Pour migrer l'ancien code**
- [ ] Identifier usages ActivityDetailPage/EventDetailPage
- [ ] Remplacer par ExperienceDetailPage + ExperienceItem
- [ ] Mettre √† jour navigation/openBuilder
- [ ] Tester transitions et states
- [ ] Supprimer ancien code
- [ ] Valider non-r√©gression

---

**Guide d√©veloppeur = Migration facilit√©e + Extensions simples + Code maintenable** üõ†Ô∏è

*Guide conforme aux standards Clean Architecture + SOLID + Atomic Design selon Matej Resetar.*