# Documentation Technique: Factory Patterns & Composants unifi√©s v2.0

*Documentation v2.0 - Composants Unifi√©s Activities + Events - 08/06/2025*

## üéØ Vue d'ensemble

Les **Factory Patterns** sont le c≈ìur de notre architecture unifi√©e. Ils permettent d'avoir des composants 100% unifi√©s qui s'adaptent automatiquement selon le type d'exp√©rience (Activity ou Event) sans logique conditionnelle dans l'UI.

---

## üè≠ Factory Patterns - Principe central

### **Principe de base**
```dart
// ‚ùå AVANT : Logique conditionnelle dans l'UI
Widget build() {
  if (experienceItem.isEvent) {
    return EventInfoWidget(event: experienceItem.asEvent);
  } else {
    return ActivityInfoWidget(activity: experienceItem.asActivity);
  }
}

// ‚úÖ APR√àS : Factory pattern unifi√©
Widget build() {
  final infoItems = ExperienceInfoFactory.createInfoItems(details);
  return InfoItemsList(items: infoItems);  // Composant dumb unifi√©
}
```

### **Avantages des Factory Patterns**
- ‚úÖ **Z√©ro logique conditionnelle** dans l'UI
- ‚úÖ **Composants 100% dumb** et r√©utilisables
- ‚úÖ **Type safety** avec pattern matching
- ‚úÖ **Extensibilit√©** : nouveau type = extension Factory
- ‚úÖ **Testabilit√©** : Factory isol√© = tests unitaires simples

---

## üèóÔ∏è ExperienceInfoFactory - Factory principal

### **Fichier**
```
lib/core/domain/services/shared/experience_info_factory.dart
```

### **Impl√©mentation**
```dart
abstract class ExperienceInfoFactory {
  /// Point d'entr√©e unifi√© pour toute exp√©rience
  static List<InfoItem> createInfoItems(ExperienceDetails details) {
    return details.when(
      activity: (activityDetails) => ActivityInfoFactory.createInfoItems(activityDetails),
      event: (eventDetails) => _createEventInfoItems(eventDetails),
    );
  }

  /// Factory sp√©cifique aux Events
  static List<InfoItem> _createEventInfoItems(EventDetails eventDetails) {
    final items = <InfoItem>[];

    // Date de l'√©v√©nement
    if (eventDetails.startDate != null) {
      final dateText = eventDetails.endDate != null
          ? '${_formatDate(eventDetails.startDate!)} - ${_formatDate(eventDetails.endDate!)}'
          : _formatDate(eventDetails.startDate!);
      
      items.add(InfoItem(
        iconName: 'calendar',
        value: 'Date : $dateText',
        type: InfoItemType.duration,
      ));
    }

    // R√©servation
    if (eventDetails.bookingRequired) {
      items.add(InfoItem(
        iconName: 'calendar-check',
        value: 'R√©servation obligatoire',
        type: InfoItemType.booking,
      ));
    }

    // Occurrences multiples
    if (eventDetails.hasMultipleOccurrences) {
      items.add(InfoItem(
        iconName: 'repeat',
        value: 'Plusieurs s√©ances',
        type: null,
      ));
    }

    return items;
  }
}
```

### **Extension pattern**
```dart
// ‚úÖ Nouveau type d'exp√©rience ? Extension simple
static List<InfoItem> _createRestaurantInfoItems(RestaurantDetails details) {
  final items = <InfoItem>[];
  
  // Cuisine type
  items.add(InfoItem(
    iconName: 'utensils',
    value: 'Cuisine : ${details.cuisineType}',
  ));
  
  return items;
}
```

---

## üß© Composants unifi√©s

### **1. ExperienceIntroSection**

**Fichier :** `lib/features/experience_detail/presentation/organisms/experience_intro_section.dart`

**R√¥le :** Section titre unifi√©e avec fallback navigation

```dart
class ExperienceIntroSection extends ConsumerWidget {
  final ExperienceItem experienceItem;
  
  // ‚úÖ Donn√©es imm√©diates pour transition fluide
  final String? immediateTitle;
  final String? immediateCity;
  final String? immediateCategoryName;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // ‚úÖ Badge Events automatique
        if (experienceItem.isEvent && experienceItem.startDate != null)
          EventDateBadge(
            startDate: experienceItem.startDate!,
            endDate: experienceItem.endDate,
          ),

        // ‚úÖ Titre selon type avec fallback
        detailState.when(
          loading: () => _buildWithFallback(null),
          loaded: (details) => _buildWithFallback(details),
        ),
      ],
    );
  }

  Widget _buildWithFallback(details) {
    if (experienceItem.isEvent) {
      return _buildEventTitleInfo(details);  // Sp√©cifique Events
    } else {
      // ‚úÖ R√©utilise ActivityTitleInfo pour Activities
      return ActivityTitleInfo(
        title: details?.name ?? immediateTitle ?? 'Chargement...',
        city: details?.city ?? immediateCity,
        categoryName: details?.categoryName ?? immediateCategoryName,
        tags: const ['Activit√© en famille', 'Populaire'],
        activityId: experienceItem.id,
      );
    }
  }
}
```

**Principe :** Composant intelligent qui choisit le bon sous-composant selon le type, avec fallback pour transition fluide.

### **2. ExperienceInfoSection**

**Fichier :** `lib/features/experience_detail/presentation/organisms/experience_info_section.dart`

**R√¥le :** Section infos pratiques 100% unifi√©e via Factory

```dart
class ExperienceInfoSection extends ConsumerWidget {
  final ExperienceItem experienceItem;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final detailState = ref.watch(experienceDetailProvider(experienceItem));

    return detailState.when(
      loading: () => _buildSkeleton(context),
      loaded: (details) {
        // ‚úÖ Factory pattern - pas de logique conditionnelle
        final infoItems = ExperienceInfoFactory.createInfoItems(details);

        if (infoItems.isEmpty) return const SizedBox.shrink();

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SectionTitle.secondary(text: 'D√©tails pratiques'),
            SizedBox(height: AppDimensions.spacingXxxs),
            
            // ‚úÖ Liste unifi√©e - m√™me composant pour Activities + Events
            Column(
              children: infoItems.map((item) =>
                  Padding(
                    padding: EdgeInsets.only(bottom: AppDimensions.spacingXs),
                    child: InfoItemTile(item: item),  // Composant dumb r√©utilis√©
                  )
              ).toList(),
            ),
          ],
        );
      },
    );
  }
}
```

**Principe :** Factory cr√©e les donn√©es, composant dumb les affiche. Z√©ro logique conditionnelle.

### **3. ExperienceDescriptionPanel**

**Fichier :** `lib/features/experience_detail/presentation/organisms/experience_description_panel.dart`

**R√¥le :** Description avec expand/collapse unifi√©

```dart
class ExperienceDescriptionPanel extends ConsumerStatefulWidget {
  final ExperienceItem experienceItem;

  @override
  Widget build(BuildContext context) {
    return detailState.when(
      loaded: (details) {
        if (details.description == null || details.description!.isEmpty) {
          return const SizedBox.shrink();
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SectionTitle.secondary(
              // ‚úÖ Titre adapt√© automatiquement
              text: experienceItem.isEvent ? '√Ä propos' : 'Pr√©sentation',
            ),
            
            // ‚úÖ M√™me logique expand/collapse pour Activities + Events
            AnimatedCrossFade(
              crossFadeState: _expanded ? CrossFadeState.showSecond : CrossFadeState.showFirst,
              firstChild: _buildCollapsedDescription(context, details.description!),
              secondChild: _buildExpandedDescription(context, details.description!),
            ),
          ],
        );
      },
    );
  }
}
```

**Principe :** M√™me comportement UI, titre adapt√© selon type via getter simple.

### **4. ExperienceFloatingActionBar**

**Fichier :** `lib/features/experience_detail/presentation/organisms/experience_floating_action_bar.dart`

**R√¥le :** Actions contextuelles selon type d'exp√©rience

```dart
class ExperienceFloatingActionBar extends ConsumerWidget {
  final ExperienceItem experienceItem;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return BottomBarWrapper(
      content: detailState.when(
        loaded: (details) {
          if (experienceItem.isEvent) {
            return _buildEventActions(context);
          } else {
            // ‚úÖ R√©utilise ActionButtonsRow pour Activities
            return details.asActivity != null 
                ? ActionButtonsRow(details: details.asActivity!)
                : _buildErrorState();
          }
        },
      ),
    );
  }

  Widget _buildEventActions(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: ElevatedButton.icon(
            onPressed: () => _openLocation(),
            icon: Icon(Icons.location_on),
            label: Text('Localisation'),
          ),
        ),
        SizedBox(width: 8),
        Expanded(
          child: OutlinedButton.icon(
            onPressed: () => _contactEvent(),
            icon: Icon(Icons.phone),
            label: Text('Contact'),
          ),
        ),
      ],
    );
  }
}
```

**Principe :** R√©utilise composants existants pour Activities, composant sp√©cifique pour Events.

---

## üîÑ Flux Factory Pattern

### **1. Donn√©es unifi√©es**
```
ExperienceDetails (Union Type)
‚îú‚îÄ‚îÄ ExperienceDetails.activity(ActivityDetails)
‚îî‚îÄ‚îÄ ExperienceDetails.event(EventDetails)
```

### **2. Factory processing**
```
ExperienceInfoFactory.createInfoItems(ExperienceDetails)
‚îú‚îÄ‚îÄ details.when()
‚îú‚îÄ‚îÄ activity: (details) => ActivityInfoFactory.createInfoItems(details)
‚îî‚îÄ‚îÄ event: (details) => _createEventInfoItems(details)
```

### **3. UI unifi√©e**
```
List<InfoItem> ‚Üí InfoItemTile (composant dumb) ‚Üí UI coh√©rente
```

---

## üé® Anatomie d'un InfoItem

### **Value Object unifi√©**
```dart
@freezed
class InfoItem with _$InfoItem {
  const factory InfoItem({
    required String iconName,     // Lucide icon ('users', 'calendar', etc.)
    required String value,        // Texte affich√©
    String? subtitle,             // Description optionnelle
    Color? valueColor,            // Override couleur
    InfoItemType? type,           // Type pour logique m√©tier
  }) = _InfoItem;
}
```

### **Mapping selon type**
```dart
// ‚úÖ Activities
InfoItem(
  iconName: 'users',
  value: 'Famille : Adapt√© aux enfants',
  type: InfoItemType.family,
)

// ‚úÖ Events
InfoItem(
  iconName: 'calendar',
  value: 'Date : 15/06/2025 - 20/06/2025',
  type: InfoItemType.duration,
)
```

### **Rendu unifi√©**
```dart
class InfoItemTile extends StatelessWidget {
  final InfoItem item;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.symmetric(vertical: AppDimensions.spacingXxxs),
      child: Row(
        children: [
          // ‚úÖ Ic√¥ne selon iconName
          Icon(
            _getIconData(item.iconName),
            size: AppDimensions.iconSizeSM,
            color: item.valueColor ?? AppColors.primary,
          ),
          SizedBox(width: AppDimensions.spacingXs),
          
          // ‚úÖ Texte unifi√©
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  item.value,
                  style: AppTypography.caption(isDark: isDark),
                ),
                
                // ‚úÖ Subtitle optionnel
                if (item.subtitle != null) ...[
                  SizedBox(height: AppDimensions.spacingXxxs),
                  Text(
                    item.subtitle!,
                    style: AppTypography.caption(isDark: isDark).copyWith(
                      color: AppColors.neutral600,
                    ),
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  IconData _getIconData(String iconName) {
    // ‚úÖ Mapping string ‚Üí IconData
    switch (iconName) {
      case 'users': return LucideIcons.users;
      case 'calendar': return LucideIcons.calendar;
      case 'calendar-check': return LucideIcons.calendarCheck;
      case 'repeat': return LucideIcons.repeat;
      default: return LucideIcons.info;
    }
  }
}
```

---

## üß™ Tests Factory Patterns

### **Tests unitaires Factory**
```dart
group('ExperienceInfoFactory', () {
  test('creates activity info items correctly', () {
    final activityDetails = ActivityDetails(
      kidFriendly: true,
      bookingLevel: 'recommended',
      minDurationMinutes: 60,
      maxDurationMinutes: 120,
    );

    final details = ExperienceDetails.activity(activityDetails);
    final items = ExperienceInfoFactory.createInfoItems(details);

    expect(items.length, 3);
    expect(items[0].iconName, 'users');
    expect(items[1].iconName, 'calendar-check');
    expect(items[2].value, contains('1h30'));
  });

  test('creates event info items correctly', () {
    final eventDetails = EventDetails(
      startDate: DateTime(2025, 6, 15),
      endDate: DateTime(2025, 6, 20),
      bookingRequired: true,
      hasMultipleOccurrences: true,
    );

    final details = ExperienceDetails.event(eventDetails);
    final items = ExperienceInfoFactory.createInfoItems(details);

    expect(items.length, 3);
    expect(items[0].iconName, 'calendar');
    expect(items[1].value, 'R√©servation obligatoire');
    expect(items[2].iconName, 'repeat');
  });
});
```

### **Tests widgets unifi√©s**
```dart
testWidgets('ExperienceInfoSection displays activity items', (tester) async {
  final experienceItem = ExperienceItem.activity(mockActivity);
  
  await tester.pumpWidget(
    ExperienceInfoSection(experienceItem: experienceItem),
  );

  expect(find.byType(InfoItemTile), findsNWidgets(3));
  expect(find.text('Famille : Adapt√© aux enfants'), findsOneWidget);
});

testWidgets('ExperienceInfoSection displays event items', (tester) async {
  final experienceItem = ExperienceItem.event(mockEvent);
  
  await tester.pumpWidget(
    ExperienceInfoSection(experienceItem: experienceItem),
  );

  expect(find.byType(InfoItemTile), findsNWidgets(3));
  expect(find.text('Date : 15/06/2025 - 20/06/2025'), findsOneWidget);
});
```

---

## üöÄ Extension des Factory Patterns

### **Nouveau type d'exp√©rience**
```dart
// 1. √âtendre ExperienceDetails
const factory ExperienceDetails.restaurant(RestaurantDetails details);

// 2. √âtendre ExperienceInfoFactory
static List<InfoItem> createInfoItems(ExperienceDetails details) {
  return details.when(
    activity: (details) => ActivityInfoFactory.createInfoItems(details),
    event: (details) => _createEventInfoItems(details),
    restaurant: (details) => _createRestaurantInfoItems(details), // ‚úÖ Nouveau
  );
}

// 3. Tous les composants fonctionnent automatiquement !
```

### **Nouvelle info pour type existant**
```dart
// Ajouter dans ActivityInfoFactory ou EventInfoFactory
static List<InfoItem> _createEventInfoItems(EventDetails details) {
  final items = <InfoItem>[];
  
  // ‚úÖ Nouvelle info - prix
  if (details.basePrice != null) {
    items.add(InfoItem(
      iconName: 'euro',
      value: details.basePrice == 0 ? 'Gratuit' : '${details.basePrice}‚Ç¨',
      type: InfoItemType.price,
    ));
  }
  
  return items;
}
```

---

## üéØ Avantages des Factory Patterns

### **1. Maintenabilit√©**
- ‚úÖ **Logique centralis√©e** dans les Factory
- ‚úÖ **Composants UI dumb** = pas de logique conditionnelle
- ‚úÖ **Tests simples** = Factory isol√©

### **2. Extensibilit√©**
- ‚úÖ **Nouveau type** = extension Factory
- ‚úÖ **Nouvelle info** = ajout dans Factory correspondant
- ‚úÖ **UI inchang√©e** = composants r√©utilis√©s

### **3. Performance**
- ‚úÖ **Widgets dumb** = moins de rebuilds
- ‚úÖ **Factory statique** = pas d'allocation m√©moire
- ‚úÖ **Cache InfoItems** possible = optimisation future

### **4. Type safety**
- ‚úÖ **Pattern matching** dans Factory
- ‚úÖ **Union types** garantissent exhaustivit√©
- ‚úÖ **Erreurs compilation** si type manquant

---

**Factory Patterns = C≈ìur de l'architecture unifi√©e + Extensibilit√© maximale + Code Clean** üè≠

*Factory Patterns conformes aux principes SOLID + Clean Architecture selon standards Matej Resetar.*